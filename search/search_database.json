var tipuesearch = {"pages":[{"title":" ForCAD ","text":"ForCAD ForCAD : A parallel Fortran library for geometric modeling using NURBS (Non-Uniform Rational B-Splines). ForCAD supports B-Spline , NURBS , Bezier and Rational Bezier curves, surfaces and volumes. Table of Contents Table of Contents Main Features Examples Installation Requirements Clone the repository Install PyVista (Optional) Using fpm Running Examples with fpm Using ForCAD as a fpm Dependency Using CMake Install Uninstall Using ForCAD with CMake Configuration Do Concurrent Support Precision Configuration CI Status API documentation Roadmap Contributing Citation References Main Features Parallelized using do concurrent . Create NURBS objects by specifying control points, weights and knots. Refine NURBS objects by inserting or removing knots and elevating degree. Compute analytical basis functions and their first and second derivatives for NURBS and B-Spline objects. Generation of IGA-compatible element connectivity and shape functions. Obtain visualized elements connectivity and coordinates for geometry and control geometry. Mesh insertion into a NURBS object. Export NURBS objects to VTK files for visualization. Export of NURBS curves and surfaces to IGES format (volumes currently not supported). Includes predefined NURBS shapes: Circle, Half Circle, Tetragon, Hexahedron, 2D Ring, Half 2D Ring, 3D Ring, Half 3D Ring, C-shapes. Rotate and translate NURBS objects. Visualization using provided python PyVista scripts. Least squares fitting for NURBS curves, surfaces and volumes. Numerical integration of: NURBS curve length, NURBS surface area and NURBS volume. Examples Below are some sample outputs from the examples directory: Installation Requirements Fortran compiler: GNU Fortran ( gfortran ) Intel Fortran Compiler ( ifx ) NVIDIA HPC SDK Fortran Compiler ( nvfortran ) LLVM Flang ( flang ) Note: Latest compiler versions are required to ensure compatibility. Build system: Fortran Package Manager ( fpm ) CMake Optional visualization tools: PyVista (recommended) ParaView Clone the repository Clone the ForCAD repository from GitHub: git clone https://github.com/gha3mi/forcad.git cd forcad Install PyVista (Optional) To install PyVista, run the following command: pip install pyvista By default PyVista visualization is enabled. To disable it, define the preprocessor flag NOSHOW_PYVISTA in the fpm.toml file or pass it as a compiler flag. Using fpm Running Examples with fpm fpm run --example <file name excluding the .f90 extension> --compiler gfortran --profile release --flag \"-ftree-parallelize-loops=8 -march=native\" After executing the examples, .vtk files will be generated in the vtk directory. To visualize these files, a show() method is provided which utilizes PyVista. Alternatively, other visualization tools like ParaView can also be used. Using ForCAD as a fpm Dependency If you want to use ForCAD as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forcad = { git = \"https://github.com/gha3mi/forcad.git\" } Using CMake Install cmake -S . -B build/cmake -DCMAKE_BUILD_TYPE = Release -DBUILD_SHARED_LIBS = ON -DCMAKE_INSTALL_PREFIX = . -G Ninja\ncmake --build build/cmake --config Release\ncmake --install build/cmake --config Release --verbose Uninstall cmake --build build/cmake --target uninstall Using ForCAD with CMake find_package ( forcad REQUIRED ) add_executable ( app main.f90 ) target_link_libraries ( app PRIVATE forcad::forcad ) Configuration Do Concurrent Support Compiler flags for enabling do concurrent parallelism: Compiler Flag(s) gfortran -fopenmp -ftree-parallelize-loops=n ifx -qopenmp -fopenmp-target-do-concurrent nvfortran -stdpar=multicore,gpu -Minfo=stdpar,accel flang-new ? lfortran ? Compiler flags can be passed to fpm using the --flag option, for example: fpm build --flag \"-stdpar=multicore,gpu -Minfo=stdpar,accel\" Alternatively, flags can be added to a fpm.rsp file in the root directory of the project. Precision Configuration The library uses double precision ( real64 ) by default for all real-valued computations. To change the precision, you can define one of the following preprocessor flags during compilation: Preprocessor Flag Fortran Kind Description REAL32 selected_real_kind(6) Single precision REAL64 (default) selected_real_kind(15) Double precision REALXDP selected_real_kind(18) Extended double precision REAL128 selected_real_kind(33) Quadruple precision Note : The examples example_ppm1.f90 , example_ppm2.f90 and example_ppm3.f90 use the ForColormap library, which only supports REAL64 precision. Example: Building with double precision fpm build --profile release --flag \"-DREAL64\" CI Status Compiler macos ubuntu windows flang-new - fpm ✅  cmake ✅ fpm ✅  cmake ❌ gfortran fpm ✅  cmake ✅ fpm ✅  cmake ✅ fpm ✅  cmake ✅ ifx - fpm ✅  cmake ✅ fpm ✅  cmake ❌ lfortran fpm ❌  cmake ❌ fpm ❌  cmake ❌ fpm ❌  cmake ❌ nvfortran - fpm ✅  cmake ✅ - This table is automatically generated by the CI workflow using setup-fortran-conda . API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForCAD using ford run the following\ncommand: ford README.md Contributing To contribute to ForCAD, please review the CONTRIBUTING.md . Citation If you use ForCAD in your research, please cite it as follows: @software { seyed_ali_ghasemi_2025_10904447 , author = {Ghasemi, S. A.} , title = {gha3mi/ForCAD} , year = {2025} , publisher = {Zenodo} , doi = {10.5281/zenodo.10904447} , url = {https://doi.org/10.5281/zenodo.10904447} } References Piegl, L., & Tiller, W. (1995). The NURBS Book. In Monographs in Visual Communications. Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-642-97385-7 An Introduction to NURBS. (2001). Elsevier. https://doi.org/10.1016/b978-1-55860-669-2.x5000-3 Sullivan et al., (2019). PyVista: 3D plotting and mesh analysis through a streamlined interface for the Visualization Toolkit (VTK). Journal of Open Source Software, 4(37), 1450, https://doi.org/10.21105/joss.01450 Ahrens, James, Geveci, Berk, Law, Charles, ParaView: An End-User Tool for Large Data Visualization, Visualization Handbook, Elsevier, 2005, ISBN-13: 9780123875822 Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"nurbs_surface – ForCAD ","text":"type, public :: nurbs_surface Inherits type~~nurbs_surface~~InheritsGraph type~nurbs_surface nurbs_surface debug debug type~nurbs_surface->debug err Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(debug), public :: err 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dA private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dA, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dA integer, intent(in), optional :: ngauss (2) generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS surface private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_area Compute the area of the NURBS surface private pure subroutine cmp_area (this, area, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(out) :: area integer, intent(in), optional :: ngauss (2) procedure, public :: cmp_degree Compute degree of the NURBS surface private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xth Generate connectivity for parameter points private pure function cmp_elem_Xth (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS surface private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS surface private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate degree private pure subroutine elevate_degree (this, dir, t, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth Export parameter space to VTK file private impure subroutine export_Xth (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth_in_Xg Export parameter space in geometry points to VTK file private impure subroutine export_Xth_in_Xg (this, filename, res, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: res character(len=*), intent(in), optional :: encoding procedure, public :: export_iges Export the NURBS surface to IGES format private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS surface object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the NURBS surface private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knot vector private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) procedure, public :: is_rational Check if the NURBS surface is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical procedure, public :: lsq_fit_bspline Fit B-spline surface to structured data points using least squares private pure subroutine lsq_fit_bspline (this, Xt, Xdata, ndata) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (2) procedure, public :: lsq_fit_nurbs Fit NURBS surface to structured data points using least squares private pure subroutine lsq_fit_nurbs (this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (2) integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS surface (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt (2) integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS surface (Minimization - Newtons method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 , set4 Set NURBS surface private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_ring Set a half ring private pure subroutine set_half_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_ring Set a ring private pure subroutine set_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_tetragon Set a tetragon private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg, vtkfile_Xth_in_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg character(len=*), intent(in), optional :: vtkfile_Xth_in_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS surface private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS surface private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS surface private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS surface private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS surface private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) procedure, private :: derivative_vector Compute the derivative of the NURBS surface private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_degree_all Get degree of the NURBS surface in both directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) procedure, private :: get_nc_all Get number of control points in all directions private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, private :: get_nc_dir Get number of control points in a specific direction private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: set1 Set knot vectors, control points and weights for the NURBS surface object private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set3 Set Bezier or Rational Bezier surface using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set4 Set NURBS surface using degree, number of control points, control points and weights private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:)","tags":"","url":"type/nurbs_surface.html"},{"title":"nurbs_curve – ForCAD ","text":"type, public :: nurbs_curve Inherits type~~nurbs_curve~~InheritsGraph type~nurbs_curve nurbs_curve debug debug type~nurbs_curve->debug err Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(debug), public :: err 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dL private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dL, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dL integer, intent(in), optional :: ngauss generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS curve private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_degree Compute degree of the NURBS curve private pure subroutine cmp_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xth Generate connectivity for parameter points private pure function cmp_elem_Xth (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_length Compute the length of the NURBS curve private pure subroutine cmp_length (this, length, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(out) :: length integer, intent(in), optional :: ngauss procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: create Generate geometry points private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS curve private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS curve private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate the degree of the curve private pure subroutine elevate_degree (this, t, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth Export parameter space to VTK file private impure subroutine export_Xth (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_iges Export the NURBS curve to an IGES file private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS curve object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the curve private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_degree Get degree of the NURBS curve private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knots private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, Xth, r, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) procedure, public :: is_rational Check if the NURBS curve is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical procedure, public :: lsq_fit_bspline Fit B-spline curve to structured data points using least squares private pure subroutine lsq_fit_bspline (this, Xt, Xdata, ndata) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata procedure, public :: lsq_fit_nurbs Fit NURBS curve to structured data points using least squares private pure subroutine lsq_fit_nurbs (this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS curve (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS curve (Minimization - Newtons method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set1a , set2 , set3 , set4 Set NURBS curve private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set1a (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: set_circle Set a circle private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_circle Set a half circle private pure subroutine set_half_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS curve private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS curve private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS curve private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS curve private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS curve private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) procedure, private :: derivative_vector Compute the derivative of the NURBS curve private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) procedure, private :: set1 Set knot vector, control points and weights for the NURBS curve object private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set1a private pure subroutine set1a (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set3 Set Bezier or Rational Bezier curve using control points and weights private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set4 Set NURBS curve using degree, number of control points, control points and weights private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:)","tags":"","url":"type/nurbs_curve.html"},{"title":"nurbs_volume – ForCAD ","text":"type, public :: nurbs_volume Inherits type~~nurbs_volume~~InheritsGraph type~nurbs_volume nurbs_volume debug debug type~nurbs_volume->debug err Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(debug), public :: err 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1) ng(2) ng(3), dim] real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dV private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dV, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dV integer, intent(in), optional :: ngauss (3) generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS volume private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_degree Compute degree of the NURBS volume private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_degreeFace Compute degrees of the faces private pure function cmp_degreeFace (this, face) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elemFace Compute faces of the IGA elements private pure function cmp_elemFace (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elemFace_Xc_vis Compute faces of the control points private pure function cmp_elemFace_Xc_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elemFace_Xg_vis Compute faces of the geometry points private pure function cmp_elemFace_Xg_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xth Generate connectivity for parameter points private pure function cmp_elem_Xth (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_volume Compute the volume of the NURBS volume private pure subroutine cmp_volume (this, volume, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(out) :: volume integer, intent(in), optional :: ngauss (3) procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS volume private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS volume private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate the degree of the NURBS volume private pure subroutine elevate_degree (this, dir, t, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth Export parameter space to VTK file private impure subroutine export_Xth (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth_in_Xg Export parameter space in geometry points to VTK file private impure subroutine export_Xth_in_Xg (this, filename, res, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: res character(len=*), intent(in), optional :: encoding procedure, public :: finalize Finalize the NURBS volume object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the NURBS volume private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knots private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) procedure, public :: is_rational Check if the NURBS volume is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical procedure, public :: lsq_fit_bspline Fit B-spline volume to structured data points using least squares private pure subroutine lsq_fit_bspline (this, Xt, Xdata, ndata) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (3) procedure, public :: lsq_fit_nurbs Fit NURBS volume to structured data points using least squares private pure subroutine lsq_fit_nurbs (this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (3) integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS volume (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt (3) integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS volume (Minimization - Newtons method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) procedure, public :: put_to_nurbs Put a shape to a NURBS volume private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), optional, contiguous :: elemConn (:,:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 , set4 Set NURBS volume private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_ring Set a half ring private pure subroutine set_half_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: set_hexahedron Set a hexahedron private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_ring Set a ring private pure subroutine set_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg, vtkfile_Xth_in_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg character(len=*), intent(in), optional :: vtkfile_Xth_in_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS volume private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS volume private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS volume private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS volume private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS volume private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) procedure, private :: derivative_vector Compute the derivative of the NURBS volume private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_degree_all Get degree of the NURBS volume in all directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) procedure, private :: get_nc_all Get number of control points in all directions private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, private :: get_nc_dir Get number of control points in a specific direction private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: set1 Set knot vectors, control points and weights for the NURBS volume object private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set3 Set Bezier or Rational Bezier volume using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, private :: set4 Set NURBS volume using degree, number of control points, control points and weights private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:)","tags":"","url":"type/nurbs_volume.html"},{"title":"set_Xc_Wc – ForCAD","text":"pure subroutine set_Xc_Wc(tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:) Calls proc~~set_xc_wc~~CallsGraph proc~set_xc_wc set_Xc_Wc cosd cosd proc~set_xc_wc->cosd tand tand proc~set_xc_wc->tand Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_xc_wc~~CalledByGraph proc~set_xc_wc set_Xc_Wc program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~set_xc_wc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_xc_wc.html"},{"title":"set_Xc_Wc – ForCAD","text":"pure subroutine set_Xc_Wc(tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:) Calls proc~~set_xc_wc~2~~CallsGraph proc~set_xc_wc~2 set_Xc_Wc cosd cosd proc~set_xc_wc~2->cosd tand tand proc~set_xc_wc~2->tand Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_xc_wc~2~~CalledByGraph proc~set_xc_wc~2 set_Xc_Wc program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~set_xc_wc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_xc_wc~2.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~~CalledByGraph proc~generate_xc generate_Xc program~example3_surface example3_surface program~example3_surface->proc~generate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc.html"},{"title":"generate_Xc – ForCAD","text":"pure function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~2~~CalledByGraph proc~generate_xc~2 generate_Xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~generate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~2.html"},{"title":"set_Xc_Wc – ForCAD","text":"pure subroutine set_Xc_Wc(tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:) Calls proc~~set_xc_wc~3~~CallsGraph proc~set_xc_wc~3 set_Xc_Wc cosd cosd proc~set_xc_wc~3->cosd tand tand proc~set_xc_wc~3->tand Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_xc_wc~3~~CalledByGraph proc~set_xc_wc~3 set_Xc_Wc program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~set_xc_wc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_xc_wc~3.html"},{"title":"exact_solution – ForCAD","text":"pure function exact_solution(p, d, n) result(u) Computes the exact solution corresponding to the source term Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (3) Coordinates (x, y, z) real(kind=rk), intent(in) :: d (3) Domain size (L1, L2, L3) integer, intent(in) :: n (3) Mode numbers (m1, m2, m3) Return Value real(kind=rk) Called by proc~~exact_solution~~CalledByGraph proc~exact_solution exact_solution program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~exact_solution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exact_solution.html"},{"title":"source_term – ForCAD","text":"pure function source_term(p, d, n) result(f) Computes the source function Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (3) Coordinates (x, y, z) real(kind=rk), intent(in) :: d (3) Domain size (L1, L2, L3) integer, intent(in) :: n (3) Mode numbers (m1, m2, m3) Return Value real(kind=rk) Called by proc~~source_term~~CalledByGraph proc~source_term source_term program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~source_term Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/source_term.html"},{"title":"build_helix – ForCAD","text":"pure subroutine build_helix(this, c, rh, p, n) Map a straight pipe-like NURBS volume onto a cylindrical helix . Each control point is first expressed relative to\nthe input center . For the axial (k) index,\ndefine a normalized parameter which runs from 0 (start) to 1 (end) along the volume. The helix angle as a function of is where n is the number of turns. For a point at polar coordinates and ,\nthe mapping is: where is the helix radius and is the pitch (axial rise per turn). Knots are preserved; only the control points are updated. Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this NURBS volume to be helicalized. real(kind=rk), intent(in) :: c (3) Center , helix radius , pitch . real(kind=rk), intent(in) :: rh Center , helix radius , pitch . real(kind=rk), intent(in) :: p Center , helix radius , pitch . integer, intent(in) :: n Number of turns. Calls proc~~build_helix~~CallsGraph proc~build_helix build_helix none~get_knot~3 nurbs_volume%get_knot proc~build_helix->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc proc~build_helix->none~get_nc~3 none~get_wc~3 nurbs_volume%get_Wc proc~build_helix->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~build_helix->none~get_xc~3 none~set~3 nurbs_volume%set proc~build_helix->none~set~3 proc~is_rational~3 nurbs_volume%is_rational proc~build_helix->proc~is_rational~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_multiplicity compute_multiplicity proc~get_nc_dir~2->interface~compute_multiplicity proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_helix~~CalledByGraph proc~build_helix build_helix program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/build_helix.html"},{"title":"generate_Xc – ForCAD","text":"pure function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~3~~CalledByGraph proc~generate_xc~3 generate_Xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~generate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~3.html"},{"title":"set_Xc_Wc – ForCAD","text":"pure subroutine set_Xc_Wc(tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:) Calls proc~~set_xc_wc~4~~CallsGraph proc~set_xc_wc~4 set_Xc_Wc cosd cosd proc~set_xc_wc~4->cosd tand tand proc~set_xc_wc~4->tand Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_xc_wc~4~~CalledByGraph proc~set_xc_wc~4 set_Xc_Wc program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~set_xc_wc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_xc_wc~4.html"},{"title":"set_Xc_Wc – ForCAD","text":"pure subroutine set_Xc_Wc(tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:) Calls proc~~set_xc_wc~5~~CallsGraph proc~set_xc_wc~5 set_Xc_Wc cosd cosd proc~set_xc_wc~5->cosd tand tand proc~set_xc_wc~5->tand Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_xc_wc~5~~CalledByGraph proc~set_xc_wc~5 set_Xc_Wc program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~set_xc_wc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_xc_wc~5.html"},{"title":"basis_bernstein – ForCAD","text":"public pure function basis_bernstein(Xt, nc) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) Called by proc~~basis_bernstein~~CalledByGraph proc~basis_bernstein basis_bernstein program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~basis_bernstein Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bernstein.html"},{"title":"basis_bspline – ForCAD","text":"public pure function basis_bspline(Xt, knot, nc, degree) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), (nc) Called by proc~~basis_bspline~~CalledByGraph proc~basis_bspline basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~cmp_tgc_1d->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~cmp_tgc_3d->proc~basis_bspline proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_xg_bspline_1d compute_Xg_bspline_1d proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->proc~basis_bspline proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline proc~lsq_fit_bspline~2->proc~basis_bspline proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->proc~basis_bspline proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->proc~basis_bspline proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs proc~lsq_fit_nurbs~2->proc~basis_bspline proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->proc~basis_bspline program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~basis_bspline interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~lsq_fit_bspline~2 proc~create~2 nurbs_curve%create program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~lsq_fit_bspline proc~create nurbs_surface%create program~lsq_fit_bspline_2d->proc~create proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 proc~create~3 nurbs_volume%create program~lsq_fit_bspline_3d->proc~create~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~lsq_fit_nurbs~2 program~lsq_fit_nurbs_1d->proc~create~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~lsq_fit_bspline~3 program~test_nurbs_volume->proc~create~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create->interface~compute_xg proc~create~2->interface~compute_xg~2 proc~create~3->interface~compute_xg~3 proc~export_xth_in_xg->interface~compute_xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->none~basis~2 program~test_nurbs_curve->proc~nearest_point2~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->none~basis program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline.html"},{"title":"compute_knot_vector – ForCAD","text":"public pure function compute_knot_vector(Xth_dir, degree, continuity) result(knot) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_knot_vector~~CallsGraph proc~compute_knot_vector compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_knot_vector~~CalledByGraph proc~compute_knot_vector compute_knot_vector proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~compute_knot_vector program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~3 nurbs_volume%set none~set~3->proc~set2~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->proc~set_c program~test_nurbs_surface->proc~set_half_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->proc~set_c~3 program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_knot_vector.html"},{"title":"det – ForCAD","text":"public pure function det(A) result(detA) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk) Called by proc~~det~~CalledByGraph proc~det det proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~det proc~ansatz~3->proc~inv proc~inv->proc~det proc~inv->proc~inv program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~det program~test_forcad_utils->proc~inv proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~inv proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~inv program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/det.html"},{"title":"eye – ForCAD","text":"public pure function eye(n) result(I) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:,:) Called by proc~~eye~~CalledByGraph proc~eye eye proc~inv inv proc~inv->proc~eye proc~inv->proc~inv program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~eye program~test_forcad_utils->proc~inv proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~inv proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~inv proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~inv proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~inv proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point2~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/eye.html"},{"title":"findspan – ForCAD","text":"public pure function findspan(n, degree, Xth, knot) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer Called by proc~~findspan~~CalledByGraph proc~findspan findspan proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~findspan proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~findspan proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->proc~findspan proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~findspan proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~findspan proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->proc~findspan program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~findspan program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~insert_knots~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~insert_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~insert_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~insert_knots~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~insert_knots~3 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~insert_knots program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~insert_knots program~test_nurbs_surface->proc~remove_knots program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~insert_knots~3 program~test_nurbs_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/findspan.html"},{"title":"hexahedron_Xc – ForCAD","text":"public pure function hexahedron_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~hexahedron_xc~~CalledByGraph proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->proc~hexahedron_xc program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~hexahedron_xc program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~hexahedron_xc program~example_twist_taper example_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/hexahedron_xc.html"},{"title":"inv – ForCAD","text":"public pure recursive function inv(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~inv~~CallsGraph proc~inv inv proc~inv->proc~inv proc~det det proc~inv->proc~det proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~inv~~CalledByGraph proc~inv inv proc~inv->proc~inv proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~inv proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~inv proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~inv proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~inv program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~inv proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point2~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/inv.html"},{"title":"kron_eye – ForCAD","text":"public pure function kron_eye(A, dim) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) integer, intent(in) :: dim Return Value real(kind=rk), (size(A,1)*dim,size(A,2)*dim) Called by proc~~kron_eye~~CalledByGraph proc~kron_eye kron_eye program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~kron_eye program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~kron_eye program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~kron_eye program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~kron_eye Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/kron_eye.html"},{"title":"linspace – ForCAD","text":"public pure function linspace(a, b, n) result(x) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a real(kind=rk), intent(in) :: b integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~linspace~~CalledByGraph proc~linspace linspace program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~linspace program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~linspace program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~linspace program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~linspace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/linspace.html"},{"title":"repelem – ForCAD","text":"public pure function repelem(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) Called by proc~~repelem~~CalledByGraph proc~repelem repelem proc~compute_knot_vector compute_knot_vector proc~compute_knot_vector->proc~repelem program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~repelem program~test_forcad_utils->proc~compute_knot_vector proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~3 nurbs_volume%set none~set~3->proc~set2~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->proc~set_c program~test_nurbs_surface->proc~set_half_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->proc~set_c~3 program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/repelem.html"},{"title":"rotation – ForCAD","text":"public pure function rotation(alpha, beta, theta) result(R) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), (3,3) Calls proc~~rotation~~CallsGraph proc~rotation rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation~~CalledByGraph proc~rotation rotation proc~rotate_xc nurbs_surface%rotate_Xc proc~rotate_xc->proc~rotation proc~rotate_xc~2 nurbs_curve%rotate_Xc proc~rotate_xc~2->proc~rotation proc~rotate_xc~3 nurbs_volume%rotate_Xc proc~rotate_xc~3->proc~rotation proc~rotate_xg nurbs_surface%rotate_Xg proc~rotate_xg->proc~rotation proc~rotate_xg~2 nurbs_curve%rotate_Xg proc~rotate_xg~2->proc~rotation proc~rotate_xg~3 nurbs_volume%rotate_Xg proc~rotate_xg~3->proc~rotation program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~rotation program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~2 program~example1_curve->proc~rotate_xg~2 program~example3_surface example3_surface program~example3_surface->proc~rotate_xc program~example3_surface->proc~rotate_xg program~example3_volume example3_volume program~example3_volume->proc~rotate_xc~3 program~example3_volume->proc~rotate_xg~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~rotate_xc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~rotate_xc~2 program~test_nurbs_curve->proc~rotate_xg~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~rotate_xc program~test_nurbs_surface->proc~rotate_xg program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~rotate_xc~3 program~test_nurbs_volume->proc~rotate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotation.html"},{"title":"solve – ForCAD","text":"public pure function solve(A, B) result(X) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~solve~~CalledByGraph proc~solve solve proc~inv inv proc~inv->proc~solve proc~inv->proc~inv proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->proc~solve proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline proc~lsq_fit_bspline~2->proc~solve proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->proc~solve proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->proc~solve proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs proc~lsq_fit_nurbs~2->proc~solve proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->proc~solve program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~solve proc~ansatz nurbs_surface%ansatz program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~solve proc~ansatz~3 nurbs_volume%ansatz program~poisson_iga_solver_3d->proc~ansatz~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~solve program~test_forcad_utils->proc~inv proc~ansatz->proc~inv proc~ansatz~3->proc~inv proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~inv proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~inv program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~lsq_fit_bspline~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~lsq_fit_bspline program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~lsq_fit_nurbs~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~lsq_fit_bspline~3 program~test_nurbs_volume->proc~nearest_point2~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_volume->proc~ansatz~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_surface->proc~cmp_area program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/solve.html"},{"title":"tetragon_Xc – ForCAD","text":"public pure function tetragon_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~tetragon_xc~~CalledByGraph proc~tetragon_xc tetragon_Xc proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->proc~tetragon_xc program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~tetragon_xc program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~set_tetragon program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/tetragon_xc.html"},{"title":"bincoeff – ForCAD","text":"private pure elemental function bincoeff(n, k) result(b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) Calls proc~~bincoeff~~CallsGraph proc~bincoeff bincoeff proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bincoeff~~CalledByGraph proc~bincoeff bincoeff proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~elevate_degree~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~elevate_degree~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/bincoeff.html"},{"title":"cmp_elemConn_C0_L – ForCAD","text":"private pure function cmp_elemConn_C0_L(nnode, p) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_l~~CalledByGraph proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~cmp_elem_xth->interface~elemconn_c0 proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~cmp_elem_xth~2->interface~elemconn_c0 proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~cmp_elem_xth~3->interface~elemconn_c0 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xth nurbs_surface%export_Xth proc~export_xth->proc~cmp_elem_xth proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->proc~cmp_elem_xth~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis program~test_nurbs_surface->proc~cmp_elem_xg_vis program~test_nurbs_surface->proc~export_xc program~test_nurbs_surface->proc~export_xg program~test_nurbs_surface->proc~export_xth program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis~3 program~test_nurbs_volume->proc~cmp_elem_xg_vis~3 program~test_nurbs_volume->proc~export_xc~3 program~test_nurbs_volume->proc~export_xg~3 program~test_nurbs_volume->proc~export_xth~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xc~3 program~example_bend_pipe->proc~export_xg~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xc~3 program~example_helix_pipe->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xc program~example_plate_hole_1_2d->proc~export_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xc~3 program~example_plate_hole_1_3d->proc~export_xg~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xc program~example_plate_hole_2_2d->proc~export_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xc~3 program~example_plate_hole_2_3d->proc~export_xg~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xc program~example_plate_hole_4_2d->proc~export_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xc~3 program~example_plate_hole_4_3d->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xc~3 program~example_toroidal_pipe->proc~export_xg~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xc~3 program~example_twist_taper->proc~export_xg~3 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xc~2 program~lsq_fit_bspline_1d->proc~export_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xc program~lsq_fit_bspline_2d->proc~export_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xc~3 program~lsq_fit_bspline_3d->proc~export_xg~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xc~2 program~lsq_fit_nurbs_1d->proc~export_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xc program~lsq_fit_nurbs_2d->proc~export_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xc~3 program~lsq_fit_nurbs_3d->proc~export_xg~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xc program~poisson_iga_solver_2d->proc~export_xg program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xc~3 program~poisson_iga_solver_3d->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_c0_l.html"},{"title":"cmp_elemConn_C0_S – ForCAD","text":"private pure function cmp_elemConn_C0_S(nnode1, nnode2, p1, p2) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_s~~CalledByGraph proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~cmp_elem_xth->interface~elemconn_c0 proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~cmp_elem_xth~2->interface~elemconn_c0 proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~cmp_elem_xth~3->interface~elemconn_c0 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xth nurbs_surface%export_Xth proc~export_xth->proc~cmp_elem_xth proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->proc~cmp_elem_xth~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis program~test_nurbs_surface->proc~cmp_elem_xg_vis program~test_nurbs_surface->proc~export_xc program~test_nurbs_surface->proc~export_xg program~test_nurbs_surface->proc~export_xth program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis~3 program~test_nurbs_volume->proc~cmp_elem_xg_vis~3 program~test_nurbs_volume->proc~export_xc~3 program~test_nurbs_volume->proc~export_xg~3 program~test_nurbs_volume->proc~export_xth~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xc~3 program~example_bend_pipe->proc~export_xg~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xc~3 program~example_helix_pipe->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xc program~example_plate_hole_1_2d->proc~export_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xc~3 program~example_plate_hole_1_3d->proc~export_xg~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xc program~example_plate_hole_2_2d->proc~export_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xc~3 program~example_plate_hole_2_3d->proc~export_xg~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xc program~example_plate_hole_4_2d->proc~export_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xc~3 program~example_plate_hole_4_3d->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xc~3 program~example_toroidal_pipe->proc~export_xg~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xc~3 program~example_twist_taper->proc~export_xg~3 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xc~2 program~lsq_fit_bspline_1d->proc~export_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xc program~lsq_fit_bspline_2d->proc~export_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xc~3 program~lsq_fit_bspline_3d->proc~export_xg~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xc~2 program~lsq_fit_nurbs_1d->proc~export_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xc program~lsq_fit_nurbs_2d->proc~export_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xc~3 program~lsq_fit_nurbs_3d->proc~export_xg~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xc program~poisson_iga_solver_2d->proc~export_xg program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xc~3 program~poisson_iga_solver_3d->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_c0_s.html"},{"title":"cmp_elemConn_C0_V – ForCAD","text":"private pure function cmp_elemConn_C0_V(nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_v~~CalledByGraph proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~cmp_elem_xth->interface~elemconn_c0 proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~cmp_elem_xth~2->interface~elemconn_c0 proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~cmp_elem_xth~3->interface~elemconn_c0 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xth nurbs_surface%export_Xth proc~export_xth->proc~cmp_elem_xth proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->proc~cmp_elem_xth~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis program~test_nurbs_surface->proc~cmp_elem_xg_vis program~test_nurbs_surface->proc~export_xc program~test_nurbs_surface->proc~export_xg program~test_nurbs_surface->proc~export_xth program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis~3 program~test_nurbs_volume->proc~cmp_elem_xg_vis~3 program~test_nurbs_volume->proc~export_xc~3 program~test_nurbs_volume->proc~export_xg~3 program~test_nurbs_volume->proc~export_xth~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xc~3 program~example_bend_pipe->proc~export_xg~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xc~3 program~example_helix_pipe->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xc program~example_plate_hole_1_2d->proc~export_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xc~3 program~example_plate_hole_1_3d->proc~export_xg~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xc program~example_plate_hole_2_2d->proc~export_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xc~3 program~example_plate_hole_2_3d->proc~export_xg~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xc program~example_plate_hole_4_2d->proc~export_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xc~3 program~example_plate_hole_4_3d->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xc~3 program~example_toroidal_pipe->proc~export_xg~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xc~3 program~example_twist_taper->proc~export_xg~3 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xc~2 program~lsq_fit_bspline_1d->proc~export_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xc program~lsq_fit_bspline_2d->proc~export_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xc~3 program~lsq_fit_bspline_3d->proc~export_xg~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xc~2 program~lsq_fit_nurbs_1d->proc~export_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xc program~lsq_fit_nurbs_2d->proc~export_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xc~3 program~lsq_fit_nurbs_3d->proc~export_xg~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xc program~poisson_iga_solver_2d->proc~export_xg program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xc~3 program~poisson_iga_solver_3d->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_c0_v.html"},{"title":"compute_multiplicity1 – ForCAD","text":"private pure function compute_multiplicity1(knot) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) Called by proc~~compute_multiplicity1~~CalledByGraph proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity1 proc~cmp_nc nurbs_surface%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_volume%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_volume%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc_dir nurbs_surface%get_nc_dir proc~get_nc_dir->interface~compute_multiplicity proc~get_nc_dir~2 nurbs_volume%get_nc_dir proc~get_nc_dir~2->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->interface~compute_multiplicity proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->interface~compute_multiplicity none~set~3 nurbs_volume%set proc~remove_knots~3->none~set~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~compute_multiplicity program~test_forcad_utils->proc~elevate_degree_a_5_9 none~get_nc nurbs_surface%get_nc none~get_nc->proc~get_nc_dir none~get_nc~3 nurbs_volume%get_nc none~get_nc~3->proc~get_nc_dir~2 proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~cmp_nc~2 proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->none~set~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~insert_knots~3 program~example_bend_pipe->proc~elevate_degree~3 proc~bend_pipe bend_pipe program~example_bend_pipe->proc~bend_pipe proc~set_ring~2 nurbs_volume%set_ring program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~insert_knots~3 program~example_helix_pipe->proc~elevate_degree~3 proc~build_helix build_helix program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~set_ring~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~insert_knots program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~insert_knots~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_nurbs_volume->none~set~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~insert_knots~3 program~example_toroidal_pipe->proc~elevate_degree~3 proc~map_to_torus_sinez map_to_torus_sineZ program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~insert_knots program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_elevate_and_insert_3d->none~set~3 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~get_continuity~2 program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~get_continuity program~lsq_fit_bspline_2d->none~get_nc program~lsq_fit_bspline_2d->none~set program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~get_continuity~3 program~lsq_fit_bspline_3d->none~get_nc~3 program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~get_continuity~2 program~lsq_fit_nurbs_1d->none~set~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~get_continuity program~lsq_fit_nurbs_2d->none~get_nc program~lsq_fit_nurbs_2d->none~set program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~get_continuity~3 program~lsq_fit_nurbs_3d->none~get_nc~3 program~lsq_fit_nurbs_3d->none~set~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots program~poisson_iga_solver_2d->none~get_nc program~poisson_iga_solver_2d->proc~cmp_elem proc~ansatz nurbs_surface%ansatz program~poisson_iga_solver_2d->proc~ansatz proc~set_tetragon nurbs_surface%set_tetragon program~poisson_iga_solver_2d->proc~set_tetragon program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 program~poisson_iga_solver_3d->none~get_nc~3 program~poisson_iga_solver_3d->proc~cmp_elem~3 proc~ansatz~3 nurbs_volume%ansatz program~poisson_iga_solver_3d->proc~ansatz~3 proc~set_hexahedron nurbs_volume%set_hexahedron program~poisson_iga_solver_3d->proc~set_hexahedron program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 program~test_nurbs_curve->proc~get_continuity~2 program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc program~test_nurbs_surface->proc~get_continuity program~test_nurbs_surface->proc~get_multiplicity program~test_nurbs_surface->proc~insert_knots program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->none~get_nc program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->none~set proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~modify_wc nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc proc~modify_xc nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc proc~set_c nurbs_surface%set_C program~test_nurbs_surface->proc~set_c proc~set_half_ring nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring proc~set_ring nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc~3 program~test_nurbs_volume->proc~get_continuity~3 program~test_nurbs_volume->proc~get_multiplicity~3 program~test_nurbs_volume->proc~insert_knots~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->none~get_nc~3 program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~modify_wc~3 nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc~3 proc~set_c~3 nurbs_volume%set_C program~test_nurbs_volume->proc~set_c~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~2->proc~set2~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~bend_pipe->none~get_nc~3 proc~bend_pipe->none~set~3 proc~build_helix->none~get_nc~3 proc~build_helix->none~set~3 proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 proc~map_to_torus_sinez->none~get_nc~3 proc~map_to_torus_sinez->none~set~3 proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~modify_wc->none~set proc~modify_wc~2->none~set~2 proc~modify_wc~3->none~set~3 proc~modify_xc->none~set proc~modify_xc~2->none~set~2 proc~modify_xc~3->none~set~3 proc~set_c->none~set proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3->none~set~3 proc~set_half_circle->none~set~2 proc~set_half_ring->none~set proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set~3 proc~set_ring->none~set proc~set_ring~2->none~set~3 proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->none~set~2 program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->none~set~3 program~compute_volume->proc~cmp_volume program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_multiplicity1.html"},{"title":"compute_multiplicity2 – ForCAD","text":"private pure function compute_multiplicity2(knot, Xth) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer Called by proc~~compute_multiplicity2~~CalledByGraph proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_nc nurbs_surface%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_volume%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_volume%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc_dir nurbs_surface%get_nc_dir proc~get_nc_dir->interface~compute_multiplicity proc~get_nc_dir~2 nurbs_volume%get_nc_dir proc~get_nc_dir~2->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->interface~compute_multiplicity proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->interface~compute_multiplicity none~set~3 nurbs_volume%set proc~remove_knots~3->none~set~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~compute_multiplicity program~test_forcad_utils->proc~elevate_degree_a_5_9 none~get_nc nurbs_surface%get_nc none~get_nc->proc~get_nc_dir none~get_nc~3 nurbs_volume%get_nc none~get_nc~3->proc~get_nc_dir~2 proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~cmp_nc~2 proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->none~set~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~insert_knots~3 program~example_bend_pipe->proc~elevate_degree~3 proc~bend_pipe bend_pipe program~example_bend_pipe->proc~bend_pipe proc~set_ring~2 nurbs_volume%set_ring program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~insert_knots~3 program~example_helix_pipe->proc~elevate_degree~3 proc~build_helix build_helix program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~set_ring~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~insert_knots program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~insert_knots~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_nurbs_volume->none~set~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~insert_knots~3 program~example_toroidal_pipe->proc~elevate_degree~3 proc~map_to_torus_sinez map_to_torus_sineZ program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~insert_knots program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_elevate_and_insert_3d->none~set~3 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~get_continuity~2 program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~get_continuity program~lsq_fit_bspline_2d->none~get_nc program~lsq_fit_bspline_2d->none~set program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~get_continuity~3 program~lsq_fit_bspline_3d->none~get_nc~3 program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~get_continuity~2 program~lsq_fit_nurbs_1d->none~set~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~get_continuity program~lsq_fit_nurbs_2d->none~get_nc program~lsq_fit_nurbs_2d->none~set program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~get_continuity~3 program~lsq_fit_nurbs_3d->none~get_nc~3 program~lsq_fit_nurbs_3d->none~set~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots program~poisson_iga_solver_2d->none~get_nc program~poisson_iga_solver_2d->proc~cmp_elem proc~ansatz nurbs_surface%ansatz program~poisson_iga_solver_2d->proc~ansatz proc~set_tetragon nurbs_surface%set_tetragon program~poisson_iga_solver_2d->proc~set_tetragon program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 program~poisson_iga_solver_3d->none~get_nc~3 program~poisson_iga_solver_3d->proc~cmp_elem~3 proc~ansatz~3 nurbs_volume%ansatz program~poisson_iga_solver_3d->proc~ansatz~3 proc~set_hexahedron nurbs_volume%set_hexahedron program~poisson_iga_solver_3d->proc~set_hexahedron program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 program~test_nurbs_curve->proc~get_continuity~2 program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc program~test_nurbs_surface->proc~get_continuity program~test_nurbs_surface->proc~get_multiplicity program~test_nurbs_surface->proc~insert_knots program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->none~get_nc program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->none~set proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~modify_wc nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc proc~modify_xc nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc proc~set_c nurbs_surface%set_C program~test_nurbs_surface->proc~set_c proc~set_half_ring nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring proc~set_ring nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc~3 program~test_nurbs_volume->proc~get_continuity~3 program~test_nurbs_volume->proc~get_multiplicity~3 program~test_nurbs_volume->proc~insert_knots~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->none~get_nc~3 program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~modify_wc~3 nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc~3 proc~set_c~3 nurbs_volume%set_C program~test_nurbs_volume->proc~set_c~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~2->proc~set2~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~bend_pipe->none~get_nc~3 proc~bend_pipe->none~set~3 proc~build_helix->none~get_nc~3 proc~build_helix->none~set~3 proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 proc~map_to_torus_sinez->none~get_nc~3 proc~map_to_torus_sinez->none~set~3 proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~modify_wc->none~set proc~modify_wc~2->none~set~2 proc~modify_wc~3->none~set~3 proc~modify_xc->none~set proc~modify_xc~2->none~set~2 proc~modify_xc~3->none~set~3 proc~set_c->none~set proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3->none~set~3 proc~set_half_circle->none~set~2 proc~set_half_ring->none~set proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set~3 proc~set_ring->none~set proc~set_ring~2->none~set~3 proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->none~set~2 program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->none~set~3 program~compute_volume->proc~cmp_volume program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_multiplicity2.html"},{"title":"dyad_t1_t1 – ForCAD","text":"private pure function dyad_t1_t1(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~dyad_t1_t1~~CalledByGraph proc~dyad_t1_t1 dyad_t1_t1 interface~dyad dyad interface~dyad->proc~dyad_t1_t1 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~dyad program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~dyad proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/dyad_t1_t1.html"},{"title":"factln – ForCAD","text":"private pure elemental function factln(n) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~factln~~CalledByGraph proc~factln factln proc~bincoeff bincoeff proc~bincoeff->proc~factln proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~elevate_degree~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~elevate_degree~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/factln.html"},{"title":"kron3 – ForCAD","text":"private pure function kron3(u, v, w) result(out) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(in), contiguous :: w (:) Return Value real(kind=rk), (size(u)*size(v)*size(w)) Called by proc~~kron3~~CalledByGraph proc~kron3 kron3 interface~kron kron interface~kron->proc~kron3 proc~cmp_tgc_2d cmp_Tgc_2d proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~cmp_tgc_3d->interface~kron proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->interface~kron proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->interface~kron proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->interface~kron proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->interface~kron proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->interface~kron proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~kron proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->interface~kron proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->interface~kron proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->interface~kron proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->interface~kron program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~kron interface~gauss_leg gauss_leg program~test_forcad_utils->interface~gauss_leg interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~lsq_fit_bspline proc~create nurbs_surface%create program~lsq_fit_bspline_2d->proc~create proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 proc~create~3 nurbs_volume%create program~lsq_fit_bspline_3d->proc~create~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~lsq_fit_bspline~3 program~test_nurbs_volume->proc~create~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 none~derivative~3 nurbs_volume%derivative program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg proc~ansatz~3->none~derivative~3 proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create->interface~compute_xg proc~create~3->interface~compute_xg~3 proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 proc~export_xth_in_xg->interface~compute_xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/kron3.html"},{"title":"kron_t1_t1 – ForCAD","text":"private pure function kron_t1_t1(u, v) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) Called by proc~~kron_t1_t1~~CalledByGraph proc~kron_t1_t1 kron_t1_t1 interface~kron kron interface~kron->proc~kron_t1_t1 proc~cmp_tgc_2d cmp_Tgc_2d proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~cmp_tgc_3d->interface~kron proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->interface~kron proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->interface~kron proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->interface~kron proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->interface~kron proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->interface~kron proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~kron proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->interface~kron proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->interface~kron proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->interface~kron proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->interface~kron program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~kron interface~gauss_leg gauss_leg program~test_forcad_utils->interface~gauss_leg interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~lsq_fit_bspline proc~create nurbs_surface%create program~lsq_fit_bspline_2d->proc~create proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 proc~create~3 nurbs_volume%create program~lsq_fit_bspline_3d->proc~create~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~lsq_fit_bspline~3 program~test_nurbs_volume->proc~create~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 none~derivative~3 nurbs_volume%derivative program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg proc~ansatz~3->none~derivative~3 proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create->interface~compute_xg proc~create~3->interface~compute_xg~3 proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 proc~export_xth_in_xg->interface~compute_xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/kron_t1_t1.html"},{"title":"kron_t1_t2 – ForCAD","text":"private pure function kron_t1_t2(u, A) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk), (size(u)*size(A,1),size(A,2)) Called by proc~~kron_t1_t2~~CalledByGraph proc~kron_t1_t2 kron_t1_t2 interface~kron kron interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d cmp_Tgc_2d proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~cmp_tgc_3d->interface~kron proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->interface~kron proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->interface~kron proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->interface~kron proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->interface~kron proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->interface~kron proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~kron proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->interface~kron proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->interface~kron proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->interface~kron proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->interface~kron program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~kron interface~gauss_leg gauss_leg program~test_forcad_utils->interface~gauss_leg interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~lsq_fit_bspline proc~create nurbs_surface%create program~lsq_fit_bspline_2d->proc~create proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 proc~create~3 nurbs_volume%create program~lsq_fit_bspline_3d->proc~create~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~lsq_fit_bspline~3 program~test_nurbs_volume->proc~create~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 none~derivative~3 nurbs_volume%derivative program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg proc~ansatz~3->none~derivative~3 proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create->interface~compute_xg proc~create~3->interface~compute_xg~3 proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 proc~export_xth_in_xg->interface~compute_xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/kron_t1_t2.html"},{"title":"unique_integer – ForCAD","text":"private pure function unique_integer(vec) result(output) Arguments Type Intent Optional Attributes Name integer, intent(in), contiguous :: vec (:) Return Value integer, allocatable, (:) Called by proc~~unique_integer~~CalledByGraph proc~unique_integer unique_integer interface~unique unique interface~unique->proc~unique_integer proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~unique proc~cmp_elem nurbs_surface%cmp_elem proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~unique proc~cmp_elem~3 nurbs_volume%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~cmp_elem->interface~unique proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~cmp_elem_xth->interface~unique proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~cmp_elem_xth~2->interface~unique proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~cmp_elem_xth~3->interface~unique proc~cmp_elem~2->interface~unique proc~cmp_elem~3->interface~unique proc~export_xth nurbs_surface%export_Xth proc~export_xth->interface~unique proc~export_xth->proc~cmp_elem_xth proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~unique proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~unique proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->interface~unique proc~export_xth~3->proc~cmp_elem_xth~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~unique proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_area->proc~cmp_elem proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 proc~cmp_volume->proc~cmp_elem~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xth_in_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~cmp_elem~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~export_xth program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~export_xth~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/unique_integer.html"},{"title":"unique_real – ForCAD","text":"private pure function unique_real(vec) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: vec (:) Return Value real(kind=rk), allocatable, (:) Called by proc~~unique_real~~CalledByGraph proc~unique_real unique_real interface~unique unique interface~unique->proc~unique_real proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~unique proc~cmp_elem nurbs_surface%cmp_elem proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~unique proc~cmp_elem~3 nurbs_volume%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~cmp_elem->interface~unique proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~cmp_elem_xth->interface~unique proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~cmp_elem_xth~2->interface~unique proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~cmp_elem_xth~3->interface~unique proc~cmp_elem~2->interface~unique proc~cmp_elem~3->interface~unique proc~export_xth nurbs_surface%export_Xth proc~export_xth->interface~unique proc~export_xth->proc~cmp_elem_xth proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~unique proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~unique proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->interface~unique proc~export_xth~3->proc~cmp_elem_xth~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~unique proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_area->proc~cmp_elem proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 proc~cmp_volume->proc~cmp_elem~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xth_in_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~cmp_elem~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~export_xth program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~export_xth~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/unique_real.html"},{"title":"elevate_degree_A_5_9 – ForCAD","text":"public pure subroutine elevate_degree_A_5_9(t, knot, degree, Xcw, nc_new, knot_new, Xcw_new, Tmap) Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) real(kind=rk), intent(out), optional, allocatable :: Tmap (:,:) Calls proc~~elevate_degree_a_5_9~~CallsGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree_a_5_9~~CalledByGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~elevate_degree~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~elevate_degree~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree_a_5_9.html"},{"title":"export_vtk_legacy – ForCAD","text":"public impure subroutine export_vtk_legacy(filename, points, elemConn, vtkCellType, point_data, field_names, encoding) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rk), intent(in), contiguous :: points (:,:) integer, intent(in), contiguous :: elemConn (:,:) integer, intent(in) :: vtkCellType real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Called by proc~~export_vtk_legacy~~CalledByGraph proc~export_vtk_legacy export_vtk_legacy proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~export_vtk_legacy proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~export_vtk_legacy proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~export_vtk_legacy proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~export_vtk_legacy proc~export_xth nurbs_surface%export_Xth proc~export_xth->proc~export_vtk_legacy proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->proc~export_vtk_legacy proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~export_vtk_legacy proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->proc~export_vtk_legacy program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~export_vtk_legacy program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xc~3 program~example_bend_pipe->proc~export_xg~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xc~3 program~example_helix_pipe->proc~export_xg~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xc program~example_plate_hole_1_2d->proc~export_xg program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xc~3 program~example_plate_hole_1_3d->proc~export_xg~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xc program~example_plate_hole_2_2d->proc~export_xg program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xc~3 program~example_plate_hole_2_3d->proc~export_xg~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xc program~example_plate_hole_4_2d->proc~export_xg program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xc~3 program~example_plate_hole_4_3d->proc~export_xg~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xc~3 program~example_toroidal_pipe->proc~export_xg~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xc~3 program~example_twist_taper->proc~export_xg~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xc~2 program~lsq_fit_bspline_1d->proc~export_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xc program~lsq_fit_bspline_2d->proc~export_xg program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xc~3 program~lsq_fit_bspline_3d->proc~export_xg~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xc~2 program~lsq_fit_nurbs_1d->proc~export_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xc program~lsq_fit_nurbs_2d->proc~export_xg program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xc~3 program~lsq_fit_nurbs_3d->proc~export_xg~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xc program~poisson_iga_solver_2d->proc~export_xg program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xc~3 program~poisson_iga_solver_3d->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xc program~test_nurbs_surface->proc~export_xg program~test_nurbs_surface->proc~export_xth program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xc~3 program~test_nurbs_volume->proc~export_xg~3 program~test_nurbs_volume->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_vtk_legacy.html"},{"title":"insert_knot_A_5_1 – ForCAD","text":"public pure subroutine insert_knot_A_5_1(p, UP, Pw, u, k, s, r, nq, UQ, Qw, T) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) real(kind=rk), intent(out), optional, allocatable :: T (:,:) Called by proc~~insert_knot_a_5_1~~CalledByGraph proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->proc~insert_knot_a_5_1 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->proc~insert_knot_a_5_1 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~insert_knots~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~insert_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~insert_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~insert_knots~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~insert_knots~3 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~insert_knots program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~insert_knots program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knot_a_5_1.html"},{"title":"remove_knots_A_5_8 – ForCAD","text":"public pure subroutine remove_knots_A_5_8(p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) Called by proc~~remove_knots_a_5_8~~CalledByGraph proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~remove_knots_a_5_8 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~remove_knots_a_5_8 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->proc~remove_knots_a_5_8 program~example1_curve example1_curve program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->proc~remove_knots~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~remove_knots program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots_a_5_8.html"},{"title":"basis_bspline_2der_A – ForCAD","text":"private pure subroutine basis_bspline_2der_A(Xt, knot, nc, degree, d2B, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) Called by proc~~basis_bspline_2der_a~~CalledByGraph proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der basis_bspline_2der interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~basis_bspline_2der interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline_2der_a.html"},{"title":"basis_bspline_2der_B – ForCAD","text":"private pure subroutine basis_bspline_2der_B(Xt, knot, nc, degree, d2B, dB) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) Called by proc~~basis_bspline_2der_b~~CalledByGraph proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der basis_bspline_2der interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~basis_bspline_2der interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline_2der_b.html"},{"title":"basis_bspline_2der_C – ForCAD","text":"private pure subroutine basis_bspline_2der_C(Xt, knot, nc, degree, d2B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) Called by proc~~basis_bspline_2der_c~~CalledByGraph proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der basis_bspline_2der interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~basis_bspline_2der interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline_2der_c.html"},{"title":"basis_bspline_der_A – ForCAD","text":"private pure subroutine basis_bspline_der_A(Xt, knot, nc, degree, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) Called by proc~~basis_bspline_der_a~~CalledByGraph proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der basis_bspline_der interface~basis_bspline_der->proc~basis_bspline_der_a proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~basis_bspline_der interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline_der_a.html"},{"title":"basis_bspline_der_B – ForCAD","text":"private pure subroutine basis_bspline_der_B(Xt, knot, nc, degree, dB) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) Called by proc~~basis_bspline_der_b~~CalledByGraph proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der basis_bspline_der interface~basis_bspline_der->proc~basis_bspline_der_b proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~basis_bspline_der interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline_der_b.html"},{"title":"cmp_elemConn_Cn_L – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_L(nnode, p, Xth, vecKnot_mul, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_l~~CalledByGraph proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_cn proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~cmp_elem~3 program~poisson_iga_solver_3d->proc~ansatz~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_cn_l.html"},{"title":"cmp_elemConn_Cn_S – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_S(nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_s~~CalledByGraph proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_cn proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~cmp_elem~3 program~poisson_iga_solver_3d->proc~ansatz~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_cn_s.html"},{"title":"cmp_elemConn_Cn_V – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_V(nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_v~~CalledByGraph proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_cn proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~cmp_elem~3 program~poisson_iga_solver_3d->proc~ansatz~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_cn_v.html"},{"title":"gauss_legendre – ForCAD","text":"private pure subroutine gauss_legendre(x, w, interval) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: x (:) real(kind=rk), intent(out) :: w (:) real(kind=rk), intent(in), contiguous :: interval (:) Called by proc~~gauss_legendre~~CalledByGraph proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d gauss_legendre_1D proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->proc~gauss_legendre interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_1d interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre.html"},{"title":"gauss_legendre_1D – ForCAD","text":"private pure subroutine gauss_legendre_1D(interval, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval (:) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_1d~~CallsGraph proc~gauss_legendre_1d gauss_legendre_1D proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_1d~~CalledByGraph proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_1d proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre_1d.html"},{"title":"gauss_legendre_2D – ForCAD","text":"private pure subroutine gauss_legendre_2D(interval1, interval2, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_2d~~CallsGraph proc~gauss_legendre_2d gauss_legendre_2D interface~kron kron proc~gauss_legendre_2d->interface~kron interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre gauss_legendre proc~gauss_legendre_2d->proc~gauss_legendre proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_2d~~CalledByGraph proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre_2d.html"},{"title":"gauss_legendre_3D – ForCAD","text":"private pure subroutine gauss_legendre_3D(interval1, interval2, interval3, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) real(kind=rk), intent(in), contiguous :: interval3 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_3d~~CallsGraph proc~gauss_legendre_3d gauss_legendre_3D interface~kron kron proc~gauss_legendre_3d->interface~kron interface~ndgrid ndgrid proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre gauss_legendre proc~gauss_legendre_3d->proc~gauss_legendre proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_3d~~CalledByGraph proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_3d proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre_3d.html"},{"title":"ndgrid2 – ForCAD","text":"private pure subroutine ndgrid2(X_dir1, X_dir2, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid2~~CalledByGraph proc~ndgrid2 ndgrid2 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid2 proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~ndgrid interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~ndgrid proc~ansatz~3->interface~gauss_leg none~derivative~3 nurbs_volume%derivative proc~ansatz~3->none~derivative~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~3 nurbs_volume%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~ndgrid proc~export_xth nurbs_surface%export_Xth proc~export_xth->interface~ndgrid proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~ndgrid proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->interface~ndgrid proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->interface~ndgrid program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->interface~ndgrid program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->interface~ndgrid program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->interface~ndgrid program~lsq_fit_nurbs_3d->proc~create~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~ndgrid program~test_forcad_utils->interface~gauss_leg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->interface~ndgrid program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~export_xth none~basis nurbs_surface%basis program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative none~derivative2 nurbs_surface%derivative2 program~test_nurbs_surface->none~derivative2 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~nearest_point2 nurbs_surface%nearest_point2 program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->interface~ndgrid program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~export_xth~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d none~basis->proc~basis_vector none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_vector none~derivative2->proc~derivative2_vector none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area->proc~ansatz proc~cmp_volume->proc~ansatz~3 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ndgrid2.html"},{"title":"ndgrid3 – ForCAD","text":"private pure subroutine ndgrid3(X_dir1, X_dir2, X_dir3, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid3~~CalledByGraph proc~ndgrid3 ndgrid3 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid3 proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~ndgrid interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~ndgrid proc~ansatz~3->interface~gauss_leg none~derivative~3 nurbs_volume%derivative proc~ansatz~3->none~derivative~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~3 nurbs_volume%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~ndgrid proc~export_xth nurbs_surface%export_Xth proc~export_xth->interface~ndgrid proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~ndgrid proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->interface~ndgrid proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->interface~ndgrid program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->interface~ndgrid program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->interface~ndgrid program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->interface~ndgrid program~lsq_fit_nurbs_3d->proc~create~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~ndgrid program~test_forcad_utils->interface~gauss_leg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->interface~ndgrid program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~export_xth none~basis nurbs_surface%basis program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative none~derivative2 nurbs_surface%derivative2 program~test_nurbs_surface->none~derivative2 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~nearest_point2 nurbs_surface%nearest_point2 program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->interface~ndgrid program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~export_xth~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d none~basis->proc~basis_vector none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_vector none~derivative2->proc~derivative2_vector none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area->proc~ansatz proc~cmp_volume->proc~ansatz~3 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ndgrid3.html"},{"title":"basis_bspline_2der – ForCAD","text":"public interface basis_bspline_2der Calls interface~~basis_bspline_2der~~CallsGraph interface~basis_bspline_2der basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~basis_bspline_2der~~CalledByGraph interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~basis_bspline_2der interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine basis_bspline_2der_A (Xt, knot, nc, degree, d2B, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) private pure subroutine basis_bspline_2der_B (Xt, knot, nc, degree, d2B, dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) private pure subroutine basis_bspline_2der_C (Xt, knot, nc, degree, d2B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc)","tags":"","url":"interface/basis_bspline_2der.html"},{"title":"basis_bspline_der – ForCAD","text":"public interface basis_bspline_der Calls interface~~basis_bspline_der~~CallsGraph interface~basis_bspline_der basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~basis_bspline_der~~CalledByGraph interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~basis_bspline_der interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine basis_bspline_der_A (Xt, knot, nc, degree, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) private pure subroutine basis_bspline_der_B (Xt, knot, nc, degree, dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc)","tags":"","url":"interface/basis_bspline_der.html"},{"title":"compute_multiplicity – ForCAD","text":"public interface compute_multiplicity Calls interface~~compute_multiplicity~~CallsGraph interface~compute_multiplicity compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_multiplicity~~CalledByGraph interface~compute_multiplicity compute_multiplicity proc~cmp_nc nurbs_surface%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_volume%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_volume%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc_dir nurbs_surface%get_nc_dir proc~get_nc_dir->interface~compute_multiplicity proc~get_nc_dir~2 nurbs_volume%get_nc_dir proc~get_nc_dir~2->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->interface~compute_multiplicity proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->interface~compute_multiplicity none~set~3 nurbs_volume%set proc~remove_knots~3->none~set~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~compute_multiplicity program~test_forcad_utils->proc~elevate_degree_a_5_9 none~get_nc nurbs_surface%get_nc none~get_nc->proc~get_nc_dir none~get_nc~3 nurbs_volume%get_nc none~get_nc~3->proc~get_nc_dir~2 proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~cmp_nc~2 proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->none~set~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~insert_knots~3 program~example_bend_pipe->proc~elevate_degree~3 proc~bend_pipe bend_pipe program~example_bend_pipe->proc~bend_pipe proc~set_ring~2 nurbs_volume%set_ring program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~insert_knots~3 program~example_helix_pipe->proc~elevate_degree~3 proc~build_helix build_helix program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~set_ring~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~insert_knots program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~insert_knots~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_nurbs_volume->none~set~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~insert_knots~3 program~example_toroidal_pipe->proc~elevate_degree~3 proc~map_to_torus_sinez map_to_torus_sineZ program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~insert_knots program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_elevate_and_insert_3d->none~set~3 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~get_continuity~2 program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~get_continuity program~lsq_fit_bspline_2d->none~get_nc program~lsq_fit_bspline_2d->none~set program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~get_continuity~3 program~lsq_fit_bspline_3d->none~get_nc~3 program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~get_continuity~2 program~lsq_fit_nurbs_1d->none~set~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~get_continuity program~lsq_fit_nurbs_2d->none~get_nc program~lsq_fit_nurbs_2d->none~set program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~get_continuity~3 program~lsq_fit_nurbs_3d->none~get_nc~3 program~lsq_fit_nurbs_3d->none~set~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots program~poisson_iga_solver_2d->none~get_nc program~poisson_iga_solver_2d->proc~cmp_elem proc~ansatz nurbs_surface%ansatz program~poisson_iga_solver_2d->proc~ansatz proc~set_tetragon nurbs_surface%set_tetragon program~poisson_iga_solver_2d->proc~set_tetragon program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 program~poisson_iga_solver_3d->none~get_nc~3 program~poisson_iga_solver_3d->proc~cmp_elem~3 proc~ansatz~3 nurbs_volume%ansatz program~poisson_iga_solver_3d->proc~ansatz~3 proc~set_hexahedron nurbs_volume%set_hexahedron program~poisson_iga_solver_3d->proc~set_hexahedron program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 program~test_nurbs_curve->proc~get_continuity~2 program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc program~test_nurbs_surface->proc~get_continuity program~test_nurbs_surface->proc~get_multiplicity program~test_nurbs_surface->proc~insert_knots program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->none~get_nc program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->none~set proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~modify_wc nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc proc~modify_xc nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc proc~set_c nurbs_surface%set_C program~test_nurbs_surface->proc~set_c proc~set_half_ring nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring proc~set_ring nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc~3 program~test_nurbs_volume->proc~get_continuity~3 program~test_nurbs_volume->proc~get_multiplicity~3 program~test_nurbs_volume->proc~insert_knots~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->none~get_nc~3 program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~modify_wc~3 nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc~3 proc~set_c~3 nurbs_volume%set_C program~test_nurbs_volume->proc~set_c~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~2->proc~set2~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~bend_pipe->none~get_nc~3 proc~bend_pipe->none~set~3 proc~build_helix->none~get_nc~3 proc~build_helix->none~set~3 proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 proc~map_to_torus_sinez->none~get_nc~3 proc~map_to_torus_sinez->none~set~3 proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~modify_wc->none~set proc~modify_wc~2->none~set~2 proc~modify_wc~3->none~set~3 proc~modify_xc->none~set proc~modify_xc~2->none~set~2 proc~modify_xc~3->none~set~3 proc~set_c->none~set proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3->none~set~3 proc~set_half_circle->none~set~2 proc~set_half_ring->none~set proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set~3 proc~set_ring->none~set proc~set_ring~2->none~set~3 proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->none~set~2 program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->none~set~3 program~compute_volume->proc~cmp_volume program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer","tags":"","url":"interface/compute_multiplicity.html"},{"title":"dyad – ForCAD","text":"public interface dyad Calls interface~~dyad~~CallsGraph interface~dyad dyad proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dyad~~CalledByGraph interface~dyad dyad proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~dyad program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~dyad proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:)","tags":"","url":"interface/dyad.html"},{"title":"elemConn_C0 – ForCAD","text":"public interface elemConn_C0 Calls interface~~elemconn_c0~~CallsGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_c0~~CalledByGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~cmp_elem_xth->interface~elemconn_c0 proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~cmp_elem_xth~2->interface~elemconn_c0 proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~cmp_elem_xth~3->interface~elemconn_c0 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xth nurbs_surface%export_Xth proc~export_xth->proc~cmp_elem_xth proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->proc~cmp_elem_xth~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis program~test_nurbs_surface->proc~cmp_elem_xg_vis program~test_nurbs_surface->proc~export_xc program~test_nurbs_surface->proc~export_xg program~test_nurbs_surface->proc~export_xth program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis~3 program~test_nurbs_volume->proc~cmp_elem_xg_vis~3 program~test_nurbs_volume->proc~export_xc~3 program~test_nurbs_volume->proc~export_xg~3 program~test_nurbs_volume->proc~export_xth~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xc~3 program~example_bend_pipe->proc~export_xg~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xc~3 program~example_helix_pipe->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xc program~example_plate_hole_1_2d->proc~export_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xc~3 program~example_plate_hole_1_3d->proc~export_xg~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xc program~example_plate_hole_2_2d->proc~export_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xc~3 program~example_plate_hole_2_3d->proc~export_xg~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xc program~example_plate_hole_4_2d->proc~export_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xc~3 program~example_plate_hole_4_3d->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xc~3 program~example_toroidal_pipe->proc~export_xg~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xc~3 program~example_twist_taper->proc~export_xg~3 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xc~2 program~lsq_fit_bspline_1d->proc~export_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xc program~lsq_fit_bspline_2d->proc~export_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xc~3 program~lsq_fit_bspline_3d->proc~export_xg~3 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xc~2 program~lsq_fit_nurbs_1d->proc~export_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xc program~lsq_fit_nurbs_2d->proc~export_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xc~3 program~lsq_fit_nurbs_3d->proc~export_xg~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xc program~poisson_iga_solver_2d->proc~export_xg program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xc~3 program~poisson_iga_solver_3d->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:)","tags":"","url":"interface/elemconn_c0.html"},{"title":"elemConn_Cn – ForCAD","text":"public interface elemConn_Cn Calls interface~~elemconn_cn~~CallsGraph interface~elemconn_cn elemConn_Cn proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_cn~~CalledByGraph interface~elemconn_cn elemConn_Cn proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~elemconn_cn proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~cmp_elem~3 program~poisson_iga_solver_3d->proc~ansatz~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:)","tags":"","url":"interface/elemconn_cn.html"},{"title":"gauss_leg – ForCAD","text":"public interface gauss_leg Calls interface~~gauss_leg~~CallsGraph interface~gauss_leg gauss_leg proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~kron kron proc~gauss_legendre_2d->interface~kron interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~gauss_leg~~CalledByGraph interface~gauss_leg gauss_leg proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval (:) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) real(kind=rk), intent(in), contiguous :: interval3 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:)","tags":"","url":"interface/gauss_leg.html"},{"title":"kron – ForCAD","text":"public interface kron Calls interface~~kron~~CallsGraph interface~kron kron proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~kron~~CalledByGraph interface~kron kron proc~cmp_tgc_2d cmp_Tgc_2d proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~cmp_tgc_3d->interface~kron proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->interface~kron proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->interface~kron proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->interface~kron proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->interface~kron proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->interface~kron proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~kron proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->interface~kron proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->interface~kron proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->interface~kron proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->interface~kron program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~kron interface~gauss_leg gauss_leg program~test_forcad_utils->interface~gauss_leg interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~lsq_fit_bspline proc~create nurbs_surface%create program~lsq_fit_bspline_2d->proc~create proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 proc~create~3 nurbs_volume%create program~lsq_fit_bspline_3d->proc~create~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~lsq_fit_bspline~3 program~test_nurbs_volume->proc~create~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 none~derivative~3 nurbs_volume%derivative program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~gauss_leg none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~gauss_leg proc~ansatz~3->none~derivative~3 proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create->interface~compute_xg proc~create~3->interface~compute_xg~3 proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 proc~export_xth_in_xg->interface~compute_xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function kron_t1_t1 (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) private pure function kron_t1_t2 (u, A) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk), (size(u)*size(A,1),size(A,2)) private pure function kron3 (u, v, w) result(out) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(in), contiguous :: w (:) Return Value real(kind=rk), (size(u)*size(v)*size(w))","tags":"","url":"interface/kron.html"},{"title":"ndgrid – ForCAD","text":"public interface ndgrid Calls interface~~ndgrid~~CallsGraph interface~ndgrid ndgrid proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~ndgrid~~CalledByGraph interface~ndgrid ndgrid proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~ndgrid interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~ndgrid proc~ansatz~3->interface~gauss_leg none~derivative~3 nurbs_volume%derivative proc~ansatz~3->none~derivative~3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~3 nurbs_volume%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~ndgrid proc~export_xth nurbs_surface%export_Xth proc~export_xth->interface~ndgrid proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~ndgrid proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->interface~ndgrid proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->interface~ndgrid program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->interface~ndgrid program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->interface~ndgrid program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->interface~ndgrid program~lsq_fit_nurbs_3d->proc~create~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~ndgrid program~test_forcad_utils->interface~gauss_leg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->interface~ndgrid program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~export_xth none~basis nurbs_surface%basis program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative none~derivative2 nurbs_surface%derivative2 program~test_nurbs_surface->none~derivative2 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~nearest_point2 nurbs_surface%nearest_point2 program~test_nurbs_surface->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->interface~ndgrid program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~export_xth~3 none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d none~basis->proc~basis_vector none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_vector none~derivative2->proc~derivative2_vector none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area->proc~ansatz proc~cmp_volume->proc~ansatz~3 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->none~basis program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->none~basis~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","url":"interface/ndgrid.html"},{"title":"unique – ForCAD","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique unique proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~unique~~CalledByGraph interface~unique unique proc~ansatz nurbs_surface%ansatz proc~ansatz->interface~unique proc~cmp_elem nurbs_surface%cmp_elem proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->interface~unique proc~cmp_elem~3 nurbs_volume%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~cmp_elem->interface~unique proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~cmp_elem_xth->interface~unique proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~cmp_elem_xth~2->interface~unique proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~cmp_elem_xth~3->interface~unique proc~cmp_elem~2->interface~unique proc~cmp_elem~3->interface~unique proc~export_xth nurbs_surface%export_Xth proc~export_xth->interface~unique proc~export_xth->proc~cmp_elem_xth proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~unique proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~unique proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->interface~unique proc~export_xth~3->proc~cmp_elem_xth~3 program~test_forcad_utils test_forcad_utils program~test_forcad_utils->interface~unique proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz proc~cmp_area->proc~cmp_elem proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 proc~cmp_volume->proc~cmp_elem~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~export_xth~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xth_in_xg~2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~cmp_elem~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~export_xth program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~export_xth~3 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), contiguous :: vec (:) Return Value integer, allocatable, (:) private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: vec (:) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/unique.html"},{"title":"cmp_Tgc_2d – ForCAD","text":"private pure function cmp_Tgc_2d(Xti, knot1, knot2, nc, degree, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in), contiguous :: nc (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)) Calls proc~~cmp_tgc_2d~~CallsGraph proc~cmp_tgc_2d cmp_Tgc_2d interface~kron kron proc~cmp_tgc_2d->interface~kron proc~basis_bspline basis_bspline proc~cmp_tgc_2d->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_tgc_2d~~CalledByGraph proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_nurbs_2d proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_surface%create proc~create->interface~compute_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~compute_xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_tgc_2d.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~~CallsGraph proc~cmp_xg nurbs_surface%cmp_Xg interface~compute_xg compute_Xg proc~cmp_xg->interface~compute_xg proc~is_rational nurbs_surface%is_rational proc~cmp_xg->proc~is_rational proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~~CalledByGraph proc~cmp_xg nurbs_surface%cmp_Xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_xg.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~~CallsGraph proc~cmp_elem nurbs_surface%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn interface~unique unique proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem~~CalledByGraph proc~cmp_elem nurbs_surface%cmp_elem proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~cmp_elem proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_2d->proc~ansatz program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem program~test_nurbs_surface->proc~cmp_area program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~~CallsGraph proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~~CalledByGraph proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis program~test_nurbs_surface->proc~export_xc program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xc program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xc program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xc program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xc program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xc program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xc_vis.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~~CallsGraph proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~~CalledByGraph proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xg_vis program~test_nurbs_surface->proc~export_xg program~example3_surface example3_surface program~example3_surface->proc~export_xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xg program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xg program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xg program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xg program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xg_vis.html"},{"title":"cmp_elem_Xth – ForCAD","text":"private pure function cmp_elem_Xth(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xth~~CallsGraph proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xth->interface~elemconn_c0 interface~unique unique proc~cmp_elem_xth->interface~unique proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xth~~CalledByGraph proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~export_xth nurbs_surface%export_Xth proc~export_xth->proc~cmp_elem_xth program~example3_surface example3_surface program~example3_surface->proc~export_xth program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xth Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xth.html"},{"title":"compute_Tgc_bspline_2d_scalar – ForCAD","text":"private pure function compute_Tgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_2d_scalar~~CallsGraph proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~kron kron proc~compute_tgc_bspline_2d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_2d_scalar~~CalledByGraph proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~basis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_2d_scalar.html"},{"title":"compute_Tgc_bspline_2d_vector – ForCAD","text":"private pure function compute_Tgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_2d_vector~~CallsGraph proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~kron kron proc~compute_tgc_bspline_2d_vector->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_2d_vector~~CalledByGraph proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_2d_vector proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~basis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_2d_vector.html"},{"title":"compute_Tgc_nurbs_2d_scalar – ForCAD","text":"private pure function compute_Tgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_2d_scalar~~CallsGraph proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~kron kron proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_2d_scalar~~CalledByGraph proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~basis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_2d_scalar.html"},{"title":"compute_Tgc_nurbs_2d_vector – ForCAD","text":"private pure function compute_Tgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_2d_vector~~CallsGraph proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~kron kron proc~compute_tgc_nurbs_2d_vector->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_2d_vector~~CalledByGraph proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~basis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_2d_vector.html"},{"title":"compute_Xg_bspline_2d – ForCAD","text":"private pure function compute_Xg_bspline_2d(Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_2d~~CallsGraph proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_2d~~CalledByGraph proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_2d proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_surface%create proc~create->interface~compute_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~compute_xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_2d.html"},{"title":"compute_Xg_bspline_2d_1point – ForCAD","text":"private pure function compute_Xg_bspline_2d_1point(Xt, knot1, knot2, degree, nc, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) Calls proc~~compute_xg_bspline_2d_1point~~CallsGraph proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~kron kron proc~compute_xg_bspline_2d_1point->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_2d_1point~~CalledByGraph proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_surface%create proc~create->interface~compute_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~compute_xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_2d_1point.html"},{"title":"compute_Xg_nurbs_2d – ForCAD","text":"private pure function compute_Xg_nurbs_2d(Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) integer, intent(in), optional, contiguous :: ng (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_2d~~CallsGraph proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d interface~kron kron proc~cmp_tgc_2d->interface~kron proc~basis_bspline basis_bspline proc~cmp_tgc_2d->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_2d~~CalledByGraph proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_nurbs_2d proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_surface%create proc~create->interface~compute_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~compute_xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_2d.html"},{"title":"compute_Xg_nurbs_2d_1point – ForCAD","text":"private pure function compute_Xg_nurbs_2d_1point(Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) Calls proc~~compute_xg_nurbs_2d_1point~~CallsGraph proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~kron kron proc~compute_xg_nurbs_2d_1point->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_2d_1point~~CalledByGraph proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_surface%create proc~create->interface~compute_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~compute_xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_2d_1point.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~~CalledByGraph proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc nurbs_surface%get_Wc none~get_wc->proc~get_wc_all proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_wc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_wc program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~get_wc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_wc program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wc_all.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~~CalledByGraph proc~get_wci nurbs_surface%get_Wci none~get_wc nurbs_surface%get_Wc none~get_wc->proc~get_wci proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_wc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_wc program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~get_wc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_wc program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wci.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~~CalledByGraph proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc nurbs_surface%get_Xc none~get_xc->proc~get_xc_all proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_xc program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~get_xc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~get_xc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xc program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xc_all.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~~CalledByGraph proc~get_xci nurbs_surface%get_Xci none~get_xc nurbs_surface%get_Xc none~get_xc->proc~get_xci proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_xc program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~get_xc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~get_xc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xc program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xci.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~~CalledByGraph proc~get_xcid nurbs_surface%get_Xcid none~get_xc nurbs_surface%get_Xc none~get_xc->proc~get_xcid proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_xc program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~get_xc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~get_xc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xc program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xcid.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xg_all~~CalledByGraph proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg nurbs_surface%get_Xg none~get_xg->proc~get_xg_all program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_xg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xg_all.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xgi~~CalledByGraph proc~get_xgi nurbs_surface%get_Xgi none~get_xg nurbs_surface%get_Xg none~get_xg->proc~get_xgi program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_xg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgi.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xgid~~CalledByGraph proc~get_xgid nurbs_surface%get_Xgid none~get_xg nurbs_surface%get_Xg none~get_xg->proc~get_xgid program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_xg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgid.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xt~~CalledByGraph proc~get_xt nurbs_surface%get_Xt program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_xt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xt.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~~CallsGraph proc~get_continuity nurbs_surface%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_continuity~~CalledByGraph proc~get_continuity nurbs_surface%get_continuity program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~get_continuity program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~get_continuity program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_continuity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_continuity.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_degree_all~~CalledByGraph proc~get_degree_all nurbs_surface%get_degree_all none~get_degree nurbs_surface%get_degree none~get_degree->proc~get_degree_all program~example3_surface example3_surface program~example3_surface->none~get_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_degree program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_degree program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~get_degree program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_all.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Called by proc~~get_degree_dir~~CalledByGraph proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree nurbs_surface%get_degree none~get_degree->proc~get_degree_dir program~example3_surface example3_surface program~example3_surface->none~get_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_degree program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_degree program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~get_degree program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_dir.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem~~CalledByGraph proc~get_elem nurbs_surface%get_elem program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_elem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xc_vis~~CalledByGraph proc~get_elem_xc_vis nurbs_surface%get_elem_Xc_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_elem_xc_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xc_vis.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xg_vis~~CalledByGraph proc~get_elem_xg_vis nurbs_surface%get_elem_Xg_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_elem_xg_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xg_vis.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~~CalledByGraph proc~get_knot_all nurbs_surface%get_knot_all none~get_knot nurbs_surface%get_knot none~get_knot->proc~get_knot_all proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~get_knot proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~get_knot proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_knot proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_knot proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~get_knot program~example3_surface example3_surface program~example3_surface->none~get_knot program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~get_knot program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_2d->proc~insert_knots program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_knot program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_knot program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_knot program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~insert_knots program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_surface->proc~insert_knots program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knot_all.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~~CalledByGraph proc~get_knoti nurbs_surface%get_knoti none~get_knot nurbs_surface%get_knot none~get_knot->proc~get_knoti proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~get_knot proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~get_knot proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_knot proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_knot proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~get_knot program~example3_surface example3_surface program~example3_surface->none~get_knot program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~get_knot program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_2d->proc~insert_knots program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_knot program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_knot program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_knot program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~insert_knots program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_surface->proc~insert_knots program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knoti.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~~CallsGraph proc~get_multiplicity nurbs_surface%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~~CalledByGraph proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_multiplicity program~test_nurbs_surface->proc~cmp_elem proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area none~set nurbs_surface%set program~test_nurbs_surface->none~set proc~elevate_degree nurbs_surface%elevate_degree program~test_nurbs_surface->proc~elevate_degree proc~modify_wc nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc proc~modify_xc nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc proc~remove_knots nurbs_surface%remove_knots program~test_nurbs_surface->proc~remove_knots proc~set_c nurbs_surface%set_C program~test_nurbs_surface->proc~set_c proc~set_half_ring nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring proc~set_ring nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon proc~ansatz nurbs_surface%ansatz proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~cmp_area->proc~cmp_elem proc~cmp_area->proc~ansatz proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_degree proc~set3 nurbs_surface%set3 proc~set3->proc~cmp_degree program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~cmp_elem program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon none~set->proc~set1 none~set->proc~set3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_area->none~set proc~elevate_degree->none~set proc~modify_wc->none~set proc~modify_xc->none~set proc~remove_knots->none~set proc~set_c->none~set proc~set_half_ring->none~set proc~set_ring->none~set proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_multiplicity.html"},{"title":"get_nc_all – ForCAD","text":"private pure function get_nc_all(this) result(nc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_nc_all~~CalledByGraph proc~get_nc_all nurbs_surface%get_nc_all none~get_nc nurbs_surface%get_nc none~get_nc->proc~get_nc_all program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_nc program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_nc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~get_nc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_nc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_all.html"},{"title":"get_nc_dir – ForCAD","text":"private pure function get_nc_dir(this, dir) result(nc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc_dir~~CallsGraph proc~get_nc_dir nurbs_surface%get_nc_dir interface~compute_multiplicity compute_multiplicity proc~get_nc_dir->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc_dir~~CalledByGraph proc~get_nc_dir nurbs_surface%get_nc_dir none~get_nc nurbs_surface%get_nc none~get_nc->proc~get_nc_dir program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~get_nc program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~get_nc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~get_nc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_nc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_dir.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_ng~~CalledByGraph proc~get_ng nurbs_surface%get_ng program~example_ppm1 example_ppm1 program~example_ppm1->proc~get_ng program~example_ppm2 example_ppm2 program~example_ppm2->proc~get_ng program~example_ppm3 example_ppm3 program~example_ppm3->proc~get_ng Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_ng.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical Called by proc~~is_rational~~CalledByGraph proc~is_rational nurbs_surface%is_rational proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->proc~is_rational proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->proc~is_rational proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->proc~is_rational proc~create nurbs_surface%create proc~create->proc~is_rational proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->proc~is_rational proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->proc~is_rational proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->proc~is_rational proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->proc~is_rational proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~is_rational proc~export_iges nurbs_surface%export_iges proc~export_iges->proc~is_rational proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->proc~is_rational proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~is_rational proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~is_rational none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_surface->proc~elevate_degree program~example3_surface->proc~export_iges program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~elevate_degree program~example_nurbs_surface->proc~export_xth_in_xg program~example_nurbs_surface->proc~insert_knots program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~elevate_degree program~fdm_elevate_and_insert_2d->proc~insert_knots program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~fdm_test_surface->none~derivative2 program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~poisson_iga_solver_2d->proc~insert_knots program~poisson_iga_solver_2d->none~basis proc~ansatz nurbs_surface%ansatz program~poisson_iga_solver_2d->proc~ansatz program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~export_iges program~test_nurbs_surface->proc~insert_knots program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->none~basis program~test_nurbs_surface->none~derivative program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~ansatz->none~derivative proc~cmp_area->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_rational.html"},{"title":"ansatz – ForCAD","text":"private pure subroutine ansatz(this, ie, ig, Tgc, dTgc_dXg, dA, ngauss) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dA integer, intent(in), optional :: ngauss (2) Calls proc~~ansatz~~CallsGraph proc~ansatz nurbs_surface%ansatz interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz->interface~ndgrid interface~unique unique proc~ansatz->interface~unique none~derivative nurbs_surface%derivative proc~ansatz->none~derivative none~set nurbs_surface%set proc~ansatz->none~set proc~cmp_elem nurbs_surface%cmp_elem proc~ansatz->proc~cmp_elem proc~det det proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar nurbs_surface%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_surface%derivative_vector none~derivative->proc~derivative_vector proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_elem->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_surface%is_rational proc~derivative_scalar->proc~is_rational proc~derivative_vector->interface~ndgrid proc~derivative_vector->interface~compute_dtgc proc~derivative_vector->proc~is_rational proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid interface~kron kron proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->proc~get_multiplicity proc~cmp_degree->set proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_2d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ansatz~~CalledByGraph proc~ansatz nurbs_surface%ansatz proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ansatz.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~~CallsGraph proc~basis_scalar nurbs_surface%basis_scalar interface~compute_tgc compute_Tgc proc~basis_scalar->interface~compute_tgc proc~is_rational nurbs_surface%is_rational proc~basis_scalar->proc~is_rational proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector interface~kron kron proc~compute_tgc_bspline_2d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_scalar~~CalledByGraph proc~basis_scalar nurbs_surface%basis_scalar none~basis nurbs_surface%basis none~basis->proc~basis_scalar program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~basis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_scalar.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res1, res2, Xt1, Xt2, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~~CallsGraph proc~basis_vector nurbs_surface%basis_vector interface~compute_tgc compute_Tgc proc~basis_vector->interface~compute_tgc interface~ndgrid ndgrid proc~basis_vector->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~basis_vector->proc~is_rational proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~kron kron proc~compute_tgc_bspline_2d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_vector~~CalledByGraph proc~basis_vector nurbs_surface%basis_vector none~basis nurbs_surface%basis none~basis->proc~basis_vector program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~basis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_vector.html"},{"title":"cmp_area – ForCAD","text":"private pure subroutine cmp_area(this, area, ngauss) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(out) :: area integer, intent(in), optional :: ngauss (2) Calls proc~~cmp_area~~CallsGraph proc~cmp_area nurbs_surface%cmp_area proc~ansatz nurbs_surface%ansatz proc~cmp_area->proc~ansatz proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_area->proc~cmp_elem reduce reduce proc~cmp_area->reduce proc~ansatz->proc~cmp_elem interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz->interface~ndgrid interface~unique unique proc~ansatz->interface~unique none~derivative nurbs_surface%derivative proc~ansatz->none~derivative none~set nurbs_surface%set proc~ansatz->none~set proc~det det proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar nurbs_surface%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_surface%derivative_vector none~derivative->proc~derivative_vector proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_surface%is_rational proc~derivative_scalar->proc~is_rational proc~derivative_vector->interface~ndgrid proc~derivative_vector->interface~compute_dtgc proc~derivative_vector->proc~is_rational proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid interface~kron kron proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->proc~get_multiplicity proc~cmp_degree->set proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_2d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_area~~CalledByGraph proc~cmp_area nurbs_surface%cmp_area program~compute_area compute_area program~compute_area->proc~cmp_area program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_area.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_degree~~CallsGraph proc~cmp_degree nurbs_surface%cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity set set proc~cmp_degree->set interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~~CalledByGraph proc~cmp_degree nurbs_surface%cmp_degree proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_degree proc~set3 nurbs_surface%set3 proc~set3->proc~cmp_degree none~set nurbs_surface%set none~set->proc~set1 none~set->proc~set3 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->proc~set_c program~test_nurbs_surface->proc~set_half_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degree.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_nc~~CallsGraph proc~cmp_nc nurbs_surface%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity set set proc~cmp_nc->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~~CalledByGraph proc~cmp_nc nurbs_surface%cmp_nc proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc none~set nurbs_surface%set program~test_nurbs_surface->none~set proc~elevate_degree nurbs_surface%elevate_degree program~test_nurbs_surface->proc~elevate_degree proc~modify_wc nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc proc~modify_xc nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc proc~remove_knots nurbs_surface%remove_knots program~test_nurbs_surface->proc~remove_knots proc~set_c nurbs_surface%set_C program~test_nurbs_surface->proc~set_c proc~set_half_ring nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring proc~set_ring nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area none~set->proc~set1 none~set->proc~set2 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~elevate_degree->none~set proc~modify_wc->none~set proc~modify_xc->none~set proc~remove_knots->none~set proc~set_c->none~set proc~set_half_ring->none~set proc~set_ring->none~set proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set proc~cmp_area->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_nc.html"},{"title":"compute_d2Tgc_bspline_2d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_2d_scalar~~CallsGraph proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_2d_scalar~~CalledByGraph proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_2d_scalar.html"},{"title":"compute_d2Tgc_bspline_2d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_2d_vector~~CallsGraph proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_2d_vector~~CalledByGraph proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_2d_vector.html"},{"title":"compute_d2Tgc_nurbs_2d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_2d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_2d_scalar~~CalledByGraph proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_2d_scalar.html"},{"title":"compute_d2Tgc_nurbs_2d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_2d_vector~~CallsGraph proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_2d_vector~~CalledByGraph proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_2d_vector.html"},{"title":"compute_dTgc_bspline_2d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~compute_dtgc_bspline_2d_scalar~~CallsGraph proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_2d_scalar~~CalledByGraph proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_2d_scalar.html"},{"title":"compute_dTgc_bspline_2d_vector – ForCAD","text":"private pure subroutine compute_dTgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_2d_vector~~CallsGraph proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_2d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_2d_vector~~CalledByGraph proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_2d_vector.html"},{"title":"compute_dTgc_nurbs_2d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~compute_dtgc_nurbs_2d_scalar~~CallsGraph proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_2d_scalar~~CalledByGraph proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_2d_scalar.html"},{"title":"compute_dTgc_nurbs_2d_vector – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_2d_vector~~CallsGraph proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_2d_vector~~CalledByGraph proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_2d_vector.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, Xt1, Xt2, Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~~CallsGraph proc~create nurbs_surface%create interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~~CalledByGraph proc~create nurbs_surface%create proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/create.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~~CallsGraph proc~derivative2_scalar nurbs_surface%derivative2_scalar interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~is_rational nurbs_surface%is_rational proc~derivative2_scalar->proc~is_rational proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~~CalledByGraph proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_scalar.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~~CallsGraph proc~derivative2_vector nurbs_surface%derivative2_vector interface~compute_d2tgc compute_d2Tgc proc~derivative2_vector->interface~compute_d2tgc interface~ndgrid ndgrid proc~derivative2_vector->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~derivative2_vector->proc~is_rational proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~~CalledByGraph proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_vector.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc, elem) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~derivative_scalar~~CallsGraph proc~derivative_scalar nurbs_surface%derivative_scalar interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_surface%is_rational proc~derivative_scalar->proc~is_rational proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_scalar~~CalledByGraph proc~derivative_scalar nurbs_surface%derivative_scalar none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_scalar.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res1, res2, Xt1, Xt2, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~~CallsGraph proc~derivative_vector nurbs_surface%derivative_vector interface~compute_dtgc compute_dTgc proc~derivative_vector->interface~compute_dtgc interface~ndgrid ndgrid proc~derivative_vector->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~derivative_vector->proc~is_rational proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_vector~~CalledByGraph proc~derivative_vector nurbs_surface%derivative_vector none~derivative nurbs_surface%derivative none~derivative->proc~derivative_vector proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_vector.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t, B, Bs) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) Calls proc~~elevate_degree~~CallsGraph proc~elevate_degree nurbs_surface%elevate_degree none~get_knot nurbs_surface%get_knot proc~elevate_degree->none~get_knot none~set nurbs_surface%set proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~is_rational nurbs_surface%is_rational proc~elevate_degree->proc~is_rational proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~~CalledByGraph proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~elevate_degree program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~elevate_degree program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename, point_data, field_names, encoding) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xc~~CallsGraph proc~export_xc nurbs_surface%export_Xc proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy set set proc~export_xc->set interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~~CalledByGraph proc~export_xc nurbs_surface%export_Xc program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xc program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xc program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xc program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xc program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xc program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xc program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xc.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename, point_data, field_names, encoding) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xg~~CallsGraph proc~export_xg nurbs_surface%export_Xg proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xg->proc~export_vtk_legacy set set proc~export_xg->set interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~~CalledByGraph proc~export_xg nurbs_surface%export_Xg program~example3_surface example3_surface program~example3_surface->proc~export_xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xg program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xg program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~export_xg program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xg program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xg.html"},{"title":"export_Xth – ForCAD","text":"private impure subroutine export_Xth(this, filename, point_data, field_names, encoding) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xth~~CallsGraph proc~export_xth nurbs_surface%export_Xth interface~ndgrid ndgrid proc~export_xth->interface~ndgrid interface~unique unique proc~export_xth->interface~unique proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~export_xth->proc~cmp_elem_xth proc~export_vtk_legacy export_vtk_legacy proc~export_xth->proc~export_vtk_legacy proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~cmp_elem_xth->interface~unique interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xth->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth~~CalledByGraph proc~export_xth nurbs_surface%export_Xth program~example3_surface example3_surface program~example3_surface->proc~export_xth program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xth Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth.html"},{"title":"export_Xth_in_Xg – ForCAD","text":"private impure subroutine export_Xth_in_Xg(this, filename, res, encoding) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: res character(len=*), intent(in), optional :: encoding Calls proc~~export_xth_in_xg~~CallsGraph proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg interface~compute_xg compute_Xg proc~export_xth_in_xg->interface~compute_xg interface~unique unique proc~export_xth_in_xg->interface~unique proc~export_vtk_legacy export_vtk_legacy proc~export_xth_in_xg->proc~export_vtk_legacy proc~is_rational nurbs_surface%is_rational proc~export_xth_in_xg->proc~is_rational set set proc~export_xth_in_xg->set proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth_in_xg~~CalledByGraph proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xth_in_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~export_xth_in_xg program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~export_xth_in_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth_in_xg.html"},{"title":"export_iges – ForCAD","text":"private impure subroutine export_iges(this, filename) Uses forIGES proc~~export_iges~~UsesGraph proc~export_iges nurbs_surface%export_iges forIGES forIGES proc~export_iges->forIGES Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename Calls proc~~export_iges~~CallsGraph proc~export_iges nurbs_surface%export_iges append append proc~export_iges->append delete delete proc~export_iges->delete init init proc~export_iges->init makedpsections makedpsections proc~export_iges->makedpsections makegsection makegsection proc~export_iges->makegsection makessection makessection proc~export_iges->makessection proc~is_rational nurbs_surface%is_rational proc~export_iges->proc~is_rational writeigesfile writeigesfile proc~export_iges->writeigesfile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_iges~~CalledByGraph proc~export_iges nurbs_surface%export_iges program~example3_surface example3_surface program~example3_surface->proc~export_iges program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_iges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_iges.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this Called by proc~~finalize~~CalledByGraph proc~finalize nurbs_surface%finalize proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~finalize program~example3_surface example3_surface program~example3_surface->proc~finalize program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~finalize program~example_ppm1 example_ppm1 program~example_ppm1->proc~finalize program~example_ppm2 example_ppm2 program~example_ppm2->proc~finalize program~example_ppm3 example_ppm3 program~example_ppm3->proc~finalize program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~finalize program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~finalize program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~finalize program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~finalize program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~finalize program~shape_c_2d shape_C_2d program~shape_c_2d->proc~finalize program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~finalize program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~finalize program~shape_tetragon shape_tetragon program~shape_tetragon->proc~finalize program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~finalize program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/finalize.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r, B, Bs) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) Calls proc~~insert_knots~~CallsGraph proc~insert_knots nurbs_surface%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity none~get_knot nurbs_surface%get_knot proc~insert_knots->none~get_knot proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~is_rational nurbs_surface%is_rational proc~insert_knots->proc~is_rational s_loc s_loc proc~insert_knots->s_loc set set proc~insert_knots->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~~CalledByGraph proc~insert_knots nurbs_surface%insert_knots program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~insert_knots program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~insert_knots program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~insert_knots program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~insert_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knots.html"},{"title":"lsq_fit_bspline – ForCAD","text":"private pure subroutine lsq_fit_bspline(this, Xt, Xdata, ndata) Uses forcad_interface proc~~lsq_fit_bspline~~UsesGraph proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline module~forcad_interface forcad_interface proc~lsq_fit_bspline->module~forcad_interface module~forcad_utils forcad_utils module~forcad_interface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (2) Calls proc~~lsq_fit_bspline~~CallsGraph proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline interface~kron kron proc~lsq_fit_bspline->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_bspline->proc~basis_bspline proc~solve solve proc~lsq_fit_bspline->proc~solve set set proc~lsq_fit_bspline->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lsq_fit_bspline~~CalledByGraph proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~lsq_fit_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/lsq_fit_bspline.html"},{"title":"lsq_fit_nurbs – ForCAD","text":"private pure subroutine lsq_fit_nurbs(this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Uses forcad_interface proc~~lsq_fit_nurbs~~UsesGraph proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs module~forcad_interface forcad_interface proc~lsq_fit_nurbs->module~forcad_interface module~forcad_utils forcad_utils module~forcad_interface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (2) integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw Calls proc~~lsq_fit_nurbs~~CallsGraph proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs interface~kron kron proc~lsq_fit_nurbs->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_nurbs->proc~basis_bspline proc~solve solve proc~lsq_fit_nurbs->proc~solve set set proc~lsq_fit_nurbs->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lsq_fit_nurbs~~CalledByGraph proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/lsq_fit_nurbs.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~~CallsGraph proc~modify_wc nurbs_surface%modify_Wc none~get_knot nurbs_surface%get_knot proc~modify_wc->none~get_knot none~get_wc nurbs_surface%get_Wc proc~modify_wc->none~get_wc none~get_xc nurbs_surface%get_Xc proc~modify_wc->none~get_xc none~set nurbs_surface%set proc~modify_wc->none~set proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_wc~~CalledByGraph proc~modify_wc nurbs_surface%modify_Wc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~modify_wc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_wc.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~~CallsGraph proc~modify_xc nurbs_surface%modify_Xc none~get_knot nurbs_surface%get_knot proc~modify_xc->none~get_knot none~get_wc nurbs_surface%get_Wc proc~modify_xc->none~get_wc none~get_xc nurbs_surface%get_Xc proc~modify_xc->none~get_xc none~set nurbs_surface%set proc~modify_xc->none~set proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_xc~~CalledByGraph proc~modify_xc nurbs_surface%modify_Xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_xc.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt (2) integer, intent(out), optional :: id Called by proc~~nearest_point~~CalledByGraph proc~nearest_point nurbs_surface%nearest_point proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~nearest_point program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~nearest_point program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) Calls proc~~nearest_point2~~CallsGraph proc~nearest_point2 nurbs_surface%nearest_point2 none~derivative2 nurbs_surface%derivative2 proc~nearest_point2->none~derivative2 proc~cmp_xg nurbs_surface%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~create nurbs_surface%create proc~nearest_point2->proc~create proc~finalize nurbs_surface%finalize proc~nearest_point2->proc~finalize proc~inv inv proc~nearest_point2->proc~inv proc~nearest_point nurbs_surface%nearest_point proc~nearest_point2->proc~nearest_point proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2->proc~derivative2_vector interface~compute_xg compute_Xg proc~cmp_xg->interface~compute_xg proc~is_rational nurbs_surface%is_rational proc~cmp_xg->proc~is_rational proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~create->proc~is_rational set set proc~create->set proc~inv->proc~inv proc~det det proc~inv->proc~det proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~compute_d2tgc_bspline_2d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~~CalledByGraph proc~nearest_point2 nurbs_surface%nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point2.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~~CallsGraph proc~remove_knots nurbs_surface%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots->interface~compute_multiplicity none~get_knot nurbs_surface%get_knot proc~remove_knots->none~get_knot none~set nurbs_surface%set proc~remove_knots->none~set proc~findspan findspan proc~remove_knots->proc~findspan proc~is_rational nurbs_surface%is_rational proc~remove_knots->proc~is_rational proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~~CalledByGraph proc~remove_knots nurbs_surface%remove_knots program~example3_surface example3_surface program~example3_surface->proc~remove_knots program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~~CallsGraph proc~rotate_xc nurbs_surface%rotate_Xc proc~rotation rotation proc~rotate_xc->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~~CalledByGraph proc~rotate_xc nurbs_surface%rotate_Xc program~example3_surface example3_surface program~example3_surface->proc~rotate_xc program~example_ppm2 example_ppm2 program~example_ppm2->proc~rotate_xc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~rotate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xc.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~~CallsGraph proc~rotate_xg nurbs_surface%rotate_Xg proc~rotation rotation proc~rotate_xg->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~~CalledByGraph proc~rotate_xg nurbs_surface%rotate_Xg program~example3_surface example3_surface program~example3_surface->proc~rotate_xg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~rotate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xg.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, Xc, Wc) Set knot vectors, control points and weights for the NURBS surface object. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~~CallsGraph proc~set1 nurbs_surface%set1 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~~CalledByGraph proc~set1 nurbs_surface%set1 none~set nurbs_surface%set none~set->proc~set1 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->proc~set_c program~test_nurbs_surface->proc~set_half_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~~CallsGraph proc~set2 nurbs_surface%set2 proc~cmp_nc nurbs_surface%cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector set set proc~set2->set proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~~CalledByGraph proc~set2 nurbs_surface%set2 none~set nurbs_surface%set none~set->proc~set2 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->proc~set_c program~test_nurbs_surface->proc~set_half_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier surface using control points and weights. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~~CallsGraph proc~set3 nurbs_surface%set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set3->proc~cmp_degree set set proc~set3->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~~CalledByGraph proc~set3 nurbs_surface%set3 none~set nurbs_surface%set none~set->proc~set3 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->proc~set_c program~test_nurbs_surface->proc~set_half_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set3.html"},{"title":"set4 – ForCAD","text":"private pure subroutine set4(this, degree, nc, Xc, Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set4~~CallsGraph proc~set4 nurbs_surface%set4 set set proc~set4->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set4~~CalledByGraph proc~set4 nurbs_surface%set4 none~set nurbs_surface%set none~set->proc~set4 proc~ansatz nurbs_surface%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~compute_area compute_area program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_surface->proc~elevate_degree program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->none~set program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->none~set program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->none~set program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->none~set program~fdm_elevate_and_insert_2d->proc~elevate_degree program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->none~set program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set program~test_nurbs_surface->proc~elevate_degree program~test_nurbs_surface->proc~modify_wc program~test_nurbs_surface->proc~modify_xc program~test_nurbs_surface->proc~remove_knots program~test_nurbs_surface->proc~set_c program~test_nurbs_surface->proc~set_half_ring program~test_nurbs_surface->proc~set_ring program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~poisson_iga_solver_2d->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set4.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_c~~CallsGraph proc~set_c nurbs_surface%set_C none~set nurbs_surface%set proc~set_c->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~~CalledByGraph proc~set_c nurbs_surface%set_C program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_c.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem~~CalledByGraph proc~set_elem nurbs_surface%set_elem program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_elem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xc_vis~~CalledByGraph proc~set_elem_xc_vis nurbs_surface%set_elem_Xc_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_elem_xc_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xc_vis.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~~CalledByGraph proc~set_elem_xg_vis nurbs_surface%set_elem_Xg_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_elem_xg_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xg_vis.html"},{"title":"set_half_ring – ForCAD","text":"private pure subroutine set_half_ring(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_half_ring~~CallsGraph proc~set_half_ring nurbs_surface%set_half_ring none~set nurbs_surface%set proc~set_half_ring->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_ring~~CalledByGraph proc~set_half_ring nurbs_surface%set_half_ring program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_half_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_half_ring.html"},{"title":"set_ring – ForCAD","text":"private pure subroutine set_ring(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_ring~~CallsGraph proc~set_ring nurbs_surface%set_ring none~set nurbs_surface%set proc~set_ring->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_ring~~CalledByGraph proc~set_ring nurbs_surface%set_ring program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_ring.html"},{"title":"set_tetragon – ForCAD","text":"private pure subroutine set_tetragon(this, L, nc, Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_tetragon~~CallsGraph proc~set_tetragon nurbs_surface%set_tetragon none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_tetragon~~CalledByGraph proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~set_tetragon program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_tetragon.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg, vtkfile_Xth_in_Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg character(len=*), intent(in), optional :: vtkfile_Xth_in_Xg Called by proc~~show~~CalledByGraph proc~show nurbs_surface%show program~example3_surface example3_surface program~example3_surface->proc~show program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~show program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~show program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~show program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~show program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~show program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~show program~shape_c_2d shape_C_2d program~shape_c_2d->proc~show program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~show program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~show program~shape_tetragon shape_tetragon program~shape_tetragon->proc~show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/show.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) Called by proc~~translate_xc~~CalledByGraph proc~translate_xc nurbs_surface%translate_Xc program~example3_surface example3_surface program~example3_surface->proc~translate_xc program~example_ppm2 example_ppm2 program~example_ppm2->proc~translate_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~translate_xc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~translate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xc.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) Called by proc~~translate_xg~~CalledByGraph proc~translate_xg nurbs_surface%translate_Xg program~example3_surface example3_surface program~example3_surface->proc~translate_xg program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~translate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xg.html"},{"title":"compute_Tgc – ForCAD","text":"public interface compute_Tgc Calls interface~~compute_tgc~~CallsGraph interface~compute_tgc compute_Tgc proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector interface~kron kron proc~compute_tgc_bspline_2d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_tgc~~CalledByGraph interface~compute_tgc compute_Tgc proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_surface%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->none~basis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_tgc.html"},{"title":"compute_dTgc – ForCAD","text":"public interface compute_dTgc Calls interface~~compute_dtgc~~CallsGraph interface~compute_dtgc compute_dTgc proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_2d_scalar->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_dtgc~~CalledByGraph interface~compute_dtgc compute_dTgc proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_surface%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_surface%ansatz proc~ansatz->none~derivative program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_dTgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:)","tags":"","url":"interface/compute_dtgc.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Calls interface~~compute_xg~~CallsGraph interface~compute_xg compute_Xg proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_xg~~CalledByGraph interface~compute_xg compute_Xg proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_surface%create proc~create->interface~compute_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg proc~export_xth_in_xg->interface~compute_xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_surface->proc~export_xth_in_xg program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->proc~create program~example_plate_hole_1_2d->proc~export_xth_in_xg program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->proc~create program~example_plate_hole_2_2d->proc~export_xth_in_xg program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->proc~create program~example_plate_hole_4_2d->proc~export_xth_in_xg program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->proc~create program~lsq_fit_bspline_2d->proc~export_xth_in_xg program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->proc~create program~lsq_fit_nurbs_2d->proc~export_xth_in_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create program~test_nurbs_surface->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Xg_nurbs_2d (Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) integer, intent(in), optional, contiguous :: ng (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d (Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point (Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_bspline_2d_1point (Xt, knot1, knot2, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2))","tags":"","url":"interface/compute_xg.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Calls interface~~compute_d2tgc~~CallsGraph interface~compute_d2tgc compute_d2Tgc proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_2d_scalar->interface~kron proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_d2tgc~~CalledByGraph interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2 program~test_nurbs_surface->proc~nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_d2Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:)","tags":"","url":"interface/compute_d2tgc.html"},{"title":"cmp_Tgc_1d – ForCAD","text":"private pure function cmp_Tgc_1d(Xti, knot, nc, degree, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xti real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc) Calls proc~~cmp_tgc_1d~~CallsGraph proc~cmp_tgc_1d cmp_Tgc_1d proc~basis_bspline basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_tgc_1d~~CalledByGraph proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_tgc_1d.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~2~~CallsGraph proc~cmp_xg~2 nurbs_curve%cmp_Xg interface~compute_xg~2 compute_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~cmp_xg~2->proc~is_rational~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~2~~CalledByGraph proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_xg~2.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~2~~CallsGraph proc~cmp_elem~2 nurbs_curve%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn interface~unique unique proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem~2~~CalledByGraph proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem~2.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~2~~CallsGraph proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~2~~CalledByGraph proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xc~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xc~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xc_vis~2.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~2~~CallsGraph proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~2~~CalledByGraph proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xg~2 program~example1_curve example1_curve program~example1_curve->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xg~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xg~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xg_vis~2.html"},{"title":"cmp_elem_Xth – ForCAD","text":"private pure function cmp_elem_Xth(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xth~2~~CallsGraph proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xth~2->interface~elemconn_c0 interface~unique unique proc~cmp_elem_xth~2->interface~unique proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xth~2~~CalledByGraph proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem_xth~2 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xth~2.html"},{"title":"compute_Tgc_bspline_1d_scalar – ForCAD","text":"private pure function compute_Tgc_bspline_1d_scalar(Xt, knot, degree, nc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_1d_scalar~~CallsGraph proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_1d_scalar~~CalledByGraph proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_1d_scalar.html"},{"title":"compute_Tgc_bspline_1d_vector – ForCAD","text":"private pure function compute_Tgc_bspline_1d_vector(Xt, knot, degree, nc, ng) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_1d_vector~~CallsGraph proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_1d_vector~~CalledByGraph proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_1d_vector.html"},{"title":"compute_Tgc_nurbs_1d_scalar – ForCAD","text":"private pure function compute_Tgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_1d_scalar~~CallsGraph proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_1d_scalar~~CalledByGraph proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_1d_scalar.html"},{"title":"compute_Tgc_nurbs_1d_vector – ForCAD","text":"private pure function compute_Tgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_1d_vector~~CallsGraph proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_1d_vector~~CalledByGraph proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_1d_vector.html"},{"title":"compute_Xg_bspline_1d – ForCAD","text":"private pure function compute_Xg_bspline_1d(Xt, knot, degree, nc, ng, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_1d~~CallsGraph proc~compute_xg_bspline_1d compute_Xg_bspline_1d proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_1d~~CalledByGraph proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_bspline_1d proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_1d.html"},{"title":"compute_Xg_bspline_1d_1point – ForCAD","text":"private pure function compute_Xg_bspline_1d_1point(Xt, knot, degree, nc, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) Calls proc~~compute_xg_bspline_1d_1point~~CallsGraph proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_1d_1point~~CalledByGraph proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_1d_1point.html"},{"title":"compute_Xg_nurbs_1d – ForCAD","text":"private pure function compute_Xg_nurbs_1d(Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_1d~~CallsGraph proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~basis_bspline basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_1d~~CalledByGraph proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_1d.html"},{"title":"compute_Xg_nurbs_1d_1point – ForCAD","text":"private pure function compute_Xg_nurbs_1d_1point(Xt, knot, degree, nc, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) Calls proc~~compute_xg_nurbs_1d_1point~~CallsGraph proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_nurbs_1d_1point->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_1d_1point~~CalledByGraph proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_1d_1point.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~2~~CalledByGraph proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2 nurbs_curve%get_Wc none~get_wc~2->proc~get_wc_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_wc~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~get_wc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_wc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wc_all~2.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~2~~CalledByGraph proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2 nurbs_curve%get_Wc none~get_wc~2->proc~get_wci~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_wc~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~get_wc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_wc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wci~2.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~2~~CalledByGraph proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xc_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~get_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xc_all~2.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~2~~CalledByGraph proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xci~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~get_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xci~2.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~2~~CalledByGraph proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xcid~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~get_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xcid~2.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xg_all~2~~CalledByGraph proc~get_xg_all~2 nurbs_curve%get_Xg_all none~get_xg~2 nurbs_curve%get_Xg none~get_xg~2->proc~get_xg_all~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~get_xg~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~get_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xg_all~2.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xgi~2~~CalledByGraph proc~get_xgi~2 nurbs_curve%get_Xgi none~get_xg~2 nurbs_curve%get_Xg none~get_xg~2->proc~get_xgi~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~get_xg~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~get_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgi~2.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xgid~2~~CalledByGraph proc~get_xgid~2 nurbs_curve%get_Xgid none~get_xg~2 nurbs_curve%get_Xg none~get_xg~2->proc~get_xgid~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~get_xg~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~get_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgid~2.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this) result(Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xt~2~~CalledByGraph proc~get_xt~2 nurbs_curve%get_Xt program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_xt~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xt~2.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this) result(c) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_continuity~2~~CallsGraph proc~get_continuity~2 nurbs_curve%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_continuity~2~~CalledByGraph proc~get_continuity~2 nurbs_curve%get_continuity program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~get_continuity~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~get_continuity~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_continuity~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_continuity~2.html"},{"title":"get_degree – ForCAD","text":"private pure function get_degree(this) result(degree) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Called by proc~~get_degree~~CalledByGraph proc~get_degree nurbs_curve%get_degree program~example1_curve example1_curve program~example1_curve->proc~get_degree program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~get_degree program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~get_degree program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem~2~~CalledByGraph proc~get_elem~2 nurbs_curve%get_elem program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_elem~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem~2.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xc_vis~2~~CalledByGraph proc~get_elem_xc_vis~2 nurbs_curve%get_elem_Xc_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_elem_xc_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xc_vis~2.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xg_vis~2~~CalledByGraph proc~get_elem_xg_vis~2 nurbs_curve%get_elem_Xg_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_elem_xg_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xg_vis~2.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~2~~CalledByGraph proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2 nurbs_curve%get_knot none~get_knot~2->proc~get_knot_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_knot~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_knot~2 program~example1_curve example1_curve program~example1_curve->none~get_knot~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~get_knot~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~get_knot~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~get_knot~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_knot~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knot_all~2.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, i) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~2~~CalledByGraph proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2 nurbs_curve%get_knot none~get_knot~2->proc~get_knoti~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_knot~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_knot~2 program~example1_curve example1_curve program~example1_curve->none~get_knot~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~get_knot~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~get_knot~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~get_knot~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_knot~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knoti~2.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this) result(m) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~2~~CallsGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~2~~CalledByGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~cmp_elem~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length none~set~2 nurbs_curve%set program~test_nurbs_curve->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~test_nurbs_curve->proc~elevate_degree~2 proc~insert_knots~2 nurbs_curve%insert_knots program~test_nurbs_curve->proc~insert_knots~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~remove_knots~2 nurbs_curve%remove_knots program~test_nurbs_curve->proc~remove_knots~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~set1a nurbs_curve%set1a proc~set1a->proc~cmp_degree~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 none~set~2->proc~set1a none~set~2->proc~set1~2 none~set~2->proc~set3~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_length->none~set~2 proc~elevate_degree~2->none~set~2 proc~insert_knots~2->none~set~2 proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~set~2 proc~remove_knots~2->none~set~2 proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle->none~set~2 program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_multiplicity~2.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Called by proc~~get_nc~~CalledByGraph proc~get_nc nurbs_curve%get_nc program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~get_nc program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~get_nc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_nc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Called by proc~~get_ng~2~~CalledByGraph proc~get_ng~2 nurbs_curve%get_ng program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_ng~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_ng~2.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical Called by proc~~is_rational~2~~CalledByGraph proc~is_rational~2 nurbs_curve%is_rational proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->proc~is_rational~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->proc~is_rational~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->proc~is_rational~2 proc~create~2 nurbs_curve%create proc~create~2->proc~is_rational~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->proc~is_rational~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->proc~is_rational~2 proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->proc~is_rational~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~is_rational~2 proc~export_iges~2 nurbs_curve%export_iges proc~export_iges~2->proc~is_rational~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~is_rational~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~is_rational~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->none~derivative2~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_iges~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~fdm_test_curve->none~derivative2~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_iges~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->none~basis~2 program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->none~derivative~2 program~test_nurbs_curve->proc~nearest_point2~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_rational~2.html"},{"title":"ansatz – ForCAD","text":"private pure subroutine ansatz(this, ie, ig, Tgc, dTgc_dXg, dL, ngauss) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dL integer, intent(in), optional :: ngauss Calls proc~~ansatz~2~~CallsGraph proc~ansatz~2 nurbs_curve%ansatz interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg interface~unique unique proc~ansatz~2->interface~unique none~derivative~2 nurbs_curve%derivative proc~ansatz~2->none~derivative~2 none~set~2 nurbs_curve%set proc~ansatz~2->none~set~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_elem~2->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~kron kron proc~gauss_legendre_2d->interface~kron interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ansatz~2~~CalledByGraph proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ansatz~2.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~2~~CallsGraph proc~basis_scalar~2 nurbs_curve%basis_scalar interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2->interface~compute_tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~basis_scalar~2->proc~is_rational~2 proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_scalar~2~~CalledByGraph proc~basis_scalar~2 nurbs_curve%basis_scalar none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_scalar~2.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~2~~CallsGraph proc~basis_vector~2 nurbs_curve%basis_vector interface~compute_tgc~2 compute_Tgc proc~basis_vector~2->interface~compute_tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~basis_vector~2->proc~is_rational~2 proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_vector~2~~CalledByGraph proc~basis_vector~2 nurbs_curve%basis_vector none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_vector~2.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Calls proc~~cmp_degree~2~~CallsGraph proc~cmp_degree~2 nurbs_curve%cmp_degree proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~2~~CalledByGraph proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a nurbs_curve%set1a proc~set1a->proc~cmp_degree~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 none~set~2 nurbs_curve%set none~set~2->proc~set1a none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degree~2.html"},{"title":"cmp_length – ForCAD","text":"private pure subroutine cmp_length(this, length, ngauss) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(out) :: length integer, intent(in), optional :: ngauss Calls proc~~cmp_length~~CallsGraph proc~cmp_length nurbs_curve%cmp_length proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_length->proc~cmp_elem~2 proc~ansatz~2->proc~cmp_elem~2 interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg interface~unique unique proc~ansatz~2->interface~unique none~derivative~2 nurbs_curve%derivative proc~ansatz~2->none~derivative~2 none~set~2 nurbs_curve%set proc~ansatz~2->none~set~2 interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~kron kron proc~gauss_legendre_2d->interface~kron interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_length~~CalledByGraph proc~cmp_length nurbs_curve%cmp_length program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_length.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Calls proc~~cmp_nc~2~~CallsGraph proc~cmp_nc~2 nurbs_curve%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~2~~CalledByGraph proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~cmp_nc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 none~set~2 nurbs_curve%set program~test_nurbs_curve->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~test_nurbs_curve->proc~elevate_degree~2 proc~insert_knots~2 nurbs_curve%insert_knots program~test_nurbs_curve->proc~insert_knots~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~remove_knots~2 nurbs_curve%remove_knots program~test_nurbs_curve->proc~remove_knots~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length none~set~2->proc~set2~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2->none~set~2 proc~insert_knots~2->none~set~2 proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~set~2 proc~remove_knots~2->none~set~2 proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_nc~2.html"},{"title":"compute_d2Tgc_bspline_1d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_1d_scalar(Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_1d_scalar~~CallsGraph proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_1d_scalar~~CalledByGraph proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_1d_scalar.html"},{"title":"compute_d2Tgc_bspline_1d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_1d_vector(Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_1d_vector~~CallsGraph proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_1d_vector~~CalledByGraph proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_1d_vector.html"},{"title":"compute_d2Tgc_nurbs_1d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_1d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_1d_scalar~~CalledByGraph proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_1d_scalar.html"},{"title":"compute_d2Tgc_nurbs_1d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_1d_vector~~CallsGraph proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_1d_vector~~CalledByGraph proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_1d_vector.html"},{"title":"compute_dTgc_bspline_1d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_bspline_1d_scalar(Xt, knot, degree, nc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~compute_dtgc_bspline_1d_scalar~~CallsGraph proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_1d_scalar~~CalledByGraph proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_1d_scalar.html"},{"title":"compute_dTgc_bspline_1d_vector – ForCAD","text":"private pure subroutine compute_dTgc_bspline_1d_vector(Xt, knot, degree, nc, ng, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_1d_vector~~CallsGraph proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_1d_vector~~CalledByGraph proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_1d_vector.html"},{"title":"compute_dTgc_nurbs_1d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~compute_dtgc_nurbs_1d_scalar~~CallsGraph proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_1d_scalar~~CalledByGraph proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_1d_scalar.html"},{"title":"compute_dTgc_nurbs_1d_vector – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_1d_vector~~CallsGraph proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_1d_vector~~CalledByGraph proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_1d_vector.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res, Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) Calls proc~~create~2~~CallsGraph proc~create~2 nurbs_curve%create interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~2~~CalledByGraph proc~create~2 nurbs_curve%create proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/create~2.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~2~~CallsGraph proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative2_scalar~2->proc~is_rational~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~2~~CalledByGraph proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_scalar~2.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~2~~CallsGraph proc~derivative2_vector~2 nurbs_curve%derivative2_vector interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative2_vector~2->proc~is_rational~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~2~~CalledByGraph proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_vector~2.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc, elem) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~derivative_scalar~2~~CallsGraph proc~derivative_scalar~2 nurbs_curve%derivative_scalar interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_scalar~2~~CalledByGraph proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_scalar~2.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res, Xt, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~2~~CallsGraph proc~derivative_vector~2 nurbs_curve%derivative_vector interface~compute_dtgc~2 compute_dTgc proc~derivative_vector~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_vector~2->proc~is_rational~2 proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_vector~2~~CalledByGraph proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_vector~2.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, t, B, Bs) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) Calls proc~~elevate_degree~2~~CallsGraph proc~elevate_degree~2 nurbs_curve%elevate_degree none~set~2 nurbs_curve%set proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~is_rational~2 nurbs_curve%is_rational proc~elevate_degree~2->proc~is_rational~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~2~~CalledByGraph proc~elevate_degree~2 nurbs_curve%elevate_degree program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree~2.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename, point_data, field_names, encoding) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xc~2~~CallsGraph proc~export_xc~2 nurbs_curve%export_Xc proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy set set proc~export_xc~2->set interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~2~~CalledByGraph proc~export_xc~2 nurbs_curve%export_Xc program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xc~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xc~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xc~2.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename, point_data, field_names, encoding) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xg~2~~CallsGraph proc~export_xg~2 nurbs_curve%export_Xg proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xg~2->proc~export_vtk_legacy set set proc~export_xg~2->set interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~2~~CalledByGraph proc~export_xg~2 nurbs_curve%export_Xg program~example1_curve example1_curve program~example1_curve->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~export_xg~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~export_xg~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xg~2.html"},{"title":"export_Xth – ForCAD","text":"private impure subroutine export_Xth(this, filename, point_data, field_names, encoding) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xth~2~~CallsGraph proc~export_xth~2 nurbs_curve%export_Xth interface~ndgrid ndgrid proc~export_xth~2->interface~ndgrid interface~unique unique proc~export_xth~2->interface~unique proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xth~2->proc~export_vtk_legacy proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~cmp_elem_xth~2->interface~unique interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xth~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth~2~~CalledByGraph proc~export_xth~2 nurbs_curve%export_Xth program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth~2.html"},{"title":"export_iges – ForCAD","text":"private impure subroutine export_iges(this, filename) Uses forIGES proc~~export_iges~2~~UsesGraph proc~export_iges~2 nurbs_curve%export_iges forIGES forIGES proc~export_iges~2->forIGES Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename Calls proc~~export_iges~2~~CallsGraph proc~export_iges~2 nurbs_curve%export_iges append append proc~export_iges~2->append delete delete proc~export_iges~2->delete init init proc~export_iges~2->init makedpsections makedpsections proc~export_iges~2->makedpsections makegsection makegsection proc~export_iges~2->makegsection makessection makessection proc~export_iges~2->makessection proc~is_rational~2 nurbs_curve%is_rational proc~export_iges~2->proc~is_rational~2 writeigesfile writeigesfile proc~export_iges~2->writeigesfile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_iges~2~~CalledByGraph proc~export_iges~2 nurbs_curve%export_iges program~example1_curve example1_curve program~example1_curve->proc~export_iges~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_iges~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_iges~2.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Called by proc~~finalize~2~~CalledByGraph proc~finalize~2 nurbs_curve%finalize proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~finalize~2 program~example1_curve example1_curve program~example1_curve->proc~finalize~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~finalize~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~finalize~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~finalize~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~finalize~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~finalize~2 program~shape_circle shape_circle program~shape_circle->proc~finalize~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~finalize~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/finalize~2.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, Xth, r, B, Bs) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) Calls proc~~insert_knots~2~~CallsGraph proc~insert_knots~2 nurbs_curve%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~is_rational~2 nurbs_curve%is_rational proc~insert_knots~2->proc~is_rational~2 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~2~~CalledByGraph proc~insert_knots~2 nurbs_curve%insert_knots program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~insert_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knots~2.html"},{"title":"lsq_fit_bspline – ForCAD","text":"private pure subroutine lsq_fit_bspline(this, Xt, Xdata, ndata) Uses forcad_interface proc~~lsq_fit_bspline~2~~UsesGraph proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline module~forcad_interface forcad_interface proc~lsq_fit_bspline~2->module~forcad_interface module~forcad_utils forcad_utils module~forcad_interface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata Calls proc~~lsq_fit_bspline~2~~CallsGraph proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline proc~basis_bspline basis_bspline proc~lsq_fit_bspline~2->proc~basis_bspline proc~solve solve proc~lsq_fit_bspline~2->proc~solve set set proc~lsq_fit_bspline~2->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lsq_fit_bspline~2~~CalledByGraph proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~lsq_fit_bspline~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/lsq_fit_bspline~2.html"},{"title":"lsq_fit_nurbs – ForCAD","text":"private pure subroutine lsq_fit_nurbs(this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Uses forcad_interface proc~~lsq_fit_nurbs~2~~UsesGraph proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs module~forcad_interface forcad_interface proc~lsq_fit_nurbs~2->module~forcad_interface module~forcad_utils forcad_utils module~forcad_interface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw Calls proc~~lsq_fit_nurbs~2~~CallsGraph proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs proc~basis_bspline basis_bspline proc~lsq_fit_nurbs~2->proc~basis_bspline proc~solve solve proc~lsq_fit_nurbs~2->proc~solve set set proc~lsq_fit_nurbs~2->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lsq_fit_nurbs~2~~CalledByGraph proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~lsq_fit_nurbs~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/lsq_fit_nurbs~2.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~2~~CallsGraph proc~modify_wc~2 nurbs_curve%modify_Wc none~get_knot~2 nurbs_curve%get_knot proc~modify_wc~2->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc proc~modify_wc~2->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc proc~modify_wc~2->none~get_xc~2 none~set~2 nurbs_curve%set proc~modify_wc~2->none~set~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_wc~2~~CalledByGraph proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~modify_wc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_wc~2.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~2~~CallsGraph proc~modify_xc~2 nurbs_curve%modify_Xc none~get_knot~2 nurbs_curve%get_knot proc~modify_xc~2->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc proc~modify_xc~2->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc proc~modify_xc~2->none~get_xc~2 none~set~2 nurbs_curve%set proc~modify_xc~2->none~set~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_xc~2~~CalledByGraph proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_xc~2.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id Called by proc~~nearest_point~2~~CalledByGraph proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~nearest_point~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point~2 program~nearest_point_1d->proc~nearest_point2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point~2.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) Calls proc~~nearest_point2~2~~CallsGraph proc~nearest_point2~2 nurbs_curve%nearest_point2 none~derivative2~2 nurbs_curve%derivative2 proc~nearest_point2~2->none~derivative2~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 proc~create~2 nurbs_curve%create proc~nearest_point2~2->proc~create~2 proc~finalize~2 nurbs_curve%finalize proc~nearest_point2~2->proc~finalize~2 proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point2~2->proc~nearest_point~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 interface~compute_xg~2 compute_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~cmp_xg~2->proc~is_rational~2 proc~create~2->interface~compute_xg~2 proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~2~~CalledByGraph proc~nearest_point2~2 nurbs_curve%nearest_point2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point2~2.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, Xth, r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~2~~CallsGraph proc~remove_knots~2 nurbs_curve%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~remove_knots~2->none~set~2 proc~findspan findspan proc~remove_knots~2->proc~findspan proc~is_rational~2 nurbs_curve%is_rational proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~2~~CalledByGraph proc~remove_knots~2 nurbs_curve%remove_knots program~example1_curve example1_curve program~example1_curve->proc~remove_knots~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~remove_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots~2.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~2~~CallsGraph proc~rotate_xc~2 nurbs_curve%rotate_Xc proc~rotation rotation proc~rotate_xc~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~2~~CalledByGraph proc~rotate_xc~2 nurbs_curve%rotate_Xc program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~rotate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xc~2.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~2~~CallsGraph proc~rotate_xg~2 nurbs_curve%rotate_Xg proc~rotation rotation proc~rotate_xg~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~2~~CalledByGraph proc~rotate_xg~2 nurbs_curve%rotate_Xg program~example1_curve example1_curve program~example1_curve->proc~rotate_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~rotate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xg~2.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot, Xc, Wc) Set knot vector, control points and weights for the NURBS curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~2~~CallsGraph proc~set1~2 nurbs_curve%set1 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 set set proc~set1~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~2~~CalledByGraph proc~set1~2 nurbs_curve%set1 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1~2.html"},{"title":"set1a – ForCAD","text":"private pure subroutine set1a(this, knot, Xc, Wc) Set knot vector, control points and weights for the NURBS curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1a~~CallsGraph proc~set1a nurbs_curve%set1a proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1a~~CalledByGraph proc~set1a nurbs_curve%set1a none~set~2 nurbs_curve%set none~set~2->proc~set1a proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1a.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir, degree, continuity, Xc, Wc) Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~2~~CallsGraph proc~set2~2 nurbs_curve%set2 proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector set set proc~set2~2->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~2~~CalledByGraph proc~set2~2 nurbs_curve%set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set2~2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, Xc, Wc) Set Bezier or Rational Bezier curve using control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~2~~CallsGraph proc~set3~2 nurbs_curve%set3 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set3~2->proc~cmp_degree~2 set set proc~set3~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~2~~CalledByGraph proc~set3~2 nurbs_curve%set3 none~set~2 nurbs_curve%set none~set~2->proc~set3~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set3~2.html"},{"title":"set4 – ForCAD","text":"private pure subroutine set4(this, degree, nc, Xc, Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set4~2~~CallsGraph proc~set4~2 nurbs_curve%set4 set set proc~set4~2->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set4~2~~CalledByGraph proc~set4~2 nurbs_curve%set4 none~set~2 nurbs_curve%set none~set~2->proc~set4~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->none~set~2 program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 program~fdm_elevate_and_insert_1d->proc~insert_knots~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->none~set~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set4~2.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_c~2~~CallsGraph proc~set_c~2 nurbs_curve%set_C none~set~2 nurbs_curve%set proc~set_c~2->none~set~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~2~~CalledByGraph proc~set_c~2 nurbs_curve%set_C program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_c~2.html"},{"title":"set_circle – ForCAD","text":"private pure subroutine set_circle(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_circle~~CallsGraph proc~set_circle nurbs_curve%set_circle none~set~2 nurbs_curve%set proc~set_circle->none~set~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_circle~~CalledByGraph proc~set_circle nurbs_curve%set_circle program~shape_circle shape_circle program~shape_circle->proc~set_circle program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_circle.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem~2~~CalledByGraph proc~set_elem~2 nurbs_curve%set_elem program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_elem~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem~2.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xc_vis~2~~CalledByGraph proc~set_elem_xc_vis~2 nurbs_curve%set_elem_Xc_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_elem_xc_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xc_vis~2.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~2~~CalledByGraph proc~set_elem_xg_vis~2 nurbs_curve%set_elem_Xg_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_elem_xg_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xg_vis~2.html"},{"title":"set_half_circle – ForCAD","text":"private pure subroutine set_half_circle(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_half_circle~~CallsGraph proc~set_half_circle nurbs_curve%set_half_circle none~set~2 nurbs_curve%set proc~set_half_circle->none~set~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_circle~~CalledByGraph proc~set_half_circle nurbs_curve%set_half_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_half_circle.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg Called by proc~~show~2~~CalledByGraph proc~show~2 nurbs_curve%show program~example1_curve example1_curve program~example1_curve->proc~show~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~show~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~show~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~show~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~show~2 program~shape_circle shape_circle program~shape_circle->proc~show~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~show~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/show~2.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) Called by proc~~translate_xc~2~~CalledByGraph proc~translate_xc~2 nurbs_curve%translate_Xc program~example1_curve example1_curve program~example1_curve->proc~translate_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~translate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xc~2.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) Called by proc~~translate_xg~2~~CalledByGraph proc~translate_xg~2 nurbs_curve%translate_Xg program~example1_curve example1_curve program~example1_curve->proc~translate_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~translate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xg~2.html"},{"title":"compute_Tgc – ForCAD","text":"public interface compute_Tgc Calls interface~~compute_tgc~2~~CallsGraph interface~compute_tgc~2 compute_Tgc proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_tgc~2~~CalledByGraph interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_scalar (Xt, knot, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_tgc~2.html"},{"title":"compute_dTgc – ForCAD","text":"public interface compute_dTgc Calls interface~~compute_dtgc~2~~CallsGraph interface~compute_dtgc~2 compute_dTgc proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_dtgc~2~~CalledByGraph interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_dTgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_1d_vector (Xt, knot, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_1d_scalar (Xt, knot, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:)","tags":"","url":"interface/compute_dtgc~2.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Calls interface~~compute_xg~2~~CallsGraph interface~compute_xg~2 compute_Xg proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_xg~2~~CalledByGraph interface~compute_xg~2 compute_Xg proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->proc~create~2 program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Xg_nurbs_1d (Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d (Xt, knot, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point (Xt, knot, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_bspline_1d_1point (Xt, knot, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2))","tags":"","url":"interface/compute_xg~2.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Calls interface~~compute_d2tgc~2~~CallsGraph interface~compute_d2tgc~2 compute_d2Tgc proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_d2tgc~2~~CalledByGraph interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_d2Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_scalar (Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:)","tags":"","url":"interface/compute_d2tgc~2.html"},{"title":"bend_pipe – ForCAD","text":"pure subroutine bend_pipe(this, center, length, rbend, angle_deg) Bend a straight pipe-like NURBS volume into a circular arc.\nEach control point is transformed relative\nto the center .\nLet the total bend angle in degrees be (input),\nand define the total bend angle in radians For each control point: Mapping: Knots and weights are preserved; only the control lattice is updated. Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this NURBS volume to be bent. real(kind=rk), intent(in) :: center (3) Pipe center coordinates . real(kind=rk), intent(in) :: length Length of the straight pipe segment before bending. real(kind=rk), intent(in) :: rbend Bend radius , i.e. distance from the bend centerline. real(kind=rk), intent(in) :: angle_deg Bend angle in degrees . Calls proc~~bend_pipe~~CallsGraph proc~bend_pipe bend_pipe none~get_knot~3 nurbs_volume%get_knot proc~bend_pipe->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc proc~bend_pipe->none~get_nc~3 none~get_wc~3 nurbs_volume%get_Wc proc~bend_pipe->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~bend_pipe->none~get_xc~3 none~set~3 nurbs_volume%set proc~bend_pipe->none~set~3 proc~is_rational~3 nurbs_volume%is_rational proc~bend_pipe->proc~is_rational~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_multiplicity compute_multiplicity proc~get_nc_dir~2->interface~compute_multiplicity proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bend_pipe~~CalledByGraph proc~bend_pipe bend_pipe program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/bend_pipe.html"},{"title":"generate_Xc – ForCAD","text":"pure function generate_Xc(L) result(cp) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~4~~CalledByGraph proc~generate_xc~4 generate_Xc program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->proc~generate_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~4.html"},{"title":"build_twist_taper – ForCAD","text":"pure subroutine build_twist_taper(this, Length, nc, twist_deg, taper) Apply a z-progressive twist and linear taper to a NURBS hexahedron. Let the control points be indexed by along .\nDefine the normalized axial coordinate which varies from 0 at the bottom face to 1 at the top face. The total twist angle (in radians) at level is i.e. a linear ramp from to . The in-plane (x–y) taper scale is chosen linear in : so at the bottom and at the top (shrinking if ). For each control point , first shift to the in-plane\ncentroid of the box,\napply the scale and rotation by about ,\nand keep unchanged: Knots are preserved; only the control points are updated. Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this Volume to be transformed. real(kind=rk), intent(in) :: Length (3) Box lengths . integer, intent(in) :: nc (3) Control points sizes. real(kind=rk), intent(in) :: twist_deg Total twist at top face (degrees). real(kind=rk), intent(in) :: taper In-plane scale at top face (0< taper ≤1). Calls proc~~build_twist_taper~~CallsGraph proc~build_twist_taper build_twist_taper none~get_knot~3 nurbs_volume%get_knot proc~build_twist_taper->none~get_knot~3 none~get_wc~3 nurbs_volume%get_Wc proc~build_twist_taper->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~build_twist_taper->none~get_xc~3 none~set~3 nurbs_volume%set proc~build_twist_taper->none~set~3 proc~is_rational~3 nurbs_volume%is_rational proc~build_twist_taper->proc~is_rational~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_twist_taper~~CalledByGraph proc~build_twist_taper build_twist_taper program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/build_twist_taper.html"},{"title":"map_to_torus_sineZ – ForCAD","text":"pure subroutine map_to_torus_sineZ(this, c, R, twist_turns, Az, nwaves_z, phase_z) Map a straight pipe (ring extruded in ) onto a toroidal pipe with:\n  • cross-section twist: ,\n  • vertical wobble: . Parameterization:\nFor the axial (k) index, define and the torus angle (here one full loop since ): For each control point , relative to ,\nset , , then . Mapping onto a torus of major radius : Knots/weights are preserved; only the control points are updated. Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: c (3) real(kind=rk), intent(in) :: R real(kind=rk), intent(in) :: twist_turns real(kind=rk), intent(in) :: Az integer, intent(in) :: nwaves_z real(kind=rk), intent(in) :: phase_z Calls proc~~map_to_torus_sinez~~CallsGraph proc~map_to_torus_sinez map_to_torus_sineZ none~get_knot~3 nurbs_volume%get_knot proc~map_to_torus_sinez->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc proc~map_to_torus_sinez->none~get_nc~3 none~get_wc~3 nurbs_volume%get_Wc proc~map_to_torus_sinez->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~map_to_torus_sinez->none~get_xc~3 none~set~3 nurbs_volume%set proc~map_to_torus_sinez->none~set~3 proc~is_rational~3 nurbs_volume%is_rational proc~map_to_torus_sinez->proc~is_rational~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_multiplicity compute_multiplicity proc~get_nc_dir~2->interface~compute_multiplicity proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_to_torus_sinez~~CalledByGraph proc~map_to_torus_sinez map_to_torus_sineZ program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/map_to_torus_sinez.html"},{"title":"generate_Xc – ForCAD","text":"pure function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~5~~CalledByGraph proc~generate_xc~5 generate_Xc program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->proc~generate_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~5.html"},{"title":"cmp_Tgc_3d – ForCAD","text":"private pure function cmp_Tgc_3d(Xti, knot1, knot2, knot3, nc, degree, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: nc (3) integer, intent(in) :: degree (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)*nc(3)) Calls proc~~cmp_tgc_3d~~CallsGraph proc~cmp_tgc_3d cmp_Tgc_3d interface~kron kron proc~cmp_tgc_3d->interface~kron proc~basis_bspline basis_bspline proc~cmp_tgc_3d->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_tgc_3d~~CalledByGraph proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_volume%create proc~create~3->interface~compute_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_tgc_3d.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~3~~CallsGraph proc~cmp_xg~3 nurbs_volume%cmp_Xg interface~compute_xg~3 compute_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~cmp_xg~3->proc~is_rational~3 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~3~~CalledByGraph proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_xg~3.html"},{"title":"cmp_degreeFace – ForCAD","text":"private pure function cmp_degreeFace(this, face) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) Called by proc~~cmp_degreeface~~CalledByGraph proc~cmp_degreeface nurbs_volume%cmp_degreeFace program~example3_volume example3_volume program~example3_volume->proc~cmp_degreeface Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degreeface.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~3~~CallsGraph proc~cmp_elem~3 nurbs_volume%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem~3~~CalledByGraph proc~cmp_elem~3 nurbs_volume%cmp_elem proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~cmp_elem~3 program~poisson_iga_solver_3d->proc~ansatz~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem~3 program~test_nurbs_volume->proc~cmp_volume program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem~3.html"},{"title":"cmp_elemFace – ForCAD","text":"private pure function cmp_elemFace(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) Called by proc~~cmp_elemface~~CalledByGraph proc~cmp_elemface nurbs_volume%cmp_elemFace program~example3_volume example3_volume program~example3_volume->proc~cmp_elemface Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemface.html"},{"title":"cmp_elemFace_Xc_vis – ForCAD","text":"private pure function cmp_elemFace_Xc_vis(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:)","tags":"","url":"proc/cmp_elemface_xc_vis.html"},{"title":"cmp_elemFace_Xg_vis – ForCAD","text":"private pure function cmp_elemFace_Xg_vis(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:)","tags":"","url":"proc/cmp_elemface_xg_vis.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~3~~CallsGraph proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~3~~CalledByGraph proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis~3 program~test_nurbs_volume->proc~export_xc~3 program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xc~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xc~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xc~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xc~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xc~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xc~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xc~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xc~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xc~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xc~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xc_vis~3.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~3~~CallsGraph proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~3~~CalledByGraph proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xg_vis~3 program~test_nurbs_volume->proc~export_xg~3 program~example3_volume example3_volume program~example3_volume->proc~export_xg~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xg~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xg~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xg~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xg~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xg~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xg~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xg~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xg~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xg_vis~3.html"},{"title":"cmp_elem_Xth – ForCAD","text":"private pure function cmp_elem_Xth(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xth~3~~CallsGraph proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xth~3->interface~elemconn_c0 interface~unique unique proc~cmp_elem_xth~3->interface~unique proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xth~3~~CalledByGraph proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~export_xth~3 nurbs_volume%export_Xth proc~export_xth~3->proc~cmp_elem_xth~3 program~example3_volume example3_volume program~example3_volume->proc~export_xth~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xth~3.html"},{"title":"compute_Tgc_bspline_3d_scalar – ForCAD","text":"private pure function compute_Tgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_3d_scalar~~CallsGraph proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~kron kron proc~compute_tgc_bspline_3d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_3d_scalar~~CalledByGraph proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~basis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_3d_scalar.html"},{"title":"compute_Tgc_bspline_3d_vector – ForCAD","text":"private pure function compute_Tgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_3d_vector~~CallsGraph proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~kron kron proc~compute_tgc_bspline_3d_vector->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_3d_vector~~CalledByGraph proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~basis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_3d_vector.html"},{"title":"compute_Tgc_nurbs_3d_scalar – ForCAD","text":"private pure function compute_Tgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_3d_scalar~~CallsGraph proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~kron kron proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_3d_scalar~~CalledByGraph proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~basis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_3d_scalar.html"},{"title":"compute_Tgc_nurbs_3d_vector – ForCAD","text":"private pure function compute_Tgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_3d_vector~~CallsGraph proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~kron kron proc~compute_tgc_nurbs_3d_vector->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_3d_vector~~CalledByGraph proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~basis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_3d_vector.html"},{"title":"compute_Xg_bspline_3d – ForCAD","text":"private pure function compute_Xg_bspline_3d(Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_3d~~CallsGraph proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_3d~~CalledByGraph proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_3d proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_volume%create proc~create~3->interface~compute_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_3d.html"},{"title":"compute_Xg_bspline_3d_1point – ForCAD","text":"private pure function compute_Xg_bspline_3d_1point(Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) Calls proc~~compute_xg_bspline_3d_1point~~CallsGraph proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~kron kron proc~compute_xg_bspline_3d_1point->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_3d_1point~~CalledByGraph proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_volume%create proc~create~3->interface~compute_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_3d_1point.html"},{"title":"compute_Xg_nurbs_3d – ForCAD","text":"private pure function compute_Xg_nurbs_3d(Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_3d~~CallsGraph proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d interface~kron kron proc~cmp_tgc_3d->interface~kron proc~basis_bspline basis_bspline proc~cmp_tgc_3d->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_3d~~CalledByGraph proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_volume%create proc~create~3->interface~compute_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_3d.html"},{"title":"compute_Xg_nurbs_3d_1point – ForCAD","text":"private pure function compute_Xg_nurbs_3d_1point(Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) Calls proc~~compute_xg_nurbs_3d_1point~~CallsGraph proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~kron kron proc~compute_xg_nurbs_3d_1point->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_3d_1point~~CalledByGraph proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_volume%create proc~create~3->interface~compute_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_3d_1point.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~3~~CalledByGraph proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3 nurbs_volume%get_Wc none~get_wc~3->proc~get_wc_all~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_wc~3 proc~build_helix build_helix proc~build_helix->none~get_wc~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~get_wc~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_wc~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_wc~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~get_wc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_wc~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wc_all~3.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~3~~CalledByGraph proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3 nurbs_volume%get_Wc none~get_wc~3->proc~get_wci~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_wc~3 proc~build_helix build_helix proc~build_helix->none~get_wc~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~get_wc~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_wc~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_wc~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~get_wc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_wc~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wci~3.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~3~~CalledByGraph proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3 nurbs_volume%get_Xc none~get_xc~3->proc~get_xc_all~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_xc~3 proc~build_helix build_helix proc~build_helix->none~get_xc~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~get_xc~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_xc~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_xc~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~get_xc~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~get_xc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xc~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xc_all~3.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~3~~CalledByGraph proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3 nurbs_volume%get_Xc none~get_xc~3->proc~get_xci~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_xc~3 proc~build_helix build_helix proc~build_helix->none~get_xc~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~get_xc~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_xc~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_xc~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~get_xc~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~get_xc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xc~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xci~3.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~3~~CalledByGraph proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3 nurbs_volume%get_Xc none~get_xc~3->proc~get_xcid~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_xc~3 proc~build_helix build_helix proc~build_helix->none~get_xc~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~get_xc~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_xc~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_xc~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~get_xc~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~get_xc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xc~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xcid~3.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xg_all~3~~CalledByGraph proc~get_xg_all~3 nurbs_volume%get_Xg_all none~get_xg~3 nurbs_volume%get_Xg none~get_xg~3->proc~get_xg_all~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_xg~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xg_all~3.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xgi~3~~CalledByGraph proc~get_xgi~3 nurbs_volume%get_Xgi none~get_xg~3 nurbs_volume%get_Xg none~get_xg~3->proc~get_xgi~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_xg~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgi~3.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xgid~3~~CalledByGraph proc~get_xgid~3 nurbs_volume%get_Xgid none~get_xg~3 nurbs_volume%get_Xg none~get_xg~3->proc~get_xgid~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_xg~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgid~3.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xt~3~~CalledByGraph proc~get_xt~3 nurbs_volume%get_Xt program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_xt~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xt~3.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~3~~CallsGraph proc~get_continuity~3 nurbs_volume%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_continuity~3~~CalledByGraph proc~get_continuity~3 nurbs_volume%get_continuity program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~get_continuity~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~get_continuity~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_continuity~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_continuity~3.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Called by proc~~get_degree_all~2~~CalledByGraph proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3 nurbs_volume%get_degree none~get_degree~3->proc~get_degree_all~2 program~example3_volume example3_volume program~example3_volume->none~get_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_degree~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_degree~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~get_degree~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_all~2.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Called by proc~~get_degree_dir~2~~CalledByGraph proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3 nurbs_volume%get_degree none~get_degree~3->proc~get_degree_dir~2 program~example3_volume example3_volume program~example3_volume->none~get_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_degree~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_degree~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~get_degree~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_dir~2.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem~3~~CalledByGraph proc~get_elem~3 nurbs_volume%get_elem program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem~3.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xc_vis~3~~CalledByGraph proc~get_elem_xc_vis~3 nurbs_volume%get_elem_Xc_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_elem_xc_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xc_vis~3.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xg_vis~3~~CalledByGraph proc~get_elem_xg_vis~3 nurbs_volume%get_elem_Xg_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_elem_xg_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xg_vis~3.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~3~~CalledByGraph proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3 nurbs_volume%get_knot none~get_knot~3->proc~get_knot_all~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_knot~3 proc~build_helix build_helix proc~build_helix->none~get_knot~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~get_knot~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~get_knot~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~get_knot~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_knot~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_knot~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_knot~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~get_knot~3 program~example3_volume example3_volume program~example3_volume->none~get_knot~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~get_knot~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_knot~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_knot~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_knot~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~insert_knots~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~insert_knots~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~insert_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~elevate_degree~3 program~example_nurbs_volume->proc~insert_knots~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~insert_knots~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knot_all~3.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~3~~CalledByGraph proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3 nurbs_volume%get_knot none~get_knot~3->proc~get_knoti~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_knot~3 proc~build_helix build_helix proc~build_helix->none~get_knot~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~get_knot~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~get_knot~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~get_knot~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_knot~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_knot~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_knot~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~get_knot~3 program~example3_volume example3_volume program~example3_volume->none~get_knot~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~get_knot~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_knot~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_knot~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_knot~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~insert_knots~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~insert_knots~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~insert_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~elevate_degree~3 program~example_nurbs_volume->proc~insert_knots~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~insert_knots~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knoti~3.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~3~~CallsGraph proc~get_multiplicity~3 nurbs_volume%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~3~~CalledByGraph proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_multiplicity~3 program~test_nurbs_volume->proc~cmp_elem~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume none~set~3 nurbs_volume%set program~test_nurbs_volume->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~test_nurbs_volume->proc~elevate_degree~3 proc~modify_wc~3 nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc~3 proc~remove_knots~3 nurbs_volume%remove_knots program~test_nurbs_volume->proc~remove_knots~3 proc~set_c~3 nurbs_volume%set_C program~test_nurbs_volume->proc~set_c~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring~2 proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring~2 nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring~2 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~cmp_volume->proc~cmp_elem~3 proc~cmp_volume->proc~ansatz~3 proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_degree~3 proc~set3~3 nurbs_volume%set3 proc~set3~3->proc~cmp_degree~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~cmp_elem~3 program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron none~set~3->proc~set1~3 none~set~3->proc~set3~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~compute_volume->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree~3->none~set~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc~3->none~set~3 proc~modify_xc~3->none~set~3 proc~remove_knots~3->none~set~3 proc~set_c~3->none~set~3 proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set~3 proc~set_ring~2->none~set~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_multiplicity~3.html"},{"title":"get_nc_all – ForCAD","text":"private pure function get_nc_all(this) result(nc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Called by proc~~get_nc_all~2~~CalledByGraph proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3 nurbs_volume%get_nc none~get_nc~3->proc~get_nc_all~2 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_nc~3 proc~build_helix build_helix proc~build_helix->none~get_nc~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_nc~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_nc~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_nc~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~get_nc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_nc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_all~2.html"},{"title":"get_nc_dir – ForCAD","text":"private pure function get_nc_dir(this, dir) result(nc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc_dir~2~~CallsGraph proc~get_nc_dir~2 nurbs_volume%get_nc_dir interface~compute_multiplicity compute_multiplicity proc~get_nc_dir~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc_dir~2~~CalledByGraph proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3 nurbs_volume%get_nc none~get_nc~3->proc~get_nc_dir~2 proc~bend_pipe bend_pipe proc~bend_pipe->none~get_nc~3 proc~build_helix build_helix proc~build_helix->none~get_nc~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~get_nc~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~get_nc~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~get_nc~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~get_nc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_nc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~map_to_torus_sinez Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_dir~2.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3)","tags":"","url":"proc/get_ng~3.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical Called by proc~~is_rational~3~~CalledByGraph proc~is_rational~3 nurbs_volume%is_rational proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->proc~is_rational~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->proc~is_rational~3 proc~bend_pipe bend_pipe proc~bend_pipe->proc~is_rational~3 proc~build_helix build_helix proc~build_helix->proc~is_rational~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->proc~is_rational~3 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->proc~is_rational~3 proc~create~3 nurbs_volume%create proc~create~3->proc~is_rational~3 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->proc~is_rational~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->proc~is_rational~3 proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->proc~is_rational~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~is_rational~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->proc~is_rational~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->proc~is_rational~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->proc~is_rational~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~is_rational~3 none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_bend_pipe->proc~insert_knots~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe->proc~insert_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_nurbs_volume->proc~insert_knots~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_toroidal_pipe->proc~insert_knots~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~fdm_test_volume->none~derivative2~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~poisson_iga_solver_3d->proc~insert_knots~3 program~poisson_iga_solver_3d->none~basis~3 proc~ansatz~3 nurbs_volume%ansatz program~poisson_iga_solver_3d->proc~ansatz~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~insert_knots~3 program~test_nurbs_volume->none~basis~3 program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->none~derivative~3 program~test_nurbs_volume->proc~nearest_point2~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~ansatz~3->none~derivative~3 proc~cmp_volume->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_rational~3.html"},{"title":"ansatz – ForCAD","text":"private pure subroutine ansatz(this, ie, ig, Tgc, dTgc_dXg, dV, ngauss) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dV integer, intent(in), optional :: ngauss (3) Calls proc~~ansatz~3~~CallsGraph proc~ansatz~3 nurbs_volume%ansatz interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz~3->interface~ndgrid interface~unique unique proc~ansatz~3->interface~unique none~derivative~3 nurbs_volume%derivative proc~ansatz~3->none~derivative~3 none~set~3 nurbs_volume%set proc~ansatz~3->none~set~3 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~det det proc~ansatz~3->proc~det proc~inv inv proc~ansatz~3->proc~inv proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~3 nurbs_volume%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_volume%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_elem~3->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->interface~compute_dtgc~3 proc~derivative_vector~3->proc~is_rational~3 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid interface~kron kron proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_degree~3->set proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_3d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ansatz~3~~CalledByGraph proc~ansatz~3 nurbs_volume%ansatz proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ansatz~3.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~3~~CallsGraph proc~basis_scalar~3 nurbs_volume%basis_scalar interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3->interface~compute_tgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~basis_scalar~3->proc~is_rational~3 proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector interface~kron kron proc~compute_tgc_bspline_3d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_scalar~3~~CalledByGraph proc~basis_scalar~3 nurbs_volume%basis_scalar none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_scalar~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~basis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_scalar~3.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~3~~CallsGraph proc~basis_vector~3 nurbs_volume%basis_vector interface~compute_tgc~3 compute_Tgc proc~basis_vector~3->interface~compute_tgc~3 interface~ndgrid ndgrid proc~basis_vector~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~basis_vector~3->proc~is_rational~3 proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~kron kron proc~compute_tgc_bspline_3d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_vector~3~~CalledByGraph proc~basis_vector~3 nurbs_volume%basis_vector none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_vector~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~basis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_vector~3.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_degree~3~~CallsGraph proc~cmp_degree~3 nurbs_volume%cmp_degree proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 set set proc~cmp_degree~3->set interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~3~~CalledByGraph proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_degree~3 proc~set3~3 nurbs_volume%set3 proc~set3~3->proc~cmp_degree~3 none~set~3 nurbs_volume%set none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~compute_volume compute_volume program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->proc~set_c~3 program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degree~3.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_nc~3~~CallsGraph proc~cmp_nc~3 nurbs_volume%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity set set proc~cmp_nc~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~3~~CalledByGraph proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc~3 none~set~3 nurbs_volume%set program~test_nurbs_volume->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~test_nurbs_volume->proc~elevate_degree~3 proc~modify_wc~3 nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc~3 proc~remove_knots~3 nurbs_volume%remove_knots program~test_nurbs_volume->proc~remove_knots~3 proc~set_c~3 nurbs_volume%set_C program~test_nurbs_volume->proc~set_c~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring~2 proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring~2 nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring~2 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree~3->none~set~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc~3->none~set~3 proc~modify_xc~3->none~set~3 proc~remove_knots~3->none~set~3 proc~set_c~3->none~set~3 proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set~3 proc~set_ring~2->none~set~3 program~compute_volume compute_volume program~compute_volume->none~set~3 program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_nc~3.html"},{"title":"cmp_volume – ForCAD","text":"private pure subroutine cmp_volume(this, volume, ngauss) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(out) :: volume integer, intent(in), optional :: ngauss (3) Calls proc~~cmp_volume~~CallsGraph proc~cmp_volume nurbs_volume%cmp_volume proc~ansatz~3 nurbs_volume%ansatz proc~cmp_volume->proc~ansatz~3 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_volume->proc~cmp_elem~3 reduce reduce proc~cmp_volume->reduce proc~ansatz~3->proc~cmp_elem~3 interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz~3->interface~ndgrid interface~unique unique proc~ansatz~3->interface~unique none~derivative~3 nurbs_volume%derivative proc~ansatz~3->none~derivative~3 none~set~3 nurbs_volume%set proc~ansatz~3->none~set~3 proc~det det proc~ansatz~3->proc~det proc~inv inv proc~ansatz~3->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~3 nurbs_volume%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_volume%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->interface~compute_dtgc~3 proc~derivative_vector~3->proc~is_rational~3 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid interface~kron kron proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_degree~3->set proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_3d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_volume~~CalledByGraph proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_volume.html"},{"title":"compute_d2Tgc_bspline_3d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_3d_scalar~~CallsGraph proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_3d_scalar~~CalledByGraph proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_3d_scalar.html"},{"title":"compute_d2Tgc_bspline_3d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_3d_vector~~CallsGraph proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_3d_vector~~CalledByGraph proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_3d_vector.html"},{"title":"compute_d2Tgc_nurbs_3d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_3d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_3d_scalar~~CalledByGraph proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_3d_scalar.html"},{"title":"compute_d2Tgc_nurbs_3d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_3d_vector~~CallsGraph proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_3d_vector~~CalledByGraph proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_3d_vector.html"},{"title":"compute_dTgc_bspline_3d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~compute_dtgc_bspline_3d_scalar~~CallsGraph proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_3d_scalar~~CalledByGraph proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_3d_scalar.html"},{"title":"compute_dTgc_bspline_3d_vector – ForCAD","text":"private pure subroutine compute_dTgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_3d_vector~~CallsGraph proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_3d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_3d_vector~~CalledByGraph proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_3d_vector.html"},{"title":"compute_dTgc_nurbs_3d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~compute_dtgc_nurbs_3d_scalar~~CallsGraph proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_3d_scalar~~CalledByGraph proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_3d_scalar.html"},{"title":"compute_dTgc_nurbs_3d_vector – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_3d_vector~~CallsGraph proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_3d_vector~~CalledByGraph proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_3d_vector.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~3~~CallsGraph proc~create~3 nurbs_volume%create interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~3~~CalledByGraph proc~create~3 nurbs_volume%create proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/create~3.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~3~~CallsGraph proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~derivative2_scalar~3->proc~is_rational~3 proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~3~~CalledByGraph proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_scalar~3.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~3~~CallsGraph proc~derivative2_vector~3 nurbs_volume%derivative2_vector interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_vector~3->interface~compute_d2tgc~3 interface~ndgrid ndgrid proc~derivative2_vector~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~derivative2_vector~3->proc~is_rational~3 proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~3~~CalledByGraph proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_vector~3.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc, elem) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) Calls proc~~derivative_scalar~3~~CallsGraph proc~derivative_scalar~3 nurbs_volume%derivative_scalar interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_scalar~3~~CalledByGraph proc~derivative_scalar~3 nurbs_volume%derivative_scalar none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_scalar~3.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~3~~CallsGraph proc~derivative_vector~3 nurbs_volume%derivative_vector interface~compute_dtgc~3 compute_dTgc proc~derivative_vector~3->interface~compute_dtgc~3 interface~ndgrid ndgrid proc~derivative_vector~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~derivative_vector~3->proc~is_rational~3 proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_vector~3~~CalledByGraph proc~derivative_vector~3 nurbs_volume%derivative_vector none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_vector~3.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t, B, Bs) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) Calls proc~~elevate_degree~3~~CallsGraph proc~elevate_degree~3 nurbs_volume%elevate_degree none~get_knot~3 nurbs_volume%get_knot proc~elevate_degree~3->none~get_knot~3 none~set~3 nurbs_volume%set proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~is_rational~3 nurbs_volume%is_rational proc~elevate_degree~3->proc~is_rational~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~3~~CalledByGraph proc~elevate_degree~3 nurbs_volume%elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~elevate_degree~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~elevate_degree~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree~3.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename, point_data, field_names, encoding) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xc~3~~CallsGraph proc~export_xc~3 nurbs_volume%export_Xc proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy set set proc~export_xc~3->set interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~3~~CalledByGraph proc~export_xc~3 nurbs_volume%export_Xc program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xc~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xc~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xc~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xc~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xc~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xc~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xc~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xc~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xc~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xc~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xc~3.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename, point_data, field_names, encoding) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xg~3~~CallsGraph proc~export_xg~3 nurbs_volume%export_Xg proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xg~3->proc~export_vtk_legacy set set proc~export_xg~3->set interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~3~~CalledByGraph proc~export_xg~3 nurbs_volume%export_Xg program~example3_volume example3_volume program~example3_volume->proc~export_xg~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xg~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xg~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xg~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xg~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xg~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xg~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xg~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xg~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xg~3.html"},{"title":"export_Xth – ForCAD","text":"private impure subroutine export_Xth(this, filename, point_data, field_names, encoding) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding Calls proc~~export_xth~3~~CallsGraph proc~export_xth~3 nurbs_volume%export_Xth interface~ndgrid ndgrid proc~export_xth~3->interface~ndgrid interface~unique unique proc~export_xth~3->interface~unique proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~export_xth~3->proc~cmp_elem_xth~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xth~3->proc~export_vtk_legacy proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~cmp_elem_xth~3->interface~unique interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xth~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth~3~~CalledByGraph proc~export_xth~3 nurbs_volume%export_Xth program~example3_volume example3_volume program~example3_volume->proc~export_xth~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth~3.html"},{"title":"export_Xth_in_Xg – ForCAD","text":"private impure subroutine export_Xth_in_Xg(this, filename, res, encoding) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: res character(len=*), intent(in), optional :: encoding Calls proc~~export_xth_in_xg~2~~CallsGraph proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg interface~compute_xg~3 compute_Xg proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_vtk_legacy export_vtk_legacy proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~is_rational~3 nurbs_volume%is_rational proc~export_xth_in_xg~2->proc~is_rational~3 set set proc~export_xth_in_xg~2->set proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth_in_xg~2~~CalledByGraph proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~export_xth_in_xg~2 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth_in_xg~2.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this Called by proc~~finalize~3~~CalledByGraph proc~finalize~3 nurbs_volume%finalize proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~finalize~3 program~example3_volume example3_volume program~example3_volume->proc~finalize~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~finalize~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~finalize~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~finalize~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~finalize~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~finalize~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~finalize~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~finalize~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~finalize~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~finalize~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~finalize~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~finalize~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/finalize~3.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r, B, Bs) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) Calls proc~~insert_knots~3~~CallsGraph proc~insert_knots~3 nurbs_volume%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity none~get_knot~3 nurbs_volume%get_knot proc~insert_knots~3->none~get_knot~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~is_rational~3 nurbs_volume%is_rational proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc set set proc~insert_knots~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~3~~CalledByGraph proc~insert_knots~3 nurbs_volume%insert_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~insert_knots~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~insert_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~insert_knots~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~insert_knots~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~insert_knots~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~insert_knots~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knots~3.html"},{"title":"lsq_fit_bspline – ForCAD","text":"private pure subroutine lsq_fit_bspline(this, Xt, Xdata, ndata) Uses forcad_interface proc~~lsq_fit_bspline~3~~UsesGraph proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline module~forcad_interface forcad_interface proc~lsq_fit_bspline~3->module~forcad_interface module~forcad_utils forcad_utils module~forcad_interface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (3) Calls proc~~lsq_fit_bspline~3~~CallsGraph proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline interface~kron kron proc~lsq_fit_bspline~3->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_bspline~3->proc~basis_bspline proc~solve solve proc~lsq_fit_bspline~3->proc~solve set set proc~lsq_fit_bspline~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lsq_fit_bspline~3~~CalledByGraph proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~lsq_fit_bspline~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/lsq_fit_bspline~3.html"},{"title":"lsq_fit_nurbs – ForCAD","text":"private pure subroutine lsq_fit_nurbs(this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Uses forcad_interface proc~~lsq_fit_nurbs~3~~UsesGraph proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs module~forcad_interface forcad_interface proc~lsq_fit_nurbs~3->module~forcad_interface module~forcad_utils forcad_utils module~forcad_interface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (3) integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw Calls proc~~lsq_fit_nurbs~3~~CallsGraph proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs interface~kron kron proc~lsq_fit_nurbs~3->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_nurbs~3->proc~basis_bspline proc~solve solve proc~lsq_fit_nurbs~3->proc~solve set set proc~lsq_fit_nurbs~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lsq_fit_nurbs~3~~CalledByGraph proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/lsq_fit_nurbs~3.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~3~~CallsGraph proc~modify_wc~3 nurbs_volume%modify_Wc none~get_knot~3 nurbs_volume%get_knot proc~modify_wc~3->none~get_knot~3 none~get_wc~3 nurbs_volume%get_Wc proc~modify_wc~3->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~modify_wc~3->none~get_xc~3 none~set~3 nurbs_volume%set proc~modify_wc~3->none~set~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_wc~3~~CalledByGraph proc~modify_wc~3 nurbs_volume%modify_Wc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~modify_wc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_wc~3.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~3~~CallsGraph proc~modify_xc~3 nurbs_volume%modify_Xc none~get_knot~3 nurbs_volume%get_knot proc~modify_xc~3->none~get_knot~3 none~get_wc~3 nurbs_volume%get_Wc proc~modify_xc~3->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~modify_xc~3->none~get_xc~3 none~set~3 nurbs_volume%set proc~modify_xc~3->none~set~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_xc~3~~CalledByGraph proc~modify_xc~3 nurbs_volume%modify_Xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_xc~3.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt (3) integer, intent(out), optional :: id Called by proc~~nearest_point~3~~CalledByGraph proc~nearest_point~3 nurbs_volume%nearest_point proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~nearest_point~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point~3 program~nearest_point_3d->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point~3.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) Calls proc~~nearest_point2~3~~CallsGraph proc~nearest_point2~3 nurbs_volume%nearest_point2 none~derivative2~3 nurbs_volume%derivative2 proc~nearest_point2~3->none~derivative2~3 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 proc~create~3 nurbs_volume%create proc~nearest_point2~3->proc~create~3 proc~finalize~3 nurbs_volume%finalize proc~nearest_point2~3->proc~finalize~3 proc~inv inv proc~nearest_point2~3->proc~inv proc~nearest_point~3 nurbs_volume%nearest_point proc~nearest_point2~3->proc~nearest_point~3 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 interface~compute_xg~3 compute_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~cmp_xg~3->proc~is_rational~3 proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~inv->proc~inv proc~det det proc~inv->proc~det proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~compute_d2tgc_bspline_3d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~3~~CalledByGraph proc~nearest_point2~3 nurbs_volume%nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point2~3.html"},{"title":"put_to_nurbs – ForCAD","text":"private pure subroutine put_to_nurbs(this, X, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), optional, contiguous :: elemConn (:,:) Calls proc~~put_to_nurbs~~CallsGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs interface~compute_xg~3 compute_Xg proc~put_to_nurbs->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~put_to_nurbs->proc~is_rational~3 proc~set_elem_xg_vis~3 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis~3 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~put_to_nurbs~~CalledByGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/put_to_nurbs.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~3~~CallsGraph proc~remove_knots~3 nurbs_volume%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~3->interface~compute_multiplicity none~get_knot~3 nurbs_volume%get_knot proc~remove_knots~3->none~get_knot~3 none~set~3 nurbs_volume%set proc~remove_knots~3->none~set~3 proc~findspan findspan proc~remove_knots~3->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~3~~CalledByGraph proc~remove_knots~3 nurbs_volume%remove_knots program~example3_volume example3_volume program~example3_volume->proc~remove_knots~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots~3.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~3~~CallsGraph proc~rotate_xc~3 nurbs_volume%rotate_Xc proc~rotation rotation proc~rotate_xc~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~3~~CalledByGraph proc~rotate_xc~3 nurbs_volume%rotate_Xc program~example3_volume example3_volume program~example3_volume->proc~rotate_xc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~rotate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xc~3.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~3~~CallsGraph proc~rotate_xg~3 nurbs_volume%rotate_Xg proc~rotation rotation proc~rotate_xg~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~3~~CalledByGraph proc~rotate_xg~3 nurbs_volume%rotate_Xg program~example3_volume example3_volume program~example3_volume->proc~rotate_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~rotate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xg~3.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, knot3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~3~~CallsGraph proc~set1~3 nurbs_volume%set1 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~3~~CalledByGraph proc~set1~3 nurbs_volume%set1 none~set~3 nurbs_volume%set none~set~3->proc~set1~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~compute_volume compute_volume program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->proc~set_c~3 program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1~3.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~3~~CallsGraph proc~set2~3 nurbs_volume%set2 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector set set proc~set2~3->set proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~3~~CalledByGraph proc~set2~3 nurbs_volume%set2 none~set~3 nurbs_volume%set none~set~3->proc~set2~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~compute_volume compute_volume program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->proc~set_c~3 program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set2~3.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier volume using control points and weights. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~3~~CallsGraph proc~set3~3 nurbs_volume%set3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set3~3->proc~cmp_degree~3 set set proc~set3~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~3~~CalledByGraph proc~set3~3 nurbs_volume%set3 none~set~3 nurbs_volume%set none~set~3->proc~set3~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~compute_volume compute_volume program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->proc~set_c~3 program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set3~3.html"},{"title":"set4 – ForCAD","text":"private pure subroutine set4(this, degree, nc, Xc, Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set4~3~~CallsGraph proc~set4~3 nurbs_volume%set4 set set proc~set4~3->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set4~3~~CalledByGraph proc~set4~3 nurbs_volume%set4 none~set~3 nurbs_volume%set none~set~3->proc~set4~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~set~3 proc~bend_pipe bend_pipe proc~bend_pipe->none~set~3 proc~build_helix build_helix proc~build_helix->none~set~3 proc~build_twist_taper build_twist_taper proc~build_twist_taper->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~map_to_torus_sinez map_to_torus_sineZ proc~map_to_torus_sinez->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~compute_volume compute_volume program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_nurbs_volume->proc~elevate_degree~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->none~set~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->none~set~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->none~set~3 program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->none~set~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set~3 program~test_nurbs_volume->proc~elevate_degree~3 program~test_nurbs_volume->proc~modify_wc~3 program~test_nurbs_volume->proc~modify_xc~3 program~test_nurbs_volume->proc~remove_knots~3 program~test_nurbs_volume->proc~set_c~3 program~test_nurbs_volume->proc~set_half_ring~2 program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring~2 program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~bend_pipe program~example_bend_pipe->proc~elevate_degree~3 program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~build_helix program~example_helix_pipe->proc~elevate_degree~3 program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~elevate_degree~3 program~example_toroidal_pipe->proc~map_to_torus_sinez program~example_toroidal_pipe->proc~set_ring~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~build_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set4~3.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_c~3~~CallsGraph proc~set_c~3 nurbs_volume%set_C none~set~3 nurbs_volume%set proc~set_c~3->none~set~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~3~~CalledByGraph proc~set_c~3 nurbs_volume%set_C program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_c~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_c~3.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem~3~~CalledByGraph proc~set_elem~3 nurbs_volume%set_elem program~example3_volume example3_volume program~example3_volume->proc~set_elem~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem~3.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xc_vis~3~~CalledByGraph proc~set_elem_xc_vis~3 nurbs_volume%set_elem_Xc_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_elem_xc_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xc_vis~3.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~3~~CalledByGraph proc~set_elem_xg_vis~3 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~set_elem_xg_vis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_elem_xg_vis~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xg_vis~3.html"},{"title":"set_half_ring – ForCAD","text":"private pure subroutine set_half_ring(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_half_ring~2~~CallsGraph proc~set_half_ring~2 nurbs_volume%set_half_ring none~set~3 nurbs_volume%set proc~set_half_ring~2->none~set~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_ring~2~~CalledByGraph proc~set_half_ring~2 nurbs_volume%set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_half_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_half_ring~2.html"},{"title":"set_hexahedron – ForCAD","text":"private pure subroutine set_hexahedron(this, L, nc, Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_hexahedron~~CallsGraph proc~set_hexahedron nurbs_volume%set_hexahedron none~set~3 nurbs_volume%set proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_hexahedron~~CalledByGraph proc~set_hexahedron nurbs_volume%set_hexahedron program~example_twist_taper example_twist_taper program~example_twist_taper->proc~set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~set_hexahedron program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_hexahedron.html"},{"title":"set_ring – ForCAD","text":"private pure subroutine set_ring(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_ring~2~~CallsGraph proc~set_ring~2 nurbs_volume%set_ring none~set~3 nurbs_volume%set proc~set_ring~2->none~set~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_ring~2~~CalledByGraph proc~set_ring~2 nurbs_volume%set_ring program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~set_ring~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~set_ring~2 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~set_ring~2 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_ring~2.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg, vtkfile_Xth_in_Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg character(len=*), intent(in), optional :: vtkfile_Xth_in_Xg Called by proc~~show~3~~CalledByGraph proc~show~3 nurbs_volume%show program~example3_volume example3_volume program~example3_volume->proc~show~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~show~3 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~show~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~show~3 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~show~3 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~show~3 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~show~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~show~3 program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~show~3 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~show~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~show~3 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~show~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~show~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~show~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~show~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~show~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/show~3.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) Called by proc~~translate_xc~3~~CalledByGraph proc~translate_xc~3 nurbs_volume%translate_Xc program~example3_volume example3_volume program~example3_volume->proc~translate_xc~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~translate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xc~3.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) Called by proc~~translate_xg~3~~CalledByGraph proc~translate_xg~3 nurbs_volume%translate_Xg program~example3_volume example3_volume program~example3_volume->proc~translate_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~translate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xg~3.html"},{"title":"compute_Tgc – ForCAD","text":"public interface compute_Tgc Calls interface~~compute_tgc~3~~CallsGraph interface~compute_tgc~3 compute_Tgc proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector interface~kron kron proc~compute_tgc_bspline_3d_scalar->interface~kron proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_tgc~3~~CalledByGraph interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_volume%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->none~basis~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_tgc~3.html"},{"title":"compute_dTgc – ForCAD","text":"public interface compute_dTgc Calls interface~~compute_dtgc~3~~CallsGraph interface~compute_dtgc~3 compute_dTgc proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der interface~kron kron proc~compute_dtgc_bspline_3d_scalar->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_dtgc~3~~CalledByGraph interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_volume%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_volume%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~ansatz~3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_dTgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:)","tags":"","url":"interface/compute_dtgc~3.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Calls interface~~compute_xg~3~~CallsGraph interface~compute_xg~3 compute_Xg proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_xg~3~~CalledByGraph interface~compute_xg~3 compute_Xg proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_volume%create proc~create~3->interface~compute_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg proc~export_xth_in_xg~2->interface~compute_xg~3 proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->interface~compute_xg~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_bend_pipe example_bend_pipe program~example_bend_pipe->proc~create~3 program~example_bend_pipe->proc~export_xth_in_xg~2 program~example_helix_pipe example_helix_pipe program~example_helix_pipe->proc~create~3 program~example_helix_pipe->proc~export_xth_in_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_nurbs_volume->proc~export_xth_in_xg~2 program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->proc~create~3 program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->proc~create~3 program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~create~3 program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->proc~create~3 program~example_toroidal_pipe->proc~export_xth_in_xg~2 program~example_twist_taper example_twist_taper program~example_twist_taper->proc~create~3 program~example_twist_taper->proc~export_xth_in_xg~2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create~3 program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->proc~create~3 program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->proc~create~3 program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create~3 program~test_nurbs_volume->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Xg_nurbs_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_bspline_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2))","tags":"","url":"interface/compute_xg~3.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Calls interface~~compute_d2tgc~3~~CallsGraph interface~compute_d2tgc~3 compute_d2Tgc proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der interface~kron kron proc~compute_d2tgc_bspline_3d_scalar->interface~kron proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_d2tgc~3~~CalledByGraph interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2~3 program~test_nurbs_volume->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_d2Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:)","tags":"","url":"interface/compute_d2tgc~3.html"},{"title":"exact_solution – ForCAD","text":"pure function exact_solution(p, d, n) result(u) Computes the exact solution corresponding to the source term Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (2) Coordinates (x, y) real(kind=rk), intent(in) :: d (2) Domain size (L1, L2) integer, intent(in) :: n (2) Mode numbers (m1, m2) Return Value real(kind=rk) Called by proc~~exact_solution~2~~CalledByGraph proc~exact_solution~2 exact_solution program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~exact_solution~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/exact_solution~2.html"},{"title":"source_term – ForCAD","text":"pure function source_term(p, d, n) result(f) Computes the source function Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (2) Coordinates (x, y) real(kind=rk), intent(in) :: d (2) Domain size (L1, L2) integer, intent(in) :: n (2) Mode numbers (m1, m2) Return Value real(kind=rk) Called by proc~~source_term~2~~CalledByGraph proc~source_term~2 source_term program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->proc~source_term~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/source_term~2.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~6~~CalledByGraph proc~generate_xc~6 generate_Xc program~example3_volume example3_volume program~example3_volume->proc~generate_xc~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~6.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~7~~CalledByGraph proc~generate_xc~7 generate_Xc program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~generate_xc~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~7.html"},{"title":"set_Xc_Wc – ForCAD","text":"pure subroutine set_Xc_Wc(tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:) Calls proc~~set_xc_wc~6~~CallsGraph proc~set_xc_wc~6 set_Xc_Wc cosd cosd proc~set_xc_wc~6->cosd tand tand proc~set_xc_wc~6->tand Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_xc_wc~6~~CalledByGraph proc~set_xc_wc~6 set_Xc_Wc program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->proc~set_xc_wc~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_xc_wc~6.html"},{"title":"generate_Xc – ForCAD","text":"pure function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~8~~CalledByGraph proc~generate_xc~8 generate_Xc program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->proc~generate_xc~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~8.html"},{"title":"forcad_interface – ForCAD","text":"Provides a unified interfaces Note note: Due to a known issue with preprocessing in fpm\n(see: https://github.com/fortran-lang/fpm/issues/773),\nconditional compilation is currently unreliable in this context.\nAs a workaround, the implementation must be selected manually. Uses forcad_utils module~~forcad_interface~~UsesGraph module~forcad_interface forcad_interface module~forcad_utils forcad_utils module~forcad_interface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_interface~~UsedByGraph module~forcad_interface forcad_interface proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->module~forcad_interface proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline proc~lsq_fit_bspline~2->module~forcad_interface proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->module~forcad_interface proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->module~forcad_interface proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs proc~lsq_fit_nurbs~2->module~forcad_interface proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->module~forcad_interface Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/forcad_interface.html"},{"title":"forcad – ForCAD","text":"Uses forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_curve forcad_kinds module~~forcad~~UsesGraph module~forcad forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad~~UsedByGraph module~forcad forcad program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_bend_pipe example_bend_pipe program~example_bend_pipe->module~forcad program~example_helix_pipe example_helix_pipe program~example_helix_pipe->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->module~forcad program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->module~forcad program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->module~forcad program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->module~forcad program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->module~forcad program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->module~forcad program~example_twist_taper example_twist_taper program~example_twist_taper->module~forcad program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->module~forcad program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->module~forcad program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->module~forcad program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->module~forcad program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->module~forcad program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->module~forcad program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->module~forcad program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->module~forcad program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/forcad.html"},{"title":"forcad_kinds – ForCAD","text":"Used by module~~forcad_kinds~~UsedByGraph module~forcad_kinds forcad_kinds module~forcad forcad module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds program~test_forcad_utils test_forcad_utils program~test_forcad_utils->module~forcad_kinds program~test_forcad_utils->module~forcad_utils program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad_kinds program~test_nurbs_curve->module~forcad_nurbs_curve module~forcad_interface forcad_interface module~forcad_interface->module~forcad_utils program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_bend_pipe example_bend_pipe program~example_bend_pipe->module~forcad program~example_helix_pipe example_helix_pipe program~example_helix_pipe->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->module~forcad program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->module~forcad program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->module~forcad program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->module~forcad program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->module~forcad program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~example_put_to_nurbs->module~forcad_utils program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->module~forcad program~example_twist_taper example_twist_taper program~example_twist_taper->module~forcad program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->module~forcad program~fdm_elevate_and_insert_1d->module~forcad_utils program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->module~forcad program~fdm_elevate_and_insert_2d->module~forcad_utils program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->module~forcad program~fdm_elevate_and_insert_3d->module~forcad_utils program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->module~forcad program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->module~forcad program~lsq_fit_bspline_2d->module~forcad_utils program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->module~forcad program~lsq_fit_bspline_3d->module~forcad_utils program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->module~forcad program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->module~forcad program~lsq_fit_nurbs_2d->module~forcad_utils program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->module~forcad program~lsq_fit_nurbs_3d->module~forcad_utils program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->module~forcad program~poisson_iga_solver_2d->module~forcad_utils program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->module~forcad program~poisson_iga_solver_3d->module~forcad_utils program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_surface->module~forcad_utils program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad program~test_nurbs_volume->module~forcad_utils proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->module~forcad_interface proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline proc~lsq_fit_bspline~2->module~forcad_interface proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->module~forcad_interface proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->module~forcad_interface proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs proc~lsq_fit_nurbs~2->module~forcad_interface proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->module~forcad_interface Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = selected_real_kind(15)","tags":"","url":"module/forcad_kinds.html"},{"title":"forcad_utils – ForCAD","text":"This module contains parameters, functions and subroutines that are used in the library. Uses forcad_kinds module~~forcad_utils~~UsesGraph module~forcad_utils forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_utils~~UsedByGraph module~forcad_utils forcad_utils module~forcad_interface forcad_interface module~forcad_interface->module~forcad_utils module~forcad_nurbs_curve forcad_nurbs_curve module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface forcad_nurbs_surface module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume forcad_nurbs_volume module~forcad_nurbs_volume->module~forcad_utils program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad_utils module~forcad forcad program~example_put_to_nurbs->module~forcad program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->module~forcad_utils program~fdm_elevate_and_insert_1d->module~forcad program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->module~forcad_utils program~fdm_elevate_and_insert_2d->module~forcad program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->module~forcad_utils program~fdm_elevate_and_insert_3d->module~forcad program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->module~forcad_utils program~lsq_fit_bspline_2d->module~forcad program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->module~forcad_utils program~lsq_fit_bspline_3d->module~forcad program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->module~forcad_utils program~lsq_fit_nurbs_2d->module~forcad program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->module~forcad_utils program~lsq_fit_nurbs_3d->module~forcad program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->module~forcad_utils program~poisson_iga_solver_2d->module~forcad program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->module~forcad_utils program~poisson_iga_solver_3d->module~forcad program~test_forcad_utils test_forcad_utils program~test_forcad_utils->module~forcad_utils program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad_utils program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad_utils program~test_nurbs_volume->module~forcad module~forcad->module~forcad_nurbs_curve module~forcad->module~forcad_nurbs_surface module~forcad->module~forcad_nurbs_volume proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline proc~lsq_fit_bspline->module~forcad_interface proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline proc~lsq_fit_bspline~2->module~forcad_interface proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline proc~lsq_fit_bspline~3->module~forcad_interface proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs proc~lsq_fit_nurbs->module~forcad_interface proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs proc~lsq_fit_nurbs~2->module~forcad_interface proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs proc~lsq_fit_nurbs~3->module~forcad_interface program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad_nurbs_curve program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_bend_pipe example_bend_pipe program~example_bend_pipe->module~forcad program~example_helix_pipe example_helix_pipe program~example_helix_pipe->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->module~forcad program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->module~forcad program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->module~forcad program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->module~forcad program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->module~forcad program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->module~forcad program~example_twist_taper example_twist_taper program~example_twist_taper->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->module~forcad program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface basis_bspline_2der private pure subroutine basis_bspline_2der_A (Xt, knot, nc, degree, d2B, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) private pure subroutine basis_bspline_2der_B (Xt, knot, nc, degree, d2B, dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) private pure subroutine basis_bspline_2der_C (Xt, knot, nc, degree, d2B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) public        interface basis_bspline_der private pure subroutine basis_bspline_der_A (Xt, knot, nc, degree, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) private pure subroutine basis_bspline_der_B (Xt, knot, nc, degree, dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) public        interface compute_multiplicity private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer public        interface dyad private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) public        interface elemConn_C0 private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) public        interface elemConn_Cn private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) public        interface gauss_leg private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval (:) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) real(kind=rk), intent(in), contiguous :: interval3 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) public        interface kron private pure function kron_t1_t1 (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) private pure function kron_t1_t2 (u, A) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk), (size(u)*size(A,1),size(A,2)) private pure function kron3 (u, v, w) result(out) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(in), contiguous :: w (:) Return Value real(kind=rk), (size(u)*size(v)*size(w)) public        interface ndgrid private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) public        interface unique private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), contiguous :: vec (:) Return Value integer, allocatable, (:) private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: vec (:) Return Value real(kind=rk), allocatable, (:) Functions public pure function basis_bernstein (Xt, nc) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline (Xt, knot, nc, degree) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), (nc) public pure function compute_knot_vector (Xth_dir, degree, continuity) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) public pure function det (A) result(detA) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk) public pure function eye (n) result(I) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:,:) public pure function findspan (n, degree, Xth, knot) result(s) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer public pure function hexahedron_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) Return Value real(kind=rk), allocatable, (:,:) public pure recursive function inv (A) result(A_inv) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk), allocatable, (:,:) public pure function kron_eye (A, dim) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) integer, intent(in) :: dim Return Value real(kind=rk), (size(A,1)*dim,size(A,2)*dim) public pure function linspace (a, b, n) result(x) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a real(kind=rk), intent(in) :: b integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) public pure function repelem (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) public pure function rotation (alpha, beta, theta) result(R) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), (3,3) public pure function solve (A, B) result(X) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) Return Value real(kind=rk), allocatable, (:,:) public pure function tetragon_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) Return Value real(kind=rk), allocatable, (:,:) private pure elemental function bincoeff (n, k) result(b) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) private pure elemental function factln (n) result(f) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) private pure function kron3 (u, v, w) result(out) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(in), contiguous :: w (:) Return Value real(kind=rk), (size(u)*size(v)*size(w)) private pure function kron_t1_t1 (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) private pure function kron_t1_t2 (u, A) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: A (:,:) Return Value real(kind=rk), (size(u)*size(A,1),size(A,2)) private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), contiguous :: vec (:) Return Value integer, allocatable, (:) private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: vec (:) Return Value real(kind=rk), allocatable, (:) Subroutines public pure subroutine elevate_degree_A_5_9 (t, knot, degree, Xcw, nc_new, knot_new, Xcw_new, Tmap) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) real(kind=rk), intent(out), optional, allocatable :: Tmap (:,:) public impure subroutine export_vtk_legacy (filename, points, elemConn, vtkCellType, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rk), intent(in), contiguous :: points (:,:) integer, intent(in), contiguous :: elemConn (:,:) integer, intent(in) :: vtkCellType real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding public pure subroutine insert_knot_A_5_1 (p, UP, Pw, u, k, s, r, nq, UQ, Qw, T) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) real(kind=rk), intent(out), optional, allocatable :: T (:,:) public pure subroutine remove_knots_A_5_8 (p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) private pure subroutine basis_bspline_2der_A (Xt, knot, nc, degree, d2B, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) private pure subroutine basis_bspline_2der_B (Xt, knot, nc, degree, d2B, dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out) :: dB (nc) private pure subroutine basis_bspline_2der_C (Xt, knot, nc, degree, d2B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) private pure subroutine basis_bspline_der_A (Xt, knot, nc, degree, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out) :: B (nc) private pure subroutine basis_bspline_der_B (Xt, knot, nc, degree, dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine gauss_legendre (x, w, interval) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: x (:) real(kind=rk), intent(out) :: w (:) real(kind=rk), intent(in), contiguous :: interval (:) private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval (:) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: interval1 (:) real(kind=rk), intent(in), contiguous :: interval2 (:) real(kind=rk), intent(in), contiguous :: interval3 (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","url":"module/forcad_utils.html"},{"title":"forcad_nurbs_surface – ForCAD","text":"This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. Uses forcad_utils fordebug forcad_kinds module~~forcad_nurbs_surface~~UsesGraph module~forcad_nurbs_surface forcad_nurbs_surface fordebug fordebug module~forcad_nurbs_surface->fordebug module~forcad_kinds forcad_kinds module~forcad_nurbs_surface->module~forcad_kinds module~forcad_utils forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_surface~~UsedByGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad forcad module~forcad->module~forcad_nurbs_surface program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_bend_pipe example_bend_pipe program~example_bend_pipe->module~forcad program~example_helix_pipe example_helix_pipe program~example_helix_pipe->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->module~forcad program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->module~forcad program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->module~forcad program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->module~forcad program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->module~forcad program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->module~forcad program~example_twist_taper example_twist_taper program~example_twist_taper->module~forcad program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->module~forcad program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->module~forcad program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->module~forcad program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->module~forcad program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->module~forcad program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->module~forcad program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->module~forcad program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->module~forcad program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface compute_Tgc private pure function compute_Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:) public        interface compute_dTgc private pure subroutine compute_dTgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private        interface compute_Xg private pure function compute_Xg_nurbs_2d (Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) integer, intent(in), optional, contiguous :: ng (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d (Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point (Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_bspline_2d_1point (Xt, knot1, knot2, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Derived Types type, public :: nurbs_surface Components Type Visibility Attributes Name Initial type(debug), public :: err 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dA Read more… generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS surface Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_area Compute the area of the NURBS surface Read more… procedure, public :: cmp_degree Compute degree of the NURBS surface Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_elem_Xth Generate connectivity for parameter points Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS surface Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS surface Read more… procedure, public :: elevate_degree Elevate degree Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: export_Xth Export parameter space to VTK file Read more… procedure, public :: export_Xth_in_Xg Export parameter space in geometry points to VTK file Read more… procedure, public :: export_iges Export the NURBS surface to IGES format Read more… procedure, public :: finalize Finalize the NURBS surface object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the NURBS surface Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knot vector Read more… generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS surface is rational Read more… procedure, public :: lsq_fit_bspline Fit B-spline surface to structured data points using least squares Read more… procedure, public :: lsq_fit_nurbs Fit NURBS surface to structured data points using least squares Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS surface (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS surface (Minimization - Newtons method) Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 , set4 Set NURBS surface Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_ring Set a half ring Read more… procedure, public :: set_ring Set a ring Read more… procedure, public :: set_tetragon Set a tetragon Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS surface Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS surface Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS surface Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS surface Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS surface Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS surface Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_degree_all Get degree of the NURBS surface in both directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… procedure, private :: get_nc_all Get number of control points in all directions Read more… procedure, private :: get_nc_dir Get number of control points in a specific direction Read more… procedure, private :: set1 Set knot vectors, control points and weights for the NURBS surface object Read more… procedure, private :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, private :: set3 Set Bezier or Rational Bezier surface using control points and weights Read more… procedure, private :: set4 Set NURBS surface using degree, number of control points, control points and weights Read more… Functions private pure function cmp_Tgc_2d (Xti, knot1, knot2, nc, degree, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in), contiguous :: nc (:) integer, intent(in), contiguous :: degree (:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)) private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xth (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function compute_Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d (Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d_1point (Xt, knot1, knot2, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_nurbs_2d (Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) integer, intent(in), optional, contiguous :: ng (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point (Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical Subroutines private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dA, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dA integer, intent(in), optional :: ngauss (2) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_area (this, area, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(out) :: area integer, intent(in), optional :: ngauss (2) private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine compute_d2Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in), optional :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, dir, t, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) private impure subroutine export_Xc (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xg (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth_in_Xg (this, filename, res, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: res character(len=*), intent(in), optional :: encoding private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) private pure subroutine lsq_fit_bspline (this, Xt, Xdata, ndata) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (2) private pure subroutine lsq_fit_nurbs (this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (2) integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt (2) integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg, vtkfile_Xth_in_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg character(len=*), intent(in), optional :: vtkfile_Xth_in_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:)","tags":"","url":"module/forcad_nurbs_surface.html"},{"title":"forcad_nurbs_curve – ForCAD","text":"This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. Uses forcad_utils fordebug forcad_kinds module~~forcad_nurbs_curve~~UsesGraph module~forcad_nurbs_curve forcad_nurbs_curve fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_kinds forcad_kinds module~forcad_nurbs_curve->module~forcad_kinds module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_curve~~UsedByGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad forcad module~forcad->module~forcad_nurbs_curve program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad_nurbs_curve program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_bend_pipe example_bend_pipe program~example_bend_pipe->module~forcad program~example_helix_pipe example_helix_pipe program~example_helix_pipe->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->module~forcad program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->module~forcad program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->module~forcad program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->module~forcad program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->module~forcad program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->module~forcad program~example_twist_taper example_twist_taper program~example_twist_taper->module~forcad program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->module~forcad program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->module~forcad program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->module~forcad program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->module~forcad program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->module~forcad program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->module~forcad program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->module~forcad program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->module~forcad program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface compute_Tgc private pure function compute_Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_scalar (Xt, knot, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) public        interface compute_dTgc private pure subroutine compute_dTgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_1d_vector (Xt, knot, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_1d_scalar (Xt, knot, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private        interface compute_Xg private pure function compute_Xg_nurbs_1d (Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d (Xt, knot, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point (Xt, knot, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_bspline_1d_1point (Xt, knot, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_scalar (Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Derived Types type, public :: nurbs_curve Components Type Visibility Attributes Name Initial type(debug), public :: err 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dL Read more… generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS curve Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_degree Compute degree of the NURBS curve Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_elem_Xth Generate connectivity for parameter points Read more… procedure, public :: cmp_length Compute the length of the NURBS curve Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS curve Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS curve Read more… procedure, public :: elevate_degree Elevate the degree of the curve Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: export_Xth Export parameter space to VTK file Read more… procedure, public :: export_iges Export the NURBS curve to an IGES file Read more… procedure, public :: finalize Finalize the NURBS curve object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the curve Read more… procedure, public :: get_degree Get degree of the NURBS curve Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knots Read more… procedure, public :: get_nc Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS curve is rational Read more… procedure, public :: lsq_fit_bspline Fit B-spline curve to structured data points using least squares Read more… procedure, public :: lsq_fit_nurbs Fit NURBS curve to structured data points using least squares Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS curve (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS curve (Minimization - Newtons method) Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set1a , set2 , set3 , set4 Set NURBS curve Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_circle Set a circle Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_circle Set a half circle Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS curve Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS curve Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS curve Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS curve Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS curve Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS curve Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… procedure, private :: set1 Set knot vector, control points and weights for the NURBS curve object Read more… procedure, private :: set1a procedure, private :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, private :: set3 Set Bezier or Rational Bezier curve using control points and weights Read more… procedure, private :: set4 Set NURBS curve using degree, number of control points, control points and weights Read more… Functions private pure function cmp_Tgc_1d (Xti, knot, nc, degree, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xti real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc) private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xth (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function compute_Tgc_bspline_1d_scalar (Xt, knot, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d (Xt, knot, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d_1point (Xt, knot, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_nurbs_1d (Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point (Xt, knot, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical Subroutines private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dL, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dL integer, intent(in), optional :: ngauss private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine cmp_length (this, length, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(out) :: length integer, intent(in), optional :: ngauss private pure subroutine cmp_nc (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine compute_d2Tgc_bspline_1d_scalar (Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_1d_scalar (Xt, knot, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_1d_vector (Xt, knot, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in), optional :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, t, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) private impure subroutine export_Xc (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xg (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine insert_knots (this, Xth, r, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) private pure subroutine lsq_fit_bspline (this, Xt, Xdata, ndata) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata private pure subroutine lsq_fit_nurbs (this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set1a (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:)","tags":"","url":"module/forcad_nurbs_curve.html"},{"title":"forcad_nurbs_volume – ForCAD","text":"This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. Uses forcad_utils fordebug forcad_kinds module~~forcad_nurbs_volume~~UsesGraph module~forcad_nurbs_volume forcad_nurbs_volume fordebug fordebug module~forcad_nurbs_volume->fordebug module~forcad_kinds forcad_kinds module~forcad_nurbs_volume->module~forcad_kinds module~forcad_utils forcad_utils module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_volume~~UsedByGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad forcad module~forcad->module~forcad_nurbs_volume program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_bend_pipe example_bend_pipe program~example_bend_pipe->module~forcad program~example_helix_pipe example_helix_pipe program~example_helix_pipe->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_plate_hole_1_2d example_plate_hole_1_2d program~example_plate_hole_1_2d->module~forcad program~example_plate_hole_1_3d example_plate_hole_1_3d program~example_plate_hole_1_3d->module~forcad program~example_plate_hole_2_2d example_plate_hole_2_2d program~example_plate_hole_2_2d->module~forcad program~example_plate_hole_2_3d example_plate_hole_2_3d program~example_plate_hole_2_3d->module~forcad program~example_plate_hole_4_2d example_plate_hole_4_2d program~example_plate_hole_4_2d->module~forcad program~example_plate_hole_4_3d example_plate_hole_4_3d program~example_plate_hole_4_3d->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~example_toroidal_pipe example_toroidal_pipe program~example_toroidal_pipe->module~forcad program~example_twist_taper example_twist_taper program~example_twist_taper->module~forcad program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d program~fdm_elevate_and_insert_1d->module~forcad program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d program~fdm_elevate_and_insert_2d->module~forcad program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d program~fdm_elevate_and_insert_3d->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~lsq_fit_bspline_1d lsq_fit_bspline_1d program~lsq_fit_bspline_1d->module~forcad program~lsq_fit_bspline_2d lsq_fit_bspline_2d program~lsq_fit_bspline_2d->module~forcad program~lsq_fit_bspline_3d lsq_fit_bspline_3d program~lsq_fit_bspline_3d->module~forcad program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d program~lsq_fit_nurbs_1d->module~forcad program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d program~lsq_fit_nurbs_2d->module~forcad program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d program~lsq_fit_nurbs_3d->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~poisson_iga_solver_2d poisson_iga_solver_2d program~poisson_iga_solver_2d->module~forcad program~poisson_iga_solver_3d poisson_iga_solver_3d program~poisson_iga_solver_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface compute_Tgc private pure function compute_Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:) public        interface compute_dTgc private pure subroutine compute_dTgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private        interface compute_Xg private pure function compute_Xg_nurbs_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_bspline_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Derived Types type, public :: nurbs_volume Components Type Visibility Attributes Name Initial type(debug), public :: err 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1) ng(2) ng(3), dim] real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dV Read more… generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS volume Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_degree Compute degree of the NURBS volume Read more… procedure, public :: cmp_degreeFace Compute degrees of the faces Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elemFace Compute faces of the IGA elements Read more… procedure, public :: cmp_elemFace_Xc_vis Compute faces of the control points Read more… procedure, public :: cmp_elemFace_Xg_vis Compute faces of the geometry points Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_elem_Xth Generate connectivity for parameter points Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: cmp_volume Compute the volume of the NURBS volume Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS volume Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS volume Read more… procedure, public :: elevate_degree Elevate the degree of the NURBS volume Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: export_Xth Export parameter space to VTK file Read more… procedure, public :: export_Xth_in_Xg Export parameter space in geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS volume object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the NURBS volume Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knots Read more… generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS volume is rational Read more… procedure, public :: lsq_fit_bspline Fit B-spline volume to structured data points using least squares Read more… procedure, public :: lsq_fit_nurbs Fit NURBS volume to structured data points using least squares Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS volume (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS volume (Minimization - Newtons method) Read more… procedure, public :: put_to_nurbs Put a shape to a NURBS volume Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 , set4 Set NURBS volume Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_ring Set a half ring Read more… procedure, public :: set_hexahedron Set a hexahedron Read more… procedure, public :: set_ring Set a ring Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS volume Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS volume Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS volume Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS volume Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS volume Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS volume Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_degree_all Get degree of the NURBS volume in all directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… procedure, private :: get_nc_all Get number of control points in all directions Read more… procedure, private :: get_nc_dir Get number of control points in a specific direction Read more… procedure, private :: set1 Set knot vectors, control points and weights for the NURBS volume object Read more… procedure, private :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, private :: set3 Set Bezier or Rational Bezier volume using control points and weights Read more… procedure, private :: set4 Set NURBS volume using degree, number of control points, control points and weights Read more… Functions private pure function cmp_Tgc_3d (Xti, knot1, knot2, knot3, nc, degree, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: nc (3) integer, intent(in) :: degree (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)*nc(3)) private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) private pure function cmp_degreeFace (this, face) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elemFace (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elemFace_Xc_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elemFace_Xg_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xth (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function compute_Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), (size(Xc,2)) private pure function compute_Xg_nurbs_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (size(Xc,2)) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical Subroutines private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dV, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dV integer, intent(in), optional :: ngauss (3) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_volume (this, volume, ngauss) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(out) :: volume integer, intent(in), optional :: ngauss (3) private pure subroutine compute_d2Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause If elem is not present: Wc refers to the full weight vector.\nIf elem is present: Wc refers to the element-local weight vector ( Wce ). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine compute_dTgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in), optional :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional, contiguous :: elem (:) private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, dir, t, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) private impure subroutine export_Xc (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xg (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth (this, filename, point_data, field_names, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename real(kind=rk), intent(in), optional, contiguous :: point_data (:,:) character(len=*), intent(in), optional, contiguous :: field_names (:) character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth_in_Xg (this, filename, res, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: res character(len=*), intent(in), optional :: encoding private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r, B, Bs) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) real(kind=rk), intent(out), optional, allocatable :: B (:,:) real(kind=rk), intent(out), optional, allocatable :: Bs (:,:) private pure subroutine lsq_fit_bspline (this, Xt, Xdata, ndata) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (3) private pure subroutine lsq_fit_nurbs (this, Xt, Xdata, ndata, maxit, tol, lambda_xc, mu0, reg_logw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: Xdata (:,:) integer, intent(in) :: ndata (3) integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: tol real(kind=rk), intent(in), optional :: lambda_xc real(kind=rk), intent(in), optional :: mu0 real(kind=rk), intent(in), optional :: reg_logw private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xg (size(point_Xg)) real(kind=rk), intent(out), optional :: nearest_Xt (3) integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional :: nearest_Xg (size(this%Xc,2)) private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), optional, contiguous :: elemConn (:,:) private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), optional, contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg, vtkfile_Xth_in_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg character(len=*), intent(in), optional :: vtkfile_Xth_in_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: vec (:)","tags":"","url":"module/forcad_nurbs_volume.html"},{"title":"shape_hexahedron – ForCAD","text":"Uses forcad program~~shape_hexahedron~~UsesGraph program~shape_hexahedron shape_hexahedron module~forcad forcad program~shape_hexahedron->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8].\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_hexahedron~~CallsGraph program~shape_hexahedron shape_hexahedron proc~create~3 nurbs_volume%create program~shape_hexahedron->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_hexahedron->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_hexahedron->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_hexahedron->proc~finalize~3 proc~set_hexahedron nurbs_volume%set_hexahedron program~shape_hexahedron->proc~set_hexahedron proc~show~3 nurbs_volume%show program~shape_hexahedron->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set none~set~3 nurbs_volume%set proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_hexahedron.html"},{"title":"example_plate_hole_1_3d – ForCAD","text":"Uses forcad program~~example_plate_hole_1_3d~~UsesGraph program~example_plate_hole_1_3d example_plate_hole_1_3d module~forcad forcad program~example_plate_hole_1_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example_plate_hole_1_3d~~CallsGraph program~example_plate_hole_1_3d example_plate_hole_1_3d none~set~3 nurbs_volume%set program~example_plate_hole_1_3d->none~set~3 proc~create~3 nurbs_volume%create program~example_plate_hole_1_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_plate_hole_1_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_plate_hole_1_3d->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_plate_hole_1_3d->proc~export_xth_in_xg~2 proc~set_xc_wc set_Xc_Wc program~example_plate_hole_1_3d->proc~set_xc_wc proc~show~3 nurbs_volume%show program~example_plate_hole_1_3d->proc~show~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set cosd cosd proc~set_xc_wc->cosd tand tand proc~set_xc_wc->tand proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), parameter :: height = 5.0_rk real(kind=rk), parameter :: length = 5.0_rk type( nurbs_volume ) :: plate_hole real(kind=rk), parameter :: radius1 = 2.5_rk real(kind=rk), parameter :: radius2 = 3.5_rk real(kind=rk), parameter :: width = 0.5_rk Subroutines pure subroutine set_Xc_Wc (tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:)","tags":"","url":"program/example_plate_hole_1_3d.html"},{"title":"test_nurbs_volume – ForCAD","text":"Uses forunittest forcad_utils forcad program~~test_nurbs_volume~~UsesGraph program~test_nurbs_volume test_nurbs_volume forunittest forunittest program~test_nurbs_volume->forunittest module~forcad forcad program~test_nurbs_volume->module~forcad module~forcad_utils forcad_utils program~test_nurbs_volume->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_nurbs_volume~~CallsGraph program~test_nurbs_volume test_nurbs_volume check check program~test_nurbs_volume->check interface~ndgrid ndgrid program~test_nurbs_volume->interface~ndgrid n n program~test_nurbs_volume->n none~basis~3 nurbs_volume%basis program~test_nurbs_volume->none~basis~3 none~derivative2~3 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2~3 none~derivative~3 nurbs_volume%derivative program~test_nurbs_volume->none~derivative~3 none~get_degree~3 nurbs_volume%get_degree program~test_nurbs_volume->none~get_degree~3 none~get_knot~3 nurbs_volume%get_knot program~test_nurbs_volume->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc program~test_nurbs_volume->none~get_nc~3 none~get_wc~3 nurbs_volume%get_Wc program~test_nurbs_volume->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc program~test_nurbs_volume->none~get_xc~3 none~get_xg~3 nurbs_volume%get_Xg program~test_nurbs_volume->none~get_xg~3 none~set~3 nurbs_volume%set program~test_nurbs_volume->none~set~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis program~test_nurbs_volume->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis program~test_nurbs_volume->proc~cmp_elem_xg_vis~3 proc~cmp_elem~3 nurbs_volume%cmp_elem program~test_nurbs_volume->proc~cmp_elem~3 proc~cmp_nc~3 nurbs_volume%cmp_nc program~test_nurbs_volume->proc~cmp_nc~3 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~create~3 nurbs_volume%create program~test_nurbs_volume->proc~create~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~test_nurbs_volume->proc~elevate_degree~3 proc~export_xc~3 nurbs_volume%export_Xc program~test_nurbs_volume->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~test_nurbs_volume->proc~export_xg~3 proc~export_xth~3 nurbs_volume%export_Xth program~test_nurbs_volume->proc~export_xth~3 proc~finalize~3 nurbs_volume%finalize program~test_nurbs_volume->proc~finalize~3 proc~get_continuity~3 nurbs_volume%get_continuity program~test_nurbs_volume->proc~get_continuity~3 proc~get_elem_xc_vis~3 nurbs_volume%get_elem_Xc_vis program~test_nurbs_volume->proc~get_elem_xc_vis~3 proc~get_elem_xg_vis~3 nurbs_volume%get_elem_Xg_vis program~test_nurbs_volume->proc~get_elem_xg_vis~3 proc~get_elem~3 nurbs_volume%get_elem program~test_nurbs_volume->proc~get_elem~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity program~test_nurbs_volume->proc~get_multiplicity~3 proc~get_xt~3 nurbs_volume%get_Xt program~test_nurbs_volume->proc~get_xt~3 proc~insert_knots~3 nurbs_volume%insert_knots program~test_nurbs_volume->proc~insert_knots~3 proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline program~test_nurbs_volume->proc~lsq_fit_bspline~3 proc~modify_wc~3 nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2~3 proc~nearest_point~3 nurbs_volume%nearest_point program~test_nurbs_volume->proc~nearest_point~3 proc~remove_knots~3 nurbs_volume%remove_knots program~test_nurbs_volume->proc~remove_knots~3 proc~rotate_xc~3 nurbs_volume%rotate_Xc program~test_nurbs_volume->proc~rotate_xc~3 proc~rotate_xg~3 nurbs_volume%rotate_Xg program~test_nurbs_volume->proc~rotate_xg~3 proc~set_c~3 nurbs_volume%set_C program~test_nurbs_volume->proc~set_c~3 proc~set_elem_xc_vis~3 nurbs_volume%set_elem_Xc_vis program~test_nurbs_volume->proc~set_elem_xc_vis~3 proc~set_elem_xg_vis~3 nurbs_volume%set_elem_Xg_vis program~test_nurbs_volume->proc~set_elem_xg_vis~3 proc~set_elem~3 nurbs_volume%set_elem program~test_nurbs_volume->proc~set_elem~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring~2 proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring~2 nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring~2 proc~translate_xc~3 nurbs_volume%translate_Xc program~test_nurbs_volume->proc~translate_xc~3 proc~translate_xg~3 nurbs_volume%translate_Xg program~test_nurbs_volume->proc~translate_xg~3 xdata xdata program~test_nurbs_volume->xdata xg_eval xg_eval program~test_nurbs_volume->xg_eval xt xt program~test_nurbs_volume->xt xt1 xt1 program~test_nurbs_volume->xt1 xt2 xt2 program~test_nurbs_volume->xt2 xt3 xt3 program~test_nurbs_volume->xt3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_scalar~3 nurbs_volume%basis_scalar none~basis~3->proc~basis_scalar~3 proc~basis_vector~3 nurbs_volume%basis_vector none~basis~3->proc~basis_vector~3 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 proc~derivative_scalar~3 nurbs_volume%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_volume%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~get_xg_all~3 nurbs_volume%get_Xg_all none~get_xg~3->proc~get_xg_all~3 proc~get_xgid~3 nurbs_volume%get_Xgid none~get_xg~3->proc~get_xgid~3 proc~get_xgi~3 nurbs_volume%get_Xgi none~get_xg~3->proc~get_xgi~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem~3->proc~get_multiplicity~3 interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity set set proc~cmp_nc~3->set proc~cmp_volume->proc~cmp_elem~3 proc~ansatz~3 nurbs_volume%ansatz proc~cmp_volume->proc~ansatz~3 reduce reduce proc~cmp_volume->reduce proc~create~3->interface~ndgrid interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~create~3->set proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth~3->interface~ndgrid proc~export_xth~3->interface~unique proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~export_xth~3->proc~cmp_elem_xth~3 proc~export_xth~3->proc~export_vtk_legacy proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~insert_knots~3->none~get_knot~3 proc~insert_knots~3->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc proc~insert_knots~3->set interface~kron kron proc~lsq_fit_bspline~3->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_bspline~3->proc~basis_bspline proc~solve solve proc~lsq_fit_bspline~3->proc~solve proc~lsq_fit_bspline~3->set proc~modify_wc~3->none~get_knot~3 proc~modify_wc~3->none~get_wc~3 proc~modify_wc~3->none~get_xc~3 proc~modify_wc~3->none~set~3 proc~modify_xc~3->none~get_knot~3 proc~modify_xc~3->none~get_wc~3 proc~modify_xc~3->none~get_xc~3 proc~modify_xc~3->none~set~3 proc~nearest_point2~3->none~derivative2~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->proc~finalize~3 proc~nearest_point2~3->proc~nearest_point~3 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 proc~inv inv proc~nearest_point2~3->proc~inv proc~remove_knots~3->none~get_knot~3 proc~remove_knots~3->none~set~3 proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~3->proc~rotation proc~rotate_xg~3->proc~rotation proc~set_c~3->none~set~3 proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~set_ring~2->none~set~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~ansatz~3->interface~ndgrid proc~ansatz~3->none~derivative~3 proc~ansatz~3->none~set~3 proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->interface~unique proc~ansatz~3->proc~inv interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg proc~det det proc~ansatz~3->proc~det proc~basis_scalar~3->proc~is_rational~3 interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3->interface~ndgrid proc~basis_vector~3->proc~is_rational~3 proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_elem_xth~3->interface~elemconn_c0 proc~cmp_elem_xth~3->interface~unique proc~cmp_xg~3->interface~compute_xg~3 proc~cmp_xg~3->proc~is_rational~3 proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~derivative_scalar~3->proc~is_rational~3 interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->proc~is_rational~3 proc~derivative_vector~3->interface~compute_dtgc~3 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_nc_dir~2->interface~compute_multiplicity proc~inv->proc~inv proc~inv->proc~solve proc~inv->proc~det proc~eye eye proc~inv->proc~eye cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1~3->proc~cmp_nc~3 proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~set2~3->proc~cmp_nc~3 proc~set2~3->set proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_degree~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_xg_bspline_3d->interface~kron proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~compute_d2tgc_bspline_3d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der proc~compute_dtgc_bspline_3d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~compute_tgc_bspline_3d_scalar->interface~kron proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Tgc (:,:) real(kind=rk), allocatable :: Tgc1 (:) real(kind=rk), allocatable :: Tgc1b (:) real(kind=rk), allocatable :: Tgcb (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xg (:,:) real(kind=rk), allocatable :: Xgb (:,:) type( nurbs_volume ) :: bsp real(kind=rk), allocatable :: d2Tgc (:,:,:) real(kind=rk), allocatable :: d2Tgc1 (:,:) real(kind=rk), allocatable :: d2Tgc1b (:,:) real(kind=rk), allocatable :: d2Tgcb (:,:,:) real(kind=rk), allocatable :: dTgc (:,:,:) real(kind=rk), allocatable :: dTgc1 (:,:) real(kind=rk), allocatable :: dTgc1b (:,:) real(kind=rk), allocatable :: dTgcb (:,:,:) integer, allocatable :: elemConn (:,:) integer :: i integer :: id real(kind=rk) :: knot1 (4) real(kind=rk) :: knot2 (4) real(kind=rk) :: knot3 (4) real(kind=rk) :: nearest_Xg (3) real(kind=rk) :: nearest_Xt (3) type( nurbs_volume ) :: nurbs type(unit_test) :: ut real(kind=rk) :: volume real(kind=rk) :: volumeb","tags":"","url":"program/test_nurbs_volume.html"},{"title":"example_plate_hole_2_2d – ForCAD","text":"Uses forcad program~~example_plate_hole_2_2d~~UsesGraph program~example_plate_hole_2_2d example_plate_hole_2_2d module~forcad forcad program~example_plate_hole_2_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example_plate_hole_2_2d~~CallsGraph program~example_plate_hole_2_2d example_plate_hole_2_2d none~set nurbs_surface%set program~example_plate_hole_2_2d->none~set proc~create nurbs_surface%create program~example_plate_hole_2_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~example_plate_hole_2_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example_plate_hole_2_2d->proc~export_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~example_plate_hole_2_2d->proc~export_xth_in_xg proc~set_xc_wc~2 set_Xc_Wc program~example_plate_hole_2_2d->proc~set_xc_wc~2 proc~show nurbs_surface%show program~example_plate_hole_2_2d->proc~show proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth_in_xg->interface~compute_xg interface~unique unique proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg->proc~export_vtk_legacy proc~export_xth_in_xg->proc~is_rational proc~export_xth_in_xg->set cosd cosd proc~set_xc_wc~2->cosd tand tand proc~set_xc_wc~2->tand proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), parameter :: height = 5.0_rk real(kind=rk), parameter :: length = 5.0_rk type( nurbs_surface ) :: plate_hole real(kind=rk), parameter :: radius1 = 2.5_rk real(kind=rk), parameter :: radius2 = 3.5_rk Subroutines pure subroutine set_Xc_Wc (tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:)","tags":"","url":"program/example_plate_hole_2_2d.html"},{"title":"example3_surface – ForCAD","text":"Uses forcad program~~example3_surface~~UsesGraph program~example3_surface example3_surface module~forcad forcad program~example3_surface->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. Define control points for the NURBS surface Define weights for the control points\nDefine knot vectors for both dimensions\nSet knot vectors, control points, and weights for the NURBS surface object Deallocate local arrays Export parameter space to a VTK file Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Export the NURBS surface to an IGES file Show the control geometry and geometry using PyVista Print size of the knot vectors\nInsert knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after inserting knots\nPrint the degrees Elevate degree by 2 in both directions\nPrint the degrees after elevating Print size of the knot vectors\nRemove knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after removing knots\nGenerate the refined NURBS surface with resolutions of 30 in both dimensions Export refined parameter space to a VTK file Export updated control points to a VTK file Export the refined generated surface to a VTK file Export the NURBS surface to an IGES file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export parameter space to a VTK file Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Export the transformed NURBS surface to an IGES file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~example3_surface~~CallsGraph program~example3_surface example3_surface none~get_degree nurbs_surface%get_degree program~example3_surface->none~get_degree none~get_knot nurbs_surface%get_knot program~example3_surface->none~get_knot none~set nurbs_surface%set program~example3_surface->none~set proc~create nurbs_surface%create program~example3_surface->proc~create proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface->proc~elevate_degree proc~export_iges nurbs_surface%export_iges program~example3_surface->proc~export_iges proc~export_xc nurbs_surface%export_Xc program~example3_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example3_surface->proc~export_xg proc~export_xth nurbs_surface%export_Xth program~example3_surface->proc~export_xth proc~finalize nurbs_surface%finalize program~example3_surface->proc~finalize proc~generate_xc generate_Xc program~example3_surface->proc~generate_xc proc~insert_knots nurbs_surface%insert_knots program~example3_surface->proc~insert_knots proc~remove_knots nurbs_surface%remove_knots program~example3_surface->proc~remove_knots proc~rotate_xc nurbs_surface%rotate_Xc program~example3_surface->proc~rotate_xc proc~rotate_xg nurbs_surface%rotate_Xg program~example3_surface->proc~rotate_xg proc~show nurbs_surface%show program~example3_surface->proc~show proc~translate_xc nurbs_surface%translate_Xc program~example3_surface->proc~translate_xc proc~translate_xg nurbs_surface%translate_Xg program~example3_surface->proc~translate_xg proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~elevate_degree->none~get_knot proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->proc~is_rational append append proc~export_iges->append delete delete proc~export_iges->delete init init proc~export_iges->init makedpsections makedpsections proc~export_iges->makedpsections makegsection makegsection proc~export_iges->makegsection makessection makessection proc~export_iges->makessection proc~export_iges->proc~is_rational writeigesfile writeigesfile proc~export_iges->writeigesfile proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth->interface~ndgrid interface~unique unique proc~export_xth->interface~unique proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~export_xth->proc~cmp_elem_xth proc~export_xth->proc~export_vtk_legacy proc~insert_knots->none~get_knot interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots->proc~is_rational s_loc s_loc proc~insert_knots->s_loc proc~insert_knots->set proc~remove_knots->none~get_knot proc~remove_knots->none~set proc~remove_knots->interface~compute_multiplicity proc~remove_knots->proc~findspan proc~remove_knots->proc~is_rational proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc->proc~rotation proc~rotate_xg->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xth->interface~unique proc~cmp_elem_xth->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (6) Arrays for knot vectors in both dimensions real(kind=rk) :: knot2 (6) Arrays for knot vectors in both dimensions type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !> Export the transformed NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","url":"program/example3_surface.html"},{"title":"fdm_test_surface – ForCAD","text":"Uses forcad program~~fdm_test_surface~~UsesGraph program~fdm_test_surface fdm_test_surface module~forcad forcad program~fdm_test_surface->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate the NURBS surface with a resolution of 20 Finalize the NURBS surface object\nGenerate the NURBS surface with a resolution of 20 Finalize the NURBS surface object Calls program~~fdm_test_surface~~CallsGraph program~fdm_test_surface fdm_test_surface none~derivative2 nurbs_surface%derivative2 program~fdm_test_surface->none~derivative2 proc~create nurbs_surface%create program~fdm_test_surface->proc~create proc~finalize nurbs_surface%finalize program~fdm_test_surface->proc~finalize proc~set_tetragon nurbs_surface%set_tetragon program~fdm_test_surface->proc~set_tetragon proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2->proc~derivative2_vector interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~compute_d2tgc_bspline_2d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: BFD (:,:) real(kind=rk), allocatable :: BFD2 (:,:) real(kind=rk), allocatable :: CFD (:,:) real(kind=rk), allocatable :: CFD2 (:,:) real(kind=rk), allocatable :: FFD (:,:) real(kind=rk), allocatable :: FFD2 (:,:) real(kind=rk), allocatable :: Tgc (:) real(kind=rk), allocatable :: Tgcm (:) real(kind=rk), allocatable :: Tgcp (:) real(kind=rk), allocatable :: Wc (:) Declare the control points weights real(kind=rk) :: Xt (2) real(kind=rk) :: Xtm (2) real(kind=rk) :: Xtp (2) real(kind=rk), allocatable :: d2Tgc (:,:) real(kind=rk), allocatable :: d2Tgcm (:,:) real(kind=rk), allocatable :: d2Tgcp (:,:) real(kind=rk), allocatable :: dTgc (:,:) real(kind=rk), allocatable :: dTgcm (:,:) real(kind=rk), allocatable :: dTgcp (:,:) integer :: i type( nurbs_surface ) :: surface Declare a NURBS surface object real(kind=rk) :: tol","tags":"","url":"program/fdm_test_surface.html"},{"title":"shape_tetragon – ForCAD","text":"Uses forcad program~~shape_tetragon~~UsesGraph program~shape_tetragon shape_tetragon module~forcad forcad program~shape_tetragon->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~shape_tetragon~~CallsGraph program~shape_tetragon shape_tetragon proc~create nurbs_surface%create program~shape_tetragon->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_tetragon->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_tetragon->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_tetragon->proc~finalize proc~set_tetragon nurbs_surface%set_tetragon program~shape_tetragon->proc~set_tetragon proc~show nurbs_surface%show program~shape_tetragon->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape Declare a NURBS surface object","tags":"","url":"program/shape_tetragon.html"},{"title":"example1_curve – ForCAD","text":"Uses forcad program~~example1_curve~~UsesGraph program~example1_curve example1_curve module~forcad forcad program~example1_curve->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Deallocate local arrays Export parameter space to a VTK file Export control points to a VTK file Generate the NURBS curve with a resolution of 20 Export the generated curve to a VTK file Export the NURBS curve to an IGES file Show the control geometry and geometry using PyVista Print size of the knot vector Insert knots 0.25, twice and 0.75, once Print size of the updated knot vector Print the degree of the curve Elevate the degree of the curve (2 times) Print the updated degree of the curve Print size of the knot vector Remove knots 0.25, twice and 0.75, once Print size of the updated knot vector Generate the refined curve with a resolution of 20 Export refined parameter space to a VTK file Export updated control points to a VTK file Export the refined generated curve to a VTK file Export the refined NURBS curve to an IGES file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export parameter space to a VTK file Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Export the transformed NURBS curve to an IGES file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example1_curve~~CallsGraph program~example1_curve example1_curve none~get_knot~2 nurbs_curve%get_knot program~example1_curve->none~get_knot~2 none~set~2 nurbs_curve%set program~example1_curve->none~set~2 proc~create~2 nurbs_curve%create program~example1_curve->proc~create~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~example1_curve->proc~elevate_degree~2 proc~export_iges~2 nurbs_curve%export_iges program~example1_curve->proc~export_iges~2 proc~export_xc~2 nurbs_curve%export_Xc program~example1_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~example1_curve->proc~export_xg~2 proc~export_xth~2 nurbs_curve%export_Xth program~example1_curve->proc~export_xth~2 proc~finalize~2 nurbs_curve%finalize program~example1_curve->proc~finalize~2 proc~get_degree nurbs_curve%get_degree program~example1_curve->proc~get_degree proc~insert_knots~2 nurbs_curve%insert_knots program~example1_curve->proc~insert_knots~2 proc~remove_knots~2 nurbs_curve%remove_knots program~example1_curve->proc~remove_knots~2 proc~rotate_xc~2 nurbs_curve%rotate_Xc program~example1_curve->proc~rotate_xc~2 proc~rotate_xg~2 nurbs_curve%rotate_Xg program~example1_curve->proc~rotate_xg~2 proc~show~2 nurbs_curve%show program~example1_curve->proc~show~2 proc~translate_xc~2 nurbs_curve%translate_Xc program~example1_curve->proc~translate_xc~2 proc~translate_xg~2 nurbs_curve%translate_Xg program~example1_curve->proc~translate_xg~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->proc~is_rational~2 append append proc~export_iges~2->append delete delete proc~export_iges~2->delete init init proc~export_iges~2->init makedpsections makedpsections proc~export_iges~2->makedpsections makegsection makegsection proc~export_iges~2->makegsection makessection makessection proc~export_iges~2->makessection proc~export_iges~2->proc~is_rational~2 writeigesfile writeigesfile proc~export_iges~2->writeigesfile proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set interface~ndgrid ndgrid proc~export_xth~2->interface~ndgrid interface~unique unique proc~export_xth~2->interface~unique proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~2->proc~export_vtk_legacy proc~insert_knots~2->none~set~2 interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~2->proc~is_rational~2 proc~remove_knots~2->none~set~2 proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->proc~findspan proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~2->proc~rotation proc~rotate_xg~2->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xth~2->interface~unique proc~cmp_elem_xth~2->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot (6) Array for knot vector type( nurbs_curve ) :: nurbs Declare a NURBS curve object Source Code program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth.vtk' ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !> Export the NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !> Export the refined NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !> Export the transformed NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","url":"program/example1_curve.html"},{"title":"nearest_point_3d – ForCAD","text":"Uses forcad program~~nearest_point_3d~~UsesGraph program~nearest_point_3d nearest_point_3d module~forcad forcad program~nearest_point_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. The weights of the control points (Wc) are optional. Generate the NURBS volume with resolutions of 20, 20, 20 Find the nearest point on the volume to a given point\nFind the nearest point on the volume to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS volume object Calls program~~nearest_point_3d~~CallsGraph program~nearest_point_3d nearest_point_3d none~set~3 nurbs_volume%set program~nearest_point_3d->none~set~3 proc~create~3 nurbs_volume%create program~nearest_point_3d->proc~create~3 proc~finalize~3 nurbs_volume%finalize program~nearest_point_3d->proc~finalize~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 program~nearest_point_3d->proc~nearest_point2~3 proc~nearest_point~3 nurbs_volume%nearest_point program~nearest_point_3d->proc~nearest_point~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->proc~finalize~3 proc~nearest_point2~3->proc~nearest_point~3 none~derivative2~3 nurbs_volume%derivative2 proc~nearest_point2~3->none~derivative2~3 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 proc~inv inv proc~nearest_point2~3->proc~inv proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 proc~cmp_xg~3->interface~compute_xg~3 proc~cmp_xg~3->proc~is_rational~3 proc~inv->proc~inv proc~det det proc~inv->proc~det proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_d2tgc_bspline_3d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (8) Weights of the control points real(kind=rk) :: Xc (8,3) Control points integer :: id id of the nearest point real(kind=rk) :: nearest_Xg (3) Coordinates of the nearest point on the volume real(kind=rk) :: nearest_Xt (3) Corresponding parametric coordinates of the nearest point type( nurbs_volume ) :: shape Declare a NURBS volume object","tags":"","url":"program/nearest_point_3d.html"},{"title":"lsq_fit_bspline_2d – ForCAD","text":"Uses forcad_utils forcad program~~lsq_fit_bspline_2d~~UsesGraph program~lsq_fit_bspline_2d lsq_fit_bspline_2d module~forcad forcad program~lsq_fit_bspline_2d->module~forcad module~forcad_utils forcad_utils program~lsq_fit_bspline_2d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~lsq_fit_bspline_2d~~CallsGraph program~lsq_fit_bspline_2d lsq_fit_bspline_2d interface~ndgrid ndgrid program~lsq_fit_bspline_2d->interface~ndgrid none~get_degree nurbs_surface%get_degree program~lsq_fit_bspline_2d->none~get_degree none~get_knot nurbs_surface%get_knot program~lsq_fit_bspline_2d->none~get_knot none~get_nc nurbs_surface%get_nc program~lsq_fit_bspline_2d->none~get_nc none~get_xg nurbs_surface%get_Xg program~lsq_fit_bspline_2d->none~get_xg none~set nurbs_surface%set program~lsq_fit_bspline_2d->none~set proc~create nurbs_surface%create program~lsq_fit_bspline_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~lsq_fit_bspline_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~lsq_fit_bspline_2d->proc~export_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~lsq_fit_bspline_2d->proc~export_xth_in_xg proc~get_continuity nurbs_surface%get_continuity program~lsq_fit_bspline_2d->proc~get_continuity proc~lsq_fit_bspline nurbs_surface%lsq_fit_bspline program~lsq_fit_bspline_2d->proc~lsq_fit_bspline proc~show nurbs_surface%show program~lsq_fit_bspline_2d->proc~show proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_nc_all nurbs_surface%get_nc_all none~get_nc->proc~get_nc_all proc~get_nc_dir nurbs_surface%get_nc_dir none~get_nc->proc~get_nc_dir proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~create->interface~ndgrid interface~compute_xg compute_Xg proc~create->interface~compute_xg proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth_in_xg->interface~compute_xg interface~unique unique proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg->proc~export_vtk_legacy proc~export_xth_in_xg->proc~is_rational proc~export_xth_in_xg->set interface~compute_multiplicity compute_multiplicity proc~get_continuity->interface~compute_multiplicity interface~kron kron proc~lsq_fit_bspline->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_bspline->proc~basis_bspline proc~solve solve proc~lsq_fit_bspline->proc~solve proc~lsq_fit_bspline->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~get_nc_dir->interface~compute_multiplicity proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_xg_bspline_2d->interface~kron proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xdata (:,:) real(kind=rk), allocatable :: Xg_eval (:,:) real(kind=rk), allocatable :: Xt (:,:) real(kind=rk), allocatable :: Xt1 (:) real(kind=rk), allocatable :: Xt2 (:) type( nurbs_surface ) :: bsp real(kind=rk) :: err1 real(kind=rk) :: err2 real(kind=rk) :: err3 integer :: i integer :: n (2) integer :: ndata real(kind=rk), parameter :: pi = acos(-1.0_rk) real(kind=rk) :: rms","tags":"","url":"program/lsq_fit_bspline_2d.html"},{"title":"fdm_test_volume – ForCAD","text":"Uses forcad program~~fdm_test_volume~~UsesGraph program~fdm_test_volume fdm_test_volume module~forcad forcad program~fdm_test_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate the NURBS volume with a resolution of 20 Finalize the NURBS volume object\nGenerate the NURBS volume with a resolution of 20 Finalize the NURBS volume object Calls program~~fdm_test_volume~~CallsGraph program~fdm_test_volume fdm_test_volume none~derivative2~3 nurbs_volume%derivative2 program~fdm_test_volume->none~derivative2~3 proc~create~3 nurbs_volume%create program~fdm_test_volume->proc~create~3 proc~finalize~3 nurbs_volume%finalize program~fdm_test_volume->proc~finalize~3 proc~set_hexahedron nurbs_volume%set_hexahedron program~fdm_test_volume->proc~set_hexahedron proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set none~set~3 nurbs_volume%set proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_3d_vector interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~compute_d2tgc_bspline_3d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->interface~kron proc~compute_d2tgc_bspline_3d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->interface~kron proc~compute_d2tgc_nurbs_3d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->interface~kron proc~compute_d2tgc_nurbs_3d_vector->interface~basis_bspline_2der proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: BFD (:,:) real(kind=rk), allocatable :: BFD2 (:,:) real(kind=rk), allocatable :: CFD (:,:) real(kind=rk), allocatable :: CFD2 (:,:) real(kind=rk), allocatable :: FFD (:,:) real(kind=rk), allocatable :: FFD2 (:,:) real(kind=rk), allocatable :: Tgc (:) real(kind=rk), allocatable :: Tgcm (:) real(kind=rk), allocatable :: Tgcp (:) real(kind=rk), allocatable :: Wc (:) Weights for the control points real(kind=rk) :: Xt (3) real(kind=rk) :: Xtm (3) real(kind=rk) :: Xtp (3) real(kind=rk), allocatable :: d2Tgc (:,:) real(kind=rk), allocatable :: d2Tgcm (:,:) real(kind=rk), allocatable :: d2Tgcp (:,:) real(kind=rk), allocatable :: dTgc (:,:) real(kind=rk), allocatable :: dTgcm (:,:) real(kind=rk), allocatable :: dTgcp (:,:) integer :: i real(kind=rk) :: tol type( nurbs_volume ) :: volume Declare a NURBS volume object","tags":"","url":"program/fdm_test_volume.html"},{"title":"example_nurbs_volume – ForCAD","text":"Uses forcad program~~example_nurbs_volume~~UsesGraph program~example_nurbs_volume example_nurbs_volume module~forcad forcad program~example_nurbs_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume.\nIt sets up control points and weights, generates the volume, and exports the control points\nand the volume to VTK files at various stages. Define control points for the NURBS volume Define weights for the control points Set control points and weights for the NURBS volume object Deallocate local arrays Elevate the degree of the NURBS volume in the first, second and third directions\nInsert knots into the NURBS volume in the first, second and third directions\nExport initial control points to a VTK file Generate the NURBS volume with a resolution of 15X15X15 Export the generated volume to a VTK file Export the parameter space to a VTK file Show the control geometry, geometry and parameters using PyVista Finalize the NURBS volume object Calls program~~example_nurbs_volume~~CallsGraph program~example_nurbs_volume example_nurbs_volume none~set~3 nurbs_volume%set program~example_nurbs_volume->none~set~3 proc~create~3 nurbs_volume%create program~example_nurbs_volume->proc~create~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~example_nurbs_volume->proc~elevate_degree~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_nurbs_volume->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_nurbs_volume->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_nurbs_volume->proc~export_xth_in_xg~2 proc~finalize~3 nurbs_volume%finalize program~example_nurbs_volume->proc~finalize~3 proc~generate_xc~2 generate_Xc program~example_nurbs_volume->proc~generate_xc~2 proc~insert_knots~3 nurbs_volume%insert_knots program~example_nurbs_volume->proc~insert_knots~3 proc~show~3 nurbs_volume%show program~example_nurbs_volume->proc~show~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~elevate_degree~3->none~set~3 none~get_knot~3 nurbs_volume%get_knot proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~insert_knots~3->none~get_knot~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc proc~insert_knots~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions pure function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !----------------------------------------------------------------------------- ! Refinement !----------------------------------------------------------------------------- !> Elevate the degree of the NURBS volume in the first, second and third directions call nurbs % elevate_degree ( 1 , 2 ) call nurbs % elevate_degree ( 2 , 2 ) call nurbs % elevate_degree ( 3 , 2 ) !> Insert knots into the NURBS volume in the first, second and third directions call nurbs % insert_knots ( 1 ,[ 0.5_rk ], [ 1 ]) call nurbs % insert_knots ( 2 ,[ 0.5_rk ], [ 1 ]) call nurbs % insert_knots ( 3 ,[ 0.5_rk ], [ 1 ]) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !> Export the parameter space to a VTK file call nurbs % export_Xth_in_Xg ( 'vtk/demo_volume_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry, geometry and parameters using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' , 'vtk/demo_volume_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- pure function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","url":"program/example_nurbs_volume.html"},{"title":"lsq_fit_nurbs_2d – ForCAD","text":"Uses forcad_utils forcad program~~lsq_fit_nurbs_2d~~UsesGraph program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d module~forcad forcad program~lsq_fit_nurbs_2d->module~forcad module~forcad_utils forcad_utils program~lsq_fit_nurbs_2d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~lsq_fit_nurbs_2d~~CallsGraph program~lsq_fit_nurbs_2d lsq_fit_nurbs_2d interface~ndgrid ndgrid program~lsq_fit_nurbs_2d->interface~ndgrid none~get_degree nurbs_surface%get_degree program~lsq_fit_nurbs_2d->none~get_degree none~get_knot nurbs_surface%get_knot program~lsq_fit_nurbs_2d->none~get_knot none~get_nc nurbs_surface%get_nc program~lsq_fit_nurbs_2d->none~get_nc none~get_xg nurbs_surface%get_Xg program~lsq_fit_nurbs_2d->none~get_xg none~set nurbs_surface%set program~lsq_fit_nurbs_2d->none~set proc~create nurbs_surface%create program~lsq_fit_nurbs_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~lsq_fit_nurbs_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~lsq_fit_nurbs_2d->proc~export_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~lsq_fit_nurbs_2d->proc~export_xth_in_xg proc~get_continuity nurbs_surface%get_continuity program~lsq_fit_nurbs_2d->proc~get_continuity proc~lsq_fit_nurbs nurbs_surface%lsq_fit_nurbs program~lsq_fit_nurbs_2d->proc~lsq_fit_nurbs proc~show nurbs_surface%show program~lsq_fit_nurbs_2d->proc~show proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_nc_all nurbs_surface%get_nc_all none~get_nc->proc~get_nc_all proc~get_nc_dir nurbs_surface%get_nc_dir none~get_nc->proc~get_nc_dir proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~create->interface~ndgrid interface~compute_xg compute_Xg proc~create->interface~compute_xg proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth_in_xg->interface~compute_xg interface~unique unique proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg->proc~export_vtk_legacy proc~export_xth_in_xg->proc~is_rational proc~export_xth_in_xg->set interface~compute_multiplicity compute_multiplicity proc~get_continuity->interface~compute_multiplicity interface~kron kron proc~lsq_fit_nurbs->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_nurbs->proc~basis_bspline proc~solve solve proc~lsq_fit_nurbs->proc~solve proc~lsq_fit_nurbs->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~get_nc_dir->interface~compute_multiplicity proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_xg_bspline_2d->interface~kron proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xdata (:,:) real(kind=rk), allocatable :: Xg_eval (:,:) real(kind=rk), allocatable :: Xt (:,:) real(kind=rk), allocatable :: Xt1 (:) real(kind=rk), allocatable :: Xt2 (:) real(kind=rk) :: err1 real(kind=rk) :: err2 real(kind=rk) :: err3 integer :: i integer :: n (2) integer :: ndata type( nurbs_surface ) :: nrb real(kind=rk), parameter :: pi = acos(-1.0_rk) real(kind=rk) :: rms","tags":"","url":"program/lsq_fit_nurbs_2d.html"},{"title":"shape_half_ring_2d – ForCAD","text":"Uses forcad program~~shape_half_ring_2d~~UsesGraph program~shape_half_ring_2d shape_half_ring_2d module~forcad forcad program~shape_half_ring_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_2d~~CallsGraph program~shape_half_ring_2d shape_half_ring_2d proc~create nurbs_surface%create program~shape_half_ring_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_half_ring_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_half_ring_2d->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_half_ring_2d->proc~finalize proc~set_half_ring nurbs_surface%set_half_ring program~shape_half_ring_2d->proc~set_half_ring proc~show nurbs_surface%show program~shape_half_ring_2d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set none~set nurbs_surface%set proc~set_half_ring->none~set proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","url":"program/shape_half_ring_2d.html"},{"title":"test_nurbs_curve – ForCAD","text":"Uses forunittest forcad_nurbs_curve forcad_kinds program~~test_nurbs_curve~~UsesGraph program~test_nurbs_curve test_nurbs_curve forunittest forunittest program~test_nurbs_curve->forunittest module~forcad_kinds forcad_kinds program~test_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve program~test_nurbs_curve->module~forcad_nurbs_curve module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_nurbs_curve~~CallsGraph program~test_nurbs_curve test_nurbs_curve check check program~test_nurbs_curve->check finalize finalize program~test_nurbs_curve->finalize initialize initialize program~test_nurbs_curve->initialize lsq_fit_bspline lsq_fit_bspline program~test_nurbs_curve->lsq_fit_bspline none~basis~2 nurbs_curve%basis program~test_nurbs_curve->none~basis~2 none~derivative2~2 nurbs_curve%derivative2 program~test_nurbs_curve->none~derivative2~2 none~derivative~2 nurbs_curve%derivative program~test_nurbs_curve->none~derivative~2 none~get_knot~2 nurbs_curve%get_knot program~test_nurbs_curve->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc program~test_nurbs_curve->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc program~test_nurbs_curve->none~get_xc~2 none~get_xg~2 nurbs_curve%get_Xg program~test_nurbs_curve->none~get_xg~2 none~set~2 nurbs_curve%set program~test_nurbs_curve->none~set~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 proc~cmp_elem~2 nurbs_curve%cmp_elem program~test_nurbs_curve->proc~cmp_elem~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_nc~2 nurbs_curve%cmp_nc program~test_nurbs_curve->proc~cmp_nc~2 proc~create~2 nurbs_curve%create program~test_nurbs_curve->proc~create~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~test_nurbs_curve->proc~elevate_degree~2 proc~export_iges~2 nurbs_curve%export_iges program~test_nurbs_curve->proc~export_iges~2 proc~export_xc~2 nurbs_curve%export_Xc program~test_nurbs_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~test_nurbs_curve->proc~export_xg~2 proc~export_xth~2 nurbs_curve%export_Xth program~test_nurbs_curve->proc~export_xth~2 proc~get_continuity~2 nurbs_curve%get_continuity program~test_nurbs_curve->proc~get_continuity~2 proc~get_degree nurbs_curve%get_degree program~test_nurbs_curve->proc~get_degree proc~get_elem_xc_vis~2 nurbs_curve%get_elem_Xc_vis program~test_nurbs_curve->proc~get_elem_xc_vis~2 proc~get_elem_xg_vis~2 nurbs_curve%get_elem_Xg_vis program~test_nurbs_curve->proc~get_elem_xg_vis~2 proc~get_elem~2 nurbs_curve%get_elem program~test_nurbs_curve->proc~get_elem~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity program~test_nurbs_curve->proc~get_multiplicity~2 proc~get_nc nurbs_curve%get_nc program~test_nurbs_curve->proc~get_nc proc~get_ng~2 nurbs_curve%get_ng program~test_nurbs_curve->proc~get_ng~2 proc~get_xt~2 nurbs_curve%get_Xt program~test_nurbs_curve->proc~get_xt~2 proc~insert_knots~2 nurbs_curve%insert_knots program~test_nurbs_curve->proc~insert_knots~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 program~test_nurbs_curve->proc~nearest_point2~2 proc~nearest_point~2 nurbs_curve%nearest_point program~test_nurbs_curve->proc~nearest_point~2 proc~remove_knots~2 nurbs_curve%remove_knots program~test_nurbs_curve->proc~remove_knots~2 proc~rotate_xc~2 nurbs_curve%rotate_Xc program~test_nurbs_curve->proc~rotate_xc~2 proc~rotate_xg~2 nurbs_curve%rotate_Xg program~test_nurbs_curve->proc~rotate_xg~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_elem_xc_vis~2 nurbs_curve%set_elem_Xc_vis program~test_nurbs_curve->proc~set_elem_xc_vis~2 proc~set_elem_xg_vis~2 nurbs_curve%set_elem_Xg_vis program~test_nurbs_curve->proc~set_elem_xg_vis~2 proc~set_elem~2 nurbs_curve%set_elem program~test_nurbs_curve->proc~set_elem~2 proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle proc~translate_xc~2 nurbs_curve%translate_Xc program~test_nurbs_curve->proc~translate_xc~2 proc~translate_xg~2 nurbs_curve%translate_Xg program~test_nurbs_curve->proc~translate_xg~2 summary summary program~test_nurbs_curve->summary xdata xdata program~test_nurbs_curve->xdata xg_eval xg_eval program~test_nurbs_curve->xg_eval xt_fit xt_fit program~test_nurbs_curve->xt_fit proc~basis_scalar~2 nurbs_curve%basis_scalar none~basis~2->proc~basis_scalar~2 proc~basis_vector~2 nurbs_curve%basis_vector none~basis~2->proc~basis_vector~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~get_xg_all~2 nurbs_curve%get_Xg_all none~get_xg~2->proc~get_xg_all~2 proc~get_xgid~2 nurbs_curve%get_Xgid none~get_xg~2->proc~get_xgid~2 proc~get_xgi~2 nurbs_curve%get_Xgi none~get_xg~2->proc~get_xgi~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem~2->proc~get_multiplicity~2 interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn interface~unique unique proc~cmp_elem~2->interface~unique proc~cmp_length->proc~cmp_elem~2 proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length->proc~ansatz~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->proc~is_rational~2 append append proc~export_iges~2->append delete delete proc~export_iges~2->delete init init proc~export_iges~2->init makedpsections makedpsections proc~export_iges~2->makedpsections makegsection makegsection proc~export_iges~2->makegsection makessection makessection proc~export_iges~2->makessection proc~export_iges~2->proc~is_rational~2 writeigesfile writeigesfile proc~export_iges~2->writeigesfile proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set interface~ndgrid ndgrid proc~export_xth~2->interface~ndgrid proc~export_xth~2->interface~unique proc~cmp_elem_xth~2 nurbs_curve%cmp_elem_Xth proc~export_xth~2->proc~cmp_elem_xth~2 proc~export_xth~2->proc~export_vtk_legacy proc~get_continuity~2->interface~compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~insert_knots~2->none~set~2 proc~insert_knots~2->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~2->proc~is_rational~2 proc~modify_wc~2->none~get_knot~2 proc~modify_wc~2->none~get_wc~2 proc~modify_wc~2->none~get_xc~2 proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~get_knot~2 proc~modify_xc~2->none~get_wc~2 proc~modify_xc~2->none~get_xc~2 proc~modify_xc~2->none~set~2 proc~nearest_point2~2->none~derivative2~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->proc~nearest_point~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 proc~finalize~2 nurbs_curve%finalize proc~nearest_point2~2->proc~finalize~2 proc~remove_knots~2->none~set~2 proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->proc~findspan proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~2->proc~rotation proc~rotate_xg~2->proc~rotation proc~set_circle->none~set~2 proc~set_half_circle->none~set~2 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~ansatz~2->none~derivative~2 proc~ansatz~2->none~set~2 proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->interface~unique interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg proc~basis_scalar~2->proc~is_rational~2 interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2->proc~is_rational~2 proc~basis_vector~2->interface~compute_tgc~2 proc~cmp_elem_xth~2->interface~elemconn_c0 proc~cmp_elem_xth~2->interface~unique proc~cmp_xg~2->interface~compute_xg~2 proc~cmp_xg~2->proc~is_rational~2 proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~derivative_scalar~2->proc~is_rational~2 interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->proc~cmp_nc~2 proc~set2~2->set proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid interface~kron kron proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer, parameter :: NTESTS = 113 real(kind=rk), parameter :: PI = acos(-1.0_rk) real(kind=rk), parameter :: TOL = 1.0e-5_rk real(kind=rk), allocatable :: Tgc (:,:) real(kind=rk), allocatable :: Tgc1 (:) real(kind=rk), allocatable :: Tgc1b (:) real(kind=rk), allocatable :: Tgcb (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xg (:,:) real(kind=rk), allocatable :: Xgb (:,:) real(kind=rk), allocatable :: Xt (:) type( nurbs_curve ) :: bsp real(kind=rk), allocatable :: d2Tgc (:,:) real(kind=rk), allocatable :: d2Tgc1 (:) real(kind=rk), allocatable :: d2Tgc1b (:) real(kind=rk), allocatable :: d2Tgcb (:,:) real(kind=rk), allocatable :: dTgc (:,:) real(kind=rk), allocatable :: dTgc1 (:) real(kind=rk), allocatable :: dTgc1b (:) real(kind=rk), allocatable :: dTgcb (:,:) integer, allocatable :: elemConn (:,:) character(len=*), parameter :: fIgs_bsp = 'iges/test_bsp_curve.iges' character(len=*), parameter :: fIgs_nurbs = 'iges/test_nurbs_curve.iges' character(len=*), parameter :: fXc_bsp = 'vtk/test_bsp_curve_Xc.vtk' character(len=*), parameter :: fXc_nurbs = 'vtk/test_nurbs_curve_Xc.vtk' character(len=*), parameter :: fXg_bsp = 'vtk/test_bsp_curve_Xg.vtk' character(len=*), parameter :: fXg_nurbs = 'vtk/test_nurbs_curve_Xg.vtk' character(len=*), parameter :: fXth_bsp = 'vtk/test_bsp_curve_Xth.vtk' character(len=*), parameter :: fXth_nurbs = 'vtk/test_nurbs_curve_Xth.vtk' integer :: i integer :: id real(kind=rk) :: knot (6) real(kind=rk) :: length real(kind=rk) :: lengthb real(kind=rk) :: nearest_Xg (3) real(kind=rk) :: nearest_Xt type( nurbs_curve ) :: nurbs logical :: okIges_bsp logical :: okIges_nurbs logical :: okXc_bsp logical :: okXc_nurbs logical :: okXg_bsp logical :: okXg_nurbs logical :: okXth_bsp logical :: okXth_nurbs integer :: ti type(unit_tests) :: ut Source Code program test_nurbs_curve use forcad_kinds , only : rk use forcad_nurbs_curve , only : nurbs_curve , compute_Tgc , compute_dTgc use forunittest , only : unit_tests implicit none integer , parameter :: NTESTS = 113 type ( unit_tests ) :: ut real ( rk ), parameter :: TOL = 1.0e-5_rk real ( rk ), parameter :: PI = acos ( - 1.0_rk ) type ( nurbs_curve ) :: nurbs , bsp real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xg (:,:), Xgb (:,:) real ( rk ) :: knot ( 6 ) integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Tgc (:,:), dTgc (:,:), Tgcb (:,:), dTgcb (:,:), d2Tgc (:,:), d2Tgcb (:,:) real ( rk ), allocatable :: Tgc1 (:), dTgc1 (:), Tgc1b (:), dTgc1b (:), d2Tgc1 (:), d2Tgc1b (:) real ( rk ) :: nearest_Xg ( 3 ), nearest_Xt , length , lengthb integer :: i , id , ti real ( rk ), allocatable :: Xt (:) character ( len =* ), parameter :: fXc_nurbs = 'vtk/test_nurbs_curve_Xc.vtk' character ( len =* ), parameter :: fXg_nurbs = 'vtk/test_nurbs_curve_Xg.vtk' character ( len =* ), parameter :: fXth_nurbs = 'vtk/test_nurbs_curve_Xth.vtk' character ( len =* ), parameter :: fIgs_nurbs = 'iges/test_nurbs_curve.iges' character ( len =* ), parameter :: fXc_bsp = 'vtk/test_bsp_curve_Xc.vtk' character ( len =* ), parameter :: fXg_bsp = 'vtk/test_bsp_curve_Xg.vtk' character ( len =* ), parameter :: fXth_bsp = 'vtk/test_bsp_curve_Xth.vtk' character ( len =* ), parameter :: fIgs_bsp = 'iges/test_bsp_curve.iges' logical :: okXc_nurbs , okXg_nurbs , okXth_nurbs , okIges_nurbs logical :: okXc_bsp , okXg_bsp , okXth_bsp , okIges_bsp call ut % initialize ( NTESTS ) ti = 1 ! Initialize curve data allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 0.9_rk , 0.8_rk ] knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! 1) Set and create NURBS and B-spline curves call nurbs % set ( knot , Xc , Wc ) call bsp % set ( knot , Xc ) call nurbs % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc (), Wc = nurbs % get_Wc ()) call bsp % set ( degree = bsp % get_degree (), nc = bsp % get_nc (), Xc = bsp % get_Xc ()) call nurbs % create ( res = 23 ) call bsp % create ( res = 23 ) call ut % test ( ti )% check ( & name = \"set(): degree==2\" , & res = nurbs % get_degree (), & expected = 2 , & msg = \"NURBS degree not 2\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): degree==2 (B-spline)\" , & res = bsp % get_degree (), & expected = 2 , & msg = \"B-spline degree not 2\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): nc==3\" , & res = nurbs % get_nc (), & expected = 3 , & msg = \"NURBS nc not 3\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): nc==3 (B-spline)\" , & res = bsp % get_nc (), & expected = 3 , & msg = \"B-spline nc not 3\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): knot matches\" , & res = nurbs % get_knot (), & expected = knot , & tol = TOL , & msg = \"NURBS knot vector mismatch\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): knot matches (B-spline)\" , & res = bsp % get_knot (), & expected = knot , & tol = TOL , & msg = \"B-spline knot vector mismatch\" , & group = \"setup\" ); ti = ti + 1 ! 2) Export tests call nurbs % export_Xc ( fXc_nurbs ) call bsp % export_Xc ( fXc_bsp ) call nurbs % export_Xg ( fXg_nurbs ) call bsp % export_Xg ( fXg_bsp ) call nurbs % export_Xth ( fXth_nurbs ) call bsp % export_Xth ( fXth_bsp ) call nurbs % export_iges ( fIgs_nurbs ) call bsp % export_iges ( fIgs_bsp ) inquire ( file = fXc_nurbs , exist = okXc_nurbs ) inquire ( file = fXg_nurbs , exist = okXg_nurbs ) inquire ( file = fXth_nurbs , exist = okXth_nurbs ) inquire ( file = fIgs_nurbs , exist = okIges_nurbs ) inquire ( file = fXc_bsp , exist = okXc_bsp ) inquire ( file = fXg_bsp , exist = okXg_bsp ) inquire ( file = fXth_bsp , exist = okXth_bsp ) inquire ( file = fIgs_bsp , exist = okIges_bsp ) call ut % test ( ti )% check ( & name = \"export_Xc/Xg/Xth/IGES(): files exist (NURBS)\" , & res = merge ( 1 , 0 , okXc_nurbs . and . okXg_nurbs . and . okXth_nurbs . and . okIges_nurbs ), & expected = 1 , & msg = \"NURBS export did not create all files\" , & group = \"io\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"export_Xc/Xg/Xth/IGES(): files exist (B-spline)\" , & res = merge ( 1 , 0 , okXc_bsp . and . okXg_bsp . and . okXth_bsp . and . okIges_bsp ), & expected = 1 , & msg = \"B-spline export did not create all files\" , & group = \"io\" ); ti = ti + 1 ! 3) Length tests call nurbs % cmp_length ( length ) call bsp % cmp_length ( lengthb ) call ut % test ( ti )% check ( & name = \"cmp_length(): length == 2 (NURBS)\" , & res = length , & expected = 2.0_rk , & tol = TOL , & msg = \"NURBS arc length incorrect\" , & group = \"geometry\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"cmp_length(): length == 2 (B-spline)\" , & res = lengthb , & expected = 2.0_rk , & tol = TOL , & msg = \"B-spline arc length incorrect\" , & group = \"geometry\" ); ti = ti + 1 ! 4) Nearest point tests call nurbs % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"nearest_point(): point matches [0,0,0] (NURBS)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"NURBS nearest point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): param == 0 (NURBS)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS nearest param incorrect\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): id == 1 (NURBS)\" , & res = id , & expected = 1 , & msg = \"NURBS nearest id incorrect\" , & group = \"nearest\" ); ti = ti + 1 call bsp % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"nearest_point(): point matches [0,0,0] (B-spline)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"B-spline nearest point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): param == 0 (B-spline)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline nearest param incorrect\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): id == 1 (B-spline)\" , & res = id , & expected = 1 , & msg = \"B-spline nearest id incorrect\" , & group = \"nearest\" ); ti = ti + 1 call nurbs % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1.0e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % test ( ti )% check ( & name = \"nearest_point2(): point matches [0,0,0] (NURBS)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"NURBS nearest_point2 point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point2(): param == 0 (NURBS)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS nearest_point2 param incorrect\" , & group = \"nearest\" ); ti = ti + 1 call bsp % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1.0e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % test ( ti )% check ( & name = \"nearest_point2(): point matches [0,0,0] (B-spline)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"B-spline nearest_point2 point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point2(): param == 0 (B-spline)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline nearest_point2 param incorrect\" , & group = \"nearest\" ); ti = ti + 1 ! 5) Store initial geometry Xg = nurbs % get_Xg () Xgb = bsp % get_Xg () ! 6) Set with Xth_dir and continuity call nurbs % set ([ 0.0_rk , 1.0_rk ], 2 , [ - 1 , - 1 ], Xc , Wc ) call bsp % set ([ 0.0_rk , 1.0_rk ], 2 , [ - 1 , - 1 ], Xc ) call nurbs % create ( res = 23 ) call bsp % create ( res = 23 ) call ut % test ( ti )% check ( & name = \"set(Xth_dir): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after set(Xth_dir)\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(Xth_dir): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after set(Xth_dir)\" , & group = \"setup\" ); ti = ti + 1 ! 7) Set with Xc and Wc call nurbs % set ( Xc , Wc ) call bsp % set ( Xc ) call nurbs % create ( res = 23 ) call bsp % create ( res = 23 ) call ut % test ( ti )% check ( & name = \"set(Xc,Wc): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after set(Xc,Wc)\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(Xc): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after set(Xc)\" , & group = \"setup\" ); ti = ti + 1 ! 8) Create with explicit Xt call nurbs % create ( Xt = nurbs % get_Xt ()) call bsp % create ( Xt = bsp % get_Xt ()) call ut % test ( ti )% check ( & name = \"create(Xt): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after create(Xt)\" , & group = \"sampling\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"create(Xt): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after create(Xt)\" , & group = \"sampling\" ); ti = ti + 1 ! 9) Export after create(Xt) call nurbs % export_Xc ( fXc_nurbs ) call bsp % export_Xc ( fXc_bsp ) call nurbs % export_Xg ( fXg_nurbs ) call bsp % export_Xg ( fXg_bsp ) call nurbs % export_Xth ( fXth_nurbs ) call bsp % export_Xth ( fXth_bsp ) call nurbs % export_iges ( fIgs_nurbs ) call bsp % export_iges ( fIgs_bsp ) inquire ( file = fXc_nurbs , exist = okXc_nurbs ) inquire ( file = fXg_nurbs , exist = okXg_nurbs ) inquire ( file = fXth_nurbs , exist = okXth_nurbs ) inquire ( file = fIgs_nurbs , exist = okIges_nurbs ) inquire ( file = fXc_bsp , exist = okXc_bsp ) inquire ( file = fXg_bsp , exist = okXg_bsp ) inquire ( file = fXth_bsp , exist = okXth_bsp ) inquire ( file = fIgs_bsp , exist = okIges_bsp ) call ut % test ( ti )% check ( & name = \"export after create(Xt): files exist (NURBS)\" , & res = merge ( 1 , 0 , okXc_nurbs . and . okXg_nurbs . and . okXth_nurbs . and . okIges_nurbs ), & expected = 1 , & msg = \"NURBS export after create(Xt) did not create all files\" , & group = \"io\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"export after create(Xt): files exist (B-spline)\" , & res = merge ( 1 , 0 , okXc_bsp . and . okXg_bsp . and . okXth_bsp . and . okIges_bsp ), & expected = 1 , & msg = \"B-spline export after create(Xt) did not create all files\" , & group = \"io\" ); ti = ti + 1 ! 10) Getter tests call ut % test ( ti )% check ( & name = \"get_Xc(): matches input (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(): matches input (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1): matches input (NURBS)\" , & res = nurbs % get_Xc ( 1 ), & expected = Xc ( 1 ,:), & tol = TOL , & msg = \"NURBS Xc(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1): matches input (B-spline)\" , & res = bsp % get_Xc ( 1 ), & expected = Xc ( 1 ,:), & tol = TOL , & msg = \"B-spline Xc(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1,1): matches input (NURBS)\" , & res = nurbs % get_Xc ( 1 , 1 ), & expected = Xc ( 1 , 1 ), & tol = TOL , & msg = \"NURBS Xc(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1,1): matches input (B-spline)\" , & res = bsp % get_Xc ( 1 , 1 ), & expected = Xc ( 1 , 1 ), & tol = TOL , & msg = \"B-spline Xc(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(): matches initial (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(): matches initial (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1): matches initial (NURBS)\" , & res = nurbs % get_Xg ( 1 ), & expected = Xg ( 1 ,:), & tol = TOL , & msg = \"NURBS Xg(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1): matches initial (B-spline)\" , & res = bsp % get_Xg ( 1 ), & expected = Xgb ( 1 ,:), & tol = TOL , & msg = \"B-spline Xg(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1,1): matches initial (NURBS)\" , & res = nurbs % get_Xg ( 1 , 1 ), & expected = Xg ( 1 , 1 ), & tol = TOL , & msg = \"NURBS Xg(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1,1): matches initial (B-spline)\" , & res = bsp % get_Xg ( 1 , 1 ), & expected = Xgb ( 1 , 1 ), & tol = TOL , & msg = \"B-spline Xg(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Wc(): matches input (NURBS)\" , & res = nurbs % get_Wc (), & expected = Wc , & tol = TOL , & msg = \"NURBS Wc mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Wc(1): matches input (NURBS)\" , & res = nurbs % get_Wc ( 1 ), & expected = Wc ( 1 ), & tol = TOL , & msg = \"NURBS Wc(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(): matches input (NURBS)\" , & res = nurbs % get_knot (), & expected = knot , & tol = TOL , & msg = \"NURBS knot mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(): matches input (B-spline)\" , & res = bsp % get_knot (), & expected = knot , & tol = TOL , & msg = \"B-spline knot mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(1): matches input (NURBS)\" , & res = nurbs % get_knot ( 1 ), & expected = knot ( 1 ), & tol = TOL , & msg = \"NURBS knot(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(1): matches input (B-spline)\" , & res = bsp % get_knot ( 1 ), & expected = knot ( 1 ), & tol = TOL , & msg = \"B-spline knot(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_ng(): matches Xg size (NURBS)\" , & res = nurbs % get_ng (), & expected = size ( Xg , 1 ), & msg = \"NURBS ng mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_ng(): matches Xgb size (B-spline)\" , & res = bsp % get_ng (), & expected = size ( Xgb , 1 ), & msg = \"B-spline ng mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_degree(): matches 2 (NURBS)\" , & res = nurbs % get_degree (), & expected = 2 , & msg = \"NURBS degree not 2\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_degree(): matches 2 (B-spline)\" , & res = bsp % get_degree (), & expected = 2 , & msg = \"B-spline degree not 2\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_multiplicity(): matches [3,3] (NURBS)\" , & res = nurbs % get_multiplicity (), & expected = [ 3 , 3 ], & msg = \"NURBS multiplicity not [3,3]\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_multiplicity(): matches [3,3] (B-spline)\" , & res = bsp % get_multiplicity (), & expected = [ 3 , 3 ], & msg = \"B-spline multiplicity not [3,3]\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_continuity(): matches [-1,-1] (NURBS)\" , & res = nurbs % get_continuity (), & expected = [ - 1 , - 1 ], & msg = \"NURBS continuity not [-1,-1]\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_continuity(): matches [-1,-1] (B-spline)\" , & res = bsp % get_continuity (), & expected = [ - 1 , - 1 ], & msg = \"B-spline continuity not [-1,-1]\" , & group = \"knot-ops\" ); ti = ti + 1 call nurbs % cmp_nc () call bsp % cmp_nc () call ut % test ( ti )% check ( & name = \"cmp_nc(): matches nc (NURBS)\" , & res = nurbs % get_nc (), & expected = size ( Xc , 1 ), & msg = \"NURBS cmp_nc mismatch\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"cmp_nc(): matches nc (B-spline)\" , & res = bsp % get_nc (), & expected = size ( Xc , 1 ), & msg = \"B-spline cmp_nc mismatch\" , & group = \"knot-ops\" ); ti = ti + 1 ! 11) Element connectivity tests elemConn = nurbs % cmp_elem_Xc_vis ( 2 ) call nurbs % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(p=2): equality (NURBS)\" , & res = nurbs % get_elem_Xc_vis (), & expected = elemConn , & msg = \"NURBS elem_Xc_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xc_vis () call nurbs % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(): equality (NURBS)\" , & res = nurbs % get_elem_Xc_vis (), & expected = elemConn , & msg = \"NURBS elem_Xc_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis ( 2 ) call bsp % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(p=2): equality (B-spline)\" , & res = bsp % get_elem_Xc_vis (), & expected = elemConn , & msg = \"B-spline elem_Xc_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis () call bsp % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(): equality (B-spline)\" , & res = bsp % get_elem_Xc_vis (), & expected = elemConn , & msg = \"B-spline elem_Xc_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis ( 2 ) call nurbs % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(p=2): equality (NURBS)\" , & res = nurbs % get_elem_Xg_vis (), & expected = elemConn , & msg = \"NURBS elem_Xg_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis () call nurbs % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(): equality (NURBS)\" , & res = nurbs % get_elem_Xg_vis (), & expected = elemConn , & msg = \"NURBS elem_Xg_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis ( 2 ) call bsp % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(p=2): equality (B-spline)\" , & res = bsp % get_elem_Xg_vis (), & expected = elemConn , & msg = \"B-spline elem_Xg_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis () call bsp % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(): equality (B-spline)\" , & res = bsp % get_elem_Xg_vis (), & expected = elemConn , & msg = \"B-spline elem_Xg_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem () call nurbs % set_elem ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem: equality (NURBS)\" , & res = nurbs % get_elem (), & expected = elemConn , & msg = \"NURBS elem mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem () call bsp % set_elem ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem: equality (B-spline)\" , & res = bsp % get_elem (), & expected = elemConn , & msg = \"B-spline elem mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) ! 12) Modify and export call nurbs % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call bsp % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call nurbs % modify_Wc ( Wc ( 1 ), 1 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( fXc_nurbs ) call bsp % export_Xc ( fXc_bsp ) call nurbs % export_Xg ( fXg_nurbs ) call bsp % export_Xg ( fXg_bsp ) call ut % test ( ti )% check ( & name = \"modify_Xc/Wc: geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after modify_Xc/Wc\" , & group = \"modify\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"modify_Xc: geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after modify_Xc\" , & group = \"modify\" ); ti = ti + 1 ! 13) Basis and derivative tests call nurbs % basis ( res = 23 , Tgc = Tgc ) call bsp % basis ( res = 23 , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"basis(res=23): sum(N)=1 rows (NURBS)\" , & res = all ( abs ( sum ( Tgc , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"NURBS basis partition of unity violated\" , & group = \"basis\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"basis(res=23): sum(N)=1 rows (B-spline)\" , & res = all ( abs ( sum ( Tgcb , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"B-spline basis partition of unity violated\" , & group = \"basis\" ); ti = ti + 1 call nurbs % basis ( Xt = 0.0_rk , Tgc = Tgc1 ) call bsp % basis ( Xt = 0.0_rk , Tgc = Tgc1b ) call ut % test ( ti )% check ( & name = \"basis(Xt=0): sum(N)=1 (NURBS)\" , & res = sum ( Tgc1 ), & expected = 1.0_rk , & tol = TOL , & msg = \"NURBS basis sum not 1 at t=0\" , & group = \"basis\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"basis(Xt=0): sum(N)=1 (B-spline)\" , & res = sum ( Tgc1b ), & expected = 1.0_rk , & tol = TOL , & msg = \"B-spline basis sum not 1 at t=0\" , & group = \"basis\" ); ti = ti + 1 allocate ( Xt ( 23 )) do i = 1 , 23 Xt ( i ) = real ( i - 1 , rk ) / real ( 23 - 1 , rk ) end do call nurbs % basis ( Xt = Xt , Tgc = Tgc ) call bsp % basis ( Xt = Xt , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"basis(Xt vector): sum(N)=1 rows (NURBS)\" , & res = all ( abs ( sum ( Tgc , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"NURBS basis partition of unity violated (vector)\" , & group = \"basis\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"basis(Xt vector): sum(N)=1 rows (B-spline)\" , & res = all ( abs ( sum ( Tgcb , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"B-spline basis partition of unity violated (vector)\" , & group = \"basis\" ); ti = ti + 1 call nurbs % derivative ( res = 23 , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( res = 23 , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative(res=23): sum(dN)=0 rows (NURBS)\" , & res = all ( abs ( sum ( dTgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(res=23): sum(dN)=0 rows (B-spline)\" , & res = all ( abs ( sum ( dTgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative ( Xt = Xt , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( Xt = Xt , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative(Xt vector): sum(dN)=0 rows (NURBS)\" , & res = all ( abs ( sum ( dTgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(Xt vector): sum(dN)=0 rows (B-spline)\" , & res = all ( abs ( sum ( dTgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative ( Xt = 0.0_rk , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative ( Xt = 0.0_rk , dTgc = dTgc1b , Tgc = Tgc1b ) call ut % test ( ti )% check ( & name = \"derivative(Xt=0): sum(dN)=0 (NURBS)\" , & res = sum ( dTgc1 ), & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(Xt=0): sum(dN)=0 (B-spline)\" , & res = sum ( dTgc1b ), & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative ( Xt = 0.0_rk , dTgc = dTgc1 , Tgc = Tgc1 , elem = [ 1 , 2 , 3 ]) call bsp % derivative ( Xt = 0.0_rk , dTgc = dTgc1b , Tgc = Tgc1b , elem = [ 1 , 2 , 3 ]) call ut % test ( ti )% check ( & name = \"derivative(Xt=0, elem): sum(dN)=0 (NURBS)\" , & res = sum ( dTgc1 ), & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS derivative sum not zero (elem)\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(Xt=0, elem): sum(dN)=0 (B-spline)\" , & res = sum ( dTgc1b ), & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline derivative sum not zero (elem)\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative2 ( res = 23 , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( res = 23 , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative2(res=23): sum(d2N)=0 rows (NURBS)\" , & res = all ( abs ( sum ( d2Tgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS second derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative2(res=23): sum(d2N)=0 rows (B-spline)\" , & res = all ( abs ( sum ( d2Tgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline second derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( Xt = Xt , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative2(Xt vector): sum(d2N)=0 rows (NURBS)\" , & res = all ( abs ( sum ( d2Tgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS second derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative2(Xt vector): sum(d2N)=0 rows (B-spline)\" , & res = all ( abs ( sum ( d2Tgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline second derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call ut % test ( ti )% check ( & name = \"derivative2(Xt=0): sum(d2N)=0 (NURBS)\" , & res = sum ( d2Tgc1 ), & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS second derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative2(Xt=0): sum(d2N)=0 (B-spline)\" , & res = sum ( d2Tgc1b ), & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline second derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 ! 14) Rotation tests (Xc) call nurbs % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xc(X-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xc(X-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xc(Y-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xc(Y-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xc(Z-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xc(Z-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 ! 15) Rotation tests (Xg) call nurbs % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xg(X-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xg(X-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xg(Y-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xg(Y-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xg(Z-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xg(Z-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 ! 16) Translation tests (Xc) call nurbs % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % test ( ti )% check ( & name = \"translate_Xc(): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after translation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"translate_Xc(): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after translation\" , & group = \"transform\" ); ti = ti + 1 ! 17) Translation tests (Xg) call nurbs % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % test ( ti )% check ( & name = \"translate_Xg(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after translation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"translate_Xg(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after translation\" , & group = \"transform\" ); ti = ti + 1 ! 18) Knot insertion call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call ut % test ( ti )% check ( & name = \"insert_knots(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after knot insertion\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"insert_knots(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after knot insertion\" , & group = \"knot-ops\" ); ti = ti + 1 ! 19) Degree elevation call nurbs % elevate_degree ( 2 ) call bsp % elevate_degree ( 2 ) call nurbs % create () call bsp % create () call ut % test ( ti )% check ( & name = \"elevate_degree(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after degree elevation\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"elevate_degree(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after degree elevation\" , & group = \"knot-ops\" ); ti = ti + 1 ! 20) Knot removal call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call ut % test ( ti )% check ( & name = \"remove_knots(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after knot removal\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"remove_knots(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after knot removal\" , & group = \"knot-ops\" ); ti = ti + 1 ! 21) Shape functions (circle, half-circle) call nurbs % set_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) call nurbs % create ( res = 23 ) call nurbs % nearest_point ([ 1.0_rk , 0.0_rk , 0.0_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"set_circle(): nearest point param (NURBS)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS circle nearest point param incorrect\" , & group = \"shapes\" ); ti = ti + 1 call nurbs % set_half_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) call nurbs % create ( res = 23 ) call nurbs % nearest_point ([ 0.0_rk , 1.0_rk , 0.0_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"set_half_circle(): nearest point param (NURBS)\" , & res = nearest_Xt , & expected = 0.5_rk , & tol = TOL , & msg = \"NURBS half-circle nearest point param incorrect\" , & group = \"shapes\" ); ti = ti + 1 ! 22) Least-squares B-spline fitting block type ( nurbs_curve ) :: bsp_fit integer :: n real ( rk ), allocatable :: Xt_fit (:), Xdata (:,:), Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = 42 allocate ( Xt_fit ( n ), Xdata ( n , 3 )) do i = 1 , n Xt_fit ( i ) = real ( i - 1 , rk ) / real ( n - 1 , rk ) Xdata ( i , 1 ) = Xt_fit ( i ) Xdata ( i , 2 ) = 0.3_rk * sin ( 4.0_rk * PI * Xt_fit ( i )) Xdata ( i , 3 ) = 0.3_rk * cos ( 4.0_rk * PI * Xt_fit ( i )) end do call bsp_fit % set ( & degree = 5 , & Xth_dir = [( real ( i - 1 , rk ) / 1 0.0_rk , i = 1 , 11 )], & continuity = [ - 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , - 1 ]) call bsp_fit % lsq_fit_bspline ( Xt_fit , Xdata , n ) call bsp_fit % create ( res = n ) Xg_eval = bsp_fit % get_Xg () err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / norm2 ( Xdata (:, 1 )) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / norm2 ( Xdata (:, 2 )) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / norm2 ( Xdata (:, 3 )) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) call ut % test ( ti )% check ( & name = \"lsq_fit_bspline(): RMS error\" , & res = rms , & expected = 0.0_rk , & tol = 1.0e-6_rk , & msg = \"B-spline least-squares fit RMS error too high\" , & group = \"basis\" ); ti = ti + 1 call bsp_fit % finalize () deallocate ( Xt_fit , Xdata , Xg_eval ) end block ! Finalize call nurbs % finalize () call bsp % finalize () deallocate ( Xc , Wc , Xg , Xgb , Xt ) if ( allocated ( Tgc )) deallocate ( Tgc ) if ( allocated ( Tgcb )) deallocate ( Tgcb ) if ( allocated ( dTgc )) deallocate ( dTgc ) if ( allocated ( dTgcb )) deallocate ( dTgcb ) if ( allocated ( d2Tgc )) deallocate ( d2Tgc ) if ( allocated ( d2Tgcb )) deallocate ( d2Tgcb ) if ( allocated ( Tgc1 )) deallocate ( Tgc1 ) if ( allocated ( Tgc1b )) deallocate ( Tgc1b ) if ( allocated ( dTgc1 )) deallocate ( dTgc1 ) if ( allocated ( dTgc1b )) deallocate ( dTgc1b ) if ( allocated ( d2Tgc1 )) deallocate ( d2Tgc1 ) if ( allocated ( d2Tgc1b )) deallocate ( d2Tgc1b ) call ut % summary ( verbose = 3 , required_score = 10 0.0 ) end program test_nurbs_curve","tags":"","url":"program/test_nurbs_curve.html"},{"title":"example_plate_hole_2_3d – ForCAD","text":"Uses forcad program~~example_plate_hole_2_3d~~UsesGraph program~example_plate_hole_2_3d example_plate_hole_2_3d module~forcad forcad program~example_plate_hole_2_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example_plate_hole_2_3d~~CallsGraph program~example_plate_hole_2_3d example_plate_hole_2_3d none~set~3 nurbs_volume%set program~example_plate_hole_2_3d->none~set~3 proc~create~3 nurbs_volume%create program~example_plate_hole_2_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_plate_hole_2_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_plate_hole_2_3d->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_plate_hole_2_3d->proc~export_xth_in_xg~2 proc~set_xc_wc~3 set_Xc_Wc program~example_plate_hole_2_3d->proc~set_xc_wc~3 proc~show~3 nurbs_volume%show program~example_plate_hole_2_3d->proc~show~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set cosd cosd proc~set_xc_wc~3->cosd tand tand proc~set_xc_wc~3->tand proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), parameter :: height = 5.0_rk real(kind=rk), parameter :: length = 5.0_rk type( nurbs_volume ) :: plate_hole real(kind=rk), parameter :: radius1 = 2.5_rk real(kind=rk), parameter :: radius2 = 3.5_rk real(kind=rk), parameter :: width = 0.5_rk Subroutines pure subroutine set_Xc_Wc (tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:)","tags":"","url":"program/example_plate_hole_2_3d.html"},{"title":"nearest_point_2d_bench – ForCAD","text":"Uses fortime forcad program~~nearest_point_2d_bench~~UsesGraph program~nearest_point_2d_bench nearest_point_2d_bench fortime fortime program~nearest_point_2d_bench->fortime module~forcad forcad program~nearest_point_2d_bench->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFinalize the NURBS surface object Calls program~~nearest_point_2d_bench~~CallsGraph program~nearest_point_2d_bench nearest_point_2d_bench proc~create nurbs_surface%create program~nearest_point_2d_bench->proc~create proc~finalize nurbs_surface%finalize program~nearest_point_2d_bench->proc~finalize proc~nearest_point nurbs_surface%nearest_point program~nearest_point_2d_bench->proc~nearest_point proc~set_tetragon nurbs_surface%set_tetragon program~nearest_point_2d_bench->proc~set_tetragon timer_start timer_start program~nearest_point_2d_bench->timer_start timer_stop timer_stop program~nearest_point_2d_bench->timer_stop interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: i integer :: id id of the nearest point integer :: j real(kind=rk) :: nearest_Xg (3) Coordinates of the nearest point on the surface real(kind=rk) :: nearest_Xt (2) Corresponding parametric coordinates of the nearest point real(kind=rk), allocatable :: points (:,:) real(kind=rk) :: pointsi (3) type( nurbs_surface ) :: shape Declare a NURBS surface object type(timer) :: t","tags":"","url":"program/nearest_point_2d_bench.html"},{"title":"poisson_iga_solver_3d – ForCAD","text":"Uses forcad_utils fortime forcad program~~poisson_iga_solver_3d~~UsesGraph program~poisson_iga_solver_3d poisson_iga_solver_3d fortime fortime program~poisson_iga_solver_3d->fortime module~forcad forcad program~poisson_iga_solver_3d->module~forcad module~forcad_utils forcad_utils program~poisson_iga_solver_3d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Solves the 3D Poisson problem using Isogeometric Analysis (IGA). This code solves the equation: using a B-spline volume on a rectangular domain. The solution is discretized using tensor-product B-spline basis functions\nover a structured control net. The global linear system is assembled and\nsolved using a basic internal Cholesky solver. The resulting solution is exported to VTK format for visualization. The L2 error norm with respect to the exact solution\nis computed and printed. Note This implementation uses B-spline geometry (no rational weights), hence the volume is not a full NURBS. Warning \"Slow solver\"\nThe solver uses an internal Cholesky factorization which is not optimized. For large systems, consider replacing it with a more scalable external solver. Domain size and number of control points\nNumber knots to insert in each direction\nMode numbers for the source term and exact solution\nResolution of the visualization grid\nfilename for VTK export Construct the NURBS volume\nFor simplicity, set_hexahedron creates a rectangular volume with uniform knot spacing\nFor more complex geometries, use vol%set() with knots, continuity,... Insert knots in the first and second directions\nExtract geometry and mesh structure\nAssemble global stiffness matrix and load vector\nApply homogeneous Dirichlet boundary conditions\nSolve the linear system K·X = b\nExport solution at control points to VTK Interpolate solution and export field\nCompute the L2 error norm Calls program~~poisson_iga_solver_3d~~CallsGraph program~poisson_iga_solver_3d poisson_iga_solver_3d none~basis~3 nurbs_volume%basis program~poisson_iga_solver_3d->none~basis~3 none~get_degree~3 nurbs_volume%get_degree program~poisson_iga_solver_3d->none~get_degree~3 none~get_nc~3 nurbs_volume%get_nc program~poisson_iga_solver_3d->none~get_nc~3 none~get_xc~3 nurbs_volume%get_Xc program~poisson_iga_solver_3d->none~get_xc~3 proc~ansatz~3 nurbs_volume%ansatz program~poisson_iga_solver_3d->proc~ansatz~3 proc~cmp_elem~3 nurbs_volume%cmp_elem program~poisson_iga_solver_3d->proc~cmp_elem~3 proc~create~3 nurbs_volume%create program~poisson_iga_solver_3d->proc~create~3 proc~exact_solution exact_solution program~poisson_iga_solver_3d->proc~exact_solution proc~export_xc~3 nurbs_volume%export_Xc program~poisson_iga_solver_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~poisson_iga_solver_3d->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~poisson_iga_solver_3d->proc~finalize~3 proc~insert_knots~3 nurbs_volume%insert_knots program~poisson_iga_solver_3d->proc~insert_knots~3 proc~set_hexahedron nurbs_volume%set_hexahedron program~poisson_iga_solver_3d->proc~set_hexahedron proc~solve solve program~poisson_iga_solver_3d->proc~solve proc~source_term source_term program~poisson_iga_solver_3d->proc~source_term timer_start timer_start program~poisson_iga_solver_3d->timer_start timer_stop timer_stop program~poisson_iga_solver_3d->timer_stop proc~basis_scalar~3 nurbs_volume%basis_scalar none~basis~3->proc~basis_scalar~3 proc~basis_vector~3 nurbs_volume%basis_vector none~basis~3->proc~basis_vector~3 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~ansatz~3->proc~cmp_elem~3 interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz~3->interface~ndgrid interface~unique unique proc~ansatz~3->interface~unique none~derivative~3 nurbs_volume%derivative proc~ansatz~3->none~derivative~3 none~set~3 nurbs_volume%set proc~ansatz~3->none~set~3 proc~det det proc~ansatz~3->proc~det proc~inv inv proc~ansatz~3->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity none~get_knot~3 nurbs_volume%get_knot proc~insert_knots~3->none~get_knot~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc proc~insert_knots~3->set proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~3 nurbs_volume%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_volume%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~basis_scalar~3->proc~is_rational~3 interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3->interface~ndgrid proc~basis_vector~3->proc~is_rational~3 proc~basis_vector~3->interface~compute_tgc~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc_dir~2->interface~compute_multiplicity proc~inv->proc~solve proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_3d_vector proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~derivative_scalar~3->proc~is_rational~3 interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->proc~is_rational~3 proc~derivative_vector~3->interface~compute_dtgc~3 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_degree~3->set proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_tgc_bspline_3d_scalar->interface~kron proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->interface~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->interface~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->interface~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_dtgc_bspline_3d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: K (:,:) Global stiffness matrix real(kind=rk) :: L (3) Domain size real(kind=rk), allocatable :: T (:) Basis function values at quadrature point real(kind=rk), allocatable :: X (:,:) Global solution vector real(kind=rk), allocatable :: Xc (:,:) Control point coordinates real(kind=rk), allocatable :: Xg (:) Physical coordinates at quadrature point real(kind=rk), allocatable :: b (:) Global right-hand side vector real(kind=rk), allocatable :: dT (:,:) Derivatives of basis functions at quadrature point real(kind=rk) :: dV Differential element volume integer, allocatable :: dirichlet_id (:) Indices for Dirichlet boundary conditions integer :: dof Degrees of freedom per control point (1 for scalar field) integer, allocatable :: elem (:,:) Element connectivity matrix integer, allocatable :: elem_e (:) Local connectivity of current element character(len=256) :: filename Filename for VTK export integer :: i Generic loop index integer :: ie Element index integer :: ig Quadrature (Gauss) point index integer :: ki (3) Number of knots to insert in each direction real(kind=rk) :: l2_error L2 error norm accumulator integer :: m (3) Mode numbers for source and exact solution integer :: nc (3) Number of control points in each direction integer :: nct Total number of control points integer :: ndof Total degrees of freedom integer :: nelem Number of elements integer :: nnelem Number of local nodes per element real(kind=rk), parameter :: pi = acos(-1.0_rk) Constant integer :: res (3) Visualization resolution type(timer) :: ti Timer object for performance measurement real(kind=rk), allocatable :: u_h (:,:) Interpolated solution field on grid type( nurbs_volume ) :: vol NURBS volume object Functions pure function exact_solution (p, d, n) result(u) Computes the exact solution corresponding to the source term Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (3) Coordinates (x, y, z) real(kind=rk), intent(in) :: d (3) Domain size (L1, L2, L3) integer, intent(in) :: n (3) Mode numbers (m1, m2, m3) Return Value real(kind=rk) pure function source_term (p, d, n) result(f) Computes the source function Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (3) Coordinates (x, y, z) real(kind=rk), intent(in) :: d (3) Domain size (L1, L2, L3) integer, intent(in) :: n (3) Mode numbers (m1, m2, m3) Return Value real(kind=rk)","tags":"","url":"program/poisson_iga_solver_3d.html"},{"title":"shape_half_ring_3d – ForCAD","text":"Uses forcad program~~shape_half_ring_3d~~UsesGraph program~shape_half_ring_3d shape_half_ring_3d module~forcad forcad program~shape_half_ring_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_3d~~CallsGraph program~shape_half_ring_3d shape_half_ring_3d proc~create~3 nurbs_volume%create program~shape_half_ring_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_half_ring_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_half_ring_3d->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_half_ring_3d->proc~finalize~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~shape_half_ring_3d->proc~set_half_ring~2 proc~show~3 nurbs_volume%show program~shape_half_ring_3d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set none~set~3 nurbs_volume%set proc~set_half_ring~2->none~set~3 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_half_ring_3d.html"},{"title":"example_helix_pipe – ForCAD","text":"Uses forcad program~~example_helix_pipe~~UsesGraph program~example_helix_pipe example_helix_pipe module~forcad forcad program~example_helix_pipe->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Example program demonstrating how to sweep a straight, pipe-like NURBS volume\ninto a cylindrical helix with a prescribed radius, pitch, and number of turns. The program:\n  Creates a straight ring extruded along (a pipe segment),\n  Refines it along the axial direction (knot insertion + degree elevation),\n  Maps the control points onto a helix of radius rh , pitch pitch , with nturns turns,\n  Exports the resulting NURBS volume to VTK,\n  Displays the geometry. Calls program~~example_helix_pipe~~CallsGraph program~example_helix_pipe example_helix_pipe proc~build_helix build_helix program~example_helix_pipe->proc~build_helix proc~create~3 nurbs_volume%create program~example_helix_pipe->proc~create~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~example_helix_pipe->proc~elevate_degree~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_helix_pipe->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_helix_pipe->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_helix_pipe->proc~export_xth_in_xg~2 proc~insert_knots~3 nurbs_volume%insert_knots program~example_helix_pipe->proc~insert_knots~3 proc~set_ring~2 nurbs_volume%set_ring program~example_helix_pipe->proc~set_ring~2 proc~show~3 nurbs_volume%show program~example_helix_pipe->proc~show~3 none~get_knot~3 nurbs_volume%get_knot proc~build_helix->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc proc~build_helix->none~get_nc~3 none~get_wc~3 nurbs_volume%get_Wc proc~build_helix->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~build_helix->none~get_xc~3 none~set~3 nurbs_volume%set proc~build_helix->none~set~3 proc~is_rational~3 nurbs_volume%is_rational proc~build_helix->proc~is_rational~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~insert_knots~3->none~get_knot~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc proc~insert_knots~3->set proc~set_ring~2->none~set~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~get_nc_dir~2->interface~compute_multiplicity proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer, parameter :: N = 50 interior knots to insert along . real(kind=rk), parameter :: center (3) = [0.0_rk, 0.0_rk, 0.0_rk] Pipe center . integer :: i real(kind=rk), parameter :: length = 1.0_rk Length of the straight segment. integer, parameter :: nturns = 3 Number of full turns. real(kind=rk), parameter :: pitch = 1.5_rk Helix pitch (axial rise per full turn). real(kind=rk), parameter :: r1 = 0.1_rk Inner radius of the pipe. real(kind=rk), parameter :: r2 = 0.2_rk Outer radius of the pipe. real(kind=rk), parameter :: rh = 1.0_rk Helix radius. type( nurbs_volume ) :: ring Straight pipe ring. type( nurbs_volume ) :: shape Helical pipe shape. Subroutines pure subroutine build_helix (this, c, rh, p, n) Map a straight pipe-like NURBS volume onto a cylindrical helix . Read more… Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this NURBS volume to be helicalized. real(kind=rk), intent(in) :: c (3) Center , helix radius , pitch . real(kind=rk), intent(in) :: rh Center , helix radius , pitch . real(kind=rk), intent(in) :: p Center , helix radius , pitch . integer, intent(in) :: n Number of turns.","tags":"","url":"program/example_helix_pipe.html"},{"title":"shape_C_3d – ForCAD","text":"Uses forcad program~~shape_c_3d~~UsesGraph program~shape_c_3d shape_C_3d module~forcad forcad program~shape_c_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_3d~~CallsGraph program~shape_c_3d shape_C_3d proc~create~3 nurbs_volume%create program~shape_c_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_c_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_c_3d->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_c_3d->proc~finalize~3 proc~set_c~3 nurbs_volume%set_C program~shape_c_3d->proc~set_c~3 proc~show~3 nurbs_volume%show program~shape_c_3d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set none~set~3 nurbs_volume%set proc~set_c~3->none~set~3 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_c_3d.html"},{"title":"example_nurbs_surface – ForCAD","text":"Uses forcad program~~example_nurbs_surface~~UsesGraph program~example_nurbs_surface example_nurbs_surface module~forcad forcad program~example_nurbs_surface->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface.\nIt sets up control points and weights, generates the surface, and exports the control points\nand the surface to VTK files at various stages. Define control points for the NURBS surface Define weights for the control points Set control points and weights for the NURBS surface object Deallocate local arrays Elevate the degree of the NURBS surface in the first and second directions\nInsert knots into the NURBS surface in the first and second directions\nExport control points to a VTK file Generate the NURBS surface with a resolution of 30x30 Export the generated surface to a VTK file Export the parameter space to a VTK file Show the control geometry, geometry and parameters using PyVista Finalize the NURBS surface object Calls program~~example_nurbs_surface~~CallsGraph program~example_nurbs_surface example_nurbs_surface none~set nurbs_surface%set program~example_nurbs_surface->none~set proc~create nurbs_surface%create program~example_nurbs_surface->proc~create proc~elevate_degree nurbs_surface%elevate_degree program~example_nurbs_surface->proc~elevate_degree proc~export_xc nurbs_surface%export_Xc program~example_nurbs_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example_nurbs_surface->proc~export_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~example_nurbs_surface->proc~export_xth_in_xg proc~finalize nurbs_surface%finalize program~example_nurbs_surface->proc~finalize proc~generate_xc~3 generate_Xc program~example_nurbs_surface->proc~generate_xc~3 proc~insert_knots nurbs_surface%insert_knots program~example_nurbs_surface->proc~insert_knots proc~show nurbs_surface%show program~example_nurbs_surface->proc~show proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~elevate_degree->none~set none~get_knot nurbs_surface%get_knot proc~elevate_degree->none~get_knot proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth_in_xg->interface~compute_xg interface~unique unique proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg->proc~export_vtk_legacy proc~export_xth_in_xg->proc~is_rational proc~export_xth_in_xg->set interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity proc~insert_knots->none~get_knot proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots->proc~is_rational s_loc s_loc proc~insert_knots->s_loc proc~insert_knots->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions pure function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !----------------------------------------------------------------------------- ! Refinement !----------------------------------------------------------------------------- !> Elevate the degree of the NURBS surface in the first and second directions call nurbs % elevate_degree ( 1 , 3 ) call nurbs % elevate_degree ( 2 , 3 ) !> Insert knots into the NURBS surface in the first and second directions call nurbs % insert_knots ( 1 ,[ 0.5_rk ], [ 1 ]) call nurbs % insert_knots ( 2 ,[ 0.5_rk ], [ 1 ]) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !> Export the parameter space to a VTK file call nurbs % export_Xth_in_Xg ( 'vtk/demo_surface_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry, geometry and parameters using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' , 'vtk/demo_surface_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- pure function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","url":"program/example_nurbs_surface.html"},{"title":"shape_half_circle – ForCAD","text":"Uses forcad program~~shape_half_circle~~UsesGraph program~shape_half_circle shape_half_circle module~forcad forcad program~shape_half_circle->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half circle shape centered at the 0,0,0 with a radius of 1 Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_circle~~CallsGraph program~shape_half_circle shape_half_circle proc~create~2 nurbs_curve%create program~shape_half_circle->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_half_circle->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_half_circle->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_half_circle->proc~finalize~2 proc~set_half_circle nurbs_curve%set_half_circle program~shape_half_circle->proc~set_half_circle proc~show~2 nurbs_curve%show program~shape_half_circle->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set none~set~2 nurbs_curve%set proc~set_half_circle->none~set~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_tgc_1d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","url":"program/shape_half_circle.html"},{"title":"shape_ring_3d – ForCAD","text":"Uses forcad program~~shape_ring_3d~~UsesGraph program~shape_ring_3d shape_ring_3d module~forcad forcad program~shape_ring_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_3d~~CallsGraph program~shape_ring_3d shape_ring_3d proc~create~3 nurbs_volume%create program~shape_ring_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_ring_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_ring_3d->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_ring_3d->proc~finalize~3 proc~set_ring~2 nurbs_volume%set_ring program~shape_ring_3d->proc~set_ring~2 proc~show~3 nurbs_volume%show program~shape_ring_3d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set none~set~3 nurbs_volume%set proc~set_ring~2->none~set~3 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_ring_3d.html"},{"title":"test_nurbs_surface – ForCAD","text":"Uses forcad_utils forunittest forcad program~~test_nurbs_surface~~UsesGraph program~test_nurbs_surface test_nurbs_surface forunittest forunittest program~test_nurbs_surface->forunittest module~forcad forcad program~test_nurbs_surface->module~forcad module~forcad_utils forcad_utils program~test_nurbs_surface->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_nurbs_surface~~CallsGraph program~test_nurbs_surface test_nurbs_surface check check program~test_nurbs_surface->check interface~ndgrid ndgrid program~test_nurbs_surface->interface~ndgrid lsq_fit_bspline lsq_fit_bspline program~test_nurbs_surface->lsq_fit_bspline n n program~test_nurbs_surface->n none~basis nurbs_surface%basis program~test_nurbs_surface->none~basis none~derivative nurbs_surface%derivative program~test_nurbs_surface->none~derivative none~derivative2 nurbs_surface%derivative2 program~test_nurbs_surface->none~derivative2 none~get_degree nurbs_surface%get_degree program~test_nurbs_surface->none~get_degree none~get_knot nurbs_surface%get_knot program~test_nurbs_surface->none~get_knot none~get_nc nurbs_surface%get_nc program~test_nurbs_surface->none~get_nc none~get_wc nurbs_surface%get_Wc program~test_nurbs_surface->none~get_wc none~get_xc nurbs_surface%get_Xc program~test_nurbs_surface->none~get_xc none~get_xg nurbs_surface%get_Xg program~test_nurbs_surface->none~get_xg none~set nurbs_surface%set program~test_nurbs_surface->none~set proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_elem nurbs_surface%cmp_elem program~test_nurbs_surface->proc~cmp_elem proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis program~test_nurbs_surface->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis program~test_nurbs_surface->proc~cmp_elem_xg_vis proc~cmp_nc nurbs_surface%cmp_nc program~test_nurbs_surface->proc~cmp_nc proc~create nurbs_surface%create program~test_nurbs_surface->proc~create proc~elevate_degree nurbs_surface%elevate_degree program~test_nurbs_surface->proc~elevate_degree proc~export_iges nurbs_surface%export_iges program~test_nurbs_surface->proc~export_iges proc~export_xc nurbs_surface%export_Xc program~test_nurbs_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~test_nurbs_surface->proc~export_xg proc~export_xth nurbs_surface%export_Xth program~test_nurbs_surface->proc~export_xth proc~finalize nurbs_surface%finalize program~test_nurbs_surface->proc~finalize proc~get_continuity nurbs_surface%get_continuity program~test_nurbs_surface->proc~get_continuity proc~get_elem nurbs_surface%get_elem program~test_nurbs_surface->proc~get_elem proc~get_elem_xc_vis nurbs_surface%get_elem_Xc_vis program~test_nurbs_surface->proc~get_elem_xc_vis proc~get_elem_xg_vis nurbs_surface%get_elem_Xg_vis program~test_nurbs_surface->proc~get_elem_xg_vis proc~get_multiplicity nurbs_surface%get_multiplicity program~test_nurbs_surface->proc~get_multiplicity proc~get_xt nurbs_surface%get_Xt program~test_nurbs_surface->proc~get_xt proc~insert_knots nurbs_surface%insert_knots program~test_nurbs_surface->proc~insert_knots proc~modify_wc nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc proc~modify_xc nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc proc~nearest_point nurbs_surface%nearest_point program~test_nurbs_surface->proc~nearest_point proc~nearest_point2 nurbs_surface%nearest_point2 program~test_nurbs_surface->proc~nearest_point2 proc~remove_knots nurbs_surface%remove_knots program~test_nurbs_surface->proc~remove_knots proc~rotate_xc nurbs_surface%rotate_Xc program~test_nurbs_surface->proc~rotate_xc proc~rotate_xg nurbs_surface%rotate_Xg program~test_nurbs_surface->proc~rotate_xg proc~set_c nurbs_surface%set_C program~test_nurbs_surface->proc~set_c proc~set_elem nurbs_surface%set_elem program~test_nurbs_surface->proc~set_elem proc~set_elem_xc_vis nurbs_surface%set_elem_Xc_vis program~test_nurbs_surface->proc~set_elem_xc_vis proc~set_elem_xg_vis nurbs_surface%set_elem_Xg_vis program~test_nurbs_surface->proc~set_elem_xg_vis proc~set_half_ring nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring proc~set_ring nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon proc~translate_xc nurbs_surface%translate_Xc program~test_nurbs_surface->proc~translate_xc proc~translate_xg nurbs_surface%translate_Xg program~test_nurbs_surface->proc~translate_xg xdata xdata program~test_nurbs_surface->xdata xg_eval xg_eval program~test_nurbs_surface->xg_eval xt xt program~test_nurbs_surface->xt xt1 xt1 program~test_nurbs_surface->xt1 xt2 xt2 program~test_nurbs_surface->xt2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_scalar nurbs_surface%basis_scalar none~basis->proc~basis_scalar proc~basis_vector nurbs_surface%basis_vector none~basis->proc~basis_vector proc~derivative_scalar nurbs_surface%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_surface%derivative_vector none~derivative->proc~derivative_vector proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2->proc~derivative2_vector proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_nc_all nurbs_surface%get_nc_all none~get_nc->proc~get_nc_all proc~get_nc_dir nurbs_surface%get_nc_dir none~get_nc->proc~get_nc_dir proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~cmp_area->proc~cmp_elem proc~ansatz nurbs_surface%ansatz proc~cmp_area->proc~ansatz reduce reduce proc~cmp_area->reduce proc~cmp_elem->proc~get_multiplicity interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn interface~unique unique proc~cmp_elem->interface~unique interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity set set proc~cmp_nc->set proc~create->interface~ndgrid interface~compute_xg compute_Xg proc~create->interface~compute_xg proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~create->set proc~elevate_degree->none~get_knot proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->proc~is_rational append append proc~export_iges->append delete delete proc~export_iges->delete init init proc~export_iges->init makedpsections makedpsections proc~export_iges->makedpsections makegsection makegsection proc~export_iges->makegsection makessection makessection proc~export_iges->makessection proc~export_iges->proc~is_rational writeigesfile writeigesfile proc~export_iges->writeigesfile proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth->interface~ndgrid proc~export_xth->interface~unique proc~cmp_elem_xth nurbs_surface%cmp_elem_Xth proc~export_xth->proc~cmp_elem_xth proc~export_xth->proc~export_vtk_legacy proc~get_continuity->interface~compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~insert_knots->none~get_knot proc~insert_knots->interface~compute_multiplicity proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots->proc~is_rational s_loc s_loc proc~insert_knots->s_loc proc~insert_knots->set proc~modify_wc->none~get_knot proc~modify_wc->none~get_wc proc~modify_wc->none~get_xc proc~modify_wc->none~set proc~modify_xc->none~get_knot proc~modify_xc->none~get_wc proc~modify_xc->none~get_xc proc~modify_xc->none~set proc~nearest_point2->none~derivative2 proc~nearest_point2->proc~create proc~nearest_point2->proc~finalize proc~nearest_point2->proc~nearest_point proc~cmp_xg nurbs_surface%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~inv inv proc~nearest_point2->proc~inv proc~remove_knots->none~get_knot proc~remove_knots->none~set proc~remove_knots->interface~compute_multiplicity proc~remove_knots->proc~findspan proc~remove_knots->proc~is_rational proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc->proc~rotation proc~rotate_xg->proc~rotation proc~set_c->none~set proc~set_half_ring->none~set proc~set_ring->none~set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~ansatz->interface~ndgrid proc~ansatz->none~derivative proc~ansatz->none~set proc~ansatz->proc~cmp_elem proc~ansatz->interface~unique proc~ansatz->proc~inv interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg proc~det det proc~ansatz->proc~det proc~basis_scalar->proc~is_rational interface~compute_tgc compute_Tgc proc~basis_scalar->interface~compute_tgc proc~basis_vector->interface~ndgrid proc~basis_vector->proc~is_rational proc~basis_vector->interface~compute_tgc proc~cmp_elem_xth->interface~elemconn_c0 proc~cmp_elem_xth->interface~unique proc~cmp_xg->interface~compute_xg proc~cmp_xg->proc~is_rational proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~derivative_scalar->proc~is_rational interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector->interface~ndgrid proc~derivative_vector->proc~is_rational proc~derivative_vector->interface~compute_dtgc proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_nc_dir->interface~compute_multiplicity proc~inv->proc~inv proc~inv->proc~det proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1->proc~cmp_nc proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~set2->proc~cmp_nc proc~set2->set proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree->proc~get_multiplicity proc~cmp_degree->set proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~compute_d2tgc_bspline_2d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~compute_dtgc_bspline_2d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~compute_tgc_bspline_2d_scalar->interface~kron proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Tgc (:,:) real(kind=rk), allocatable :: Tgc1 (:) real(kind=rk), allocatable :: Tgc1b (:) real(kind=rk), allocatable :: Tgcb (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xg (:,:) real(kind=rk), allocatable :: Xgb (:,:) real(kind=rk) :: area real(kind=rk) :: areab type( nurbs_surface ) :: bsp real(kind=rk), allocatable :: d2Tgc (:,:,:) real(kind=rk), allocatable :: d2Tgc1 (:,:) real(kind=rk), allocatable :: d2Tgc1b (:,:) real(kind=rk), allocatable :: d2Tgcb (:,:,:) real(kind=rk), allocatable :: dTgc (:,:,:) real(kind=rk), allocatable :: dTgc1 (:,:) real(kind=rk), allocatable :: dTgc1b (:,:) real(kind=rk), allocatable :: dTgcb (:,:,:) integer, allocatable :: elemConn (:,:) integer :: i integer :: id real(kind=rk) :: knot1 (4) real(kind=rk) :: knot2 (4) real(kind=rk) :: nearest_Xg (3) real(kind=rk) :: nearest_Xt (2) type( nurbs_surface ) :: nurbs type(unit_test) :: ut","tags":"","url":"program/test_nurbs_surface.html"},{"title":"lsq_fit_bspline_3d – ForCAD","text":"Uses forcad_utils forcad program~~lsq_fit_bspline_3d~~UsesGraph program~lsq_fit_bspline_3d lsq_fit_bspline_3d module~forcad forcad program~lsq_fit_bspline_3d->module~forcad module~forcad_utils forcad_utils program~lsq_fit_bspline_3d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~lsq_fit_bspline_3d~~CallsGraph program~lsq_fit_bspline_3d lsq_fit_bspline_3d interface~ndgrid ndgrid program~lsq_fit_bspline_3d->interface~ndgrid none~get_degree~3 nurbs_volume%get_degree program~lsq_fit_bspline_3d->none~get_degree~3 none~get_knot~3 nurbs_volume%get_knot program~lsq_fit_bspline_3d->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc program~lsq_fit_bspline_3d->none~get_nc~3 none~get_xg~3 nurbs_volume%get_Xg program~lsq_fit_bspline_3d->none~get_xg~3 none~set~3 nurbs_volume%set program~lsq_fit_bspline_3d->none~set~3 proc~create~3 nurbs_volume%create program~lsq_fit_bspline_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~lsq_fit_bspline_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~lsq_fit_bspline_3d->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~lsq_fit_bspline_3d->proc~export_xth_in_xg~2 proc~get_continuity~3 nurbs_volume%get_continuity program~lsq_fit_bspline_3d->proc~get_continuity~3 proc~lsq_fit_bspline~3 nurbs_volume%lsq_fit_bspline program~lsq_fit_bspline_3d->proc~lsq_fit_bspline~3 proc~show~3 nurbs_volume%show program~lsq_fit_bspline_3d->proc~show~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_xg_all~3 nurbs_volume%get_Xg_all none~get_xg~3->proc~get_xg_all~3 proc~get_xgid~3 nurbs_volume%get_Xgid none~get_xg~3->proc~get_xgid~3 proc~get_xgi~3 nurbs_volume%get_Xgi none~get_xg~3->proc~get_xgi~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~create~3->interface~ndgrid interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set interface~compute_multiplicity compute_multiplicity proc~get_continuity~3->interface~compute_multiplicity interface~kron kron proc~lsq_fit_bspline~3->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_bspline~3->proc~basis_bspline proc~solve solve proc~lsq_fit_bspline~3->proc~solve proc~lsq_fit_bspline~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~get_nc_dir~2->interface~compute_multiplicity proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_xg_bspline_3d->interface~kron proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xdata (:,:) real(kind=rk), allocatable :: Xg_eval (:,:) real(kind=rk), allocatable :: Xt (:,:) real(kind=rk), allocatable :: Xt1 (:) real(kind=rk), allocatable :: Xt2 (:) real(kind=rk), allocatable :: Xt3 (:) type( nurbs_volume ) :: bsp real(kind=rk) :: err1 real(kind=rk) :: err2 real(kind=rk) :: err3 integer :: i integer :: n (3) integer :: ndata real(kind=rk), parameter :: pi = acos(-1.0_rk) real(kind=rk) :: rms","tags":"","url":"program/lsq_fit_bspline_3d.html"},{"title":"nearest_point_1d – ForCAD","text":"Uses forcad program~~nearest_point_1d~~UsesGraph program~nearest_point_1d nearest_point_1d module~forcad forcad program~nearest_point_1d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Find the nearest point on the curve to a given point\nFind the nearest point on the curve to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS curve object Calls program~~nearest_point_1d~~CallsGraph program~nearest_point_1d nearest_point_1d none~set~2 nurbs_curve%set program~nearest_point_1d->none~set~2 proc~create~2 nurbs_curve%create program~nearest_point_1d->proc~create~2 proc~finalize~2 nurbs_curve%finalize program~nearest_point_1d->proc~finalize~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 program~nearest_point_1d->proc~nearest_point2~2 proc~nearest_point~2 nurbs_curve%nearest_point program~nearest_point_1d->proc~nearest_point~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->proc~finalize~2 proc~nearest_point2~2->proc~nearest_point~2 none~derivative2~2 nurbs_curve%derivative2 proc~nearest_point2~2->none~derivative2~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 proc~cmp_xg~2->interface~compute_xg~2 proc~cmp_xg~2->proc~is_rational~2 proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_tgc_1d->proc~basis_bspline proc~get_multiplicity~2->interface~compute_multiplicity interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights integer :: id Variable for the id of the nearest point real(kind=rk) :: knot (6) Array for knot vector real(kind=rk) :: nearest_Xg (3) Array for the nearest point on the curve real(kind=rk) :: nearest_Xt Array for the parametric coordinates of the nearest point type( nurbs_curve ) :: shape Declare a NURBS curve object","tags":"","url":"program/nearest_point_1d.html"},{"title":"lsq_fit_nurbs_3d – ForCAD","text":"Uses forcad_utils forcad program~~lsq_fit_nurbs_3d~~UsesGraph program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d module~forcad forcad program~lsq_fit_nurbs_3d->module~forcad module~forcad_utils forcad_utils program~lsq_fit_nurbs_3d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~lsq_fit_nurbs_3d~~CallsGraph program~lsq_fit_nurbs_3d lsq_fit_nurbs_3d interface~ndgrid ndgrid program~lsq_fit_nurbs_3d->interface~ndgrid none~get_degree~3 nurbs_volume%get_degree program~lsq_fit_nurbs_3d->none~get_degree~3 none~get_knot~3 nurbs_volume%get_knot program~lsq_fit_nurbs_3d->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc program~lsq_fit_nurbs_3d->none~get_nc~3 none~get_xg~3 nurbs_volume%get_Xg program~lsq_fit_nurbs_3d->none~get_xg~3 none~set~3 nurbs_volume%set program~lsq_fit_nurbs_3d->none~set~3 proc~create~3 nurbs_volume%create program~lsq_fit_nurbs_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~lsq_fit_nurbs_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~lsq_fit_nurbs_3d->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~lsq_fit_nurbs_3d->proc~export_xth_in_xg~2 proc~get_continuity~3 nurbs_volume%get_continuity program~lsq_fit_nurbs_3d->proc~get_continuity~3 proc~lsq_fit_nurbs~3 nurbs_volume%lsq_fit_nurbs program~lsq_fit_nurbs_3d->proc~lsq_fit_nurbs~3 proc~show~3 nurbs_volume%show program~lsq_fit_nurbs_3d->proc~show~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_xg_all~3 nurbs_volume%get_Xg_all none~get_xg~3->proc~get_xg_all~3 proc~get_xgid~3 nurbs_volume%get_Xgid none~get_xg~3->proc~get_xgid~3 proc~get_xgi~3 nurbs_volume%get_Xgi none~get_xg~3->proc~get_xgi~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~create~3->interface~ndgrid interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set interface~compute_multiplicity compute_multiplicity proc~get_continuity~3->interface~compute_multiplicity interface~kron kron proc~lsq_fit_nurbs~3->interface~kron proc~basis_bspline basis_bspline proc~lsq_fit_nurbs~3->proc~basis_bspline proc~solve solve proc~lsq_fit_nurbs~3->proc~solve proc~lsq_fit_nurbs~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~get_nc_dir~2->interface~compute_multiplicity proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_xg_bspline_3d->interface~kron proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xdata (:,:) real(kind=rk), allocatable :: Xg_eval (:,:) real(kind=rk), allocatable :: Xt (:,:) real(kind=rk), allocatable :: Xt1 (:) real(kind=rk), allocatable :: Xt2 (:) real(kind=rk), allocatable :: Xt3 (:) real(kind=rk) :: err1 real(kind=rk) :: err2 real(kind=rk) :: err3 integer :: i integer :: n (3) integer :: ndata type( nurbs_volume ) :: nrb real(kind=rk), parameter :: pi = acos(-1.0_rk) real(kind=rk) :: rms","tags":"","url":"program/lsq_fit_nurbs_3d.html"},{"title":"example_plate_hole_4_2d – ForCAD","text":"Uses forcad program~~example_plate_hole_4_2d~~UsesGraph program~example_plate_hole_4_2d example_plate_hole_4_2d module~forcad forcad program~example_plate_hole_4_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example_plate_hole_4_2d~~CallsGraph program~example_plate_hole_4_2d example_plate_hole_4_2d none~set nurbs_surface%set program~example_plate_hole_4_2d->none~set proc~create nurbs_surface%create program~example_plate_hole_4_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~example_plate_hole_4_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example_plate_hole_4_2d->proc~export_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~example_plate_hole_4_2d->proc~export_xth_in_xg proc~set_xc_wc~4 set_Xc_Wc program~example_plate_hole_4_2d->proc~set_xc_wc~4 proc~show nurbs_surface%show program~example_plate_hole_4_2d->proc~show proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth_in_xg->interface~compute_xg interface~unique unique proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg->proc~export_vtk_legacy proc~export_xth_in_xg->proc~is_rational proc~export_xth_in_xg->set cosd cosd proc~set_xc_wc~4->cosd tand tand proc~set_xc_wc~4->tand proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), parameter :: height = 5.0_rk real(kind=rk), parameter :: length = 5.0_rk type( nurbs_surface ) :: plate_hole real(kind=rk), parameter :: radius1 = 2.5_rk real(kind=rk), parameter :: radius2 = 3.5_rk Subroutines pure subroutine set_Xc_Wc (tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:)","tags":"","url":"program/example_plate_hole_4_2d.html"},{"title":"example_plate_hole_1_2d – ForCAD","text":"Uses forcad program~~example_plate_hole_1_2d~~UsesGraph program~example_plate_hole_1_2d example_plate_hole_1_2d module~forcad forcad program~example_plate_hole_1_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example_plate_hole_1_2d~~CallsGraph program~example_plate_hole_1_2d example_plate_hole_1_2d none~set nurbs_surface%set program~example_plate_hole_1_2d->none~set proc~create nurbs_surface%create program~example_plate_hole_1_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~example_plate_hole_1_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example_plate_hole_1_2d->proc~export_xg proc~export_xth_in_xg nurbs_surface%export_Xth_in_Xg program~example_plate_hole_1_2d->proc~export_xth_in_xg proc~set_xc_wc~5 set_Xc_Wc program~example_plate_hole_1_2d->proc~set_xc_wc~5 proc~show nurbs_surface%show program~example_plate_hole_1_2d->proc~show proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set proc~export_xth_in_xg->interface~compute_xg interface~unique unique proc~export_xth_in_xg->interface~unique proc~export_xth_in_xg->proc~export_vtk_legacy proc~export_xth_in_xg->proc~is_rational proc~export_xth_in_xg->set cosd cosd proc~set_xc_wc~5->cosd tand tand proc~set_xc_wc~5->tand proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), parameter :: height = 5.0_rk real(kind=rk), parameter :: length = 5.0_rk type( nurbs_surface ) :: plate_hole real(kind=rk), parameter :: radius1 = 2.5_rk real(kind=rk), parameter :: radius2 = 3.5_rk Subroutines pure subroutine set_Xc_Wc (tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:)","tags":"","url":"program/example_plate_hole_1_2d.html"},{"title":"compute_volume – ForCAD","text":"Uses forcad program~~compute_volume~~UsesGraph program~compute_volume compute_volume module~forcad forcad program~compute_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_volume~~CallsGraph program~compute_volume compute_volume none~set~3 nurbs_volume%set program~compute_volume->none~set~3 proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~ansatz~3 nurbs_volume%ansatz proc~cmp_volume->proc~ansatz~3 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_volume->proc~cmp_elem~3 reduce reduce proc~cmp_volume->reduce proc~ansatz~3->none~set~3 proc~ansatz~3->proc~cmp_elem~3 interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz~3->interface~ndgrid interface~unique unique proc~ansatz~3->interface~unique none~derivative~3 nurbs_volume%derivative proc~ansatz~3->none~derivative~3 proc~det det proc~ansatz~3->proc~det proc~inv inv proc~ansatz~3->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 set set proc~set1~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->set proc~set3~3->proc~cmp_degree~3 proc~set3~3->set proc~set4~3->set proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~3 nurbs_volume%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_volume%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_degree~3->set proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->interface~compute_dtgc~3 proc~derivative_vector~3->proc~is_rational~3 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid interface~kron kron proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_3d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~compute_dtgc_bspline_3d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->interface~kron proc~compute_dtgc_bspline_3d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->interface~kron proc~compute_dtgc_nurbs_3d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->interface~kron proc~compute_dtgc_nurbs_3d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (8,3) type( nurbs_volume ) :: shape real(kind=rk) :: volume","tags":"","url":"program/compute_volume.html"},{"title":"example_ppm3 – ForCAD","text":"Uses forcolormap fortime forcad forimage program~~example_ppm3~~UsesGraph program~example_ppm3 example_ppm3 forcolormap forcolormap program~example_ppm3->forcolormap forimage forimage program~example_ppm3->forimage fortime fortime program~example_ppm3->fortime module~forcad forcad program~example_ppm3->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon Calls program~~example_ppm3~~CallsGraph program~example_ppm3 example_ppm3 compute_rgb compute_rgb program~example_ppm3->compute_rgb export_pnm export_pnm program~example_ppm3->export_pnm get_b get_b program~example_ppm3->get_b get_g get_g program~example_ppm3->get_g get_r get_r program~example_ppm3->get_r none~get_xg nurbs_surface%get_Xg program~example_ppm3->none~get_xg proc~create nurbs_surface%create program~example_ppm3->proc~create proc~finalize nurbs_surface%finalize program~example_ppm3->proc~finalize proc~get_ng nurbs_surface%get_ng program~example_ppm3->proc~get_ng proc~modify_xc nurbs_surface%modify_Xc program~example_ppm3->proc~modify_xc proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm3->proc~set_tetragon proc~translate_xc nurbs_surface%translate_Xc program~example_ppm3->proc~translate_xc set set program~example_ppm3->set set_pnm set_pnm program~example_ppm3->set_pnm timer_start timer_start program~example_ppm3->timer_start timer_stop timer_stop program~example_ppm3->timer_stop proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid proc~create->set interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational none~get_knot nurbs_surface%get_knot proc~modify_xc->none~get_knot none~get_wc nurbs_surface%get_Wc proc~modify_xc->none~get_wc none~get_xc nurbs_surface%get_Xc proc~modify_xc->none~get_xc none~set nurbs_surface%set proc~modify_xc->none~set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image integer :: ng (2) integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","url":"program/example_ppm3.html"},{"title":"example_bend_pipe – ForCAD","text":"Uses forcad program~~example_bend_pipe~~UsesGraph program~example_bend_pipe example_bend_pipe module~forcad forcad program~example_bend_pipe->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Example program demonstrating how to bend a straight pipe-like NURBS volume into a circular arc. The program:\n  Creates a straight pipe segment (as a ring extruded in ),\n  Refines the shape,\n  Applies bending with different bend angles (90°, 270°, 360°),\n  Exports the resulting NURBS volumes to VTK,\n  Displays the geometry. Calls program~~example_bend_pipe~~CallsGraph program~example_bend_pipe example_bend_pipe proc~bend_pipe bend_pipe program~example_bend_pipe->proc~bend_pipe proc~create~3 nurbs_volume%create program~example_bend_pipe->proc~create~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~example_bend_pipe->proc~elevate_degree~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_bend_pipe->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_bend_pipe->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_bend_pipe->proc~export_xth_in_xg~2 proc~insert_knots~3 nurbs_volume%insert_knots program~example_bend_pipe->proc~insert_knots~3 proc~set_ring~2 nurbs_volume%set_ring program~example_bend_pipe->proc~set_ring~2 proc~show~3 nurbs_volume%show program~example_bend_pipe->proc~show~3 none~get_knot~3 nurbs_volume%get_knot proc~bend_pipe->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc proc~bend_pipe->none~get_nc~3 none~get_wc~3 nurbs_volume%get_Wc proc~bend_pipe->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~bend_pipe->none~get_xc~3 none~set~3 nurbs_volume%set proc~bend_pipe->none~set~3 proc~is_rational~3 nurbs_volume%is_rational proc~bend_pipe->proc~is_rational~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~insert_knots~3->none~get_knot~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc proc~insert_knots~3->set proc~set_ring~2->none~set~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~get_nc_dir~2->interface~compute_multiplicity proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), parameter :: a (3) = [90.0_rk, 270.0_rk, 360.0_rk] Bend angles (degrees). real(kind=rk), parameter :: c (3) = [0.0_rk, 0.0_rk, 0.0_rk] Center of the ring. real(kind=rk), parameter :: l = 1.0_rk Length of the straight segment. real(kind=rk), parameter :: r1 = 0.3_rk Inner radius of the pipe. real(kind=rk), parameter :: r2 = 0.5_rk Outer radius of the pipe. real(kind=rk), parameter :: rb = 1.5_rk Bend radius. type( nurbs_volume ) :: ring Straight pipe ring type( nurbs_volume ) :: shape Bent pipe shape Subroutines pure subroutine bend_pipe (this, center, length, rbend, angle_deg) Bend a straight pipe-like NURBS volume into a circular arc.\nEach control point is transformed relative\nto the center .\nLet the total bend angle in degrees be (input),\nand define the total bend angle in radians For each control point: Mapping: Knots and weights are preserved; only the control lattice is updated. Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this NURBS volume to be bent. real(kind=rk), intent(in) :: center (3) Pipe center coordinates . real(kind=rk), intent(in) :: length Length of the straight pipe segment before bending. real(kind=rk), intent(in) :: rbend Bend radius , i.e. distance from the bend centerline. real(kind=rk), intent(in) :: angle_deg Bend angle in degrees .","tags":"","url":"program/example_bend_pipe.html"},{"title":"fdm_test_curve – ForCAD","text":"Uses forcad program~~fdm_test_curve~~UsesGraph program~fdm_test_curve fdm_test_curve module~forcad forcad program~fdm_test_curve->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Finalize the NURBS curve object\nDefine control points for the NURBS curve\nDefine knot vector Set knot vector, control points for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Finalize the NURBS curve object Calls program~~fdm_test_curve~~CallsGraph program~fdm_test_curve fdm_test_curve none~derivative2~2 nurbs_curve%derivative2 program~fdm_test_curve->none~derivative2~2 none~set~2 nurbs_curve%set program~fdm_test_curve->none~set~2 proc~create~2 nurbs_curve%create program~fdm_test_curve->proc~create~2 proc~finalize~2 nurbs_curve%finalize program~fdm_test_curve->proc~finalize~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_tgc_1d->proc~basis_bspline interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->interface~basis_bspline_2der proc~get_multiplicity~2->interface~compute_multiplicity proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Tgc (:) real(kind=rk), allocatable :: Tgcm (:) real(kind=rk), allocatable :: Tgcp (:) real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: Xt real(kind=rk) :: Xtm real(kind=rk) :: Xtp type( nurbs_curve ) :: curve Declare a NURBS curve object real(kind=rk), allocatable :: d2Tgc (:) real(kind=rk), allocatable :: d2Tgcm (:) real(kind=rk), allocatable :: d2Tgcp (:) real(kind=rk), allocatable :: dTgc (:) real(kind=rk), allocatable :: dTgcm (:) real(kind=rk), allocatable :: dTgcp (:) real(kind=rk) :: knot (6) Array for knot vector real(kind=rk) :: tol","tags":"","url":"program/fdm_test_curve.html"},{"title":"fdm_elevate_and_insert_2d – ForCAD","text":"Uses forcad_utils fortime forcad program~~fdm_elevate_and_insert_2d~~UsesGraph program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d fortime fortime program~fdm_elevate_and_insert_2d->fortime module~forcad forcad program~fdm_elevate_and_insert_2d->module~forcad module~forcad_utils forcad_utils program~fdm_elevate_and_insert_2d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. set control points set weights\nset knot vectors\nset NURBS surface deallocate temporary arrays copy initial NURBS surface (before refinement) get initial control points, dimension, number of control points and degrees of freedom\nelevate degree in two directions and get sensitivities (Bs: in compact form, memory efficient)\nset knot vectors to insert\nmultiplicities of knots to insert\ninsert knots in three directions and get sensitivities (Bs: in compact form, memory efficient)\ncompute global sensitivities (dXc_old/dXc_new)\nstart finite difference computations compute relative error between finite difference and analytical sensitivities finalize Calls program~~fdm_elevate_and_insert_2d~~CallsGraph program~fdm_elevate_and_insert_2d fdm_elevate_and_insert_2d none~get_knot nurbs_surface%get_knot program~fdm_elevate_and_insert_2d->none~get_knot none~get_wc nurbs_surface%get_Wc program~fdm_elevate_and_insert_2d->none~get_wc none~get_xc nurbs_surface%get_Xc program~fdm_elevate_and_insert_2d->none~get_xc none~set nurbs_surface%set program~fdm_elevate_and_insert_2d->none~set proc~elevate_degree nurbs_surface%elevate_degree program~fdm_elevate_and_insert_2d->proc~elevate_degree proc~finalize nurbs_surface%finalize program~fdm_elevate_and_insert_2d->proc~finalize proc~generate_xc~4 generate_Xc program~fdm_elevate_and_insert_2d->proc~generate_xc~4 proc~insert_knots nurbs_surface%insert_knots program~fdm_elevate_and_insert_2d->proc~insert_knots proc~kron_eye kron_eye program~fdm_elevate_and_insert_2d->proc~kron_eye proc~linspace linspace program~fdm_elevate_and_insert_2d->proc~linspace timer_start timer_start program~fdm_elevate_and_insert_2d->timer_start timer_stop timer_stop program~fdm_elevate_and_insert_2d->timer_stop proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~elevate_degree->none~get_knot proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~is_rational nurbs_surface%is_rational proc~elevate_degree->proc~is_rational proc~insert_knots->none~get_knot interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots->proc~is_rational s_loc s_loc proc~insert_knots->s_loc set set proc~insert_knots->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: Bfd (:,:) real(kind=rk), allocatable :: Bs (:,:) real(kind=rk), allocatable :: S1 (:,:) real(kind=rk), allocatable :: S2 (:,:) real(kind=rk), allocatable :: S3 (:,:) real(kind=rk), allocatable :: S4 (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xc0 (:,:) real(kind=rk), allocatable :: Xcm_vec (:) real(kind=rk), allocatable :: Xcp_vec (:) real(kind=rk), allocatable :: Xm (:,:) real(kind=rk), allocatable :: Xp (:,:) integer :: d integer, parameter :: dg1 = 3 degrees to elevate integer, parameter :: dg2 = 2 degrees to elevate integer :: dim integer :: i integer :: idx real(kind=rk), allocatable :: knot1 (:) real(kind=rk), allocatable :: knot2 (:) integer, parameter :: n1 = 5 number of knots to insert integer, parameter :: n2 = 4 number of knots to insert integer :: nc0 integer :: ndof_new integer :: ndof_old integer, allocatable :: r1 (:) integer, allocatable :: r2 (:) real(kind=rk) :: rel_err type( nurbs_surface ) :: sh0 type( nurbs_surface ) :: shfd type( nurbs_surface ) :: shr type(timer) :: t real(kind=rk), parameter :: tol = 1e-5_rk tolerance of finite differences real(kind=rk), allocatable :: u1 (:) real(kind=rk), allocatable :: u2 (:) Functions pure function generate_Xc (L) result(cp) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:)","tags":"","url":"program/fdm_elevate_and_insert_2d.html"},{"title":"shape_ring_2d – ForCAD","text":"Uses forcad program~~shape_ring_2d~~UsesGraph program~shape_ring_2d shape_ring_2d module~forcad forcad program~shape_ring_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape with inner radius 1.0 and outer radius 2.0. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_2d~~CallsGraph program~shape_ring_2d shape_ring_2d proc~create nurbs_surface%create program~shape_ring_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_ring_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_ring_2d->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_ring_2d->proc~finalize proc~set_ring nurbs_surface%set_ring program~shape_ring_2d->proc~set_ring proc~show nurbs_surface%show program~shape_ring_2d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set none~set nurbs_surface%set proc~set_ring->none~set proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","url":"program/shape_ring_2d.html"},{"title":"example_twist_taper – ForCAD","text":"Uses forcad program~~example_twist_taper~~UsesGraph program~example_twist_taper example_twist_taper module~forcad forcad program~example_twist_taper->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Example program demonstrating how to apply a progressive twist and linear taper to a hexahedral NURBS volume along its axial (z) direction. The program:\n  Creates a straight hexahedral block (control points nc = [7,7,9] over a box of size L ),\n  Copies it to shape ,\n  Applies a z-dependent twist up to twist_deg and a linear taper to factor taper ,\n  Exports the resulting NURBS volume to VTK,\n  Displays the geometry. Calls program~~example_twist_taper~~CallsGraph program~example_twist_taper example_twist_taper proc~build_twist_taper build_twist_taper program~example_twist_taper->proc~build_twist_taper proc~create~3 nurbs_volume%create program~example_twist_taper->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_twist_taper->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_twist_taper->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_twist_taper->proc~export_xth_in_xg~2 proc~set_hexahedron nurbs_volume%set_hexahedron program~example_twist_taper->proc~set_hexahedron proc~show~3 nurbs_volume%show program~example_twist_taper->proc~show~3 none~get_knot~3 nurbs_volume%get_knot proc~build_twist_taper->none~get_knot~3 none~get_wc~3 nurbs_volume%get_Wc proc~build_twist_taper->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~build_twist_taper->none~get_xc~3 none~set~3 nurbs_volume%set proc~build_twist_taper->none~set~3 proc~is_rational~3 nurbs_volume%is_rational proc~build_twist_taper->proc~is_rational~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), parameter :: L (3) = [1.0_rk, 1.0_rk, 3.0_rk] Domain extents in . type( nurbs_volume ) :: hexa integer, parameter :: nc (3) = [7, 7, 9] Control point counts per direction. type( nurbs_volume ) :: shape real(kind=rk), parameter :: taper = 0.1_rk Target in-plane scale at the top face (0< taper ≤1). real(kind=rk), parameter :: twist_deg = 360.0_rk Total twist angle (degrees) at the top face. Subroutines pure subroutine build_twist_taper (this, Length, nc, twist_deg, taper) Apply a z-progressive twist and linear taper to a NURBS hexahedron. Read more… Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this Volume to be transformed. real(kind=rk), intent(in) :: Length (3) Box lengths . integer, intent(in) :: nc (3) Control points sizes. real(kind=rk), intent(in) :: twist_deg Total twist at top face (degrees). real(kind=rk), intent(in) :: taper In-plane scale at top face (0< taper ≤1).","tags":"","url":"program/example_twist_taper.html"},{"title":"example_toroidal_pipe – ForCAD","text":"Uses forcad program~~example_toroidal_pipe~~UsesGraph program~example_toroidal_pipe example_toroidal_pipe module~forcad forcad program~example_toroidal_pipe->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Example program demonstrating how to sweep a straight, pipe-like NURBS volume\nonto a toroidal pipe (donut) with an optional progressive cross-section twist and a sinusoidal wobble in the global z-direction as it travels around the torus. The program:\n  Creates a straight pipe segment (ring extruded along ),\n  Refines it along the axial direction (knot insertion + degree elevation),\n  Maps the control points onto a torus of major radius R ,\n  Applies a cross-section twist of twist_turns full rotations over one loop,\n  Superimposes a vertical wobble ,\n  Exports the resulting NURBS volume to VTK and displays it,\n  Prints the approximate enclosed volume (Gaussian integration). Calls program~~example_toroidal_pipe~~CallsGraph program~example_toroidal_pipe example_toroidal_pipe proc~create~3 nurbs_volume%create program~example_toroidal_pipe->proc~create~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~example_toroidal_pipe->proc~elevate_degree~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_toroidal_pipe->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_toroidal_pipe->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_toroidal_pipe->proc~export_xth_in_xg~2 proc~insert_knots~3 nurbs_volume%insert_knots program~example_toroidal_pipe->proc~insert_knots~3 proc~map_to_torus_sinez map_to_torus_sineZ program~example_toroidal_pipe->proc~map_to_torus_sinez proc~set_ring~2 nurbs_volume%set_ring program~example_toroidal_pipe->proc~set_ring~2 proc~show~3 nurbs_volume%show program~example_toroidal_pipe->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set none~get_knot~3 nurbs_volume%get_knot proc~elevate_degree~3->none~get_knot~3 none~set~3 nurbs_volume%set proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~insert_knots~3->none~get_knot~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc proc~insert_knots~3->set proc~map_to_torus_sinez->none~get_knot~3 none~get_nc~3 nurbs_volume%get_nc proc~map_to_torus_sinez->none~get_nc~3 none~get_wc~3 nurbs_volume%get_Wc proc~map_to_torus_sinez->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~map_to_torus_sinez->none~get_xc~3 proc~map_to_torus_sinez->none~set~3 proc~map_to_torus_sinez->proc~is_rational~3 proc~set_ring~2->none~set~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_volume%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_volume%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~get_nc_dir~2->interface~compute_multiplicity proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), parameter :: Az = 0.1_rk amplitude of vertical wobble integer, parameter :: Nref = 30 real(kind=rk), parameter :: R = 1.00_rk major radius real(kind=rk), parameter :: center (3) = [0.0_rk, 0.0_rk, 0.0_rk] center of the ring integer :: i real(kind=rk), parameter :: length = 1.0_rk length of the pipe integer, parameter :: nwaves_z = 6 number of sine waves per full loop real(kind=rk), parameter :: phase_z = 0.1_rk phase shift (radians) real(kind=rk), parameter :: r1 = 0.12_rk inner radius real(kind=rk), parameter :: r2 = 0.20_rk outer radius type( nurbs_volume ) :: ring straight pipe segment type( nurbs_volume ) :: shape toroidal pipe shape real(kind=rk), parameter :: twist_turns = 1.0_rk cross-section twist (turns over full loop) Subroutines pure subroutine map_to_torus_sineZ (this, c, R, twist_turns, Az, nwaves_z, phase_z) Map a straight pipe (ring extruded in ) onto a toroidal pipe with:\n  • cross-section twist: ,\n  • vertical wobble: . Read more… Arguments Type Intent Optional Attributes Name type( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: c (3) real(kind=rk), intent(in) :: R real(kind=rk), intent(in) :: twist_turns real(kind=rk), intent(in) :: Az integer, intent(in) :: nwaves_z real(kind=rk), intent(in) :: phase_z","tags":"","url":"program/example_toroidal_pipe.html"},{"title":"example_put_to_nurbs – ForCAD","text":"Uses forcad_utils forcad program~~example_put_to_nurbs~~UsesGraph program~example_put_to_nurbs example_put_to_nurbs module~forcad forcad program~example_put_to_nurbs->module~forcad module~forcad_utils forcad_utils program~example_put_to_nurbs->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. You can create your shape or use a predefined one\nRead coordinates from file\nRead element connectivities from file\nSet a control shape that will be used to put the shape into\nThe contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points\nBy modifying the control shape you can modify the shape Map the shape into the shape Deallocate local variables Export the shape and the control shape to vtk files\nShow the control geometry and geometry using PyVista Finalize the control shape Calls program~~example_put_to_nurbs~~CallsGraph program~example_put_to_nurbs example_put_to_nurbs none~set~3 nurbs_volume%set program~example_put_to_nurbs->none~set~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_put_to_nurbs->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_put_to_nurbs->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~example_put_to_nurbs->proc~finalize~3 proc~hexahedron_xc hexahedron_Xc program~example_put_to_nurbs->proc~hexahedron_xc proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs proc~show~3 nurbs_volume%show program~example_put_to_nurbs->proc~show~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy set set proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set interface~compute_xg~3 compute_Xg proc~put_to_nurbs->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~put_to_nurbs->proc~is_rational~3 proc~set_elem_xg_vis~3 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis~3 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: X (:,:) type( nurbs_volume ) :: control_shape integer, allocatable :: elem (:,:) integer :: i integer :: nunit","tags":"","url":"program/example_put_to_nurbs.html"},{"title":"fdm_elevate_and_insert_1d – ForCAD","text":"Uses forcad_utils fortime forcad program~~fdm_elevate_and_insert_1d~~UsesGraph program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d fortime fortime program~fdm_elevate_and_insert_1d->fortime module~forcad forcad program~fdm_elevate_and_insert_1d->module~forcad module~forcad_utils forcad_utils program~fdm_elevate_and_insert_1d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. set control points set weights\nset knot vector set NURBS curve deallocate temporary arrays copy initial NURBS curve (before refinement) get initial control points, dimension, number of control points and degrees of freedom\nelevate degree and get sensitivities (Bs: in compact form, memory efficient)\nset knot vectors to insert\nmultiplicities of knots to insert insert knots and get sensitivities (Bs: in compact form, memory efficient)\ncompute global sensitivities (dXc_old/dXc_new)\nget new degrees of freedom (after refinement) start finite difference computations\ncompute relative error between finite difference and analytical sensitivities finalize Calls program~~fdm_elevate_and_insert_1d~~CallsGraph program~fdm_elevate_and_insert_1d fdm_elevate_and_insert_1d none~get_knot~2 nurbs_curve%get_knot program~fdm_elevate_and_insert_1d->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc program~fdm_elevate_and_insert_1d->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc program~fdm_elevate_and_insert_1d->none~get_xc~2 none~set~2 nurbs_curve%set program~fdm_elevate_and_insert_1d->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~fdm_elevate_and_insert_1d->proc~elevate_degree~2 proc~finalize~2 nurbs_curve%finalize program~fdm_elevate_and_insert_1d->proc~finalize~2 proc~generate_xc~5 generate_Xc program~fdm_elevate_and_insert_1d->proc~generate_xc~5 proc~insert_knots~2 nurbs_curve%insert_knots program~fdm_elevate_and_insert_1d->proc~insert_knots~2 proc~kron_eye kron_eye program~fdm_elevate_and_insert_1d->proc~kron_eye proc~linspace linspace program~fdm_elevate_and_insert_1d->proc~linspace timer_start timer_start program~fdm_elevate_and_insert_1d->timer_start timer_stop timer_stop program~fdm_elevate_and_insert_1d->timer_stop proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~is_rational~2 nurbs_curve%is_rational proc~elevate_degree~2->proc~is_rational~2 proc~insert_knots~2->none~set~2 interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~2->proc~is_rational~2 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~factln factln proc~bincoeff->proc~factln proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: Bfd (:,:) real(kind=rk), allocatable :: Bs (:,:) real(kind=rk), allocatable :: S1 (:,:) real(kind=rk), allocatable :: S2 (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xc0 (:,:) real(kind=rk), allocatable :: Xcm_vec (:) real(kind=rk), allocatable :: Xcp_vec (:) real(kind=rk), allocatable :: Xm (:,:) real(kind=rk), allocatable :: Xp (:,:) integer :: d integer :: dim integer :: i integer :: idx real(kind=rk), allocatable :: knot (:) integer :: nc0 integer :: ndof_new integer :: ndof_old integer, parameter :: nins = 5 number of knots to insert integer, allocatable :: r (:) real(kind=rk) :: rel_err type( nurbs_curve ) :: sh0 type( nurbs_curve ) :: shfd type( nurbs_curve ) :: shr type(timer) :: t integer, parameter :: tdeg = 3 degrees to elevate real(kind=rk), parameter :: tol = 1e-5_rk tolerance of finite differences real(kind=rk), allocatable :: u (:) Functions pure function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:)","tags":"","url":"program/fdm_elevate_and_insert_1d.html"},{"title":"example_ppm2 – ForCAD","text":"Uses forcolormap fortime forcad forimage program~~example_ppm2~~UsesGraph program~example_ppm2 example_ppm2 forcolormap forcolormap program~example_ppm2->forcolormap forimage forimage program~example_ppm2->forimage fortime fortime program~example_ppm2->fortime module~forcad forcad program~example_ppm2->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm2~~CallsGraph program~example_ppm2 example_ppm2 compute_rgb compute_rgb program~example_ppm2->compute_rgb export_pnm export_pnm program~example_ppm2->export_pnm get_b get_b program~example_ppm2->get_b get_g get_g program~example_ppm2->get_g get_r get_r program~example_ppm2->get_r none~get_xg nurbs_surface%get_Xg program~example_ppm2->none~get_xg proc~create nurbs_surface%create program~example_ppm2->proc~create proc~finalize nurbs_surface%finalize program~example_ppm2->proc~finalize proc~get_ng nurbs_surface%get_ng program~example_ppm2->proc~get_ng proc~rotate_xc nurbs_surface%rotate_Xc program~example_ppm2->proc~rotate_xc proc~set_half_ring nurbs_surface%set_half_ring program~example_ppm2->proc~set_half_ring proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm2->proc~set_tetragon proc~translate_xc nurbs_surface%translate_Xc program~example_ppm2->proc~translate_xc set set program~example_ppm2->set set_pnm set_pnm program~example_ppm2->set_pnm timer_start timer_start program~example_ppm2->timer_start timer_stop timer_stop program~example_ppm2->timer_stop proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid proc~create->set interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~rotation rotation proc~rotate_xc->proc~rotation none~set nurbs_surface%set proc~set_half_ring->none~set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 cosd cosd proc~rotation->cosd sind sind proc~rotation->sind interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","url":"program/example_ppm2.html"},{"title":"compute_length – ForCAD","text":"Uses forcad program~~compute_length~~UsesGraph program~compute_length compute_length module~forcad forcad program~compute_length->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_length~~CallsGraph program~compute_length compute_length none~set~2 nurbs_curve%set program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_length->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~2->proc~cmp_elem~2 interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg interface~unique unique proc~ansatz~2->interface~unique none~derivative~2 nurbs_curve%derivative proc~ansatz~2->none~derivative~2 interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 set set proc~set1a->set proc~set1~2->proc~cmp_degree~2 proc~set1~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->set proc~set3~2->proc~cmp_degree~2 proc~set3~2->set proc~set4~2->set proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~kron kron proc~gauss_legendre_2d->interface~kron interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (2,3) real(kind=rk) :: length type( nurbs_curve ) :: shape","tags":"","url":"program/compute_length.html"},{"title":"compute_area – ForCAD","text":"Uses forcad program~~compute_area~~UsesGraph program~compute_area compute_area module~forcad forcad program~compute_area->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_area~~CallsGraph program~compute_area compute_area none~set nurbs_surface%set program~compute_area->none~set proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~ansatz nurbs_surface%ansatz proc~cmp_area->proc~ansatz proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_area->proc~cmp_elem reduce reduce proc~cmp_area->reduce proc~ansatz->none~set proc~ansatz->proc~cmp_elem interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz->interface~ndgrid interface~unique unique proc~ansatz->interface~unique none~derivative nurbs_surface%derivative proc~ansatz->none~derivative proc~det det proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc set set proc~set1->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->set proc~set3->proc~cmp_degree proc~set3->set proc~set4->set proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar nurbs_surface%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_surface%derivative_vector none~derivative->proc~derivative_vector proc~cmp_degree->proc~get_multiplicity proc~cmp_degree->set proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_surface%is_rational proc~derivative_scalar->proc~is_rational proc~derivative_vector->interface~ndgrid proc~derivative_vector->interface~compute_dtgc proc~derivative_vector->proc~is_rational proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid interface~kron kron proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~compute_dtgc_bspline_2d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (4,3) real(kind=rk) :: area type( nurbs_surface ) :: shape","tags":"","url":"program/compute_area.html"},{"title":"lsq_fit_bspline_1d – ForCAD","text":"Uses forcad program~~lsq_fit_bspline_1d~~UsesGraph program~lsq_fit_bspline_1d lsq_fit_bspline_1d module~forcad forcad program~lsq_fit_bspline_1d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~lsq_fit_bspline_1d~~CallsGraph program~lsq_fit_bspline_1d lsq_fit_bspline_1d none~get_knot~2 nurbs_curve%get_knot program~lsq_fit_bspline_1d->none~get_knot~2 none~get_xg~2 nurbs_curve%get_Xg program~lsq_fit_bspline_1d->none~get_xg~2 none~set~2 nurbs_curve%set program~lsq_fit_bspline_1d->none~set~2 proc~create~2 nurbs_curve%create program~lsq_fit_bspline_1d->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~lsq_fit_bspline_1d->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~lsq_fit_bspline_1d->proc~export_xg~2 proc~get_continuity~2 nurbs_curve%get_continuity program~lsq_fit_bspline_1d->proc~get_continuity~2 proc~get_degree nurbs_curve%get_degree program~lsq_fit_bspline_1d->proc~get_degree proc~get_nc nurbs_curve%get_nc program~lsq_fit_bspline_1d->proc~get_nc proc~lsq_fit_bspline~2 nurbs_curve%lsq_fit_bspline program~lsq_fit_bspline_1d->proc~lsq_fit_bspline~2 proc~show~2 nurbs_curve%show program~lsq_fit_bspline_1d->proc~show~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_xg_all~2 nurbs_curve%get_Xg_all none~get_xg~2->proc~get_xg_all~2 proc~get_xgid~2 nurbs_curve%get_Xgid none~get_xg~2->proc~get_xgid~2 proc~get_xgi~2 nurbs_curve%get_Xgi none~get_xg~2->proc~get_xgi~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set interface~compute_multiplicity compute_multiplicity proc~get_continuity~2->interface~compute_multiplicity proc~basis_bspline basis_bspline proc~lsq_fit_bspline~2->proc~basis_bspline proc~solve solve proc~lsq_fit_bspline~2->proc~solve proc~lsq_fit_bspline~2->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xdata (:,:) real(kind=rk), allocatable :: Xg_eval (:,:) real(kind=rk), allocatable :: Xt (:) type( nurbs_curve ) :: bsp real(kind=rk) :: err1 real(kind=rk) :: err2 real(kind=rk) :: err3 integer :: i integer :: n real(kind=rk), parameter :: pi = acos(-1.0_rk) real(kind=rk) :: rms","tags":"","url":"program/lsq_fit_bspline_1d.html"},{"title":"shape_C_2d – ForCAD","text":"Uses forcad program~~shape_c_2d~~UsesGraph program~shape_c_2d shape_C_2d module~forcad forcad program~shape_c_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_2d~~CallsGraph program~shape_c_2d shape_C_2d proc~create nurbs_surface%create program~shape_c_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_c_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_c_2d->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_c_2d->proc~finalize proc~set_c nurbs_surface%set_C program~shape_c_2d->proc~set_c proc~show nurbs_surface%show program~shape_c_2d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set none~set nurbs_surface%set proc~set_c->none~set proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","url":"program/shape_c_2d.html"},{"title":"lsq_fit_nurbs_1d – ForCAD","text":"Uses forcad program~~lsq_fit_nurbs_1d~~UsesGraph program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d module~forcad forcad program~lsq_fit_nurbs_1d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~lsq_fit_nurbs_1d~~CallsGraph program~lsq_fit_nurbs_1d lsq_fit_nurbs_1d none~get_knot~2 nurbs_curve%get_knot program~lsq_fit_nurbs_1d->none~get_knot~2 none~get_xg~2 nurbs_curve%get_Xg program~lsq_fit_nurbs_1d->none~get_xg~2 none~set~2 nurbs_curve%set program~lsq_fit_nurbs_1d->none~set~2 proc~create~2 nurbs_curve%create program~lsq_fit_nurbs_1d->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~lsq_fit_nurbs_1d->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~lsq_fit_nurbs_1d->proc~export_xg~2 proc~get_continuity~2 nurbs_curve%get_continuity program~lsq_fit_nurbs_1d->proc~get_continuity~2 proc~get_degree nurbs_curve%get_degree program~lsq_fit_nurbs_1d->proc~get_degree proc~get_nc nurbs_curve%get_nc program~lsq_fit_nurbs_1d->proc~get_nc proc~lsq_fit_nurbs~2 nurbs_curve%lsq_fit_nurbs program~lsq_fit_nurbs_1d->proc~lsq_fit_nurbs~2 proc~show~2 nurbs_curve%show program~lsq_fit_nurbs_1d->proc~show~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_xg_all~2 nurbs_curve%get_Xg_all none~get_xg~2->proc~get_xg_all~2 proc~get_xgid~2 nurbs_curve%get_Xgid none~get_xg~2->proc~get_xgid~2 proc~get_xgi~2 nurbs_curve%get_Xgi none~get_xg~2->proc~get_xgi~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set interface~compute_multiplicity compute_multiplicity proc~get_continuity~2->interface~compute_multiplicity proc~basis_bspline basis_bspline proc~lsq_fit_nurbs~2->proc~basis_bspline proc~solve solve proc~lsq_fit_nurbs~2->proc~solve proc~lsq_fit_nurbs~2->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xdata (:,:) real(kind=rk), allocatable :: Xg_eval (:,:) real(kind=rk), allocatable :: Xt (:) real(kind=rk) :: err1 real(kind=rk) :: err2 real(kind=rk) :: err3 integer :: i integer :: n type( nurbs_curve ) :: nrb real(kind=rk), parameter :: pi = acos(-1.0_rk) real(kind=rk) :: rms","tags":"","url":"program/lsq_fit_nurbs_1d.html"},{"title":"poisson_iga_solver_2d – ForCAD","text":"Uses forcad_utils fortime forcad program~~poisson_iga_solver_2d~~UsesGraph program~poisson_iga_solver_2d poisson_iga_solver_2d fortime fortime program~poisson_iga_solver_2d->fortime module~forcad forcad program~poisson_iga_solver_2d->module~forcad module~forcad_utils forcad_utils program~poisson_iga_solver_2d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Solves the 2D Poisson problem using Isogeometric Analysis (IGA). This code solves the equation: using a B-spline surface on a rectangular domain. The solution is discretized using tensor-product B-spline basis functions\nover a structured control net. The global linear system is assembled and\nsolved using a basic internal Cholesky solver. The resulting solution is exported to VTK format for visualization. The L2 error norm with respect to the exact solution\nis computed and printed. Note This implementation uses B-spline geometry (no rational weights), hence the surface is not a full NURBS. Warning \"Slow solver\"\nThe solver uses an internal Cholesky factorization which is not optimized. For large systems, consider replacing it with a more scalable external solver. Domain size and number of control points\nNumber knots to insert in each direction\nMode numbers for the source term and exact solution\nResolution of the visualization grid\nfilename for VTK export Construct the NURBS surface\nFor simplicity, set_tetragon creates a rectangular surface with uniform knot spacing\nFor more complex geometries, use surf%set() with knots, continuity,... Insert knots in the first and second directions\nExtract geometry and mesh structure\nAssemble global stiffness matrix and load vector\nApply homogeneous Dirichlet boundary conditions\nSolve the linear system K·X = b\nExport solution at control points to VTK Interpolate solution and export field\nCompute the L2 error norm Calls program~~poisson_iga_solver_2d~~CallsGraph program~poisson_iga_solver_2d poisson_iga_solver_2d none~basis nurbs_surface%basis program~poisson_iga_solver_2d->none~basis none~get_degree nurbs_surface%get_degree program~poisson_iga_solver_2d->none~get_degree none~get_nc nurbs_surface%get_nc program~poisson_iga_solver_2d->none~get_nc none~get_xc nurbs_surface%get_Xc program~poisson_iga_solver_2d->none~get_xc proc~ansatz nurbs_surface%ansatz program~poisson_iga_solver_2d->proc~ansatz proc~cmp_elem nurbs_surface%cmp_elem program~poisson_iga_solver_2d->proc~cmp_elem proc~create nurbs_surface%create program~poisson_iga_solver_2d->proc~create proc~exact_solution~2 exact_solution program~poisson_iga_solver_2d->proc~exact_solution~2 proc~export_xc nurbs_surface%export_Xc program~poisson_iga_solver_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~poisson_iga_solver_2d->proc~export_xg proc~finalize nurbs_surface%finalize program~poisson_iga_solver_2d->proc~finalize proc~insert_knots nurbs_surface%insert_knots program~poisson_iga_solver_2d->proc~insert_knots proc~set_tetragon nurbs_surface%set_tetragon program~poisson_iga_solver_2d->proc~set_tetragon proc~solve solve program~poisson_iga_solver_2d->proc~solve proc~source_term~2 source_term program~poisson_iga_solver_2d->proc~source_term~2 timer_start timer_start program~poisson_iga_solver_2d->timer_start timer_stop timer_stop program~poisson_iga_solver_2d->timer_stop proc~basis_scalar nurbs_surface%basis_scalar none~basis->proc~basis_scalar proc~basis_vector nurbs_surface%basis_vector none~basis->proc~basis_vector proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_nc_all nurbs_surface%get_nc_all none~get_nc->proc~get_nc_all proc~get_nc_dir nurbs_surface%get_nc_dir none~get_nc->proc~get_nc_dir proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~ansatz->proc~cmp_elem interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz->interface~ndgrid interface~unique unique proc~ansatz->interface~unique none~derivative nurbs_surface%derivative proc~ansatz->none~derivative none~set nurbs_surface%set proc~ansatz->none~set proc~det det proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem->proc~get_multiplicity interface~compute_xg compute_Xg proc~create->interface~compute_xg proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xc->set proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xg->set interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity none~get_knot nurbs_surface%get_knot proc~insert_knots->none~get_knot proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots->proc~is_rational s_loc s_loc proc~insert_knots->s_loc proc~insert_knots->set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar nurbs_surface%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_surface%derivative_vector none~derivative->proc~derivative_vector proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 proc~basis_scalar->proc~is_rational interface~compute_tgc compute_Tgc proc~basis_scalar->interface~compute_tgc proc~basis_vector->interface~ndgrid proc~basis_vector->proc~is_rational proc~basis_vector->interface~compute_tgc interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~get_multiplicity->interface~compute_multiplicity proc~get_nc_dir->interface~compute_multiplicity proc~inv->proc~solve proc~inv->proc~det proc~inv->proc~inv proc~eye eye proc~inv->proc~eye proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc->proc~compute_tgc_nurbs_2d_vector proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~derivative_scalar->proc~is_rational interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector->interface~ndgrid proc~derivative_vector->proc~is_rational proc~derivative_vector->interface~compute_dtgc proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->proc~gauss_legendre proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_2d_vector proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->proc~get_multiplicity proc~cmp_degree->set proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc->set proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_tgc_bspline_2d_scalar->interface~kron proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->interface~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->interface~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->interface~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_dtgc_bspline_2d_scalar->interface~kron interface~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->interface~kron proc~compute_dtgc_bspline_2d_vector->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->interface~kron proc~compute_dtgc_nurbs_2d_scalar->interface~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->interface~kron proc~compute_dtgc_nurbs_2d_vector->interface~basis_bspline_der proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: K (:,:) Global stiffness matrix real(kind=rk) :: L (2) Domain size real(kind=rk), allocatable :: T (:) Basis function values at quadrature point real(kind=rk), allocatable :: X (:,:) Global solution vector real(kind=rk), allocatable :: Xc (:,:) Control point coordinates real(kind=rk), allocatable :: Xg (:) Physical coordinates at quadrature point real(kind=rk), allocatable :: b (:) Global right-hand side vector real(kind=rk) :: dA Differential element area real(kind=rk), allocatable :: dT (:,:) Derivatives of basis functions at quadrature point integer, allocatable :: dirichlet_id (:) Indices for Dirichlet boundary conditions integer :: dof Degrees of freedom per control point (1 for scalar field) integer, allocatable :: elem (:,:) Element connectivity matrix integer, allocatable :: elem_e (:) Local connectivity of current element character(len=256) :: filename Filename for VTK export integer :: i Generic loop index integer :: ie Element index integer :: ig Quadrature (Gauss) point index integer :: ki (2) Number of knots to insert in each direction real(kind=rk) :: l2_error L2 error norm accumulator integer :: m (2) Mode numbers for source and exact solution integer :: nc (2) Number of control points in each direction integer :: nct Total number of control points integer :: ndof Total degrees of freedom integer :: nelem Number of elements integer :: nnelem Number of local nodes per element real(kind=rk), parameter :: pi = acos(-1.0_rk) Constant integer :: res (2) Visualization resolution type( nurbs_surface ) :: surf NURBS surface object type(timer) :: ti Timer object for performance measurement real(kind=rk), allocatable :: u_h (:,:) Interpolated solution field on grid Functions pure function exact_solution (p, d, n) result(u) Computes the exact solution corresponding to the source term Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (2) Coordinates (x, y) real(kind=rk), intent(in) :: d (2) Domain size (L1, L2) integer, intent(in) :: n (2) Mode numbers (m1, m2) Return Value real(kind=rk) pure function source_term (p, d, n) result(f) Computes the source function Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: p (2) Coordinates (x, y) real(kind=rk), intent(in) :: d (2) Domain size (L1, L2) integer, intent(in) :: n (2) Mode numbers (m1, m2) Return Value real(kind=rk)","tags":"","url":"program/poisson_iga_solver_2d.html"},{"title":"example3_volume – ForCAD","text":"Uses forcad program~~example3_volume~~UsesGraph program~example3_volume example3_volume module~forcad forcad program~example3_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. Define the control points for the NURBS volume Define weights for the control points (optional)\nDefine knot vectors for all three dimensions\nSet knot vectors, control points, and weights for the NURBS volume object\nWc is optional. Deallocate local arrays Export parameter space to a VTK file Export the control points to a VTK file Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions Export the generated volume to a VTK file Export the NURBS volume to an IGES file\nNot supported for volumes.\nShow the control geometry and geometry using PyVista Print size of knot vectors\nInsert knots 0.25 and 0.75 in all three directions\nPrint size of knot vectors after inserting knots\nPrint degrees Elevate degree by 2 in all three directions\nPrint degrees after elevating Print size of knot vectors\nPrint size of knot vectors after removing knots\nGenerate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions Export refined parameter space to a VTK file Export updated control points to a VTK file Export the refined generated volume to a VTK file Export the NURBS volume to an IGES file\nNot supported for volumes.\nShow the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export parameter space to a VTK file Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Export the NURBS volume to an IGES file\nNot supported for volumes.\nShow the control geometry and geometry using PyVista first compute and set the connectivities of volume elements get the connectivity of the face1 of the first element\nget the degree of the faces\nFinalize the NURBS volume object Calls program~~example3_volume~~CallsGraph program~example3_volume example3_volume none~get_degree~3 nurbs_volume%get_degree program~example3_volume->none~get_degree~3 none~get_knot~3 nurbs_volume%get_knot program~example3_volume->none~get_knot~3 none~set~3 nurbs_volume%set program~example3_volume->none~set~3 proc~cmp_degreeface nurbs_volume%cmp_degreeFace program~example3_volume->proc~cmp_degreeface proc~cmp_elemface nurbs_volume%cmp_elemFace program~example3_volume->proc~cmp_elemface proc~cmp_elem~3 nurbs_volume%cmp_elem program~example3_volume->proc~cmp_elem~3 proc~create~3 nurbs_volume%create program~example3_volume->proc~create~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree~3 proc~export_xc~3 nurbs_volume%export_Xc program~example3_volume->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example3_volume->proc~export_xg~3 proc~export_xth~3 nurbs_volume%export_Xth program~example3_volume->proc~export_xth~3 proc~finalize~3 nurbs_volume%finalize program~example3_volume->proc~finalize~3 proc~generate_xc~6 generate_Xc program~example3_volume->proc~generate_xc~6 proc~insert_knots~3 nurbs_volume%insert_knots program~example3_volume->proc~insert_knots~3 proc~remove_knots~3 nurbs_volume%remove_knots program~example3_volume->proc~remove_knots~3 proc~rotate_xc~3 nurbs_volume%rotate_Xc program~example3_volume->proc~rotate_xc~3 proc~rotate_xg~3 nurbs_volume%rotate_Xg program~example3_volume->proc~rotate_xg~3 proc~set_elem~3 nurbs_volume%set_elem program~example3_volume->proc~set_elem~3 proc~show~3 nurbs_volume%show program~example3_volume->proc~show~3 proc~translate_xc~3 nurbs_volume%translate_Xc program~example3_volume->proc~translate_xc~3 proc~translate_xg~3 nurbs_volume%translate_Xg program~example3_volume->proc~translate_xg~3 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth~3->interface~ndgrid proc~export_xth~3->interface~unique proc~cmp_elem_xth~3 nurbs_volume%cmp_elem_Xth proc~export_xth~3->proc~cmp_elem_xth~3 proc~export_xth~3->proc~export_vtk_legacy proc~insert_knots~3->none~get_knot~3 interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc proc~insert_knots~3->set proc~remove_knots~3->none~get_knot~3 proc~remove_knots~3->none~set~3 proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~3->proc~rotation proc~rotate_xg~3->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem_xth~3->interface~unique proc~cmp_elem_xth~3->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_multiplicity~3->interface~compute_multiplicity cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_degree~3->set proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot2 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot3 (4) Arrays for knot vectors in all three dimensions type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","url":"program/example3_volume.html"},{"title":"example_nurbs_curve – ForCAD","text":"Uses forcad program~~example_nurbs_curve~~UsesGraph program~example_nurbs_curve example_nurbs_curve module~forcad forcad program~example_nurbs_curve->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve.\nIt sets up control points and weights, generates the curve, and exports the control points\nand the curve to VTK files at various stages. Define control points for the NURBS curve Define weights for the control points Set control points and weights for the NURBS curve object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS curve with a resolution of 500 Export the generated curve to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example_nurbs_curve~~CallsGraph program~example_nurbs_curve example_nurbs_curve none~set~2 nurbs_curve%set program~example_nurbs_curve->none~set~2 proc~create~2 nurbs_curve%create program~example_nurbs_curve->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~example_nurbs_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~example_nurbs_curve->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~example_nurbs_curve->proc~finalize~2 proc~generate_xc~7 generate_Xc program~example_nurbs_curve->proc~generate_xc~7 proc~show~2 nurbs_curve%show program~example_nurbs_curve->proc~show~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_tgc_1d->proc~basis_bspline proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_curve ) :: nurbs Declare a NURBS curve object Functions function generate_Xc (num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","url":"program/example_nurbs_curve.html"},{"title":"example_plate_hole_4_3d – ForCAD","text":"Uses forcad program~~example_plate_hole_4_3d~~UsesGraph program~example_plate_hole_4_3d example_plate_hole_4_3d module~forcad forcad program~example_plate_hole_4_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example_plate_hole_4_3d~~CallsGraph program~example_plate_hole_4_3d example_plate_hole_4_3d none~set~3 nurbs_volume%set program~example_plate_hole_4_3d->none~set~3 proc~create~3 nurbs_volume%create program~example_plate_hole_4_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_plate_hole_4_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_plate_hole_4_3d->proc~export_xg~3 proc~export_xth_in_xg~2 nurbs_volume%export_Xth_in_Xg program~example_plate_hole_4_3d->proc~export_xth_in_xg~2 proc~set_xc_wc~6 set_Xc_Wc program~example_plate_hole_4_3d->proc~set_xc_wc~6 proc~show~3 nurbs_volume%show program~example_plate_hole_4_3d->proc~show~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 set set proc~create~3->set proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xc~3->set proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xg~3->set proc~export_xth_in_xg~2->interface~compute_xg~3 interface~unique unique proc~export_xth_in_xg~2->interface~unique proc~export_xth_in_xg~2->proc~export_vtk_legacy proc~export_xth_in_xg~2->proc~is_rational~3 proc~export_xth_in_xg~2->set cosd cosd proc~set_xc_wc~6->cosd tand tand proc~set_xc_wc~6->tand proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg~3->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg~3->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg~3->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg~3->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_3d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point->interface~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->interface~kron proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_3d->interface~kron proc~cmp_tgc_3d->proc~basis_bspline proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), parameter :: height = 5.0_rk real(kind=rk), parameter :: length = 5.0_rk type( nurbs_volume ) :: plate_hole real(kind=rk), parameter :: radius1 = 2.5_rk real(kind=rk), parameter :: radius2 = 3.5_rk real(kind=rk), parameter :: width = 0.5_rk Subroutines pure subroutine set_Xc_Wc (tp, params, X_c, W_c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tp real(kind=rk), intent(in), contiguous :: params (:) real(kind=rk), intent(out), allocatable :: X_c (:,:) real(kind=rk), intent(out), allocatable :: W_c (:)","tags":"","url":"program/example_plate_hole_4_3d.html"},{"title":"example_ppm1 – ForCAD","text":"Uses forcolormap fortime forcad forimage program~~example_ppm1~~UsesGraph program~example_ppm1 example_ppm1 forcolormap forcolormap program~example_ppm1->forcolormap forimage forimage program~example_ppm1->forimage fortime fortime program~example_ppm1->fortime module~forcad forcad program~example_ppm1->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm1~~CallsGraph program~example_ppm1 example_ppm1 compute_rgb compute_rgb program~example_ppm1->compute_rgb export_pnm export_pnm program~example_ppm1->export_pnm get_b get_b program~example_ppm1->get_b get_g get_g program~example_ppm1->get_g get_r get_r program~example_ppm1->get_r none~get_xg nurbs_surface%get_Xg program~example_ppm1->none~get_xg proc~create nurbs_surface%create program~example_ppm1->proc~create proc~finalize nurbs_surface%finalize program~example_ppm1->proc~finalize proc~get_ng nurbs_surface%get_ng program~example_ppm1->proc~get_ng proc~set_ring nurbs_surface%set_ring program~example_ppm1->proc~set_ring proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm1->proc~set_tetragon set set program~example_ppm1->set set_pnm set_pnm program~example_ppm1->set_pnm timer_start timer_start program~example_ppm1->timer_start timer_stop timer_stop program~example_ppm1->timer_stop proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid proc~create->set interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational none~set nurbs_surface%set proc~set_ring->none~set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","url":"program/example_ppm1.html"},{"title":"fdm_elevate_and_insert_3d – ForCAD","text":"Uses forcad_utils fortime forcad program~~fdm_elevate_and_insert_3d~~UsesGraph program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d fortime fortime program~fdm_elevate_and_insert_3d->fortime module~forcad forcad program~fdm_elevate_and_insert_3d->module~forcad module~forcad_utils forcad_utils program~fdm_elevate_and_insert_3d->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. set control points set weights\nset knot vectors\nset NURBS volume deallocate temporary arrays copy initial NURBS volume (before refinement) get initial control points, dimension, number of control points and degrees of freedom\nelevate degree in three directions and get sensitivities (Bs: in compact form, memory efficient)\nset knot vectors to insert\nmultiplicities of knots to insert\ninsert knots in three directions and get sensitivities (Bs: in compact form, memory efficient)\ncompute global sensitivities (dXc_old/dXc_new)\nget new degrees of freedom (after refinement) start finite difference computations\ncompute relative error between finite difference and analytical sensitivities finalize Calls program~~fdm_elevate_and_insert_3d~~CallsGraph program~fdm_elevate_and_insert_3d fdm_elevate_and_insert_3d none~get_knot~3 nurbs_volume%get_knot program~fdm_elevate_and_insert_3d->none~get_knot~3 none~get_wc~3 nurbs_volume%get_Wc program~fdm_elevate_and_insert_3d->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc program~fdm_elevate_and_insert_3d->none~get_xc~3 none~set~3 nurbs_volume%set program~fdm_elevate_and_insert_3d->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~fdm_elevate_and_insert_3d->proc~elevate_degree~3 proc~finalize~3 nurbs_volume%finalize program~fdm_elevate_and_insert_3d->proc~finalize~3 proc~generate_xc~8 generate_Xc program~fdm_elevate_and_insert_3d->proc~generate_xc~8 proc~insert_knots~3 nurbs_volume%insert_knots program~fdm_elevate_and_insert_3d->proc~insert_knots~3 proc~kron_eye kron_eye program~fdm_elevate_and_insert_3d->proc~kron_eye proc~linspace linspace program~fdm_elevate_and_insert_3d->proc~linspace timer_start timer_start program~fdm_elevate_and_insert_3d->timer_start timer_stop timer_stop program~fdm_elevate_and_insert_3d->timer_stop proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_volume%set4 none~set~3->proc~set4~3 proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~is_rational~3 nurbs_volume%is_rational proc~elevate_degree~3->proc~is_rational~3 proc~insert_knots~3->none~get_knot~3 interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 s_loc s_loc proc~insert_knots~3->s_loc set set proc~insert_knots~3->set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~set1~3->set proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->set proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->set proc~set3~3->proc~cmp_degree~3 proc~set4~3->set proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3->set proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_nc~3->set proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: Bfd (:,:) real(kind=rk), allocatable :: Bs (:,:) real(kind=rk), allocatable :: S1 (:,:) real(kind=rk), allocatable :: S2 (:,:) real(kind=rk), allocatable :: S3 (:,:) real(kind=rk), allocatable :: S4 (:,:) real(kind=rk), allocatable :: S5 (:,:) real(kind=rk), allocatable :: S6 (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xc0 (:,:) real(kind=rk), allocatable :: Xcm_vec (:) real(kind=rk), allocatable :: Xcp_vec (:) real(kind=rk), allocatable :: Xm (:,:) real(kind=rk), allocatable :: Xp (:,:) integer :: d integer, parameter :: dg1 = 4 degrees to elevate integer, parameter :: dg2 = 3 degrees to elevate integer, parameter :: dg3 = 2 degrees to elevate integer :: dim integer :: i integer :: idx real(kind=rk), allocatable :: knot1 (:) real(kind=rk), allocatable :: knot2 (:) real(kind=rk), allocatable :: knot3 (:) integer, parameter :: n1 = 2 number of knots to insert integer, parameter :: n2 = 3 number of knots to insert integer, parameter :: n3 = 4 number of knots to insert integer :: nc0 integer :: ndof_new integer :: ndof_old integer, allocatable :: r1 (:) integer, allocatable :: r2 (:) integer, allocatable :: r3 (:) real(kind=rk) :: rel_err type( nurbs_volume ) :: sh0 type( nurbs_volume ) :: shfd type( nurbs_volume ) :: shr type(timer) :: t real(kind=rk), parameter :: tol = 1e-5_rk tolerance of finite differences real(kind=rk), allocatable :: u1 (:) real(kind=rk), allocatable :: u2 (:) real(kind=rk), allocatable :: u3 (:) Functions pure function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:)","tags":"","url":"program/fdm_elevate_and_insert_3d.html"},{"title":"test_forcad_utils – ForCAD","text":"Uses forcad_utils forunittest forcad_kinds program~~test_forcad_utils~~UsesGraph program~test_forcad_utils test_forcad_utils forunittest forunittest program~test_forcad_utils->forunittest module~forcad_kinds forcad_kinds program~test_forcad_utils->module~forcad_kinds module~forcad_utils forcad_utils program~test_forcad_utils->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Unit test program for forcad_utils .\nusing ForUnitTest: https://github.com/gha3mi/forunittest Calls program~~test_forcad_utils~~CallsGraph program~test_forcad_utils test_forcad_utils check check program~test_forcad_utils->check initialize initialize program~test_forcad_utils->initialize interface~basis_bspline_2der basis_bspline_2der program~test_forcad_utils->interface~basis_bspline_2der interface~basis_bspline_der basis_bspline_der program~test_forcad_utils->interface~basis_bspline_der interface~compute_multiplicity compute_multiplicity program~test_forcad_utils->interface~compute_multiplicity interface~dyad dyad program~test_forcad_utils->interface~dyad interface~elemconn_c0 elemConn_C0 program~test_forcad_utils->interface~elemconn_c0 interface~elemconn_cn elemConn_Cn program~test_forcad_utils->interface~elemconn_cn interface~gauss_leg gauss_leg program~test_forcad_utils->interface~gauss_leg interface~kron kron program~test_forcad_utils->interface~kron interface~ndgrid ndgrid program~test_forcad_utils->interface~ndgrid interface~unique unique program~test_forcad_utils->interface~unique proc~basis_bernstein basis_bernstein program~test_forcad_utils->proc~basis_bernstein proc~basis_bspline basis_bspline program~test_forcad_utils->proc~basis_bspline proc~compute_knot_vector compute_knot_vector program~test_forcad_utils->proc~compute_knot_vector proc~det det program~test_forcad_utils->proc~det proc~elevate_degree_a_5_9 elevate_degree_A_5_9 program~test_forcad_utils->proc~elevate_degree_a_5_9 proc~export_vtk_legacy export_vtk_legacy program~test_forcad_utils->proc~export_vtk_legacy proc~eye eye program~test_forcad_utils->proc~eye proc~findspan findspan program~test_forcad_utils->proc~findspan proc~hexahedron_xc hexahedron_Xc program~test_forcad_utils->proc~hexahedron_xc proc~insert_knot_a_5_1 insert_knot_A_5_1 program~test_forcad_utils->proc~insert_knot_a_5_1 proc~inv inv program~test_forcad_utils->proc~inv proc~kron_eye kron_eye program~test_forcad_utils->proc~kron_eye proc~linspace linspace program~test_forcad_utils->proc~linspace proc~repelem repelem program~test_forcad_utils->proc~repelem proc~rotation rotation program~test_forcad_utils->proc~rotation proc~solve solve program~test_forcad_utils->proc~solve proc~tetragon_xc tetragon_Xc program~test_forcad_utils->proc~tetragon_xc summary summary program~test_forcad_utils->summary proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c proc~basis_bspline_der_a basis_bspline_der_A interface~basis_bspline_der->proc~basis_bspline_der_a proc~basis_bspline_der_b basis_bspline_der_B interface~basis_bspline_der->proc~basis_bspline_der_b proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~compute_knot_vector->proc~repelem proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~inv->proc~det proc~inv->proc~eye proc~inv->proc~inv proc~inv->proc~solve cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~factln factln proc~bincoeff->proc~factln proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~kron proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:) real(kind=rk), allocatable :: A2 (:,:) real(kind=rk) :: A2x2 (2,2) real(kind=rk) :: A4 (2,2) real(kind=rk), allocatable :: A_inv (:,:) real(kind=rk) :: B4 (4) real(kind=rk) :: B_ref (4) real(kind=rk) :: Bk (4,2) real(kind=rk), allocatable :: K1 (:) real(kind=rk), allocatable :: K2 (:) real(kind=rk), allocatable :: K3 (:) real(kind=rk), allocatable :: M (:,:) real(kind=rk), allocatable :: Pw (:,:) real(kind=rk), allocatable :: Qw (:,:) real(kind=rk), allocatable :: R (:,:) real(kind=rk), allocatable :: R_expected (:,:) real(kind=rk), allocatable :: Wksi (:) real(kind=rk), allocatable :: X1 (:) real(kind=rk), allocatable :: X2 (:) real(kind=rk), allocatable :: X3 (:) real(kind=rk), allocatable :: Xksi (:,:) real(kind=rk) :: Xt real(kind=rk), allocatable :: Xt2 (:,:) real(kind=rk), allocatable :: Xt3 (:,:) integer, allocatable :: conn1D (:,:) integer, allocatable :: conn2D (:,:) integer, allocatable :: conn3D (:,:) real(kind=rk) :: d2B (4) real(kind=rk) :: d2B_ref (4) real(kind=rk) :: dB (4) real(kind=rk) :: dB_ref (4) integer :: degree integer :: k real(kind=rk) :: knot (7) real(kind=rk), allocatable :: knot_in (:) real(kind=rk), allocatable :: knot_out (:) integer :: nc integer :: nq real(kind=rk), allocatable :: out (:) integer :: p integer :: rr integer :: s real(kind=rk) :: u (2) real(kind=rk), allocatable :: u2 (:) type(unit_tests) :: ut real(kind=rk) :: v (2) real(kind=rk), allocatable :: v2 (:) real(kind=rk), allocatable :: vec (:) character(len=*), parameter :: vtk_file = \"vtk/test_output.vtk\" real(kind=rk) :: w (4) real(kind=rk), allocatable :: w2 (:) Source Code program test_forcad_utils use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , basis_bspline_der , basis_bspline_2der , & basis_bernstein , compute_multiplicity , ndgrid , dyad , kron , unique , findspan , & compute_knot_vector , insert_knot_A_5_1 , remove_knots_A_5_8 , elevate_degree_A_5_9 , & hexahedron_Xc , tetragon_Xc , elemConn_C0 , elemConn_Cn , rotation , det , inv , gauss_leg , & export_vtk_legacy , solve , repelem , linspace , eye , kron_eye use forunittest , only : unit_tests implicit none type ( unit_tests ) :: ut real ( rk ) :: Xt integer :: nc , degree real ( rk ) :: knot ( 7 ) real ( rk ) :: B4 ( 4 ), dB ( 4 ), d2B ( 4 ), A4 ( 2 , 2 ) real ( rk ) :: B_ref ( 4 ), dB_ref ( 4 ), d2B_ref ( 4 ) real ( rk ) :: u ( 2 ), v ( 2 ), w ( 4 ) real ( rk ), allocatable :: u2 (:), v2 (:), w2 (:) real ( rk ) :: A2x2 ( 2 , 2 ), Bk ( 4 , 2 ) real ( rk ), allocatable :: A (:), vec (:), M (:,:) real ( rk ), allocatable :: X1 (:), X2 (:), X3 (:) real ( rk ), allocatable :: Xt2 (:,:), Xt3 (:,:) real ( rk ), allocatable :: R (:,:), R_expected (:,:) real ( rk ), allocatable :: knot_in (:), knot_out (:), Pw (:,:), Qw (:,:) real ( rk ), allocatable :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: K3 (:), K2 (:), K1 (:), out (:) integer , allocatable :: conn1D (:,:), conn2D (:,:), conn3D (:,:) integer :: nq , p , rr , s , k character ( len =* ), parameter :: vtk_file = \"vtk/test_output.vtk\" real ( rk ), allocatable :: A2 (:,:), A_inv (:,:) ! Initialize unit tests call ut % initialize ( n = 57 ) ! ---------------------------- ! Test: basis_bspline ! ---------------------------- degree = 2 nc = 4 knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 0.5_rk , 1.0_rk , 1.0_rk , 1.0_rk ] Xt = 0.5_rk B4 = basis_bspline ( Xt , knot , nc , degree ) B_ref = [ 0.0_rk , 0.5_rk , 0.5_rk , 0.0_rk ] call ut % test ( 1 )% check ( & name = \"basis_bspline\" , & res = B4 , & expected = B_ref , & msg = \"Partition of unity and shape check\" , & group = \"basis\" ) call ut % test ( 2 )% check ( & name = \"basis_sum\" , & res = sum ( B4 ), & expected = 1.0_rk , & msg = \"Partition of unity\" , & group = \"basis\" ) call basis_bspline_der ( Xt , knot , nc , degree , dB , B4 ) dB_ref = [ 0.0_rk , - 2.0_rk , 2.0_rk , 0.0_rk ] call ut % test ( 3 )% check ( & name = \"basis_bspline_der\" , & res = dB , & expected = dB_ref , & msg = \"1st derivative shape check\" , & group = \"basis_der\" ) call basis_bspline_der ( Xt , knot , nc , degree , dB ) call ut % test ( 4 )% check ( & name = \"basis_bspline_der_B\" , & res = dB , & expected = dB_ref , & msg = \"1st derivative alternate\" , & group = \"basis_der\" ) call basis_bspline_2der ( Xt , knot , nc , degree , d2B , dB , B4 ) d2B_ref = [ 0.0_rk , 4.0_rk , - 1 2.0_rk , 8.0_rk ] call ut % test ( 5 )% check ( & name = \"basis_bspline_2der_A\" , & res = d2B , & expected = d2B_ref , & msg = \"2nd derivative shape check A\" , & group = \"basis_2der\" ) call basis_bspline_2der ( Xt , knot , nc , degree , d2B , dB ) call ut % test ( 6 )% check ( & name = \"basis_bspline_2der_B\" , & res = d2B , & expected = d2B_ref , & msg = \"2nd derivative shape check B\" , & group = \"basis_2der\" ) call basis_bspline_2der ( Xt , knot , nc , degree , d2B ) call ut % test ( 7 )% check ( & name = \"basis_bspline_2der_C\" , & res = d2B , & expected = d2B_ref , & msg = \"2nd derivative shape check C\" , & group = \"basis_2der\" ) Xt = - 0.1_rk B4 = basis_bspline ( Xt , knot , nc , degree ) call ut % test ( 8 )% check ( & name = \"basis_out_of_bounds_low\" , & res = sum ( B4 ), & expected = 0.0_rk , & msg = \"Out-of-bounds left\" , & group = \"bounds\" ) Xt = 1.1_rk B4 = basis_bspline ( Xt , knot , nc , degree ) call ut % test ( 9 )% check ( & name = \"basis_out_of_bounds_high\" , & res = sum ( B4 ), & expected = 0.0_rk , & msg = \"Out-of-bounds right\" , & group = \"bounds\" ) ! ---------------------------- ! Test: basis_bernstein ! ---------------------------- call ut % test ( 10 )% check ( & name = \"basis_bernstein_sum\" , & res = sum ( basis_bernstein ( 0.3_rk , 3 )), & expected = 1.0_rk , & msg = \"Bernstein basis partition of unity\" , & group = \"bernstein\" ) ! ---------------------------- ! Test: compute_multiplicity ! ---------------------------- call ut % test ( 11 )% check ( & name = \"compute_multiplicity1\" , & res = compute_multiplicity ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ]), & expected = [ 2 , 2 ], & msg = \"Multiplicity vector\" , & group = \"multiplicity\" ) call ut % test ( 12 )% check ( & name = \"compute_multiplicity2\" , & res = compute_multiplicity ([ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ], 1.0_rk ), & expected = 3 , & msg = \"Multiplicity at value\" , & group = \"multiplicity\" ) ! ---------------------------- ! Test: ndgrid ! ---------------------------- X1 = [ 1.0_rk , 2.0_rk ] X2 = [ 1 0.0_rk , 2 0.0_rk ] X3 = [ 10 0.0_rk ] call ndgrid ( X1 , X2 , Xt2 ) call ndgrid ( X1 , X2 , X3 , Xt3 ) call ut % test ( 13 )% check ( & name = \"ndgrid2_shape\" , & res = shape ( Xt2 ), & expected = [ 4 , 2 ], & msg = \"ndgrid2 shape\" , & group = \"ndgrid\" ) call ut % test ( 14 )% check ( & name = \"ndgrid3_value\" , & res = Xt3 (:, 3 ), & expected = [ 10 0.0_rk , 10 0.0_rk , 10 0.0_rk , 10 0.0_rk ], & msg = \"ndgrid3 constant Z\" , & group = \"ndgrid\" ) ! ---------------------------- ! Test: dyad ! ---------------------------- A = [ 1.0_rk , 2.0_rk ] vec = [ 3.0_rk , 4.0_rk , 5.0_rk ] M = dyad ( A , vec ) call ut % test ( 15 )% check ( & name = \"dyad_check\" , & res = M , & expected = reshape ([ 3.0_rk , 6.0_rk , 4.0_rk , 8.0_rk , 5.0_rk , 1 0.0_rk ], [ 2 , 3 ]), & msg = \"Outer product a .dyad. b\" , & group = \"dyad\" ) ! ---------------------------- ! Test: kron ! ---------------------------- u = [ 1.0_rk , 2.0_rk ] v = [ 3.0_rk , 4.0_rk ] w = kron ( u , v ) call ut % test ( 16 )% check ( & name = \"kron_vector\" , & res = w , & expected = [ 3.0_rk , 4.0_rk , 6.0_rk , 8.0_rk ], & msg = \"u .kron. v\" , & group = \"kron\" ) A2x2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]) Bk = kron ( u , A2x2 ) call ut % test ( 17 )% check ( & name = \"kron_matrix\" , & res = Bk , & expected = reshape ([ 1.0_rk , 2.0_rk , 2.0_rk , 4.0_rk , 3.0_rk , 4.0_rk , 6.0_rk , 8.0_rk ], [ 4 , 2 ]), & msg = \"u .kron. A\" , & group = \"kron\" ) ! ---------------------------- ! Test: unique ! ---------------------------- call ut % test ( 18 )% check ( & name = \"unique_integer\" , & res = unique ([ 1 , 2 , 2 , 3 , 1 , 4 ]), & expected = [ 1 , 2 , 3 , 4 ], & msg = \"Unique integers\" , & group = \"unique\" ) call ut % test ( 19 )% check ( & name = \"unique_real\" , & res = unique ([ 1.0_rk , 1.0_rk + 1e-16_rk , 2.0_rk , 1.0_rk , 3.0_rk ]), & expected = [ 1.0_rk , 2.0_rk , 3.0_rk ], & msg = \"Unique real with tolerance\" , & group = \"unique\" ) ! ---------------------------- ! Test: findspan ! ---------------------------- call ut % test ( 20 )% check ( & name = \"findspan_middle\" , & res = findspan ( 4 , 2 , 0.5_rk , knot ), & expected = 3 , & msg = \"Find span index at Xt=0.5\" , & group = \"findspan\" ) ! ---------------------------- ! Test: compute_knot_vector ! ---------------------------- call ut % test ( 21 )% check ( & name = \"compute_knot_vector\" , & res = compute_knot_vector ([ 0.0_rk , 1.0_rk , 2.0_rk ], 2 , [ - 1 , 1 , - 1 ]), & expected = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 2.0_rk , 2.0_rk , 2.0_rk ], & msg = \"Knot vector construction\" , & group = \"knot\" ) ! ---------------------------- ! Test: repelem ! ---------------------------- call ut % test ( 22 )% check ( & name = \"repelem\" , & res = repelem ([ 1.0_rk , 2.0_rk , 3.0_rk ], [ 2 , 1 , 3 ]), & expected = [ 1.0_rk , 1.0_rk , 2.0_rk , 3.0_rk , 3.0_rk , 3.0_rk ], & msg = \"Repeat vector elements\" , & group = \"repelem\" ) ! ---------------------------- ! Test: hexahedron_Xc ! ---------------------------- call ut % test ( 23 )% check ( & name = \"hexahedron_Xc_shape\" , & res = shape ( hexahedron_Xc ([ 1.0_rk , 1.0_rk , 1.0_rk ], [ 2 , 2 , 2 ])), & expected = [ 8 , 3 ], & msg = \"3D grid shape\" , & group = \"geometry\" ) ! ---------------------------- ! Test: tetragon_Xc ! ---------------------------- call ut % test ( 24 )% check ( & name = \"tetragon_Xc_shape\" , & res = shape ( tetragon_Xc ([ 1.0_rk , 1.0_rk ], [ 2 , 2 ])), & expected = [ 4 , 3 ], & msg = \"2D grid shape\" , & group = \"geometry\" ) ! ---------------------------- ! Test: rotation ! ---------------------------- call ut % test ( 25 )% check ( & name = \"rotation_identity\" , & res = rotation ( 0.0_rk , 0.0_rk , 0.0_rk ), & expected = reshape ([ 1.0_rk , 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk ], [ 3 , 3 ]), & msg = \"Rotation(0,0,0) = I\" , & group = \"rotation\" ) ! ---------------------------- ! Test: det ! ---------------------------- call ut % test ( 26 )% check ( & name = \"det_2x2\" , & res = det ( reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ])), & expected = - 2.0_rk , & msg = \"Determinant 2x2\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv ! ---------------------------- call ut % test ( 27 )% check ( & name = \"inv_2x2\" , & res = inv ( reshape ([ 4.0_rk , 7.0_rk , 2.0_rk , 6.0_rk ], [ 2 , 2 ])), & expected = reshape ([ 0.6_rk , - 0.7_rk , - 0.2_rk , 0.4_rk ], [ 2 , 2 ]), & msg = \"Inverse of 2x2\" , & group = \"matrix\" ) ! ---------------------------- ! Test: solve ! ---------------------------- A4 = reshape ([ 4.0_rk , 1.0_rk , 1.0_rk , 3.0_rk ], [ 2 , 2 ]) R_expected = reshape ([ 1.0_rk / 1 1.0_rk , 7.0_rk / 1 1.0_rk ], [ 2 , 1 ]) R = solve ( A4 , reshape ([ 1.0_rk , 2.0_rk ], [ 2 , 1 ])) call ut % test ( 28 )% check ( & name = \"solve_linear_system\" , & res = R , & expected = R_expected , & msg = \"Solving A.X = B\" , & group = \"matrix\" ) ! ---------------------------- ! Test: insert_knot_A_5_1 ! ---------------------------- p = 2 rr = 1 s = 1 k = 3 allocate ( knot_in ( 0 : 6 )) knot_in = [ 0.0_rk , 0.0_rk , 0.0_rk , 0.5_rk , 1.0_rk , 1.0_rk , 1.0_rk ] allocate ( Pw ( 0 : 2 , 1 : 2 )) Pw ( 0 ,:) = [ 0.0_rk , 0.0_rk ] Pw ( 1 ,:) = [ 0.5_rk , 0.5_rk ] Pw ( 2 ,:) = [ 1.0_rk , 1.0_rk ] call insert_knot_A_5_1 ( p , knot_in , Pw , 0.5_rk , k , s , rr , nq , knot_out , Qw ) call ut % test ( 29 )% check ( & name = \"insert_knot_A_5_1_nq\" , & res = nq , & expected = 3 , & msg = \"Inserted knot, new number of control points\" , & group = \"insert_knot\" ) ! ---------------------------- ! Test: elevate_degree_A_5_9 ! ---------------------------- deallocate ( knot_in , knot_out , Pw , Qw ) knot_in = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] allocate ( Pw ( 1 : 2 , 1 : 2 )) Pw ( 1 ,:) = [ 0.0_rk , 0.0_rk ] Pw ( 2 ,:) = [ 0.5_rk , 0.5_rk ] call elevate_degree_A_5_9 ( t = 1 , knot = knot_in , degree = 1 , Xcw = Pw , nc_new = nc , knot_new = knot_out , Xcw_new = Qw ) call ut % test ( 30 )% check ( & name = \"elevate_degree_nc\" , & res = nc , & expected = 3 , & msg = \"New number of control points after elevation\" , & group = \"elevate_degree\" ) ! ---------------------------- ! Test: gauss_legendre_1D ! ---------------------------- call gauss_leg ([ 0.0_rk , 1.0_rk ], 2 , Xksi = vec , Wksi = A ) call ut % test ( 31 )% check ( & name = \"gauss_legendre_1D_pts\" , & res = size ( vec ), & expected = 3 , & msg = \"Number of Gauss points (1D)\" , & group = \"quadrature\" ) ! ---------------------------- ! Test: gauss_legendre_2D ! ---------------------------- call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 2 , 2 ], Xksi = Xksi , Wksi = Wksi ) call ut % test ( 32 )% check ( & name = \"gauss_legendre_2D_shape\" , & res = shape ( Xksi ), & expected = [ 9 , 2 ], & msg = \"Gauss points shape (2D)\" , & group = \"quadrature\" ) ! ---------------------------- ! Test: gauss_legendre_3D ! ---------------------------- call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 , 1 ], Xksi = Xksi , Wksi = Wksi ) call ut % test ( 33 )% check ( & name = \"gauss_legendre_3D_size\" , & res = size ( Xksi , 1 ), & expected = 8 , & msg = \"Number of Gauss points (3D)\" , & group = \"quadrature\" ) ! ---------------------------- ! Test: export_vtk_legacy ! ---------------------------- call export_vtk_legacy ( filename = vtk_file , points = reshape ([ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 0.0_rk , 0.0_rk ], [ 2 , 3 ]), & elemConn = reshape ([ 1 , 2 ], [ 1 , 2 ]), vtkCellType = 3 , encoding = \"binary\" ) call ut % test ( 34 )% check ( & name = \"export_vtk_legacy\" , & res = . true ., & expected = . true ., & msg = \"Export to VTK (not crashing)\" , & group = \"export\" ) call export_vtk_legacy ( filename = vtk_file , points = reshape ([ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 0.0_rk , 0.0_rk ], [ 2 , 3 ]), & elemConn = reshape ([ 1 , 2 ], [ 1 , 2 ]), vtkCellType = 3 , encoding = \"ascii\" ) call ut % test ( 35 )% check ( & name = \"export_vtk_legacy\" , & res = . true ., & expected = . true ., & msg = \"Export to VTK (not crashing)\" , & group = \"export\" ) ! ---------------------------- ! Test: linspace ! ---------------------------- call ut % test ( 36 )% check ( & name = \"linspace_uniform\" , & res = linspace ( 0.0_rk , 1.0_rk , 5 ), & expected = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ], & msg = \"Uniform linspace from 0 to 1\" , & group = \"linspace\" ) ! ---------------------------- ! Test: kron3 ! ---------------------------- K1 = [ 1.0_rk , 2.0_rk ] K2 = [ 3.0_rk ] K3 = [ 4.0_rk , 5.0_rk ] out = kron ( K1 , K2 , K3 ) call ut % test ( 37 )% check ( & name = \"kron3_product\" , & res = out , & expected = [ 1 2.0_rk , 1 5.0_rk , 2 4.0_rk , 3 0.0_rk ], & msg = \"kron3 result values\" , & group = \"kron\" ) ! ---------------------------- ! Test: elemConn_C0 ! ---------------------------- conn1D = elemConn_C0 ( 5 , 2 ) call ut % test ( 38 )% check ( & name = \"elemConn_C0_L\" , & res = conn1D , & expected = reshape ([ 1 , 3 , 2 , 4 , 3 , 5 ], [ 2 , 3 ]), & msg = \"Linear C0 connectivity\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_Cn (L) ! ---------------------------- call elemConn_Cn ( 5 , 2 , [ 0.0_rk , 0.5_rk , 1.0_rk ], [ 3 , 1 , 3 ], conn1D ) call ut % test ( 39 )% check ( & name = \"elemConn_Cn_L\" , & res = conn1D , & expected = reshape ([ 1 , 2 , 2 , 3 , 3 , 4 ], [ 2 , 3 ]), & msg = \"Linear Cn connectivity\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_C0 (2D) ! ---------------------------- conn2D = elemConn_C0 ( 5 , 5 , 2 , 2 ) call ut % test ( 40 )% check ( & name = \"elemConn_C0_S\" , & res = shape ( conn2D ), & expected = [ 4 , 9 ], & msg = \"Surface C0 connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_Cn (2D) ! ---------------------------- call elemConn_Cn ( 5 , 5 , 2 , 2 , [ 0.0_rk , 0.5_rk , 1.0_rk ], [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 3 , 1 , 3 ], [ 3 , 1 , 3 ], conn2D ) call ut % test ( 41 )% check ( & name = \"elemConn_Cn_S\" , & res = shape ( conn2D ), & expected = [ 4 , 9 ], & msg = \"Surface Cn connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_C0 (3D) ! ---------------------------- conn3D = elemConn_C0 ( 5 , 5 , 5 , 2 , 2 , 2 ) call ut % test ( 42 )% check ( & name = \"elemConn_C0_V\" , & res = shape ( conn3D ), & expected = [ 8 , 27 ], & msg = \"Volume C0 connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_Cn (3D) ! ---------------------------- call elemConn_Cn ( 5 , 5 , 5 , 2 , 2 , 2 , & [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 3 , 1 , 3 ], [ 3 , 1 , 3 ], [ 3 , 1 , 3 ], conn3D ) call ut % test ( 43 )% check ( & name = \"elemConn_Cn_V\" , & res = shape ( conn3D ), & expected = [ 8 , 27 ], & msg = \"Volume Cn connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: inv (3x3 matrix) ! ---------------------------- allocate ( A2 ( 3 , 3 )) A2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , & 0.0_rk , 1.0_rk , 4.0_rk , & 5.0_rk , 6.0_rk , 0.0_rk ], [ 3 , 3 ]) A_inv = inv ( A2 ) call ut % test ( 44 )% check ( & name = \"inv_3x3\" , & res = matmul ( A2 , A_inv ), & expected = eye ( 3 ), & msg = \"A . inv(A) = I for 3x3\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv (rectangular 3x2 matrix) ! ---------------------------- deallocate ( A2 , A_inv ) allocate ( A2 ( 3 , 2 )) A2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk , 5.0_rk , 6.0_rk ], [ 3 , 2 ]) A_inv = inv ( A2 ) call ut % test ( 45 )% check ( & name = \"inv_rectangular_3x2\" , & res = matmul ( A_inv , A2 ), & expected = eye ( 2 ), & msg = \"inv(A) . A = I for 3x2\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv (rectangular 2x3 matrix) ! ---------------------------- deallocate ( A2 , A_inv ) allocate ( A2 ( 2 , 3 )) A2 = reshape ([ 1.0_rk , 4.0_rk , 2.0_rk , 5.0_rk , 3.0_rk , 6.0_rk ], [ 2 , 3 ]) A_inv = inv ( A2 ) call ut % test ( 46 )% check ( & name = \"inv_rectangular_2x3\" , & res = matmul ( A2 , A_inv ), & expected = eye ( 2 ), & msg = \"A . inv(A) = I for 2x3\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv (identity matrix) ! ---------------------------- deallocate ( A2 , A_inv ) allocate ( A2 ( 4 , 4 )) A2 = eye ( 4 ) A_inv = inv ( A2 ) call ut % test ( 47 )% check ( & name = \"inv_identity\" , & res = A_inv , & expected = A2 , & msg = \"inv(I) = I\" , & group = \"matrix\" ) call ut % test ( 48 )% check ( & name = \"inv_rectangular_2x3_proj\" , & res = matmul ( A_inv , A2 ), & expected = transpose ( matmul ( A_inv , A2 )), & msg = \"inv(A) . A is symmetric projection (2x3)\" , & group = \"matrix\" ) ! ---------------------------- ! Test: kron_eye ! ---------------------------- if ( allocated ( A2 )) deallocate ( A2 ) allocate ( A2 ( 2 , 2 )) A2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ],[ 2 , 2 ]) R = kron_eye ( A2 , 2 ) call ut % test ( 49 )% check ( & name = \"kron_eye_block_diag\" , & res = R , & expected = reshape ([ & 1.0_rk , 0.0_rk , 2.0_rk , 0.0_rk , & 0.0_rk , 1.0_rk , 0.0_rk , 2.0_rk , & 3.0_rk , 0.0_rk , 4.0_rk , 0.0_rk , & 0.0_rk , 3.0_rk , 0.0_rk , 4.0_rk ], [ 4 , 4 ]), & msg = \"Kronecker with identity blocks\" , & group = \"kron\" ) ! ---------------------------- ! Test: kron_t1_t1 (vector .kron. vector) ! ---------------------------- ! different sizes + negatives/zeros u2 = [ - 1.0_rk , 0.0_rk , 2.0_rk ] v2 = [ 5.0_rk , - 3.0_rk ] w2 = kron ( u2 , v2 ) call ut % test ( 50 )% check ( & name = \"kron_t1_t1_values\" , & res = w2 , & expected = [ - 5.0_rk , 3.0_rk , 0.0_rk , 0.0_rk , 1 0.0_rk , - 6.0_rk ], & msg = \"kron(u,v) concatenates u(i)*v blocks\" , & group = \"kron\" ) ! length matches size(u)*size(v) call ut % test ( 51 )% check ( & name = \"kron_t1_t1_size\" , & res = size ( w2 ), & expected = size ( u2 ) * size ( v2 ), & msg = \"Length of kron(u,v)\" , & group = \"kron\" ) ! non-commutativity (order matters) call ut % test ( 52 )% check ( & name = \"kron_t1_t1_noncommutative\" , & res = all ( w2 == kron ( v2 , u2 )), & expected = . false ., & msg = \"kron(u,v) /= kron(v,u) for vectors\" , & group = \"kron\" ) ! ---------------------------- ! Test: kron3(u, v, w) ! ---------------------------- ! values with zeros/negatives and |v|=2, |w|=1 u2 = [ - 1.0_rk , 2.0_rk ] v2 = [ 0.0_rk , 3.0_rk ] K3 = [ - 2.0_rk ] out = kron ( u2 , v2 , K3 ) ! kron3 call ut % test ( 53 )% check ( & name = \"kron3_values_mixed\" , & res = out , & expected = [ 0.0_rk , 6.0_rk , 0.0_rk , - 1 2.0_rk ], & msg = \"ordering: (u1*v1*w1, u1*v2*w1, u2*v1*w1, u2*v2*w1)\" , & group = \"kron\" ) ! size = |u|*|v|*|w| call ut % test ( 54 )% check ( & name = \"kron3_size\" , & res = size ( out ), & expected = size ( u2 ) * size ( v2 ) * size ( K3 ), & msg = \"length of kron3 output\" , & group = \"kron\" ) ! associativity check: kron3(u,v,w) == kron(u, kron(v,w)) u2 = [ 1.0_rk , 2.0_rk ] v2 = [ 3.0_rk , 4.0_rk ] K3 = [ 5.0_rk ] out = kron ( u2 , v2 , K3 ) w2 = kron ( v2 , K3 ) A = kron ( u2 , w2 ) call ut % test ( 55 )% check ( & name = \"kron3_associativity_vec\" , & res = all ( abs ( out - A ) <= epsilon ( 0.0_rk )), & expected = . true ., & msg = \"kron3 equals kron(u, kron(v,w))\" , & group = \"kron\" ) ! another ordering/values case (|u|=2, |v|=1, |w|=3) u2 = [ 2.0_rk , - 1.0_rk ] v2 = [ 7.0_rk ] K3 = [ 1.0_rk , 0.0_rk , - 2.0_rk ] out = kron ( u2 , v2 , K3 ) call ut % test ( 56 )% check ( & name = \"kron3_values_ordering\" , & res = out , & expected = [ 1 4.0_rk , 0.0_rk , - 2 8.0_rk , - 7.0_rk , 0.0_rk , 1 4.0_rk ], & msg = \"iterate i (u), then j (v), then k (w)\" , & group = \"kron\" ) ! non-commutativity across arguments u2 = [ 1.0_rk , 2.0_rk ] v2 = [ 3.0_rk , 4.0_rk ] K3 = [ 5.0_rk ] ! length-1 w is fine; non-commutativity comes from u vs v call ut % test ( 57 )% check ( & name = \"kron3_noncommutative\" , & res = all ( kron ( u2 , v2 , K3 ) == kron ( v2 , u2 , K3 )), & expected = . false ., & msg = \"kron3(u,v,w) /= kron3(v,u,w)\" , & group = \"kron\" ) ! summary of tests call ut % summary ( & required_score = 10 0.0 , & verbose = 3 , & stop_fail = . false .) end program test_forcad_utils","tags":"","url":"program/test_forcad_utils.html"},{"title":"shape_circle – ForCAD","text":"Uses forcad program~~shape_circle~~UsesGraph program~shape_circle shape_circle module~forcad forcad program~shape_circle->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS circle with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_circle~~CallsGraph program~shape_circle shape_circle proc~create~2 nurbs_curve%create program~shape_circle->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_circle->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_circle->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_circle->proc~finalize~2 proc~set_circle nurbs_curve%set_circle program~shape_circle->proc~set_circle proc~show~2 nurbs_curve%show program~shape_circle->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set none~set~2 nurbs_curve%set proc~set_circle->none~set~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_tgc_1d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","url":"program/shape_circle.html"},{"title":"nearest_point_2d – ForCAD","text":"Uses forcad program~~nearest_point_2d~~UsesGraph program~nearest_point_2d nearest_point_2d module~forcad forcad program~nearest_point_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a surface with 4 control points\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFind the nearest point on the surface to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS surface object Calls program~~nearest_point_2d~~CallsGraph program~nearest_point_2d nearest_point_2d none~set nurbs_surface%set program~nearest_point_2d->none~set proc~create nurbs_surface%create program~nearest_point_2d->proc~create proc~finalize nurbs_surface%finalize program~nearest_point_2d->proc~finalize proc~nearest_point nurbs_surface%nearest_point program~nearest_point_2d->proc~nearest_point proc~nearest_point2 nurbs_surface%nearest_point2 program~nearest_point_2d->proc~nearest_point2 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~set4 nurbs_surface%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational set set proc~create->set proc~nearest_point2->proc~create proc~nearest_point2->proc~finalize proc~nearest_point2->proc~nearest_point none~derivative2 nurbs_surface%derivative2 proc~nearest_point2->none~derivative2 proc~cmp_xg nurbs_surface%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~inv inv proc~nearest_point2->proc~inv proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2->proc~derivative2_vector proc~cmp_xg->interface~compute_xg proc~cmp_xg->proc~is_rational proc~inv->proc~inv proc~det det proc~inv->proc~det proc~eye eye proc~inv->proc~eye proc~solve solve proc~inv->proc~solve proc~set1->set proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->set proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->set proc~set3->proc~cmp_degree proc~set4->set proc~cmp_degree->set proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->set interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~kron kron proc~compute_xg_bspline_2d->interface~kron proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point->interface~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->interface~kron proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_2d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~kron3 kron3 interface~kron->proc~kron3 proc~kron_t1_t1 kron_t1_t1 interface~kron->proc~kron_t1_t1 proc~kron_t1_t2 kron_t1_t2 interface~kron->proc~kron_t1_t2 proc~cmp_tgc_2d->interface~kron proc~cmp_tgc_2d->proc~basis_bspline proc~get_multiplicity->interface~compute_multiplicity proc~compute_d2tgc_bspline_2d_scalar->interface~kron interface~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->interface~kron proc~compute_d2tgc_bspline_2d_vector->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->interface~kron proc~compute_d2tgc_nurbs_2d_scalar->interface~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->interface~kron proc~compute_d2tgc_nurbs_2d_vector->interface~basis_bspline_2der proc~basis_bspline_2der_a basis_bspline_2der_A interface~basis_bspline_2der->proc~basis_bspline_2der_a proc~basis_bspline_2der_b basis_bspline_2der_B interface~basis_bspline_2der->proc~basis_bspline_2der_b proc~basis_bspline_2der_c basis_bspline_2der_C interface~basis_bspline_2der->proc~basis_bspline_2der_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (4) Weights of the control points real(kind=rk) :: Xc (4,3) Control points integer :: id id of the nearest point real(kind=rk) :: nearest_Xg (3) Coordinates of the nearest point on the surface real(kind=rk) :: nearest_Xt (2) Corresponding parametric coordinates of the nearest point type( nurbs_surface ) :: shape Declare a NURBS surface object","tags":"","url":"program/nearest_point_2d.html"},{"title":"shape_C_1d – ForCAD","text":"Uses forcad program~~shape_c_1d~~UsesGraph program~shape_c_1d shape_C_1d module~forcad forcad program~shape_c_1d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_kinds fordebug fordebug module~forcad_nurbs_curve->fordebug module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->fordebug module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->fordebug module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_1d~~CallsGraph program~shape_c_1d shape_C_1d proc~create~2 nurbs_curve%create program~shape_c_1d->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_c_1d->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_c_1d->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_c_1d->proc~finalize~2 proc~set_c~2 nurbs_curve%set_C program~shape_c_1d->proc~set_c~2 proc~show~2 nurbs_curve%show program~shape_c_1d->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 set set proc~create~2->set proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~2->set proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~2->set none~set~2 nurbs_curve%set proc~set_c~2->none~set~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~set1a->set proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->set proc~set1~2->proc~cmp_degree~2 proc~set2~2->set proc~cmp_nc~2 nurbs_curve%cmp_nc proc~set2~2->proc~cmp_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->set proc~set3~2->proc~cmp_degree~2 proc~set4~2->set proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_tgc_1d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","url":"program/shape_c_1d.html"},{"title":"shape_hexahedron.f90 – ForCAD","text":"This file depends on sourcefile~~shape_hexahedron.f90~~EfferentGraph sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_hexahedron use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8]. !> The weights of the control points (Wc) are optional. call shape % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 6 , 8 ]) ! Additional modifications can be made to control points and weights, or the NURBS can be refined using knot insertion or degree elevation. ! call shape%insert_knots(...) ! call shape%elevate_degree(...) ! ... !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_hexahedron_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 8 , 16 , 32 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_hexahedron_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_hexahedron_Xc.vtk' , 'vtk/shape_hexahedron_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_hexahedron.f90.html"},{"title":"example_plate_hole_1_3d.f90 – ForCAD","text":"This file depends on sourcefile~~example_plate_hole_1_3d.f90~~EfferentGraph sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_plate_hole_1_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: plate_hole real ( rk ), allocatable :: Xc (:,:) real ( rk ), allocatable :: Wc (:) real ( rk ), parameter :: radius1 = 2.5_rk real ( rk ), parameter :: radius2 = 3.5_rk real ( rk ), parameter :: length = 5.0_rk real ( rk ), parameter :: height = 5.0_rk real ( rk ), parameter :: width = 0.5_rk call set_Xc_Wc ( 'ellipse' , [ radius1 , radius2 , length , height , width ], Xc , Wc ) call plate_hole % set (& knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 2.0_rk , 2.0_rk , 3.0_rk , 4.0_rk , 4.0_rk , 5.0_rk , 6.0_rk , 6.0_rk , 7.0_rk , 8.0_rk , 8.0_rk , 8.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ,& Wc = Wc & ) call plate_hole % create ( 31 , 31 , 5 ) call plate_hole % export_Xc ( \"vtk/plate_hole_1_3d_Xc.vtk\" ) call plate_hole % export_Xg ( \"vtk/plate_hole_1_3d_Xg.vtk\" ) call plate_hole % export_Xth_in_Xg ( \"vtk/plate_hole_1_3d_Xth.vtk\" ) call plate_hole % show ( \"vtk/plate_hole_1_3d_Xc.vtk\" , \"vtk/plate_hole_1_3d_Xg.vtk\" , \"vtk/plate_hole_1_3d_Xth.vtk\" ) contains !=============================================================================== pure subroutine set_Xc_Wc ( tp , params , X_c , W_c ) character ( len =* ), intent ( in ) :: tp real ( rk ), intent ( in ), contiguous :: params (:) real ( rk ), allocatable , intent ( out ) :: X_c (:,:) real ( rk ), allocatable , intent ( out ) :: W_c (:) real ( rk ) :: r1 , r2 , l , w , h select case ( tp ) case ( 'circle' ) r1 = params ( 1 ) l = params ( 3 ) h = params ( 4 ) w = params ( 5 ) if ( r1 < 0.0_rk ) error stop 'Radius must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' if ( w < 0.0_rk ) error stop 'Width must be positive' allocate ( X_c ( 39 * 2 , 3 )) X_c ( 1 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 2 , 1 : 2 ) = [ - r1 , r1 * tand ( 2 2.5_rk )] X_c ( 3 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 4 , 1 : 2 ) = [ 0.0_rk , r1 ] X_c ( 5 , 1 : 2 ) = [ r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 6 , 1 : 2 ) = [ r1 , r1 * tand ( 2 2.5_rk )] X_c ( 7 , 1 : 2 ) = [ r1 , 0.0_rk ] X_c ( 8 , 1 : 2 ) = [ r1 , - r1 * tand ( 2 2.5_rk )] X_c ( 9 , 1 : 2 ) = [ r1 * tand ( 2 2.5_rk ), - r1 ] X_c ( 10 , 1 : 2 ) = [ 0.0_rk , - r1 ] X_c ( 11 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), - r1 ] X_c ( 12 , 1 : 2 ) = [ - r1 , - r1 * tand ( 2 2.5_rk )] X_c ( 13 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 14 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 16 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 17 , 1 : 2 ) = [ 0.0_rk , ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 18 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 19 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 20 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 21 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), - ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 22 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 23 , 1 : 2 ) = [ 0.0_rk , - ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 24 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 25 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), - ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 26 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 27 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 28 , 1 : 2 ) = [ - l , h ] X_c ( 29 , 1 : 2 ) = [ - l , h ] X_c ( 30 , 1 : 2 ) = [ 0.0_rk , h ] X_c ( 31 , 1 : 2 ) = [ l , h ] X_c ( 32 , 1 : 2 ) = [ l , h ] X_c ( 33 , 1 : 2 ) = [ l , 0.0_rk ] X_c ( 34 , 1 : 2 ) = [ l , - h ] X_c ( 35 , 1 : 2 ) = [ l , - h ] X_c ( 36 , 1 : 2 ) = [ 0.0_rk , - h ] X_c ( 37 , 1 : 2 ) = [ - l , - h ] X_c ( 38 , 1 : 2 ) = [ - l , - h ] X_c ( 39 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 40 : 78 , 1 : 2 ) = X_c ( 1 : 39 , 1 : 2 ) X_c ( 1 : 39 , 3 ) = 0.0_rk X_c ( 40 : 78 , 3 ) = w allocate ( W_c ( 39 * 2 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 , 41 , 42 , 44 , 45 , 47 , 48 , 50 , 51 ]) = ( 1.0_rk + 1.0_rk / sqrt ( 2.0_rk )) / 2.0_rk case ( 'ellipse' ) r1 = params ( 1 ) r2 = params ( 2 ) l = params ( 3 ) h = params ( 4 ) w = params ( 5 ) if ( r1 < 0.0_rk ) error stop 'Radius1 must be positive' if ( r2 < 0.0_rk ) error stop 'Radius2 must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' if ( w < 0.0_rk ) error stop 'Width must be positive' allocate ( X_c ( 39 * 2 , 3 )) X_c ( 1 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 2 , 1 : 2 ) = [ - r1 , r2 * tand ( 2 2.5_rk )] X_c ( 3 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 4 , 1 : 2 ) = [ 0.0_rk , r2 ] X_c ( 5 , 1 : 2 ) = [ r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 6 , 1 : 2 ) = [ r1 , r2 * tand ( 2 2.5_rk )] X_c ( 7 , 1 : 2 ) = [ r1 , 0.0_rk ] X_c ( 8 , 1 : 2 ) = [ r1 , - r2 * tand ( 2 2.5_rk )] X_c ( 9 , 1 : 2 ) = [ r1 * tand ( 2 2.5_rk ), - r2 ] X_c ( 10 , 1 : 2 ) = [ 0.0_rk , - r2 ] X_c ( 11 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), - r2 ] X_c ( 12 , 1 : 2 ) = [ - r1 , - r2 * tand ( 2 2.5_rk )] X_c ( 13 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 14 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 16 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 17 , 1 : 2 ) = [ 0.0_rk , ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 18 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 19 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 20 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 21 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), - ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 22 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 23 , 1 : 2 ) = [ 0.0_rk , - ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 24 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 25 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), - ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 26 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 27 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 28 , 1 : 2 ) = [ - l , h ] X_c ( 29 , 1 : 2 ) = [ - l , h ] X_c ( 30 , 1 : 2 ) = [ 0.0_rk , h ] X_c ( 31 , 1 : 2 ) = [ l , h ] X_c ( 32 , 1 : 2 ) = [ l , h ] X_c ( 33 , 1 : 2 ) = [ l , 0.0_rk ] X_c ( 34 , 1 : 2 ) = [ l , - h ] X_c ( 35 , 1 : 2 ) = [ l , - h ] X_c ( 36 , 1 : 2 ) = [ 0.0_rk , - h ] X_c ( 37 , 1 : 2 ) = [ - l , - h ] X_c ( 38 , 1 : 2 ) = [ - l , - h ] X_c ( 39 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 40 : 78 , 1 : 2 ) = X_c ( 1 : 39 , 1 : 2 ) X_c ( 1 : 39 , 3 ) = 0.0_rk X_c ( 40 : 78 , 3 ) = w allocate ( W_c ( 39 * 2 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 , 41 , 42 , 44 , 45 , 47 , 48 , 50 , 51 ]) = cosd ( 2 2.5_rk ) case default error stop 'set_Xc_Wc: Invalid type. Valid types are: circle, ellipse' end select end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_plate_hole_1_3d.f90.html"},{"title":"test_nurbs_volume.f90 – ForCAD","text":"This file depends on sourcefile~~test_nurbs_volume.f90~~EfferentGraph sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_nurbs_volume use forcad , only : rk , nurbs_volume use forunittest , only : unit_test implicit none type ( nurbs_volume ) :: nurbs , bsp real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xg (:,:), Xgb (:,:) integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Tgc (:,:), dTgc (:,:,:), Tgcb (:,:), dTgcb (:,:,:), d2Tgc (:,:,:), d2Tgcb (:,:,:) real ( rk ), allocatable :: Tgc1 (:), dTgc1 (:,:), Tgc1b (:), dTgc1b (:,:), d2Tgc1 (:,:), d2Tgc1b (:,:) real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ), volume , volumeb integer :: i , id real ( rk ) :: nearest_Xg ( 3 ), nearest_Xt ( 3 ) type ( unit_test ) :: ut allocate ( Xc ( 8 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 5.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 5.0_rk ] Xc ( 6 ,:) = [ 5.0_rk , 0.0_rk , 5.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 5.0_rk , 5.0_rk ] Xc ( 8 ,:) = [ 5.0_rk , 5.0_rk , 5.0_rk ] allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 0.9_rk knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) call bsp % set ( knot1 , knot2 , knot3 , Xc ) call nurbs % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc (), Wc = nurbs % get_Wc ()) call bsp % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc ()) call nurbs % create ( 20 , 20 , 20 ) call bsp % create ( 20 , 20 , 20 ) call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call nurbs % cmp_volume ( volume ) call bsp % cmp_volume ( volumeb ) call ut % check ( res = volume , expected = 12 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_volume: 01\" ) call ut % check ( res = volumeb , expected = 12 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_volume: 02\" ) call nurbs % nearest_point ([ 0.0_rk , 0.0_rk , - 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 03\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 04\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_volume: 05\" ) call bsp % nearest_point ([ 0.0_rk , 0.0_rk , - 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 06\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 07\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_volume: 08\" ) call nurbs % nearest_point2 ([ 0.0_rk , 0.0_rk , - 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 09\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 10\" ) call bsp % nearest_point2 ([ 0.0_rk , 0.0_rk , - 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 11\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 12\" ) Xg = nurbs % get_Xg () Xgb = bsp % get_Xg () call nurbs % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc , Wc ) call bsp % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 13\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 14\" ) call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) call bsp % set ([ 2 , 2 , 2 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 15\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 16\" ) call nurbs % create ( Xt1 = nurbs % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call bsp % create ( Xt1 = bsp % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 17\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 18\" ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 19\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 20\" ) call ut % check ( res = nurbs % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 21\" ) call ut % check ( res = bsp % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 22\" ) call ut % check ( res = nurbs % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 23\" ) call ut % check ( res = bsp % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 24\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 25\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 26\" ) call ut % check ( res = nurbs % get_Xg ( 1 ), expected = Xg ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 27\" ) call ut % check ( res = bsp % get_Xg ( 1 ), expected = Xgb ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 28\" ) call ut % check ( res = nurbs % get_Xg ( 1 , 1 ), expected = Xg ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 29\" ) call ut % check ( res = bsp % get_Xg ( 1 , 1 ), expected = Xgb ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 30\" ) call ut % check ( res = nurbs % get_Wc (), expected = Wc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 31\" ) call ut % check ( res = nurbs % get_Wc ( 1 ), expected = Wc ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 32\" ) call ut % check ( res = nurbs % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_volume: 33\" ) call ut % check ( res = bsp % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_volume: 34\" ) call ut % check ( res = nurbs % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 35\" ) call ut % check ( res = bsp % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 36\" ) ! call ut%check(res=nurbs%get_ng(), expected=size(Xg,1), msg=\"test_nurbs_volume: 37\") ! call ut%check(res=bsp%get_ng(), expected=size(Xgb,1), msg=\"test_nurbs_volume: 38\") call ut % check ( res = nurbs % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_volume: 39\" ) call ut % check ( res = bsp % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_volume: 40\" ) call ut % check ( res = nurbs % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_volume: 41\" ) call ut % check ( res = bsp % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_volume: 42\" ) call ut % check ( res = nurbs % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_volume: 43\" ) call ut % check ( res = bsp % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_volume: 44\" ) ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 45\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 46\") call nurbs % cmp_nc () call bsp % cmp_nc () ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 47\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 48\") elemConn = nurbs % cmp_elem_Xc_vis ([ 1 , 1 , 1 ]) call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 49\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xc_vis () call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 50\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis ([ 1 , 1 , 1 ]) call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 51\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis () call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 52\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis ([ 1 , 1 , 1 ]) call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 53\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis () call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 54\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis ([ 1 , 1 , 1 ]) call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 55\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis () call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 56\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem () call nurbs % set_elem ( elemConn ) call ut % check ( res = nurbs % get_elem (), expected = elemConn , msg = \"test_nurbs_volume: 57\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem () call bsp % set_elem ( elemConn ) call ut % check ( res = bsp % get_elem (), expected = elemConn , msg = \"test_nurbs_volume: 58\" ) deallocate ( elemConn ) call nurbs % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call bsp % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call nurbs % modify_Wc ( Wc ( 1 ), 1 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 59\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 60\" ) call nurbs % basis ( res1 = 20 , res2 = 20 , res3 = 20 , Tgc = Tgc ) call bsp % basis ( res1 = 20 , res2 = 20 , res3 = 20 , Tgc = Tgc ) call nurbs % basis ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], Tgc = Tgc1 ) call bsp % basis ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], Tgc = Tgc1b ) call nurbs % basis (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Tgc = Tgc ) call bsp % basis (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Tgc = Tgc ) call nurbs % derivative ( res1 = 20 , res2 = 20 , res3 = 20 , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( res1 = 20 , res2 = 20 , res3 = 20 , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], dTgc = dTgc , Tgc = Tgc ) call bsp % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 , elem = [ 1 , 2 , 3 ]) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b , elem = [ 1 , 2 , 3 ]) call nurbs % derivative2 ( res1 = 20 , res2 = 20 , res3 = 20 , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( res1 = 20 , res2 = 20 , res3 = 20 , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1b , Tgc = Tgc1b ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1b , Tgc = Tgc1b ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 61\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 62\" ) call nurbs % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 63\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 64\" ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 65\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 66\" ) call nurbs % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 67\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 68\" ) call nurbs % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 69\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 70\" ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 71\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 72\" ) call nurbs % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 73\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 74\" ) call nurbs % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 75\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 76\" ) call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 77\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 78\" ) call nurbs % elevate_degree ( 1 , 2 ) call nurbs % elevate_degree ( 2 , 2 ) call nurbs % elevate_degree ( 3 , 2 ) call bsp % elevate_degree ( 1 , 2 ) call bsp % elevate_degree ( 2 , 2 ) call bsp % elevate_degree ( 3 , 2 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 79\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 80\" ) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! call bsp%remove_knots(1, [0.25_rk, 0.75_rk], [2,1]) ! call bsp%remove_knots(2, [0.25_rk, 0.75_rk], [2,1]) ! call bsp%remove_knots(3, [0.25_rk, 0.75_rk], [2,1]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 81\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 82\" ) call nurbs % set_hexahedron ([ 2.0_rk , 2.0_rk , 2.0_rk ], [ 2 , 2 , 2 ]) call bsp % set_hexahedron ([ 2.0_rk , 2.0_rk , 2.0_rk ], [ 2 , 2 , 2 ], [ 1.0_rk , 1.0_rk , 0.9_rk , 0.9_rk , 1.0_rk , 1.0_rk , 1.0_rk , 0.9_rk ]) call nurbs % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 2.0_rk ) call nurbs % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 2.0_rk ) call nurbs % set_C ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 2.0_rk ) call nurbs % finalize () call bsp % finalize () deallocate ( Xc , Wc , Xg , Xgb ) !============================================================================ ! Least-squares B-spline volume fitting !============================================================================ block use forcad , only : rk , nurbs_volume use forcad_utils , only : ndgrid use forunittest , only : unit_test type ( nurbs_volume ) :: bsp integer :: n ( 3 ), ndata , i real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xdata (:,:) real ( rk ), allocatable :: Xt1 (:), Xt2 (:), Xt3 (:), Xt (:,:) real ( rk ), allocatable :: Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = [ 6 , 6 , 6 ] allocate ( Xt1 ( n ( 1 )), Xt2 ( n ( 2 )), Xt3 ( n ( 3 ))) do concurrent ( i = 1 : n ( 1 )) Xt1 ( i ) = real ( i - 1 , rk ) / real ( n ( 1 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 2 )) Xt2 ( i ) = real ( i - 1 , rk ) / real ( n ( 2 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 3 )) Xt3 ( i ) = real ( i - 1 , rk ) / real ( n ( 3 ) - 1 , rk ) end do call ndgrid ( Xt1 , Xt2 , Xt3 , Xt ) ndata = n ( 1 ) * n ( 2 ) * n ( 3 ) allocate ( Xdata ( ndata , 3 )) do i = 1 , ndata Xdata ( i , 1 ) = Xt ( i , 1 ) + 0.1_rk * sin ( 2.0_rk * pi * Xt ( i , 2 )) Xdata ( i , 2 ) = Xt ( i , 2 ) + 0.1_rk * sin ( 2.0_rk * pi * Xt ( i , 3 )) Xdata ( i , 3 ) = Xt ( i , 3 ) + 0.1_rk * sin ( 2.0_rk * pi * Xt ( i , 1 )) end do call bsp % set (& degree = [ 2 , 2 , 2 ],& Xth_dir1 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& Xth_dir2 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& Xth_dir3 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& continuity1 = [ - 1 , 1 , 1 , 1 , - 1 ],& continuity2 = [ - 1 , 1 , 1 , 1 , - 1 ],& continuity3 = [ - 1 , 1 , 1 , 1 , - 1 ]) call bsp % lsq_fit_bspline ( Xt , Xdata , n ) call bsp % create ( Xt1 = Xt1 , Xt2 = Xt2 , Xt3 = Xt3 ) Xg_eval = bsp % get_Xg () err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / norm2 ( Xdata (:, 1 )) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / norm2 ( Xdata (:, 2 )) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / norm2 ( Xdata (:, 3 )) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) call ut % check ( res = rms , expected = 0.0_rk , tol = 1e-6_rk , msg = \"test_nurbs_volume: 83\" ) call bsp % finalize () deallocate ( Xt1 , Xt2 , Xt3 , Xt , Xdata , Xg_eval ) end block end program","tags":"","url":"sourcefile/test_nurbs_volume.f90.html"},{"title":"example_plate_hole_2_2d.f90 – ForCAD","text":"This file depends on sourcefile~~example_plate_hole_2_2d.f90~~EfferentGraph sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_plate_hole_2_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: plate_hole real ( rk ), allocatable :: Xc (:,:) real ( rk ), allocatable :: Wc (:) real ( rk ), parameter :: radius1 = 2.5_rk real ( rk ), parameter :: radius2 = 3.5_rk real ( rk ), parameter :: length = 5.0_rk real ( rk ), parameter :: height = 5.0_rk call set_Xc_Wc ( 'ellipse' , [ radius1 , radius2 , length , height ], Xc , Wc ) call plate_hole % set (& knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 2.0_rk , 2.0_rk , 3.0_rk , 4.0_rk , 4.0_rk , 4.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ,& Wc = Wc & ) call plate_hole % create ( 31 , 31 ) call plate_hole % export_Xc ( \"vtk/plate_hole_2_2d_Xc.vtk\" ) call plate_hole % export_Xg ( \"vtk/plate_hole_2_2d_Xg.vtk\" ) call plate_hole % export_Xth_in_Xg ( \"vtk/plate_hole_2_2d_Xth.vtk\" ) call plate_hole % show ( \"vtk/plate_hole_2_2d_Xc.vtk\" , \"vtk/plate_hole_2_2d_Xg.vtk\" , \"vtk/plate_hole_2_2d_Xth.vtk\" ) contains !=============================================================================== pure subroutine set_Xc_Wc ( tp , params , X_c , W_c ) character ( len =* ), intent ( in ) :: tp real ( rk ), intent ( in ), contiguous :: params (:) real ( rk ), allocatable , intent ( out ) :: X_c (:,:) real ( rk ), allocatable , intent ( out ) :: W_c (:) real ( rk ) :: r1 , r2 , l , h select case ( tp ) case ( 'circle' ) r1 = params ( 1 ) l = params ( 3 ) h = params ( 4 ) if ( r1 < 0.0_rk ) error stop 'Radius must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' allocate ( X_c ( 21 , 2 )) X_c ( 1 , :) = [ - r1 , 0.0_rk ] X_c ( 2 , :) = [ - r1 , r1 * tand ( 2 2.5_rk )] X_c ( 3 , :) = [ - r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 4 , :) = [ 0.0_rk , r1 ] X_c ( 5 , :) = [ r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 6 , :) = [ r1 , r1 * tand ( 2 2.5_rk )] X_c ( 7 , :) = [ r1 , 0.0_rk ] X_c ( 8 , :) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 9 , :) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 10 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 11 ,:) = [ 0.0_rk , ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 12 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 13 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 14 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 ,:) = [ - l , 0.0_rk ] X_c ( 16 ,:) = [ - l , h ] X_c ( 17 ,:) = [ - l , h ] X_c ( 18 ,:) = [ 0.0_rk , h ] X_c ( 19 ,:) = [ l , h ] X_c ( 20 ,:) = [ l , h ] X_c ( 21 ,:) = [ l , 0.0_rk ] allocate ( W_c ( 21 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 ]) = ( 1.0_rk + 1.0_rk / sqrt ( 2.0_rk )) / 2.0_rk case ( 'ellipse' ) r1 = params ( 1 ) r2 = params ( 2 ) l = params ( 3 ) h = params ( 4 ) if ( r1 < 0.0_rk ) error stop 'Radius1 must be positive' if ( r2 < 0.0_rk ) error stop 'Radius2 must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' allocate ( X_c ( 21 , 2 )) X_c ( 1 ,:) = [ - r1 , 0.0_rk ] X_c ( 2 ,:) = [ - r1 , r2 * tand ( 2 2.5_rk )] X_c ( 3 ,:) = [ - r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 4 ,:) = [ 0.0_rk , r2 ] X_c ( 5 ,:) = [ r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 6 ,:) = [ r1 , r2 * tand ( 2 2.5_rk )] X_c ( 7 ,:) = [ r1 , 0.0_rk ] X_c ( 8 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 9 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 10 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 11 ,:) = [ 0.0_rk , ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 12 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 13 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 14 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 ,:) = [ - l , 0.0_rk ] X_c ( 16 ,:) = [ - l , h ] X_c ( 17 ,:) = [ - l , h ] X_c ( 18 ,:) = [ 0.0_rk , h ] X_c ( 19 ,:) = [ l , h ] X_c ( 20 ,:) = [ l , h ] X_c ( 21 ,:) = [ l , 0.0_rk ] allocate ( W_c ( 21 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 ]) = cosd ( 2 2.5_rk ) case default error stop 'set_Xc_Wc: Invalid type. Valid types are: circle, ellipse' end select end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_plate_hole_2_2d.f90.html"},{"title":"example_surface_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_surface_1.f90~~EfferentGraph sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. program example3_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !> Export the transformed NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","url":"sourcefile/example_surface_1.f90.html"},{"title":"forcad_interface.F90 – ForCAD","text":"This file depends on sourcefile~~forcad_interface.f90~~EfferentGraph sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_interface.f90~~AfferentGraph sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Provides a unified interfaces !> @note !> note: Due to a known issue with preprocessing in fpm !> (see: https://github.com/fortran-lang/fpm/issues/773), !> conditional compilation is currently unreliable in this context. !> As a workaround, the implementation must be selected manually. !> @endnote module forcad_interface ! #ifdef USE_STDLIB_SOLVE !    use stdlib_linalg, only: solve ! #else !    use forcad_utils, only: solve ! #endif use forcad_utils , only : solve ! use stdlib_linalg, only: solve implicit none private public solve end module","tags":"","url":"sourcefile/forcad_interface.f90.html"},{"title":"fdm_surface.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_surface.f90~~EfferentGraph sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_test_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: surface !! Declare a NURBS surface object real ( rk ), allocatable :: Wc (:) !! Declare the control points weights real ( rk ) :: Xtp ( 2 ), tol , Xt ( 2 ), Xtm ( 2 ) real ( rk ), allocatable :: Tgc (:), dTgc (:,:), Tgcp (:), dTgcp (:,:), Tgcm (:), dTgcm (:,:), d2Tgc (:,:), d2Tgcp (:,:), d2Tgcm (:,:) real ( rk ), allocatable :: CFD (:,:), BFD (:,:), FFD (:,:), CFD2 (:,:), BFD2 (:,:), FFD2 (:,:) integer :: i !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.2_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 0.2_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.2_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.2_rk ] call surface % set_tetragon ( L = [ 5.0_rk , 8.0_rk ], nc = [ 4 , 4 ], Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 20 call surface % create ( 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 16 , 2 ), BFD ( 16 , 2 ), FFD ( 16 , 2 )) allocate ( CFD2 ( 2 * 16 , 2 ), BFD2 ( 2 * 16 , 2 ), FFD2 ( 2 * 16 , 2 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk call surface % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 2 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call surface % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call surface % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 2 * 16 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 2 * 16 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 2 * 16 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS surface object call surface % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- call surface % set_tetragon ( L = [ 5.0_rk , 8.0_rk ], nc = [ 4 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 20 call surface % create ( 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 16 , 2 ), BFD ( 16 , 2 ), FFD ( 16 , 2 )) allocate ( CFD2 ( 2 * 16 , 2 ), BFD2 ( 2 * 16 , 2 ), FFD2 ( 2 * 16 , 2 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk call surface % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 2 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call surface % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call surface % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 2 * 16 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 2 * 16 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 2 * 16 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS surface object call surface % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) end program","tags":"","url":"sourcefile/fdm_surface.f90.html"},{"title":"shape_tetragon.f90 – ForCAD","text":"This file depends on sourcefile~~shape_tetragon.f90~~EfferentGraph sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_tetragon use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !> Export the control points to a VTK file call shape % export_Xc ( 'vtk/shape_tetragon_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !> Export the generated surface to a VTK file call shape % export_Xg ( 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_tetragon_Xc.vtk' , 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () end program","tags":"","url":"sourcefile/shape_tetragon.f90.html"},{"title":"example_curve_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_curve_1.f90~~EfferentGraph sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth.vtk' ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !> Export the NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !> Export the refined NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !> Export the transformed NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","url":"sourcefile/example_curve_1.f90.html"},{"title":"forcad.f90 – ForCAD","text":"This file depends on sourcefile~~forcad.f90~~EfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad.f90~~AfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forcad use forcad_kinds , only : rk use forcad_nurbs_curve , only : nurbs_curve use forcad_nurbs_surface , only : nurbs_surface use forcad_nurbs_volume , only : nurbs_volume implicit none private public rk , nurbs_curve , nurbs_surface , nurbs_volume end module forcad","tags":"","url":"sourcefile/forcad.f90.html"},{"title":"nearest_point_3d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_3d.f90~~EfferentGraph sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !! Declare a NURBS volume object real ( rk ) :: nearest_Xg ( 3 ) !! Coordinates of the nearest point on the volume real ( rk ) :: nearest_Xt ( 3 ) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 8 , 3 ) !! Control points real ( rk ) :: Wc ( 8 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS hexahedron !----------------------------------------------------------------------------- Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 4.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 4.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 2.0_rk ] Xc ( 6 ,:) = [ 2.0_rk , 0.0_rk , 2.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 4.0_rk , 2.0_rk ] Xc ( 8 ,:) = [ 2.0_rk , 4.0_rk , 2.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 1.11_rk , 1.0_rk , 0.5_rk , 0.5_rk , 1.2_rk , 1.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, 20 call shape % create ( 30 , 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the volume !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.5_rk , 3.5_rk , 1.1_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the volume (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) call shape % nearest_point2 ([ 1.5_rk , 3.5_rk , 1.1_rk ], 1.0e-11_rk , 500 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","url":"sourcefile/nearest_point_3d.f90.html"},{"title":"lsq_fit_bspline_2d.f90 – ForCAD","text":"This file depends on sourcefile~~lsq_fit_bspline_2d.f90~~EfferentGraph sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program lsq_fit_bspline_2d use forcad , only : rk , nurbs_surface use forcad_utils , only : ndgrid implicit none type ( nurbs_surface ) :: bsp integer :: n ( 2 ), ndata , i real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xdata (:,:) real ( rk ), allocatable :: Xt1 (:), Xt2 (:), Xt (:,:) real ( rk ), allocatable :: Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = [ 14 , 14 ] ! create parametric grid points allocate ( Xt1 ( n ( 1 )), Xt2 ( n ( 2 ))) do concurrent ( i = 1 : n ( 1 )) Xt1 ( i ) = real ( i - 1 , rk ) / real ( n ( 1 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 2 )) Xt2 ( i ) = real ( i - 1 , rk ) / real ( n ( 2 ) - 1 , rk ) end do call ndgrid ( Xt1 , Xt2 , Xt ) ! data points to be fitted ndata = n ( 1 ) * n ( 2 ) allocate ( Xdata ( ndata , 3 )) do i = 1 , ndata Xdata ( i , 1 ) = Xt ( i , 1 ) Xdata ( i , 2 ) = Xt ( i , 2 ) Xdata ( i , 3 ) = 0.1_rk * sin ( 2.0_rk * pi * Xt ( i , 1 )) * cos ( 2.0_rk * pi * Xt ( i , 2 )) end do ! set up B-Spline surface ! Xth_dir1(1) = minval(Xt1), Xth_dir1(2) = maxval(Xt1) ! Xth_dir2(1) = minval(Xt2), Xth_dir2(2) = maxval(Xt2) call bsp % set (& degree = [ 4 , 4 ],& Xth_dir1 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& Xth_dir2 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& continuity1 = [ - 1 , 1 , 1 , 1 , - 1 ],& continuity2 = [ - 1 , 1 , 1 , 1 , - 1 ]) print '(a)' , \"========================================\" print '(a)' , \"B-Spline Surface Configuration\" print '(a)' , \"----------------------------------------\" print '(a,2(i0,a))' , \"Degrees    : \" , bsp % get_degree ( 1 ), \", \" , bsp % get_degree ( 2 ) print '(a,2(i0,a))' , \"Control pts: \" , bsp % get_nc ( 1 ), \" x \" , bsp % get_nc ( 2 ) print '(a,2(i0,a))' , \"Data grid  : \" , n ( 1 ), \" x \" , n ( 2 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Continuity\" print '(a,*(i3,1x))' , \"  dir1:\" , bsp % get_continuity ( 1 ) print '(a,*(i3,1x))' , \"  dir2:\" , bsp % get_continuity ( 2 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Knot vectors\" print '(a,*(f5.2,1x))' , \"  dir1:\" , bsp % get_knot ( 1 ) print '(a,*(f5.2,1x))' , \"  dir2:\" , bsp % get_knot ( 2 ) print '(a)' , \"========================================\" print '(a)' , \"Fitting least squares surface...\" call bsp % lsq_fit_bspline ( Xt , Xdata , n ) print '(a)' , \"Fitting complete.\" ! create B-Spline surface call bsp % create ( Xt1 = Xt1 , Xt2 = Xt2 ) Xg_eval = bsp % get_Xg () ! Compute errors err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / max ( norm2 ( Xdata (:, 1 )), epsilon ( 0.0_rk ) ) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / max ( norm2 ( Xdata (:, 2 )), epsilon ( 0.0_rk ) ) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / max ( norm2 ( Xdata (:, 3 )), epsilon ( 0.0_rk ) ) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) print '(a)' , \"========================================\" print '(a)' , \"Fitting Error Report\" print '(a)' , \"----------------------------------------\" print '(a,e13.6)' , \"Rel. error (dir1):\" , err1 print '(a,e13.6)' , \"Rel. error (dir2):\" , err2 print '(a,e13.6)' , \"Rel. error (dir3):\" , err3 print '(a,e13.6)' , \"Total RMS error  :\" , rms print '(a)' , \"========================================\" ! Export results call bsp % export_Xc ( \"vtk/lsq_fit_bspline_2d_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/lsq_fit_bspline_2d_Xg.vtk\" ) call bsp % export_Xth_in_Xg ( \"vtk/lsq_fit_bspline_2d_Xth.vtk\" , res = 20 ) call bsp % show ( \"vtk/lsq_fit_bspline_2d_Xc.vtk\" , \"vtk/lsq_fit_bspline_2d_Xg.vtk\" , \"vtk/lsq_fit_bspline_2d_Xth.vtk\" ) end program","tags":"","url":"sourcefile/lsq_fit_bspline_2d.f90.html"},{"title":"fdm_volume.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_volume.f90~~EfferentGraph sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_test_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: volume !! Declare a NURBS volume object real ( rk ), allocatable :: Wc (:) !! Weights for the control points real ( rk ) :: Xt ( 3 ), tol , Xtm ( 3 ), Xtp ( 3 ) real ( rk ), allocatable :: Tgc (:), dTgc (:,:), Tgcp (:), dTgcp (:,:), Tgcm (:), dTgcm (:,:), d2Tgc (:,:), d2Tgcp (:,:), d2Tgcm (:,:) real ( rk ), allocatable :: CFD (:,:), BFD (:,:), FFD (:,:), CFD2 (:,:), BFD2 (:,:), FFD2 (:,:) integer :: i !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- allocate ( Wc ( 64 )) Wc = 1.0_rk Wc ( 10 ) = 0.5_rk call volume % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 4 , 4 ], Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 20 call volume % create ( 20 , 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 64 , 3 ), BFD ( 64 , 3 ), FFD ( 64 , 3 )) allocate ( CFD2 ( 3 * 64 , 3 ), BFD2 ( 3 * 64 , 3 ), FFD2 ( 3 * 64 , 3 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk Xt ( 3 ) = 0.7_rk call volume % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 3 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call volume % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call volume % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 3 * 64 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 3 * 64 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 3 * 64 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS volume object call volume % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) deallocate ( Wc ) !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- call volume % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 4 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 20 call volume % create ( 20 , 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 64 , 3 ), BFD ( 64 , 3 ), FFD ( 64 , 3 )) allocate ( CFD2 ( 3 * 64 , 3 ), BFD2 ( 3 * 64 , 3 ), FFD2 ( 3 * 64 , 3 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk Xt ( 3 ) = 0.7_rk call volume % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 3 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call volume % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call volume % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 3 * 64 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 3 * 64 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 3 * 64 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS volume object call volume % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) end program","tags":"","url":"sourcefile/fdm_volume.f90.html"},{"title":"demo_volume.f90 – ForCAD","text":"This file depends on sourcefile~~demo_volume.f90~~EfferentGraph sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume. !> It sets up control points and weights, generates the volume, and exports the control points !> and the volume to VTK files at various stages. program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !----------------------------------------------------------------------------- ! Refinement !----------------------------------------------------------------------------- !> Elevate the degree of the NURBS volume in the first, second and third directions call nurbs % elevate_degree ( 1 , 2 ) call nurbs % elevate_degree ( 2 , 2 ) call nurbs % elevate_degree ( 3 , 2 ) !> Insert knots into the NURBS volume in the first, second and third directions call nurbs % insert_knots ( 1 ,[ 0.5_rk ], [ 1 ]) call nurbs % insert_knots ( 2 ,[ 0.5_rk ], [ 1 ]) call nurbs % insert_knots ( 3 ,[ 0.5_rk ], [ 1 ]) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !> Export the parameter space to a VTK file call nurbs % export_Xth_in_Xg ( 'vtk/demo_volume_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry, geometry and parameters using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' , 'vtk/demo_volume_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- pure function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","url":"sourcefile/demo_volume.f90.html"},{"title":"lsq_fit_nurbs_2d.f90 – ForCAD","text":"This file depends on sourcefile~~lsq_fit_nurbs_2d.f90~~EfferentGraph sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program lsq_fit_nurbs_2d use forcad , only : rk , nurbs_surface use forcad_utils , only : ndgrid implicit none type ( nurbs_surface ) :: nrb integer :: n ( 2 ), ndata , i real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xdata (:,:) real ( rk ), allocatable :: Xt1 (:), Xt2 (:), Xt (:,:) real ( rk ), allocatable :: Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = [ 60 , 30 ] ! create parametric grid points allocate ( Xt1 ( n ( 1 )), Xt2 ( n ( 2 ))) do concurrent ( i = 1 : n ( 1 )) Xt1 ( i ) = real ( i - 1 , rk ) / real ( n ( 1 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 2 )) Xt2 ( i ) = real ( i - 1 , rk ) / real ( n ( 2 ) - 1 , rk ) end do call ndgrid ( Xt1 , Xt2 , Xt ) ! data points to be fitted ndata = n ( 1 ) * n ( 2 ) allocate ( Xdata ( ndata , 3 )) do i = 1 , ndata Xdata ( i , 1 ) = 0.0_rk + ( 1.0_rk + 0.35_rk * cos ( 2.0_rk * pi * Xt ( i , 2 ))) * cos ( 2.0_rk * pi * Xt ( i , 1 )) Xdata ( i , 2 ) = 0.0_rk + ( 1.0_rk + 0.35_rk * cos ( 2.0_rk * pi * Xt ( i , 2 ))) * sin ( 2.0_rk * pi * Xt ( i , 1 )) Xdata ( i , 3 ) = 0.0_rk + 0.35_rk * sin ( 2.0_rk * pi * Xt ( i , 2 )) end do ! set up NURBS surface call nrb % set (& degree = [ 4 , 4 ],& Xth_dir1 = [ 0.0_rk , 0.1_rk , 0.2_rk , 0.3_rk , 0.4_rk , 0.5_rk , 0.6_rk , 0.7_rk , 0.8_rk , 0.9_rk , 1.0_rk ],& Xth_dir2 = [ 0.0_rk , 0.2_rk , 0.4_rk , 0.6_rk , 0.8_rk , 1.0_rk ],& continuity1 = [ - 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , - 1 ],& continuity2 = [ - 1 , 1 , 1 , 1 , 1 , - 1 ]) print '(a)' , \"========================================\" print '(a)' , \"NURBS Surface Configuration\" print '(a)' , \"----------------------------------------\" print '(a,2(i0,a))' , \"Degrees    : \" , nrb % get_degree ( 1 ), \", \" , nrb % get_degree ( 2 ) print '(a,2(i0,a))' , \"Control pts: \" , nrb % get_nc ( 1 ), \" x \" , nrb % get_nc ( 2 ) print '(a,2(i0,a))' , \"Data grid  : \" , n ( 1 ), \" x \" , n ( 2 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Continuity\" print '(a,*(i3,1x))' , \"  dir1:\" , nrb % get_continuity ( 1 ) print '(a,*(i3,1x))' , \"  dir2:\" , nrb % get_continuity ( 2 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Knot vectors\" print '(a,*(f5.2,1x))' , \"  dir1:\" , nrb % get_knot ( 1 ) print '(a,*(f5.2,1x))' , \"  dir2:\" , nrb % get_knot ( 2 ) print '(a)' , \"========================================\" print '(a)' , \"Fitting least squares surface...\" call nrb % lsq_fit_nurbs (& Xt = Xt , & Xdata = Xdata , & ndata = n , & maxit = 100 , & tol = sqrt ( epsilon ( 0.0_rk )), & lambda_xc = sqrt ( epsilon ( 0.0_rk )), & reg_logw = sqrt ( epsilon ( 0.0_rk )) ) print '(a)' , \"Fitting complete.\" ! create NURBS surface call nrb % create ( Xt1 = Xt1 , Xt2 = Xt2 ) Xg_eval = nrb % get_Xg () ! Compute errors err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / max ( norm2 ( Xdata (:, 1 )), epsilon ( 0.0_rk ) ) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / max ( norm2 ( Xdata (:, 2 )), epsilon ( 0.0_rk ) ) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / max ( norm2 ( Xdata (:, 3 )), epsilon ( 0.0_rk ) ) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) print '(a)' , \"========================================\" print '(a)' , \"Fitting Error Report\" print '(a)' , \"----------------------------------------\" print '(a,e13.6)' , \"Rel. error (dir1):\" , err1 print '(a,e13.6)' , \"Rel. error (dir2):\" , err2 print '(a,e13.6)' , \"Rel. error (dir3):\" , err3 print '(a,e13.6)' , \"Total RMS error  :\" , rms print '(a)' , \"========================================\" ! Export results call nrb % export_Xc ( \"vtk/lsq_fit_nurbs_2d_Xc.vtk\" ) call nrb % export_Xg ( \"vtk/lsq_fit_nurbs_2d_Xg.vtk\" ) call nrb % export_Xth_in_Xg ( \"vtk/lsq_fit_nurbs_2d_Xth.vtk\" , res = 20 ) call nrb % show ( \"vtk/lsq_fit_nurbs_2d_Xc.vtk\" , \"vtk/lsq_fit_nurbs_2d_Xg.vtk\" , \"vtk/lsq_fit_nurbs_2d_Xth.vtk\" ) end program","tags":"","url":"sourcefile/lsq_fit_nurbs_2d.f90.html"},{"title":"shape_half_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_2d.f90~~EfferentGraph sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_2d_Xc.vtk' , 'vtk/shape_half_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_half_ring_2d.f90.html"},{"title":"test_nurbs_curve.f90 – ForCAD","text":"This file depends on sourcefile~~test_nurbs_curve.f90~~EfferentGraph sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_nurbs_curve use forcad_kinds , only : rk use forcad_nurbs_curve , only : nurbs_curve , compute_Tgc , compute_dTgc use forunittest , only : unit_tests implicit none integer , parameter :: NTESTS = 113 type ( unit_tests ) :: ut real ( rk ), parameter :: TOL = 1.0e-5_rk real ( rk ), parameter :: PI = acos ( - 1.0_rk ) type ( nurbs_curve ) :: nurbs , bsp real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xg (:,:), Xgb (:,:) real ( rk ) :: knot ( 6 ) integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Tgc (:,:), dTgc (:,:), Tgcb (:,:), dTgcb (:,:), d2Tgc (:,:), d2Tgcb (:,:) real ( rk ), allocatable :: Tgc1 (:), dTgc1 (:), Tgc1b (:), dTgc1b (:), d2Tgc1 (:), d2Tgc1b (:) real ( rk ) :: nearest_Xg ( 3 ), nearest_Xt , length , lengthb integer :: i , id , ti real ( rk ), allocatable :: Xt (:) character ( len =* ), parameter :: fXc_nurbs = 'vtk/test_nurbs_curve_Xc.vtk' character ( len =* ), parameter :: fXg_nurbs = 'vtk/test_nurbs_curve_Xg.vtk' character ( len =* ), parameter :: fXth_nurbs = 'vtk/test_nurbs_curve_Xth.vtk' character ( len =* ), parameter :: fIgs_nurbs = 'iges/test_nurbs_curve.iges' character ( len =* ), parameter :: fXc_bsp = 'vtk/test_bsp_curve_Xc.vtk' character ( len =* ), parameter :: fXg_bsp = 'vtk/test_bsp_curve_Xg.vtk' character ( len =* ), parameter :: fXth_bsp = 'vtk/test_bsp_curve_Xth.vtk' character ( len =* ), parameter :: fIgs_bsp = 'iges/test_bsp_curve.iges' logical :: okXc_nurbs , okXg_nurbs , okXth_nurbs , okIges_nurbs logical :: okXc_bsp , okXg_bsp , okXth_bsp , okIges_bsp call ut % initialize ( NTESTS ) ti = 1 ! Initialize curve data allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 0.9_rk , 0.8_rk ] knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! 1) Set and create NURBS and B-spline curves call nurbs % set ( knot , Xc , Wc ) call bsp % set ( knot , Xc ) call nurbs % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc (), Wc = nurbs % get_Wc ()) call bsp % set ( degree = bsp % get_degree (), nc = bsp % get_nc (), Xc = bsp % get_Xc ()) call nurbs % create ( res = 23 ) call bsp % create ( res = 23 ) call ut % test ( ti )% check ( & name = \"set(): degree==2\" , & res = nurbs % get_degree (), & expected = 2 , & msg = \"NURBS degree not 2\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): degree==2 (B-spline)\" , & res = bsp % get_degree (), & expected = 2 , & msg = \"B-spline degree not 2\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): nc==3\" , & res = nurbs % get_nc (), & expected = 3 , & msg = \"NURBS nc not 3\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): nc==3 (B-spline)\" , & res = bsp % get_nc (), & expected = 3 , & msg = \"B-spline nc not 3\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): knot matches\" , & res = nurbs % get_knot (), & expected = knot , & tol = TOL , & msg = \"NURBS knot vector mismatch\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(): knot matches (B-spline)\" , & res = bsp % get_knot (), & expected = knot , & tol = TOL , & msg = \"B-spline knot vector mismatch\" , & group = \"setup\" ); ti = ti + 1 ! 2) Export tests call nurbs % export_Xc ( fXc_nurbs ) call bsp % export_Xc ( fXc_bsp ) call nurbs % export_Xg ( fXg_nurbs ) call bsp % export_Xg ( fXg_bsp ) call nurbs % export_Xth ( fXth_nurbs ) call bsp % export_Xth ( fXth_bsp ) call nurbs % export_iges ( fIgs_nurbs ) call bsp % export_iges ( fIgs_bsp ) inquire ( file = fXc_nurbs , exist = okXc_nurbs ) inquire ( file = fXg_nurbs , exist = okXg_nurbs ) inquire ( file = fXth_nurbs , exist = okXth_nurbs ) inquire ( file = fIgs_nurbs , exist = okIges_nurbs ) inquire ( file = fXc_bsp , exist = okXc_bsp ) inquire ( file = fXg_bsp , exist = okXg_bsp ) inquire ( file = fXth_bsp , exist = okXth_bsp ) inquire ( file = fIgs_bsp , exist = okIges_bsp ) call ut % test ( ti )% check ( & name = \"export_Xc/Xg/Xth/IGES(): files exist (NURBS)\" , & res = merge ( 1 , 0 , okXc_nurbs . and . okXg_nurbs . and . okXth_nurbs . and . okIges_nurbs ), & expected = 1 , & msg = \"NURBS export did not create all files\" , & group = \"io\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"export_Xc/Xg/Xth/IGES(): files exist (B-spline)\" , & res = merge ( 1 , 0 , okXc_bsp . and . okXg_bsp . and . okXth_bsp . and . okIges_bsp ), & expected = 1 , & msg = \"B-spline export did not create all files\" , & group = \"io\" ); ti = ti + 1 ! 3) Length tests call nurbs % cmp_length ( length ) call bsp % cmp_length ( lengthb ) call ut % test ( ti )% check ( & name = \"cmp_length(): length == 2 (NURBS)\" , & res = length , & expected = 2.0_rk , & tol = TOL , & msg = \"NURBS arc length incorrect\" , & group = \"geometry\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"cmp_length(): length == 2 (B-spline)\" , & res = lengthb , & expected = 2.0_rk , & tol = TOL , & msg = \"B-spline arc length incorrect\" , & group = \"geometry\" ); ti = ti + 1 ! 4) Nearest point tests call nurbs % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"nearest_point(): point matches [0,0,0] (NURBS)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"NURBS nearest point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): param == 0 (NURBS)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS nearest param incorrect\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): id == 1 (NURBS)\" , & res = id , & expected = 1 , & msg = \"NURBS nearest id incorrect\" , & group = \"nearest\" ); ti = ti + 1 call bsp % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"nearest_point(): point matches [0,0,0] (B-spline)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"B-spline nearest point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): param == 0 (B-spline)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline nearest param incorrect\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point(): id == 1 (B-spline)\" , & res = id , & expected = 1 , & msg = \"B-spline nearest id incorrect\" , & group = \"nearest\" ); ti = ti + 1 call nurbs % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1.0e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % test ( ti )% check ( & name = \"nearest_point2(): point matches [0,0,0] (NURBS)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"NURBS nearest_point2 point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point2(): param == 0 (NURBS)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS nearest_point2 param incorrect\" , & group = \"nearest\" ); ti = ti + 1 call bsp % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1.0e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % test ( ti )% check ( & name = \"nearest_point2(): point matches [0,0,0] (B-spline)\" , & res = nearest_Xg , & expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], & tol = TOL , & msg = \"B-spline nearest_point2 point mismatch\" , & group = \"nearest\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"nearest_point2(): param == 0 (B-spline)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline nearest_point2 param incorrect\" , & group = \"nearest\" ); ti = ti + 1 ! 5) Store initial geometry Xg = nurbs % get_Xg () Xgb = bsp % get_Xg () ! 6) Set with Xth_dir and continuity call nurbs % set ([ 0.0_rk , 1.0_rk ], 2 , [ - 1 , - 1 ], Xc , Wc ) call bsp % set ([ 0.0_rk , 1.0_rk ], 2 , [ - 1 , - 1 ], Xc ) call nurbs % create ( res = 23 ) call bsp % create ( res = 23 ) call ut % test ( ti )% check ( & name = \"set(Xth_dir): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after set(Xth_dir)\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(Xth_dir): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after set(Xth_dir)\" , & group = \"setup\" ); ti = ti + 1 ! 7) Set with Xc and Wc call nurbs % set ( Xc , Wc ) call bsp % set ( Xc ) call nurbs % create ( res = 23 ) call bsp % create ( res = 23 ) call ut % test ( ti )% check ( & name = \"set(Xc,Wc): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after set(Xc,Wc)\" , & group = \"setup\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"set(Xc): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after set(Xc)\" , & group = \"setup\" ); ti = ti + 1 ! 8) Create with explicit Xt call nurbs % create ( Xt = nurbs % get_Xt ()) call bsp % create ( Xt = bsp % get_Xt ()) call ut % test ( ti )% check ( & name = \"create(Xt): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after create(Xt)\" , & group = \"sampling\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"create(Xt): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after create(Xt)\" , & group = \"sampling\" ); ti = ti + 1 ! 9) Export after create(Xt) call nurbs % export_Xc ( fXc_nurbs ) call bsp % export_Xc ( fXc_bsp ) call nurbs % export_Xg ( fXg_nurbs ) call bsp % export_Xg ( fXg_bsp ) call nurbs % export_Xth ( fXth_nurbs ) call bsp % export_Xth ( fXth_bsp ) call nurbs % export_iges ( fIgs_nurbs ) call bsp % export_iges ( fIgs_bsp ) inquire ( file = fXc_nurbs , exist = okXc_nurbs ) inquire ( file = fXg_nurbs , exist = okXg_nurbs ) inquire ( file = fXth_nurbs , exist = okXth_nurbs ) inquire ( file = fIgs_nurbs , exist = okIges_nurbs ) inquire ( file = fXc_bsp , exist = okXc_bsp ) inquire ( file = fXg_bsp , exist = okXg_bsp ) inquire ( file = fXth_bsp , exist = okXth_bsp ) inquire ( file = fIgs_bsp , exist = okIges_bsp ) call ut % test ( ti )% check ( & name = \"export after create(Xt): files exist (NURBS)\" , & res = merge ( 1 , 0 , okXc_nurbs . and . okXg_nurbs . and . okXth_nurbs . and . okIges_nurbs ), & expected = 1 , & msg = \"NURBS export after create(Xt) did not create all files\" , & group = \"io\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"export after create(Xt): files exist (B-spline)\" , & res = merge ( 1 , 0 , okXc_bsp . and . okXg_bsp . and . okXth_bsp . and . okIges_bsp ), & expected = 1 , & msg = \"B-spline export after create(Xt) did not create all files\" , & group = \"io\" ); ti = ti + 1 ! 10) Getter tests call ut % test ( ti )% check ( & name = \"get_Xc(): matches input (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(): matches input (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1): matches input (NURBS)\" , & res = nurbs % get_Xc ( 1 ), & expected = Xc ( 1 ,:), & tol = TOL , & msg = \"NURBS Xc(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1): matches input (B-spline)\" , & res = bsp % get_Xc ( 1 ), & expected = Xc ( 1 ,:), & tol = TOL , & msg = \"B-spline Xc(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1,1): matches input (NURBS)\" , & res = nurbs % get_Xc ( 1 , 1 ), & expected = Xc ( 1 , 1 ), & tol = TOL , & msg = \"NURBS Xc(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xc(1,1): matches input (B-spline)\" , & res = bsp % get_Xc ( 1 , 1 ), & expected = Xc ( 1 , 1 ), & tol = TOL , & msg = \"B-spline Xc(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(): matches initial (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(): matches initial (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1): matches initial (NURBS)\" , & res = nurbs % get_Xg ( 1 ), & expected = Xg ( 1 ,:), & tol = TOL , & msg = \"NURBS Xg(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1): matches initial (B-spline)\" , & res = bsp % get_Xg ( 1 ), & expected = Xgb ( 1 ,:), & tol = TOL , & msg = \"B-spline Xg(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1,1): matches initial (NURBS)\" , & res = nurbs % get_Xg ( 1 , 1 ), & expected = Xg ( 1 , 1 ), & tol = TOL , & msg = \"NURBS Xg(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Xg(1,1): matches initial (B-spline)\" , & res = bsp % get_Xg ( 1 , 1 ), & expected = Xgb ( 1 , 1 ), & tol = TOL , & msg = \"B-spline Xg(1,1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Wc(): matches input (NURBS)\" , & res = nurbs % get_Wc (), & expected = Wc , & tol = TOL , & msg = \"NURBS Wc mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_Wc(1): matches input (NURBS)\" , & res = nurbs % get_Wc ( 1 ), & expected = Wc ( 1 ), & tol = TOL , & msg = \"NURBS Wc(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(): matches input (NURBS)\" , & res = nurbs % get_knot (), & expected = knot , & tol = TOL , & msg = \"NURBS knot mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(): matches input (B-spline)\" , & res = bsp % get_knot (), & expected = knot , & tol = TOL , & msg = \"B-spline knot mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(1): matches input (NURBS)\" , & res = nurbs % get_knot ( 1 ), & expected = knot ( 1 ), & tol = TOL , & msg = \"NURBS knot(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_knot(1): matches input (B-spline)\" , & res = bsp % get_knot ( 1 ), & expected = knot ( 1 ), & tol = TOL , & msg = \"B-spline knot(1) mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_ng(): matches Xg size (NURBS)\" , & res = nurbs % get_ng (), & expected = size ( Xg , 1 ), & msg = \"NURBS ng mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_ng(): matches Xgb size (B-spline)\" , & res = bsp % get_ng (), & expected = size ( Xgb , 1 ), & msg = \"B-spline ng mismatch\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_degree(): matches 2 (NURBS)\" , & res = nurbs % get_degree (), & expected = 2 , & msg = \"NURBS degree not 2\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_degree(): matches 2 (B-spline)\" , & res = bsp % get_degree (), & expected = 2 , & msg = \"B-spline degree not 2\" , & group = \"getters\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_multiplicity(): matches [3,3] (NURBS)\" , & res = nurbs % get_multiplicity (), & expected = [ 3 , 3 ], & msg = \"NURBS multiplicity not [3,3]\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_multiplicity(): matches [3,3] (B-spline)\" , & res = bsp % get_multiplicity (), & expected = [ 3 , 3 ], & msg = \"B-spline multiplicity not [3,3]\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_continuity(): matches [-1,-1] (NURBS)\" , & res = nurbs % get_continuity (), & expected = [ - 1 , - 1 ], & msg = \"NURBS continuity not [-1,-1]\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"get_continuity(): matches [-1,-1] (B-spline)\" , & res = bsp % get_continuity (), & expected = [ - 1 , - 1 ], & msg = \"B-spline continuity not [-1,-1]\" , & group = \"knot-ops\" ); ti = ti + 1 call nurbs % cmp_nc () call bsp % cmp_nc () call ut % test ( ti )% check ( & name = \"cmp_nc(): matches nc (NURBS)\" , & res = nurbs % get_nc (), & expected = size ( Xc , 1 ), & msg = \"NURBS cmp_nc mismatch\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"cmp_nc(): matches nc (B-spline)\" , & res = bsp % get_nc (), & expected = size ( Xc , 1 ), & msg = \"B-spline cmp_nc mismatch\" , & group = \"knot-ops\" ); ti = ti + 1 ! 11) Element connectivity tests elemConn = nurbs % cmp_elem_Xc_vis ( 2 ) call nurbs % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(p=2): equality (NURBS)\" , & res = nurbs % get_elem_Xc_vis (), & expected = elemConn , & msg = \"NURBS elem_Xc_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xc_vis () call nurbs % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(): equality (NURBS)\" , & res = nurbs % get_elem_Xc_vis (), & expected = elemConn , & msg = \"NURBS elem_Xc_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis ( 2 ) call bsp % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(p=2): equality (B-spline)\" , & res = bsp % get_elem_Xc_vis (), & expected = elemConn , & msg = \"B-spline elem_Xc_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis () call bsp % set_elem_Xc_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xc_vis(): equality (B-spline)\" , & res = bsp % get_elem_Xc_vis (), & expected = elemConn , & msg = \"B-spline elem_Xc_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis ( 2 ) call nurbs % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(p=2): equality (NURBS)\" , & res = nurbs % get_elem_Xg_vis (), & expected = elemConn , & msg = \"NURBS elem_Xg_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis () call nurbs % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(): equality (NURBS)\" , & res = nurbs % get_elem_Xg_vis (), & expected = elemConn , & msg = \"NURBS elem_Xg_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis ( 2 ) call bsp % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(p=2): equality (B-spline)\" , & res = bsp % get_elem_Xg_vis (), & expected = elemConn , & msg = \"B-spline elem_Xg_vis(p=2) mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis () call bsp % set_elem_Xg_vis ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem_Xg_vis(): equality (B-spline)\" , & res = bsp % get_elem_Xg_vis (), & expected = elemConn , & msg = \"B-spline elem_Xg_vis mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = nurbs % cmp_elem () call nurbs % set_elem ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem: equality (NURBS)\" , & res = nurbs % get_elem (), & expected = elemConn , & msg = \"NURBS elem mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) elemConn = bsp % cmp_elem () call bsp % set_elem ( elemConn ) call ut % test ( ti )% check ( & name = \"set/get elem: equality (B-spline)\" , & res = bsp % get_elem (), & expected = elemConn , & msg = \"B-spline elem mismatch\" , & group = \"elements\" ); ti = ti + 1 deallocate ( elemConn ) ! 12) Modify and export call nurbs % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call bsp % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call nurbs % modify_Wc ( Wc ( 1 ), 1 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( fXc_nurbs ) call bsp % export_Xc ( fXc_bsp ) call nurbs % export_Xg ( fXg_nurbs ) call bsp % export_Xg ( fXg_bsp ) call ut % test ( ti )% check ( & name = \"modify_Xc/Wc: geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after modify_Xc/Wc\" , & group = \"modify\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"modify_Xc: geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after modify_Xc\" , & group = \"modify\" ); ti = ti + 1 ! 13) Basis and derivative tests call nurbs % basis ( res = 23 , Tgc = Tgc ) call bsp % basis ( res = 23 , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"basis(res=23): sum(N)=1 rows (NURBS)\" , & res = all ( abs ( sum ( Tgc , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"NURBS basis partition of unity violated\" , & group = \"basis\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"basis(res=23): sum(N)=1 rows (B-spline)\" , & res = all ( abs ( sum ( Tgcb , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"B-spline basis partition of unity violated\" , & group = \"basis\" ); ti = ti + 1 call nurbs % basis ( Xt = 0.0_rk , Tgc = Tgc1 ) call bsp % basis ( Xt = 0.0_rk , Tgc = Tgc1b ) call ut % test ( ti )% check ( & name = \"basis(Xt=0): sum(N)=1 (NURBS)\" , & res = sum ( Tgc1 ), & expected = 1.0_rk , & tol = TOL , & msg = \"NURBS basis sum not 1 at t=0\" , & group = \"basis\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"basis(Xt=0): sum(N)=1 (B-spline)\" , & res = sum ( Tgc1b ), & expected = 1.0_rk , & tol = TOL , & msg = \"B-spline basis sum not 1 at t=0\" , & group = \"basis\" ); ti = ti + 1 allocate ( Xt ( 23 )) do i = 1 , 23 Xt ( i ) = real ( i - 1 , rk ) / real ( 23 - 1 , rk ) end do call nurbs % basis ( Xt = Xt , Tgc = Tgc ) call bsp % basis ( Xt = Xt , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"basis(Xt vector): sum(N)=1 rows (NURBS)\" , & res = all ( abs ( sum ( Tgc , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"NURBS basis partition of unity violated (vector)\" , & group = \"basis\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"basis(Xt vector): sum(N)=1 rows (B-spline)\" , & res = all ( abs ( sum ( Tgcb , dim = 2 ) - 1.0_rk ) <= TOL ), & expected = . true ., & msg = \"B-spline basis partition of unity violated (vector)\" , & group = \"basis\" ); ti = ti + 1 call nurbs % derivative ( res = 23 , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( res = 23 , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative(res=23): sum(dN)=0 rows (NURBS)\" , & res = all ( abs ( sum ( dTgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(res=23): sum(dN)=0 rows (B-spline)\" , & res = all ( abs ( sum ( dTgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative ( Xt = Xt , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( Xt = Xt , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative(Xt vector): sum(dN)=0 rows (NURBS)\" , & res = all ( abs ( sum ( dTgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(Xt vector): sum(dN)=0 rows (B-spline)\" , & res = all ( abs ( sum ( dTgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative ( Xt = 0.0_rk , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative ( Xt = 0.0_rk , dTgc = dTgc1b , Tgc = Tgc1b ) call ut % test ( ti )% check ( & name = \"derivative(Xt=0): sum(dN)=0 (NURBS)\" , & res = sum ( dTgc1 ), & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(Xt=0): sum(dN)=0 (B-spline)\" , & res = sum ( dTgc1b ), & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative ( Xt = 0.0_rk , dTgc = dTgc1 , Tgc = Tgc1 , elem = [ 1 , 2 , 3 ]) call bsp % derivative ( Xt = 0.0_rk , dTgc = dTgc1b , Tgc = Tgc1b , elem = [ 1 , 2 , 3 ]) call ut % test ( ti )% check ( & name = \"derivative(Xt=0, elem): sum(dN)=0 (NURBS)\" , & res = sum ( dTgc1 ), & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS derivative sum not zero (elem)\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative(Xt=0, elem): sum(dN)=0 (B-spline)\" , & res = sum ( dTgc1b ), & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline derivative sum not zero (elem)\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative2 ( res = 23 , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( res = 23 , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative2(res=23): sum(d2N)=0 rows (NURBS)\" , & res = all ( abs ( sum ( d2Tgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS second derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative2(res=23): sum(d2N)=0 rows (B-spline)\" , & res = all ( abs ( sum ( d2Tgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline second derivative sum not zero\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( Xt = Xt , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call ut % test ( ti )% check ( & name = \"derivative2(Xt vector): sum(d2N)=0 rows (NURBS)\" , & res = all ( abs ( sum ( d2Tgc , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"NURBS second derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative2(Xt vector): sum(d2N)=0 rows (B-spline)\" , & res = all ( abs ( sum ( d2Tgcb , dim = 2 )) <= TOL ), & expected = . true ., & msg = \"B-spline second derivative sum not zero (vector)\" , & group = \"derivatives\" ); ti = ti + 1 call nurbs % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call ut % test ( ti )% check ( & name = \"derivative2(Xt=0): sum(d2N)=0 (NURBS)\" , & res = sum ( d2Tgc1 ), & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS second derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"derivative2(Xt=0): sum(d2N)=0 (B-spline)\" , & res = sum ( d2Tgc1b ), & expected = 0.0_rk , & tol = TOL , & msg = \"B-spline second derivative sum not zero at t=0\" , & group = \"derivatives\" ); ti = ti + 1 ! 14) Rotation tests (Xc) call nurbs % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xc(X-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xc(X-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xc(Y-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xc(Y-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xc(Z-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xc(Z-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 ! 15) Rotation tests (Xg) call nurbs % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xg(X-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xg(X-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after X-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xg(Y-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xg(Y-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after Y-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % test ( ti )% check ( & name = \"rotate_Xg(Z-axis): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"rotate_Xg(Z-axis): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after Z-axis rotation\" , & group = \"transform\" ); ti = ti + 1 ! 16) Translation tests (Xc) call nurbs % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % test ( ti )% check ( & name = \"translate_Xc(): geometry preserved (NURBS)\" , & res = nurbs % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"NURBS Xc changed after translation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"translate_Xc(): geometry preserved (B-spline)\" , & res = bsp % get_Xc (), & expected = Xc , & tol = TOL , & msg = \"B-spline Xc changed after translation\" , & group = \"transform\" ); ti = ti + 1 ! 17) Translation tests (Xg) call nurbs % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % test ( ti )% check ( & name = \"translate_Xg(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS Xg changed after translation\" , & group = \"transform\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"translate_Xg(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline Xg changed after translation\" , & group = \"transform\" ); ti = ti + 1 ! 18) Knot insertion call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call ut % test ( ti )% check ( & name = \"insert_knots(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after knot insertion\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"insert_knots(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after knot insertion\" , & group = \"knot-ops\" ); ti = ti + 1 ! 19) Degree elevation call nurbs % elevate_degree ( 2 ) call bsp % elevate_degree ( 2 ) call nurbs % create () call bsp % create () call ut % test ( ti )% check ( & name = \"elevate_degree(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after degree elevation\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"elevate_degree(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after degree elevation\" , & group = \"knot-ops\" ); ti = ti + 1 ! 20) Knot removal call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call ut % test ( ti )% check ( & name = \"remove_knots(): geometry preserved (NURBS)\" , & res = nurbs % get_Xg (), & expected = Xg , & tol = TOL , & msg = \"NURBS geometry changed after knot removal\" , & group = \"knot-ops\" ); ti = ti + 1 call ut % test ( ti )% check ( & name = \"remove_knots(): geometry preserved (B-spline)\" , & res = bsp % get_Xg (), & expected = Xgb , & tol = TOL , & msg = \"B-spline geometry changed after knot removal\" , & group = \"knot-ops\" ); ti = ti + 1 ! 21) Shape functions (circle, half-circle) call nurbs % set_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) call nurbs % create ( res = 23 ) call nurbs % nearest_point ([ 1.0_rk , 0.0_rk , 0.0_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"set_circle(): nearest point param (NURBS)\" , & res = nearest_Xt , & expected = 0.0_rk , & tol = TOL , & msg = \"NURBS circle nearest point param incorrect\" , & group = \"shapes\" ); ti = ti + 1 call nurbs % set_half_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) call nurbs % create ( res = 23 ) call nurbs % nearest_point ([ 0.0_rk , 1.0_rk , 0.0_rk ], nearest_Xg , nearest_Xt , id ) call ut % test ( ti )% check ( & name = \"set_half_circle(): nearest point param (NURBS)\" , & res = nearest_Xt , & expected = 0.5_rk , & tol = TOL , & msg = \"NURBS half-circle nearest point param incorrect\" , & group = \"shapes\" ); ti = ti + 1 ! 22) Least-squares B-spline fitting block type ( nurbs_curve ) :: bsp_fit integer :: n real ( rk ), allocatable :: Xt_fit (:), Xdata (:,:), Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = 42 allocate ( Xt_fit ( n ), Xdata ( n , 3 )) do i = 1 , n Xt_fit ( i ) = real ( i - 1 , rk ) / real ( n - 1 , rk ) Xdata ( i , 1 ) = Xt_fit ( i ) Xdata ( i , 2 ) = 0.3_rk * sin ( 4.0_rk * PI * Xt_fit ( i )) Xdata ( i , 3 ) = 0.3_rk * cos ( 4.0_rk * PI * Xt_fit ( i )) end do call bsp_fit % set ( & degree = 5 , & Xth_dir = [( real ( i - 1 , rk ) / 1 0.0_rk , i = 1 , 11 )], & continuity = [ - 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , - 1 ]) call bsp_fit % lsq_fit_bspline ( Xt_fit , Xdata , n ) call bsp_fit % create ( res = n ) Xg_eval = bsp_fit % get_Xg () err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / norm2 ( Xdata (:, 1 )) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / norm2 ( Xdata (:, 2 )) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / norm2 ( Xdata (:, 3 )) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) call ut % test ( ti )% check ( & name = \"lsq_fit_bspline(): RMS error\" , & res = rms , & expected = 0.0_rk , & tol = 1.0e-6_rk , & msg = \"B-spline least-squares fit RMS error too high\" , & group = \"basis\" ); ti = ti + 1 call bsp_fit % finalize () deallocate ( Xt_fit , Xdata , Xg_eval ) end block ! Finalize call nurbs % finalize () call bsp % finalize () deallocate ( Xc , Wc , Xg , Xgb , Xt ) if ( allocated ( Tgc )) deallocate ( Tgc ) if ( allocated ( Tgcb )) deallocate ( Tgcb ) if ( allocated ( dTgc )) deallocate ( dTgc ) if ( allocated ( dTgcb )) deallocate ( dTgcb ) if ( allocated ( d2Tgc )) deallocate ( d2Tgc ) if ( allocated ( d2Tgcb )) deallocate ( d2Tgcb ) if ( allocated ( Tgc1 )) deallocate ( Tgc1 ) if ( allocated ( Tgc1b )) deallocate ( Tgc1b ) if ( allocated ( dTgc1 )) deallocate ( dTgc1 ) if ( allocated ( dTgc1b )) deallocate ( dTgc1b ) if ( allocated ( d2Tgc1 )) deallocate ( d2Tgc1 ) if ( allocated ( d2Tgc1b )) deallocate ( d2Tgc1b ) call ut % summary ( verbose = 3 , required_score = 10 0.0 ) end program test_nurbs_curve","tags":"","url":"sourcefile/test_nurbs_curve.f90.html"},{"title":"forcad_kinds.F90 – ForCAD","text":"Files dependent on this one sourcefile~~forcad_kinds.f90~~AfferentGraph sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~test_utils.f90 test_utils.f90 sourcefile~test_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~test_utils.f90->sourcefile~forcad_utils.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad_utils.f90 sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad_utils.f90 sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad_utils.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad_utils.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad_utils.f90 sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forcad_kinds implicit none private public rk #ifdef REAL32 integer , parameter :: rk = selected_real_kind ( 6 ) #elif REAL64 integer , parameter :: rk = selected_real_kind ( 15 ) #elif REALXDP integer , parameter :: rk = selected_real_kind ( 18 ) #elif REAL128 integer , parameter :: rk = selected_real_kind ( 33 ) #else integer , parameter :: rk = selected_real_kind ( 15 ) #endif end module","tags":"","url":"sourcefile/forcad_kinds.f90.html"},{"title":"example_plate_hole_2_3d.f90 – ForCAD","text":"This file depends on sourcefile~~example_plate_hole_2_3d.f90~~EfferentGraph sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_plate_hole_2_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: plate_hole real ( rk ), allocatable :: Xc (:,:) real ( rk ), allocatable :: Wc (:) real ( rk ), parameter :: radius1 = 2.5_rk real ( rk ), parameter :: radius2 = 3.5_rk real ( rk ), parameter :: length = 5.0_rk real ( rk ), parameter :: height = 5.0_rk real ( rk ), parameter :: width = 0.5_rk call set_Xc_Wc ( 'ellipse' , [ radius1 , radius2 , length , height , width ], Xc , Wc ) call plate_hole % set (& knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 2.0_rk , 2.0_rk , 3.0_rk , 4.0_rk , 4.0_rk , 4.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ,& Wc = Wc & ) call plate_hole % create ( 31 , 31 , 5 ) call plate_hole % export_Xc ( \"vtk/plate_hole_2_3d_Xc.vtk\" ) call plate_hole % export_Xg ( \"vtk/plate_hole_2_3d_Xg.vtk\" ) call plate_hole % export_Xth_in_Xg ( \"vtk/plate_hole_2_3d_Xth.vtk\" ) call plate_hole % show ( \"vtk/plate_hole_2_3d_Xc.vtk\" , \"vtk/plate_hole_2_3d_Xg.vtk\" , \"vtk/plate_hole_2_3d_Xth.vtk\" ) contains !=============================================================================== pure subroutine set_Xc_Wc ( tp , params , X_c , W_c ) character ( len =* ), intent ( in ) :: tp real ( rk ), intent ( in ), contiguous :: params (:) real ( rk ), allocatable , intent ( out ) :: X_c (:,:) real ( rk ), allocatable , intent ( out ) :: W_c (:) real ( rk ) :: r1 , r2 , l , w , h select case ( tp ) case ( 'circle' ) r1 = params ( 1 ) l = params ( 3 ) h = params ( 4 ) w = params ( 5 ) if ( r1 < 0.0_rk ) error stop 'Radius must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' if ( w < 0.0_rk ) error stop 'Width must be positive' allocate ( X_c ( 21 * 2 , 3 )) X_c ( 1 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 2 , 1 : 2 ) = [ - r1 , r1 * tand ( 2 2.5_rk )] X_c ( 3 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 4 , 1 : 2 ) = [ 0.0_rk , r1 ] X_c ( 5 , 1 : 2 ) = [ r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 6 , 1 : 2 ) = [ r1 , r1 * tand ( 2 2.5_rk )] X_c ( 7 , 1 : 2 ) = [ r1 , 0.0_rk ] X_c ( 8 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 9 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 10 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 11 , 1 : 2 ) = [ 0.0_rk , ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 12 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 13 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 14 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 16 , 1 : 2 ) = [ - l , h ] X_c ( 17 , 1 : 2 ) = [ - l , h ] X_c ( 18 , 1 : 2 ) = [ 0.0_rk , h ] X_c ( 19 , 1 : 2 ) = [ l , h ] X_c ( 20 , 1 : 2 ) = [ l , h ] X_c ( 21 , 1 : 2 ) = [ l , 0.0_rk ] X_c ( 22 : 42 , 1 : 2 ) = X_c ( 1 : 21 , 1 : 2 ) X_c ( 1 : 21 , 3 ) = 0.0_rk X_c ( 22 : 42 , 3 ) = w allocate ( W_c ( 21 * 2 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 , 23 , 24 , 26 , 27 ]) = ( 1.0_rk + 1.0_rk / sqrt ( 2.0_rk )) / 2.0_rk case ( 'ellipse' ) r1 = params ( 1 ) r2 = params ( 2 ) l = params ( 3 ) h = params ( 4 ) w = params ( 5 ) if ( r1 < 0.0_rk ) error stop 'Radius1 must be positive' if ( r2 < 0.0_rk ) error stop 'Radius2 must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' if ( w < 0.0_rk ) error stop 'Width must be positive' allocate ( X_c ( 21 * 2 , 3 )) X_c ( 1 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 2 , 1 : 2 ) = [ - r1 , r2 * tand ( 2 2.5_rk )] X_c ( 3 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 4 , 1 : 2 ) = [ 0.0_rk , r2 ] X_c ( 5 , 1 : 2 ) = [ r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 6 , 1 : 2 ) = [ r1 , r2 * tand ( 2 2.5_rk )] X_c ( 7 , 1 : 2 ) = [ r1 , 0.0_rk ] X_c ( 8 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 9 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 10 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 11 , 1 : 2 ) = [ 0.0_rk , ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 12 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 13 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 14 , 1 : 2 ) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 16 , 1 : 2 ) = [ - l , h ] X_c ( 17 , 1 : 2 ) = [ - l , h ] X_c ( 18 , 1 : 2 ) = [ 0.0_rk , h ] X_c ( 19 , 1 : 2 ) = [ l , h ] X_c ( 20 , 1 : 2 ) = [ l , h ] X_c ( 21 , 1 : 2 ) = [ l , 0.0_rk ] X_c ( 22 : 42 , 1 : 2 ) = X_c ( 1 : 21 , 1 : 2 ) X_c ( 1 : 21 , 3 ) = 0.0_rk X_c ( 22 : 42 , 3 ) = w allocate ( W_c ( 21 * 2 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 , 23 , 24 , 26 , 27 ]) = cosd ( 2 2.5_rk ) case default error stop 'set_Xc_Wc: Invalid type. Valid types are: circle, ellipse' end select end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_plate_hole_2_3d.f90.html"},{"title":"nearest_point_2d_bench.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d_bench.f90~~EfferentGraph sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d_bench use forcad , only : rk , nurbs_surface use fortime , only : timer implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ) :: nearest_Xg ( 3 ) !! Coordinates of the nearest point on the surface real ( rk ) :: nearest_Xt ( 2 ) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ), allocatable :: points (:,:) real ( rk ) :: pointsi ( 3 ) integer :: i , j type ( timer ) :: t !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 100 , 100 ) !----------------------------------------------------------------------------- ! Nearest point on the surface !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) do j = 1 , 40 allocate ( points ( j * 1000 , 3 )) print * , j * 1000 call random_number ( points ) call t % timer_start () do i = 1 , size ( points , 1 ) pointsi = points ( i ,:) call shape % nearest_point ( pointsi , nearest_Xg , nearest_Xt , id ) end do call t % timer_stop () deallocate ( points ) end do !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () end program","tags":"","url":"sourcefile/nearest_point_2d_bench.f90.html"},{"title":"poisson_iga_solver_3d.f90 – ForCAD","text":"This file depends on sourcefile~~poisson_iga_solver_3d.f90~~EfferentGraph sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Solves the 3D Poisson problem using Isogeometric Analysis (IGA). !> !> This code solves the equation: !>  !>   -\\Delta u = f \\quad \\text{in } \\Omega, \\qquad u = 0 \\quad \\text{on } \\partial \\Omega !>  !> using a B-spline volume on a rectangular domain. !> !> The solution is discretized using tensor-product B-spline basis functions !> over a structured control net. The global linear system is assembled and !> solved using a basic internal Cholesky solver. !> !> The resulting solution is exported to VTK format for visualization. !> !> The L2 error norm with respect to the exact solution !> is computed and printed. !> !> @note !> This implementation uses B-spline geometry (no rational weights), hence the volume is not a full NURBS. !> @endnote !> !> @warning \"Slow solver\" !> The solver uses an internal Cholesky factorization which is not optimized. For large systems, consider replacing it with a more scalable external solver. !> @endwarning !> program poisson_iga_solver_3d use forcad , only : rk , nurbs_volume use forcad_utils , only : solve use fortime , only : timer implicit none type ( nurbs_volume ) :: vol !! NURBS volume object real ( rk ), parameter :: pi = acos ( - 1.0_rk ) !! Constant  \\pi  integer :: ie !! Element index integer :: ig !! Quadrature (Gauss) point index integer :: i !! Generic loop index integer :: nelem !! Number of elements integer :: nnelem !! Number of local nodes per element integer :: nc ( 3 ) !! Number of control points in each direction integer :: nct !! Total number of control points integer :: res ( 3 ) !! Visualization resolution integer :: dof !! Degrees of freedom per control point (1 for scalar field) integer :: ndof !! Total degrees of freedom integer :: m ( 3 ) !! Mode numbers  (m_1, m_2, m_3)  for source and exact solution integer :: ki ( 3 ) !! Number of knots to insert in each direction integer , allocatable :: elem (:,:) !! Element connectivity matrix integer , allocatable :: elem_e (:) !! Local connectivity of current element integer , allocatable :: dirichlet_id (:) !! Indices for Dirichlet boundary conditions real ( rk ), allocatable :: K (:,:) !! Global stiffness matrix  K  real ( rk ), allocatable :: b (:) !! Global right-hand side vector  b  real ( rk ), allocatable :: Xc (:,:) !! Control point coordinates real ( rk ), allocatable :: Xg (:) !! Physical coordinates at quadrature point real ( rk ), allocatable :: T (:) !! Basis function values at quadrature point real ( rk ), allocatable :: dT (:,:) !! Derivatives of basis functions at quadrature point real ( rk ), allocatable :: X (:,:) !! Global solution vector  X  real ( rk ), allocatable :: u_h (:,:) !! Interpolated solution field  u(x,y)  on grid real ( rk ) :: dV !! Differential element volume  \\text{d}V = J \\cdot w  real ( rk ) :: l2_error !! L2 error norm accumulator  \\|u_h - u\\|&#94;2  real ( rk ) :: L ( 3 ) !! Domain size  (L_1, L_2, L_3) \\in \\mathbb{R}&#94;3  character ( len = 256 ) :: filename !! Filename for VTK export type ( timer ) :: ti !! Timer object for performance measurement !> Domain size and number of control points L = [ 1.0_rk , 1.0_rk , 1.0_rk ] nc = [ 6 , 6 , 6 ] !> Number knots to insert in each direction ki = [ 3 , 3 , 3 ] !> Mode numbers for the source term and exact solution m = [ 2 , 2 , 2 ] !> Resolution of the visualization grid res = [ 50 , 50 , 50 ] !> filename for VTK export filename = \"vtk/poisson_iga_solver_3d\" !> Construct the NURBS volume !> For simplicity, set_hexahedron creates a rectangular volume with uniform knot spacing !> For more complex geometries, use vol%set() with knots, continuity,... call vol % set_hexahedron ( L = L , nc = nc ) !> Insert knots in the first and second directions call vol % insert_knots ( 1 , [( real ( i , rk ) / real ( ki ( 1 ), rk ), i = 1 , ki ( 1 ) - 1 )], [( 1 , i = 1 , ki ( 1 ) - 1 )]) call vol % insert_knots ( 2 , [( real ( i , rk ) / real ( ki ( 2 ), rk ), i = 1 , ki ( 2 ) - 1 )], [( 1 , i = 1 , ki ( 2 ) - 1 )]) call vol % insert_knots ( 3 , [( real ( i , rk ) / real ( ki ( 3 ), rk ), i = 1 , ki ( 3 ) - 1 )], [( 1 , i = 1 , ki ( 3 ) - 1 )]) !> Extract geometry and mesh structure Xc = vol % get_Xc () elem = vol % cmp_elem () nct = product ( vol % get_nc ()) nelem = size ( elem , 1 ) nnelem = size ( elem , 2 ) dof = 1 ndof = dof * nct print '(a,g0,\",\",g0,\",\",g0)' , \"Degree (dir1, dir2, dir3)                  : \" , vol % get_degree ( 1 ), vol % get_degree ( 2 ), vol % get_degree ( 3 ) print '(a,g0,\"x\",g0,\"x\",g0)' , \"Control net size (dir1 x dir2 x dir3)      : \" , nc ( 1 ), nc ( 2 ), nc ( 3 ) print '(a,g0)' , \"Total control points                       : \" , nct print '(a,g0)' , \"Number of elements                         : \" , nelem print '(a,g0)' , \"Degrees of freedom (DoFs)                  : \" , ndof print '(a,g0,\" x \",g0,\" x \",g0)' , \"Domain size (L1, L2, L3)                   : \" , L ( 1 ), L ( 2 ), L ( 3 ) print '(a,g0,\",\",g0,\",\",g0)' , \"Mode numbers (m1, m2, m3)                  : \" , m ( 1 ), m ( 2 ), m ( 3 ) print '(a,g0,\",\",g0,\",\",g0)' , \"Knot insertion (dir1, dir2, dir3)          : \" , ki ( 1 ), ki ( 2 ), ki ( 3 ) print '(a,g0,\"x\",g0,\"x\",g0)' , \"Visualization resolution (res1, res2, res3): \" , res ( 1 ), res ( 2 ), res ( 3 ) !> Assemble global stiffness matrix and load vector allocate ( K ( nct , nct ), b ( nct ), source = 0.0_rk ) call ti % timer_start () !$omp parallel do private(ie, ig, elem_e, T, dT, Xg, dV) shared(K, b) do ie = 1 , nelem elem_e = elem ( ie , :) do ig = 1 , nnelem call vol % ansatz ( ie , ig , T , dT , dV ) Xg = matmul ( T , Xc ( elem_e ,:)) !$omp critical b ( elem_e ) = b ( elem_e ) + T * source_term ( Xg , L , m ) * dV K ( elem_e , elem_e ) = K ( elem_e , elem_e ) + matmul ( dT , transpose ( dT )) * dV !$omp end critical end do end do !$omp end parallel do call ti % timer_stop ( message = \"Assembly                             : \" ) !> Apply homogeneous Dirichlet boundary conditions call ti % timer_start () allocate ( dirichlet_id ( 0 )) do i = 1 , nct if (& abs ( Xc ( i , 1 )) < 1e-12_rk . or . abs ( Xc ( i , 1 ) - L ( 1 )) < 1e-12_rk . or . & abs ( Xc ( i , 2 )) < 1e-12_rk . or . abs ( Xc ( i , 2 ) - L ( 2 )) < 1e-12_rk . or . & abs ( Xc ( i , 3 )) < 1e-12_rk . or . abs ( Xc ( i , 3 ) - L ( 3 )) < 1e-12_rk ) then dirichlet_id = [ dirichlet_id , i ] end if end do K ( dirichlet_id , :) = 0.0_rk K (:, dirichlet_id ) = 0.0_rk b ( dirichlet_id ) = 0.0_rk do concurrent ( i = 1 : size ( dirichlet_id )) K ( dirichlet_id ( i ), dirichlet_id ( i )) = 1.0_rk end do call ti % timer_stop ( message = \"Boundary conditions                  : \" ) !> Solve the linear system K·X = b call ti % timer_start () X = solve ( K , reshape ( b , [ nct , 1 ])) call ti % timer_stop ( message = \"System solution                      : \" ) !> Export solution at control points to VTK call vol % export_Xc ( filename = trim ( filename ) // \".vtk\" , point_data = reshape ( X , [ nct , 1 ]), field_names = [ \"u\" ]) !> Interpolate solution and export field call vol % create ( res1 = res ( 1 ), res2 = res ( 2 ), res3 = res ( 3 )) call vol % basis ( Tgc = u_h ) u_h = matmul ( u_h , reshape ( X (:, 1 ), [ nct , 1 ])) call vol % export_Xg ( filename = trim ( filename ) // \"_interp.vtk\" , point_data = u_h , field_names = [ \"u\" ]) !> Compute the L2 error norm call ti % timer_start () l2_error = 0.0_rk do ie = 1 , nelem elem_e = elem ( ie , :) do ig = 1 , nnelem call vol % ansatz ( ie , ig , T , dT , dV ) Xg = matmul ( T , Xc ( elem_e ,:)) l2_error = l2_error + ( dot_product ( T , X ( elem_e , 1 )) - exact_solution ( Xg , L , m )) ** 2 * dV end do end do call ti % timer_stop ( message = \"L2 error evaluation                  : \" ) print '(a,1pe11.4)' , \"L2 error norm                        = \" , sqrt ( l2_error ) print '(a,a,a,a)' , trim ( filename ) // \".vtk\" , \" and \" , trim ( filename ) // \"_interp.vtk\" , \" exported\" call vol % finalize () ! deallocate(K, b, Xc, Xg, T, dT, X, u_h) contains !> Computes the source function  f(x,y,z) = \\sin(m_1 \\pi x / L_1) \\sin(m_2 \\pi y / L_2) \\sin(m_3 \\pi z / L_3)  pure function source_term ( p , d , n ) result ( f ) real ( rk ), intent ( in ) :: p ( 3 ) !! Coordinates (x, y, z) real ( rk ), intent ( in ) :: d ( 3 ) !! Domain size (L1, L2, L3) integer , intent ( in ) :: n ( 3 ) !! Mode numbers (m1, m2, m3) real ( rk ) :: f f = sin ( n ( 1 ) * pi * p ( 1 ) / d ( 1 )) * sin ( n ( 2 ) * pi * p ( 2 ) / d ( 2 )) * sin ( n ( 3 ) * pi * p ( 3 ) / d ( 3 )) end function !> Computes the exact solution corresponding to the source term !> !>  !> u(x, y, z) = \\frac{1}{\\lambda} \\sin(m_1 \\pi x / L_1) \\sin(m_2 \\pi y / L_2) \\sin(m_3 \\pi z / L_3) !> \\quad\\text{where}\\quad !> \\lambda = \\left( \\frac{m_1 \\pi}{L_1} \\right)&#94;2 + \\left( \\frac{m_2 \\pi}{L_2} \\right)&#94;2 + \\left( \\frac{m_3 \\pi}{L_3} \\right)&#94;2 !>  pure function exact_solution ( p , d , n ) result ( u ) real ( rk ), intent ( in ) :: p ( 3 ) !! Coordinates (x, y, z) real ( rk ), intent ( in ) :: d ( 3 ) !! Domain size (L1, L2, L3) integer , intent ( in ) :: n ( 3 ) !! Mode numbers (m1, m2, m3) real ( rk ) :: u , lam lam = ( n ( 1 ) * pi / d ( 1 )) ** 2 + ( n ( 2 ) * pi / d ( 2 )) ** 2 + ( n ( 3 ) * pi / d ( 3 )) ** 2 u = ( 1.0_rk / lam ) * sin ( n ( 1 ) * pi * p ( 1 ) / d ( 1 )) * sin ( n ( 2 ) * pi * p ( 2 ) / d ( 2 )) * sin ( n ( 3 ) * pi * p ( 3 ) / d ( 3 )) end function end program","tags":"","url":"sourcefile/poisson_iga_solver_3d.f90.html"},{"title":"shape_half_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_3d.f90~~EfferentGraph sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_3d_Xc.vtk' , 'vtk/shape_half_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_half_ring_3d.f90.html"},{"title":"example_helix_pipe.f90 – ForCAD","text":"This file depends on sourcefile~~example_helix_pipe.f90~~EfferentGraph sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Example program demonstrating how to sweep a straight, pipe-like NURBS volume !> into a **cylindrical helix** with a prescribed radius, pitch, and number of turns. !> !> The program: !>   Creates a straight ring extruded along z (a pipe segment), !>   Refines it along the axial direction (knot insertion + degree elevation), !>   Maps the control points onto a helix of radius `rh`, pitch `pitch`, with `nturns` turns, !>   Exports the resulting NURBS volume to VTK, !>   Displays the geometry. program example_helix_pipe use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: ring !! Straight pipe ring. type ( nurbs_volume ) :: shape !! Helical pipe shape. real ( rk ), parameter :: center ( 3 ) = [ 0.0_rk , 0.0_rk , 0.0_rk ] !! Pipe center (c_x,c_y,c_z). real ( rk ), parameter :: r1 = 0.1_rk !! Inner radius of the pipe. real ( rk ), parameter :: r2 = 0.2_rk !! Outer radius of the pipe. real ( rk ), parameter :: length = 1.0_rk !! Length of the straight segment. real ( rk ), parameter :: rh = 1.0_rk !! Helix radius. real ( rk ), parameter :: pitch = 1.5_rk !! Helix pitch (axial rise per full turn). integer , parameter :: nturns = 3 !! Number of full turns. integer , parameter :: N = 50 !! # interior knots to insert along z. integer :: i ! Initialize a straight pipe ring call ring % set_ring ( center = center , radius1 = r1 , radius2 = r2 , length = length ) ! Refine along z (dir=3): add N evenly-spaced interior knots (multiplicity 1 keeps C&#94;{p-1}). call ring % insert_knots ( dir = 3 , Xth = [( real ( i , rk ) / real ( N + 1 , rk ), i = 1 , N )], r = [( 1 , i = 1 , N )]) ! elevate degree along z to increase smoothness/flexibility call ring % elevate_degree ( 3 , 5 ) ! Build the helical shape shape = ring call build_helix ( shape , c = center , rh = rh , p = pitch , n = nturns ) ! Create the NURBS volume sampling call shape % create ( 50 , 50 , 250 ) ! Export the NURBS volume to VTK files call shape % export_Xc ( \"vtk/helix_pipe_Xc.vtk\" ) call shape % export_Xg ( \"vtk/helix_pipe_Xg.vtk\" ) call shape % export_Xth_in_Xg ( \"vtk/helix_pipe_Xth.vtk\" , res = 20 ) ! Show the NURBS volume call shape % show ( \"vtk/helix_pipe_Xc.vtk\" , \"vtk/helix_pipe_Xg.vtk\" , \"vtk/helix_pipe_Xth.vtk\" ) contains !=============================================================================== !> Map a straight pipe-like NURBS volume onto a **cylindrical helix**. !> !> Each control point \\mathbf{X}_c=(x,y,z) is first expressed relative to !> the input center \\mathbf{c}=(c_x,c_y,c_z). For the axial (k) index, !> define a normalized parameter !>  !>   s(k) = !>   \\begin{cases} !>     \\dfrac{k-1}{n_c&#94;{(z)}-1}, & n_c&#94;{(z)} > 1,\\4pt] !>     0, & \\text{otherwise}, !>   \\end{cases} !>  !> which runs from 0 (start) to 1 (end) along the volume. !> !> The helix angle as a function of s is !>  !>   \\theta(s) = 2\\pi\\,n\\,s , !>  !> where `n` is the number of turns. For a point at polar coordinates !> \\rho=\\sqrt{(x-c_x)&#94;2+(y-c_y)&#94;2} and \\phi=\\operatorname{atan2}(y-c_y,x-c_x), !> the mapping is: !>  !>   X = c_x + \\bigl(r_h + \\rho\\cos\\phi\\bigr)\\cos\\theta(s),\\quad !>   Y = c_y + \\bigl(r_h + \\rho\\cos\\phi\\bigr)\\sin\\theta(s),\\quad !>   Z = c_z + \\rho\\sin\\phi + p\\,s , !>  !> where r_h is the helix radius and p is the pitch (axial rise per turn). !> !>  Knots are preserved; only the control points are updated. pure subroutine build_helix ( this , c , rh , p , n ) type ( nurbs_volume ), intent ( inout ) :: this !! NURBS volume to be helicalized. real ( rk ), intent ( in ) :: c ( 3 ), rh , p !! Center \\mathbf{c}, helix radius r_h, pitch p. integer , intent ( in ) :: n !! Number of turns. real ( rk ), allocatable :: Xc (:,:), X4 (:,:,:,:) integer :: nc ( 3 ), i , j , k , dim real ( rk ) :: s , theta , x0 , y0 , rho , phi , X , Y , Z real ( rk ), parameter :: pi = acos ( - 1.0_rk ) Xc = this % get_Xc (); dim = size ( Xc , 2 ) nc = this % get_nc () X4 = reshape ( Xc , [ nc ( 1 ), nc ( 2 ), nc ( 3 ), dim ]) do k = 1 , nc ( 3 ) s = merge ( real ( k - 1 , rk ) / real ( max ( 1 , nc ( 3 ) - 1 ), rk ), 0._rk , nc ( 3 ) > 1 ) theta = 2.0_rk * pi * real ( n , rk ) * s do j = 1 , nc ( 2 ) do i = 1 , nc ( 1 ) x0 = X4 ( i , j , k , 1 ) - c ( 1 ) y0 = X4 ( i , j , k , 2 ) - c ( 2 ) rho = sqrt ( x0 * x0 + y0 * y0 ) phi = merge ( atan2 ( y0 , x0 ), 0._rk , rho > 0._rk ) X = ( rh + rho * cos ( phi )) * cos ( theta ) + c ( 1 ) Y = ( rh + rho * cos ( phi )) * sin ( theta ) + c ( 2 ) Z = rho * sin ( phi ) + c ( 3 ) + p * s X4 ( i , j , k , 1 ) = X ; X4 ( i , j , k , 2 ) = Y ; X4 ( i , j , k , 3 ) = Z end do end do end do Xc = reshape ( X4 , [ product ( nc ), dim ]) if ( this % is_rational ()) then call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc , this % get_Wc ()) else call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc ) end if end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_helix_pipe.f90.html"},{"title":"shape_C_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_3d.f90~~EfferentGraph sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk , length = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_3d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 , 10 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_3d_Xc.vtk' , 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_c_3d.f90.html"},{"title":"demo_surface.f90 – ForCAD","text":"This file depends on sourcefile~~demo_surface.f90~~EfferentGraph sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface. !> It sets up control points and weights, generates the surface, and exports the control points !> and the surface to VTK files at various stages. program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !----------------------------------------------------------------------------- ! Refinement !----------------------------------------------------------------------------- !> Elevate the degree of the NURBS surface in the first and second directions call nurbs % elevate_degree ( 1 , 3 ) call nurbs % elevate_degree ( 2 , 3 ) !> Insert knots into the NURBS surface in the first and second directions call nurbs % insert_knots ( 1 ,[ 0.5_rk ], [ 1 ]) call nurbs % insert_knots ( 2 ,[ 0.5_rk ], [ 1 ]) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !> Export the parameter space to a VTK file call nurbs % export_Xth_in_Xg ( 'vtk/demo_surface_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry, geometry and parameters using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' , 'vtk/demo_surface_Xth_in_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- pure function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","url":"sourcefile/demo_surface.f90.html"},{"title":"shape_half_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_circle.f90~~EfferentGraph sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !> Set up a half circle shape centered at the 0,0,0 with a radius of 1 call shape % set_half_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_circle_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_circle_Xc.vtk' , 'vtk/shape_half_circle_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_half_circle.f90.html"},{"title":"shape_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_3d.f90~~EfferentGraph sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_3d_Xc.vtk' , 'vtk/shape_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_ring_3d.f90.html"},{"title":"test_nurbs_surface.f90 – ForCAD","text":"This file depends on sourcefile~~test_nurbs_surface.f90~~EfferentGraph sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_nurbs_surface use forcad , only : rk , nurbs_surface use forcad_utils , only : ndgrid use forunittest , only : unit_test implicit none type ( nurbs_surface ) :: nurbs , bsp real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), area , areab real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xg (:,:), Xgb (:,:) integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Tgc (:,:), dTgc (:,:,:), Tgcb (:,:), dTgcb (:,:,:), d2Tgc (:,:,:), d2Tgcb (:,:,:) real ( rk ), allocatable :: Tgc1 (:), dTgc1 (:,:), Tgc1b (:), dTgc1b (:,:), d2Tgc1 (:,:), d2Tgc1b (:,:) integer :: i , id real ( rk ) :: nearest_Xg ( 3 ), nearest_Xt ( 2 ) type ( unit_test ) :: ut allocate ( Xc ( 4 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 5.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 0.9_rk knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] call nurbs % set ( knot1 , knot2 , Xc , Wc ) call bsp % set ( knot1 , knot2 , Xc ) call nurbs % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc (), Wc = nurbs % get_Wc ()) call bsp % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc ()) call nurbs % create ( 20 , 20 ) call bsp % create ( 20 , 20 ) call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call nurbs % cmp_area ( area ) call bsp % cmp_area ( areab ) call ut % check ( res = area , expected = 2 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_surface: 01\" ) call ut % check ( res = areab , expected = 2 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_surface: 02\" ) call nurbs % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 03\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 04\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_surface: 05\" ) call bsp % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 06\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 07\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_surface: 08\" ) call nurbs % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 09\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 10\" ) call bsp % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 11\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 12\" ) Xg = nurbs % get_Xg () Xgb = bsp % get_Xg () call nurbs % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc , Wc ) call bsp % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 13\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 14\" ) call nurbs % set ([ 2 , 2 ], Xc , Wc ) call bsp % set ([ 2 , 2 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 15\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 16\" ) call nurbs % create ( Xt1 = nurbs % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call bsp % create ( Xt1 = bsp % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 17\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 18\" ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 19\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 20\" ) call ut % check ( res = nurbs % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 21\" ) call ut % check ( res = bsp % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 22\" ) call ut % check ( res = nurbs % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 23\" ) call ut % check ( res = bsp % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 24\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 25\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 26\" ) call ut % check ( res = nurbs % get_Xg ( 1 ), expected = Xg ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 27\" ) call ut % check ( res = bsp % get_Xg ( 1 ), expected = Xgb ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 28\" ) call ut % check ( res = nurbs % get_Xg ( 1 , 1 ), expected = Xg ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 29\" ) call ut % check ( res = bsp % get_Xg ( 1 , 1 ), expected = Xgb ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 30\" ) call ut % check ( res = nurbs % get_Wc (), expected = Wc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 31\" ) call ut % check ( res = nurbs % get_Wc ( 1 ), expected = Wc ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 32\" ) call ut % check ( res = nurbs % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_surface: 33\" ) call ut % check ( res = bsp % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_surface: 34\" ) call ut % check ( res = nurbs % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 35\" ) call ut % check ( res = bsp % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 36\" ) ! call ut%check(res=nurbs%get_ng(), expected=size(Xg,1), msg=\"test_nurbs_surface: 37\") ! call ut%check(res=bsp%get_ng(), expected=size(Xgb,1), msg=\"test_nurbs_surface: 38\") call ut % check ( res = nurbs % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_surface: 39\" ) call ut % check ( res = bsp % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_surface: 40\" ) call ut % check ( res = nurbs % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_surface: 41\" ) call ut % check ( res = bsp % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_surface: 42\" ) call ut % check ( res = nurbs % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_surface: 43\" ) call ut % check ( res = bsp % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_surface: 44\" ) ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 45\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 46\") call nurbs % cmp_nc () call bsp % cmp_nc () ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 47\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 48\") elemConn = nurbs % cmp_elem_Xc_vis ([ 1 , 1 ]) call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 49\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xc_vis () call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 50\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis ([ 1 , 1 ]) call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 51\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis () call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 52\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis ([ 1 , 1 ]) call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 53\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis () call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 54\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis ([ 1 , 1 ]) call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 55\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis () call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 56\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem () call nurbs % set_elem ( elemConn ) call ut % check ( res = nurbs % get_elem (), expected = elemConn , msg = \"test_nurbs_surface: 57\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem () call bsp % set_elem ( elemConn ) call ut % check ( res = bsp % get_elem (), expected = elemConn , msg = \"test_nurbs_surface: 58\" ) deallocate ( elemConn ) call nurbs % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call bsp % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call nurbs % modify_Wc ( Wc ( 1 ), 1 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 59\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 60\" ) call nurbs % basis ( res1 = 20 , res2 = 20 , Tgc = Tgc ) call bsp % basis ( res1 = 20 , res2 = 20 , Tgc = Tgc ) call nurbs % basis ( Xt = [ 0.0_rk , 0.0_rk ], Tgc = Tgc1 ) call bsp % basis ( Xt = [ 0.0_rk , 0.0_rk ], Tgc = Tgc1b ) call nurbs % basis ( Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Tgc = Tgc ) call bsp % basis ( Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Tgc = Tgc ) call nurbs % derivative ( res1 = 20 , res2 = 20 , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( res1 = 20 , res2 = 20 , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], dTgc = dTgc , Tgc = Tgc ) call bsp % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 , elem = [ 1 , 2 , 3 ]) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b , elem = [ 1 , 2 , 3 ]) call nurbs % derivative2 ( res1 = 20 , res2 = 20 , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( res1 = 20 , res2 = 20 , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 61\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 62\" ) call nurbs % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 63\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 64\" ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 65\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 66\" ) call nurbs % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 67\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 68\" ) call nurbs % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 69\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 70\" ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 71\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 72\" ) call nurbs % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 73\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 74\" ) call nurbs % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 75\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 76\" ) call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 77\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 78\" ) call nurbs % elevate_degree ( 1 , 2 ) call nurbs % elevate_degree ( 2 , 2 ) call bsp % elevate_degree ( 1 , 2 ) call bsp % elevate_degree ( 2 , 2 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 79\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 80\" ) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 81\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 82\" ) call nurbs % set_tetragon ([ 2.0_rk , 2.0_rk ], [ 2 , 2 ]) call bsp % set_tetragon ([ 2.0_rk , 2.0_rk ], [ 2 , 2 ], [ 1.0_rk , 1.0_rk , 0.9_rk , 0.9_rk ]) call nurbs % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) call nurbs % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) call nurbs % set_C ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) call nurbs % finalize () call bsp % finalize () deallocate ( Xc , Wc , Xg , Xgb ) !============================================================================ ! Least-squares B-spline surface fitting !============================================================================ block type ( nurbs_surface ) :: bsp_fit integer :: j , n ( 2 ), ndata real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xt1 (:), Xt2 (:), Xt (:,:), Xdata (:,:), Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = [ 6 , 6 ] allocate ( Xt1 ( n ( 1 )), Xt2 ( n ( 2 ))) do concurrent ( j = 1 : n ( 1 )) Xt1 ( j ) = real ( j - 1 , rk ) / real ( n ( 1 ) - 1 , rk ) end do do concurrent ( j = 1 : n ( 2 )) Xt2 ( j ) = real ( j - 1 , rk ) / real ( n ( 2 ) - 1 , rk ) end do call ndgrid ( Xt1 , Xt2 , Xt ) ndata = n ( 1 ) * n ( 2 ) allocate ( Xdata ( ndata , 3 )) do j = 1 , ndata Xdata ( j , 1 ) = Xt ( j , 1 ) Xdata ( j , 2 ) = Xt ( j , 2 ) Xdata ( j , 3 ) = 0.1_rk * sin ( 2.0_rk * pi * Xt ( j , 1 )) * cos ( 2.0_rk * pi * Xt ( j , 2 )) end do call bsp_fit % set (& degree = [ 2 , 2 ],& Xth_dir1 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& Xth_dir2 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& continuity1 = [ - 1 , 1 , 1 , 1 , - 1 ],& continuity2 = [ - 1 , 1 , 1 , 1 , - 1 ]) call bsp_fit % lsq_fit_bspline ( Xt , Xdata , n ) call bsp_fit % create ( n ( 1 ), n ( 2 )) Xg_eval = bsp_fit % get_Xg () err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / norm2 ( Xdata (:, 1 )) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / norm2 ( Xdata (:, 2 )) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / norm2 ( Xdata (:, 3 )) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) call ut % check ( res = rms , expected = 0.0_rk , tol = 1e-6_rk , msg = \"test_nurbs_surface: 83\" ) call bsp_fit % finalize () deallocate ( Xt1 , Xt2 , Xt , Xdata , Xg_eval ) end block end program","tags":"","url":"sourcefile/test_nurbs_surface.f90.html"},{"title":"lsq_fit_bspline_3d.f90 – ForCAD","text":"This file depends on sourcefile~~lsq_fit_bspline_3d.f90~~EfferentGraph sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program lsq_fit_bspline_3d use forcad , only : rk , nurbs_volume use forcad_utils , only : ndgrid implicit none type ( nurbs_volume ) :: bsp integer :: n ( 3 ), ndata , i real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xdata (:,:) real ( rk ), allocatable :: Xt1 (:), Xt2 (:), Xt3 (:), Xt (:,:) real ( rk ), allocatable :: Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = [ 10 , 10 , 10 ] ! create parametric grid points allocate ( Xt1 ( n ( 1 )), Xt2 ( n ( 2 )), Xt3 ( n ( 3 ))) do concurrent ( i = 1 : n ( 1 )) Xt1 ( i ) = real ( i - 1 , rk ) / real ( n ( 1 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 2 )) Xt2 ( i ) = real ( i - 1 , rk ) / real ( n ( 2 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 3 )) Xt3 ( i ) = real ( i - 1 , rk ) / real ( n ( 3 ) - 1 , rk ) end do call ndgrid ( Xt1 , Xt2 , Xt3 , Xt ) ! data points to be fitted ndata = n ( 1 ) * n ( 2 ) * n ( 3 ) allocate ( Xdata ( ndata , 3 )) do i = 1 , ndata Xdata ( i , 1 ) = Xt ( i , 1 ) + 0.1_rk * sin ( 2.0_rk * pi * Xt ( i , 2 )) Xdata ( i , 2 ) = Xt ( i , 2 ) + 0.1_rk * sin ( 2.0_rk * pi * Xt ( i , 3 )) Xdata ( i , 3 ) = Xt ( i , 3 ) + 0.1_rk * sin ( 2.0_rk * pi * Xt ( i , 1 )) end do ! set up B-Spline volume call bsp % set (& degree = [ 3 , 3 , 3 ],& Xth_dir1 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& Xth_dir2 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& Xth_dir3 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& continuity1 = [ - 1 , 1 , 1 , 1 , - 1 ],& continuity2 = [ - 1 , 1 , 1 , 1 , - 1 ],& continuity3 = [ - 1 , 1 , 1 , 1 , - 1 ]) print '(a)' , \"========================================\" print '(a)' , \"B-Spline Volume Configuration\" print '(a)' , \"----------------------------------------\" print '(a,3(i0,a))' , \"Degrees    : \" , bsp % get_degree ( 1 ), \", \" , bsp % get_degree ( 2 ), \", \" , bsp % get_degree ( 3 ) print '(a,3(i0,a))' , \"Control pts: \" , bsp % get_nc ( 1 ), \" x \" , bsp % get_nc ( 2 ), \" x \" , bsp % get_nc ( 3 ) print '(a,3(i0,a))' , \"Data grid  : \" , n ( 1 ), \" x \" , n ( 2 ), \" x \" , n ( 3 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Continuity\" print '(a,*(i3,1x))' , \"  dir1:\" , bsp % get_continuity ( 1 ) print '(a,*(i3,1x))' , \"  dir2:\" , bsp % get_continuity ( 2 ) print '(a,*(i3,1x))' , \"  dir3:\" , bsp % get_continuity ( 3 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Knot vectors\" print '(a,*(f5.2,1x))' , \"  dir1:\" , bsp % get_knot ( 1 ) print '(a,*(f5.2,1x))' , \"  dir2:\" , bsp % get_knot ( 2 ) print '(a,*(f5.2,1x))' , \"  dir3:\" , bsp % get_knot ( 3 ) print '(a)' , \"========================================\" print '(a)' , \"Fitting least squares volume...\" call bsp % lsq_fit_bspline ( Xt , Xdata , n ) print '(a)' , \"Fitting complete.\" ! create B-Spline volume ! call bsp%create(n(1), n(2), n(3)) call bsp % create ( Xt1 = Xt1 , Xt2 = Xt2 , Xt3 = Xt3 ) Xg_eval = bsp % get_Xg () ! Compute relative errors in each direction err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / max ( norm2 ( Xdata (:, 1 )), epsilon ( 0.0_rk ) ) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / max ( norm2 ( Xdata (:, 2 )), epsilon ( 0.0_rk ) ) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / max ( norm2 ( Xdata (:, 3 )), epsilon ( 0.0_rk ) ) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) ! Report print '(a)' , \"========================================\" print '(a)' , \"Fitting Error Report\" print '(a)' , \"----------------------------------------\" print '(a,e13.6)' , \"Rel. error (dir1):\" , err1 print '(a,e13.6)' , \"Rel. error (dir2):\" , err2 print '(a,e13.6)' , \"Rel. error (dir3):\" , err3 print '(a,e13.6)' , \"Total RMS error  :\" , rms print '(a)' , \"========================================\" ! Export results and visualize call bsp % export_Xc ( \"vtk/lsq_fit_bspline_3d_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/lsq_fit_bspline_3d_Xg.vtk\" ) call bsp % export_Xth_in_Xg ( \"vtk/lsq_fit_bspline_3d_Xth.vtk\" , res = 20 ) call bsp % show ( \"vtk/lsq_fit_bspline_3d_Xc.vtk\" , \"vtk/lsq_fit_bspline_3d_Xg.vtk\" , \"vtk/lsq_fit_bspline_3d_Xth.vtk\" ) end program","tags":"","url":"sourcefile/lsq_fit_bspline_3d.f90.html"},{"title":"nearest_point_1d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_1d.f90~~EfferentGraph sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector real ( rk ) :: nearest_Xg ( 3 ) !! Array for the nearest point on the curve real ( rk ) :: nearest_Xt !! Array for the parametric coordinates of the nearest point integer :: id !! Variable for the id of the nearest point !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 1.1_rk , 1.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call shape % set ( knot , Xc , Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call shape % create ( 20 ) !----------------------------------------------------------------------------- ! Nearest point on the curve !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 4.5_rk , 4.5_rk , 5.0_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the curve (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) call shape % nearest_point2 ([ 4.5_rk , 4.5_rk , 5.0_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () deallocate ( Xc , Wc ) end program","tags":"","url":"sourcefile/nearest_point_1d.f90.html"},{"title":"lsq_fit_nurbs_3d.f90 – ForCAD","text":"This file depends on sourcefile~~lsq_fit_nurbs_3d.f90~~EfferentGraph sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program lsq_fit_nurbs_3d use forcad , only : rk , nurbs_volume use forcad_utils , only : ndgrid implicit none type ( nurbs_volume ) :: nrb integer :: n ( 3 ), ndata , i real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xdata (:,:) real ( rk ), allocatable :: Xt1 (:), Xt2 (:), Xt3 (:), Xt (:,:) real ( rk ), allocatable :: Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = [ 36 , 14 , 12 ] ! create parametric grid points allocate ( Xt1 ( n ( 1 )), Xt2 ( n ( 2 )), Xt3 ( n ( 3 ))) do concurrent ( i = 1 : n ( 1 )) Xt1 ( i ) = real ( i - 1 , rk ) / real ( n ( 1 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 2 )) Xt2 ( i ) = real ( i - 1 , rk ) / real ( n ( 2 ) - 1 , rk ) end do do concurrent ( i = 1 : n ( 3 )) Xt3 ( i ) = real ( i - 1 , rk ) / real ( n ( 3 ) - 1 , rk ) end do call ndgrid ( Xt1 , Xt2 , Xt3 , Xt ) ! data points to be fitted ndata = n ( 1 ) * n ( 2 ) * n ( 3 ) allocate ( Xdata ( ndata , 3 )) do i = 1 , ndata Xdata ( i , 1 ) = 0.0_rk + ( 1.0_rk + 0.35_rk * Xt ( i , 3 ) * cos ( 2.0_rk * pi * Xt ( i , 2 ))) * cos ( 2.0_rk * pi * Xt ( i , 1 )) Xdata ( i , 2 ) = 0.0_rk + ( 1.0_rk + 0.35_rk * Xt ( i , 3 ) * cos ( 2.0_rk * pi * Xt ( i , 2 ))) * sin ( 2.0_rk * pi * Xt ( i , 1 )) Xdata ( i , 3 ) = 0.0_rk + 0.35_rk * Xt ( i , 3 ) * sin ( 2.0_rk * pi * Xt ( i , 2 )) end do ! set up NURBS volume call nrb % set (& degree = [ 3 , 3 , 3 ],& Xth_dir1 = [ 0.0_rk , 0.2_rk , 0.4_rk , 0.6_rk , 0.8_rk , 1.0_rk ],& Xth_dir2 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& Xth_dir3 = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ],& continuity1 = [ - 1 , 1 , 1 , 1 , 1 , - 1 ],& continuity2 = [ - 1 , 1 , 1 , 1 , - 1 ],& continuity3 = [ - 1 , 1 , 1 , 1 , - 1 ]) print '(a)' , \"========================================\" print '(a)' , \"NURBS Volume Configuration\" print '(a)' , \"----------------------------------------\" print '(a,3(i0,a))' , \"Degrees    : \" , nrb % get_degree ( 1 ), \", \" , nrb % get_degree ( 2 ), \", \" , nrb % get_degree ( 3 ) print '(a,3(i0,a))' , \"Control pts: \" , nrb % get_nc ( 1 ), \" x \" , nrb % get_nc ( 2 ), \" x \" , nrb % get_nc ( 3 ) print '(a,3(i0,a))' , \"Data grid  : \" , n ( 1 ), \" x \" , n ( 2 ), \" x \" , n ( 3 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Continuity\" print '(a,*(i3,1x))' , \"  dir1:\" , nrb % get_continuity ( 1 ) print '(a,*(i3,1x))' , \"  dir2:\" , nrb % get_continuity ( 2 ) print '(a,*(i3,1x))' , \"  dir3:\" , nrb % get_continuity ( 3 ) print '(a)' , \"----------------------------------------\" print '(a)' , \"Knot vectors\" print '(a,*(f5.2,1x))' , \"  dir1:\" , nrb % get_knot ( 1 ) print '(a,*(f5.2,1x))' , \"  dir2:\" , nrb % get_knot ( 2 ) print '(a,*(f5.2,1x))' , \"  dir3:\" , nrb % get_knot ( 3 ) print '(a)' , \"========================================\" print '(a)' , \"Fitting least squares volume...\" call nrb % lsq_fit_nurbs (& Xt = Xt , & Xdata = Xdata , & ndata = n , & maxit = 30 , & tol = sqrt ( epsilon ( 0.0_rk )), & lambda_xc = sqrt ( epsilon ( 0.0_rk )), & reg_logw = sqrt ( epsilon ( 0.0_rk )) ) print '(a)' , \"Fitting complete.\" ! create NURBS volume call nrb % create ( Xt1 = Xt1 , Xt2 = Xt2 , Xt3 = Xt3 ) Xg_eval = nrb % get_Xg () ! Compute errors err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / max ( norm2 ( Xdata (:, 1 )), epsilon ( 0.0_rk ) ) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / max ( norm2 ( Xdata (:, 2 )), epsilon ( 0.0_rk ) ) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / max ( norm2 ( Xdata (:, 3 )), epsilon ( 0.0_rk ) ) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) print '(a)' , \"========================================\" print '(a)' , \"Fitting Error Report\" print '(a)' , \"----------------------------------------\" print '(a,e13.6)' , \"Rel. error (dir1):\" , err1 print '(a,e13.6)' , \"Rel. error (dir2):\" , err2 print '(a,e13.6)' , \"Rel. error (dir3):\" , err3 print '(a,e13.6)' , \"Total RMS error  :\" , rms print '(a)' , \"========================================\" ! Export results call nrb % export_Xc ( \"vtk/lsq_fit_nurbs_3d_Xc.vtk\" ) call nrb % export_Xg ( \"vtk/lsq_fit_nurbs_3d_Xg.vtk\" ) call nrb % export_Xth_in_Xg ( \"vtk/lsq_fit_nurbs_3d_Xth.vtk\" , res = 20 ) call nrb % show ( \"vtk/lsq_fit_nurbs_3d_Xc.vtk\" , \"vtk/lsq_fit_nurbs_3d_Xg.vtk\" , \"vtk/lsq_fit_nurbs_3d_Xth.vtk\" ) end program","tags":"","url":"sourcefile/lsq_fit_nurbs_3d.f90.html"},{"title":"example_plate_hole_4_2d.f90 – ForCAD","text":"This file depends on sourcefile~~example_plate_hole_4_2d.f90~~EfferentGraph sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_plate_hole_4_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: plate_hole real ( rk ), allocatable :: Xc (:,:) real ( rk ), allocatable :: Wc (:) real ( rk ), parameter :: radius1 = 2.5_rk real ( rk ), parameter :: radius2 = 3.5_rk real ( rk ), parameter :: length = 5.0_rk real ( rk ), parameter :: height = 5.0_rk call set_Xc_Wc ( 'ellipse' , [ radius1 , radius2 , length , height ], Xc , Wc ) call plate_hole % set (& knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 0.5_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ,& Wc = Wc & ) call plate_hole % create ( 31 , 31 ) call plate_hole % export_Xc ( \"vtk/plate_hole_4_2d_Xc.vtk\" ) call plate_hole % export_Xg ( \"vtk/plate_hole_4_2d_Xg.vtk\" ) call plate_hole % export_Xth_in_Xg ( \"vtk/plate_hole_4_2d_Xth.vtk\" ) call plate_hole % show ( \"vtk/plate_hole_4_2d_Xc.vtk\" , \"vtk/plate_hole_4_2d_Xg.vtk\" , \"vtk/plate_hole_4_2d_Xth.vtk\" ) contains !=============================================================================== pure subroutine set_Xc_Wc ( tp , params , X_c , W_c ) character ( len =* ), intent ( in ) :: tp real ( rk ), intent ( in ), contiguous :: params (:) real ( rk ), allocatable , intent ( out ) :: X_c (:,:) real ( rk ), allocatable , intent ( out ) :: W_c (:) real ( rk ) :: r1 , r2 , l , h select case ( tp ) case ( 'circle' ) r1 = params ( 1 ) l = params ( 3 ) h = params ( 4 ) if ( r1 < 0.0_rk ) error stop 'Radius must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' allocate ( X_c ( 12 , 2 )) X_c ( 1 , :) = [ - r1 , 0.0_rk ] X_c ( 2 , :) = [ - r1 , r1 * tand ( 2 2.5_rk )] X_c ( 3 , :) = [ - r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 4 , :) = [ 0.0_rk , r1 ] X_c ( 5 , :) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 6 , :) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 7 , :) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 8 , :) = [ 0.0_rk , ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 9 , :) = [ - l , 0.0_rk ] X_c ( 10 ,:) = [ - l , h ] X_c ( 11 ,:) = [ - l , h ] X_c ( 12 ,:) = [ 0.0_rk , h ] allocate ( W_c ( 12 ), source = 1.0_rk ) W_c ([ 2 , 3 ]) = ( 1.0_rk + 1.0_rk / sqrt ( 2.0_rk )) / 2.0_rk case ( 'ellipse' ) r1 = params ( 1 ) r2 = params ( 2 ) l = params ( 3 ) h = params ( 4 ) if ( r1 < 0.0_rk ) error stop 'Radius1 must be positive' if ( r2 < 0.0_rk ) error stop 'Radius2 must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' allocate ( X_c ( 12 , 2 )) X_c ( 1 ,:) = [ - r1 , 0.0_rk ] X_c ( 2 ,:) = [ - r1 , r2 * tand ( 2 2.5_rk )] X_c ( 3 ,:) = [ - r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 4 ,:) = [ 0.0_rk , r2 ] X_c ( 5 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 6 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 7 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 8 ,:) = [ 0.0_rk , ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 9 ,:) = [ - l , 0.0_rk ] X_c ( 10 ,:) = [ - l , h ] X_c ( 11 ,:) = [ - l , h ] X_c ( 12 ,:) = [ 0.0_rk , h ] allocate ( W_c ( 12 ), source = 1.0_rk ) W_c ([ 2 , 3 ]) = cosd ( 2 2.5_rk ) case default error stop 'set_Xc_Wc: Invalid type. Valid types are: circle, ellipse' end select end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_plate_hole_4_2d.f90.html"},{"title":"example_plate_hole_1_2d.f90 – ForCAD","text":"This file depends on sourcefile~~example_plate_hole_1_2d.f90~~EfferentGraph sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_plate_hole_1_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: plate_hole real ( rk ), allocatable :: Xc (:,:) real ( rk ), allocatable :: Wc (:) real ( rk ), parameter :: radius1 = 2.5_rk real ( rk ), parameter :: radius2 = 3.5_rk real ( rk ), parameter :: length = 5.0_rk real ( rk ), parameter :: height = 5.0_rk call set_Xc_Wc ( 'ellipse' , [ radius1 , radius2 , length , height ], Xc , Wc ) call plate_hole % set (& knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 2.0_rk , 2.0_rk , 3.0_rk , 4.0_rk , 4.0_rk , 5.0_rk , 6.0_rk , 6.0_rk , 7.0_rk , 8.0_rk , 8.0_rk , 8.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ,& Wc = Wc & ) call plate_hole % create ( 31 , 31 ) call plate_hole % export_Xc ( \"vtk/plate_hole_1_2d_Xc.vtk\" ) call plate_hole % export_Xg ( \"vtk/plate_hole_1_2d_Xg.vtk\" ) call plate_hole % export_Xth_in_Xg ( \"vtk/plate_hole_1_2d_Xth.vtk\" ) call plate_hole % show ( \"vtk/plate_hole_1_2d_Xc.vtk\" , \"vtk/plate_hole_1_2d_Xg.vtk\" , \"vtk/plate_hole_1_2d_Xth.vtk\" ) contains !=============================================================================== pure subroutine set_Xc_Wc ( tp , params , X_c , W_c ) character ( len =* ), intent ( in ) :: tp real ( rk ), intent ( in ), contiguous :: params (:) real ( rk ), allocatable , intent ( out ) :: X_c (:,:) real ( rk ), allocatable , intent ( out ) :: W_c (:) real ( rk ) :: r1 , r2 , l , h select case ( tp ) case ( 'circle' ) r1 = params ( 1 ) l = params ( 3 ) h = params ( 4 ) if ( r1 < 0.0_rk ) error stop 'Radius must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' allocate ( X_c ( 39 , 2 )) X_c ( 1 , :) = [ - r1 , 0.0_rk ] X_c ( 2 , :) = [ - r1 , r1 * tand ( 2 2.5_rk )] X_c ( 3 , :) = [ - r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 4 , :) = [ 0.0_rk , r1 ] X_c ( 5 , :) = [ r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 6 , :) = [ r1 , r1 * tand ( 2 2.5_rk )] X_c ( 7 , :) = [ r1 , 0.0_rk ] X_c ( 8 , :) = [ r1 , - r1 * tand ( 2 2.5_rk )] X_c ( 9 , :) = [ r1 * tand ( 2 2.5_rk ), - r1 ] X_c ( 10 ,:) = [ 0.0_rk , - r1 ] X_c ( 11 ,:) = [ - r1 * tand ( 2 2.5_rk ), - r1 ] X_c ( 12 ,:) = [ - r1 , - r1 * tand ( 2 2.5_rk )] X_c ( 13 ,:) = [ - r1 , 0.0_rk ] X_c ( 14 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 16 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 17 ,:) = [ 0.0_rk , ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 18 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 19 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 20 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 21 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), - ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 22 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 23 ,:) = [ 0.0_rk , - ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 24 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 25 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), - ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 26 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 27 ,:) = [ - l , 0.0_rk ] X_c ( 28 ,:) = [ - l , h ] X_c ( 29 ,:) = [ - l , h ] X_c ( 30 ,:) = [ 0.0_rk , h ] X_c ( 31 ,:) = [ l , h ] X_c ( 32 ,:) = [ l , h ] X_c ( 33 ,:) = [ l , 0.0_rk ] X_c ( 34 ,:) = [ l , - h ] X_c ( 35 ,:) = [ l , - h ] X_c ( 36 ,:) = [ 0.0_rk , - h ] X_c ( 37 ,:) = [ - l , - h ] X_c ( 38 ,:) = [ - l , - h ] X_c ( 39 ,:) = [ - l , 0.0_rk ] allocate ( W_c ( 39 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ]) = ( 1.0_rk + 1.0_rk / sqrt ( 2.0_rk )) / 2.0_rk case ( 'ellipse' ) r1 = params ( 1 ) r2 = params ( 2 ) l = params ( 3 ) h = params ( 4 ) if ( r1 < 0.0_rk ) error stop 'Radius1 must be positive' if ( r2 < 0.0_rk ) error stop 'Radius2 must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' allocate ( X_c ( 39 , 2 )) X_c ( 1 ,:) = [ - r1 , 0.0_rk ] X_c ( 2 ,:) = [ - r1 , r2 * tand ( 2 2.5_rk )] X_c ( 3 ,:) = [ - r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 4 ,:) = [ 0.0_rk , r2 ] X_c ( 5 ,:) = [ r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 6 ,:) = [ r1 , r2 * tand ( 2 2.5_rk )] X_c ( 7 ,:) = [ r1 , 0.0_rk ] X_c ( 8 ,:) = [ r1 , - r2 * tand ( 2 2.5_rk )] X_c ( 9 ,:) = [ r1 * tand ( 2 2.5_rk ), - r2 ] X_c ( 10 ,:) = [ 0.0_rk , - r2 ] X_c ( 11 ,:) = [ - r1 * tand ( 2 2.5_rk ), - r2 ] X_c ( 12 ,:) = [ - r1 , - r2 * tand ( 2 2.5_rk )] X_c ( 13 ,:) = [ - r1 , 0.0_rk ] X_c ( 14 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 15 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 16 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 17 ,:) = [ 0.0_rk , ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 18 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 19 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 20 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 21 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ), - ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 22 ,:) = [( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 23 ,:) = [ 0.0_rk , - ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 24 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), - ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 25 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), - ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 26 ,:) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 27 ,:) = [ - l , 0.0_rk ] X_c ( 28 ,:) = [ - l , h ] X_c ( 29 ,:) = [ - l , h ] X_c ( 30 ,:) = [ 0.0_rk , h ] X_c ( 31 ,:) = [ l , h ] X_c ( 32 ,:) = [ l , h ] X_c ( 33 ,:) = [ l , 0.0_rk ] X_c ( 34 ,:) = [ l , - h ] X_c ( 35 ,:) = [ l , - h ] X_c ( 36 ,:) = [ 0.0_rk , - h ] X_c ( 37 ,:) = [ - l , - h ] X_c ( 38 ,:) = [ - l , - h ] X_c ( 39 ,:) = [ - l , 0.0_rk ] allocate ( W_c ( 39 ), source = 1.0_rk ) W_c ([ 2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ]) = cosd ( 2 2.5_rk ) case default error stop 'set_Xc_Wc: Invalid type. Valid types are: circle, ellipse' end select end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_plate_hole_1_2d.f90.html"},{"title":"forcad_utils.F90 – ForCAD","text":"This file depends on sourcefile~~forcad_utils.f90~~EfferentGraph sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_utils.f90~~AfferentGraph sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad_utils.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad_utils.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad_utils.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad_utils.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad_utils.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 sourcefile~test_utils.f90 test_utils.f90 sourcefile~test_utils.f90->sourcefile~forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module contains parameters, functions and subroutines that are used in the library. module forcad_utils use forcad_kinds , only : rk implicit none private public basis_bernstein , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , tetragon_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , basis_bspline_2der , det , inv , dyad , gauss_leg , export_vtk_legacy , solve , & repelem , linspace , eye , kron_eye !=============================================================================== interface elemConn_C0 module procedure cmp_elemConn_C0_L module procedure cmp_elemConn_C0_S module procedure cmp_elemConn_C0_V end interface !=============================================================================== !=============================================================================== interface elemConn_Cn module procedure cmp_elemConn_Cn_L module procedure cmp_elemConn_Cn_S module procedure cmp_elemConn_Cn_V end interface !=============================================================================== !=============================================================================== interface ndgrid module procedure ndgrid2 module procedure ndgrid3 end interface !=============================================================================== !=============================================================================== interface compute_multiplicity module procedure compute_multiplicity1 module procedure compute_multiplicity2 end interface !=============================================================================== !=============================================================================== interface unique module procedure unique_integer module procedure unique_real end interface !=============================================================================== !=============================================================================== interface dyad module procedure dyad_t1_t1 end interface !=============================================================================== !=============================================================================== interface gauss_leg module procedure gauss_legendre_1D module procedure gauss_legendre_2D module procedure gauss_legendre_3D end interface !=============================================================================== !=============================================================================== interface kron module procedure kron_t1_t1 module procedure kron_t1_t2 module procedure kron3 end interface !=============================================================================== !=============================================================================== interface basis_bspline_der module procedure basis_bspline_der_A module procedure basis_bspline_der_B end interface !=============================================================================== !=============================================================================== interface basis_bspline_2der module procedure basis_bspline_2der_A module procedure basis_bspline_2der_B module procedure basis_bspline_2der_C end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bspline ( Xt , knot , nc , degree ) result ( B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ) :: B ( nc ) integer :: span , j , r , low , mid , high , nk real ( rk ) :: left ( degree ), right ( degree ) real ( rk ) :: N ( 0 : degree ) real ( rk ) :: saved , temp integer :: i , index_start if ( nc == 0 ) then B = 0.0_rk return end if B = 0.0_rk nk = size ( knot ) if ( Xt < knot ( 1 ) . or . Xt > knot ( nk )) then B = 0.0_rk return end if ! Find span ! if (Xt == knot(nk)) then if ( abs ( Xt - knot ( nk )) < 2.0_rk * epsilon ( 0.0_rk )) then span = nk - degree - 1 else low = degree + 1 high = nk - degree do while ( low <= high ) mid = ( low + high ) / 2 if ( Xt >= knot ( mid ) . and . Xt < knot ( mid + 1 )) then span = mid exit else if ( Xt < knot ( mid )) then high = mid - 1 else low = mid + 1 end if end do end if ! Cox-de Boor recursion N = 0.0_rk N ( 0 ) = 1.0_rk do j = 1 , degree left ( j ) = Xt - knot ( span + 1 - j ) right ( j ) = knot ( span + j ) - Xt saved = 0.0_rk do r = 0 , j - 1 temp = N ( r ) / ( right ( r + 1 ) + left ( j - r )) N ( r ) = saved + right ( r + 1 ) * temp saved = left ( j - r ) * temp end do N ( j ) = saved end do index_start = span - degree do i = 0 , degree if ( index_start + i >= 1 . and . index_start + i <= nc ) then B ( index_start + i ) = N ( i ) end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_der_A ( Xt , knot , nc , degree , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( out ) :: dB ( nc ) real ( rk ), intent ( out ) :: B ( nc ) integer :: i , p real ( rk ) :: Xth_i , Xth_i1 , Xth_ip , Xth_ip1 , Xth_last real ( rk ) :: B_curr ( nc ) real ( rk ) :: dB_curr ( nc ) B = 0.0_rk dB = 0.0_rk ! Degree 0 initialization do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_last = knot ( size ( knot )) ! if ((Xt >= Xth_i .and. Xt < Xth_i1) .or. (Xt == Xth_last .and. Xt == Xth_i1)) then if (( Xt >= Xth_i . and . Xt < Xth_i1 ) . or . ( abs ( Xt - Xth_last ) < 2.0_rk * epsilon ( 0.0_rk ) . and . abs ( Xt - Xth_i1 ) < 2.0_rk * epsilon ( 0.0_rk ))) then B ( i ) = 1.0_rk dB ( i ) = 0.0_rk end if end do ! Recursion for higher degrees do p = 1 , degree B_curr = 0.0_rk dB_curr = 0.0_rk do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) ! if (Xth_ip /= Xth_i) then if ( abs ( Xth_ip - Xth_i ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * B ( i ) dB_curr ( i ) = B ( i ) / ( Xth_ip - Xth_i ) + ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * dB ( i ) end if ! if (i < nc .and. Xth_ip1 /= Xth_i1) then if ( i < nc . and . abs ( Xth_ip1 - Xth_i1 ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = B_curr ( i ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * B ( i + 1 ) dB_curr ( i ) = dB_curr ( i ) - B ( i + 1 ) / ( Xth_ip1 - Xth_i1 ) + & ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * dB ( i + 1 ) end if end do B = B_curr dB = dB_curr end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_der_B ( Xt , knot , nc , degree , dB ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( out ) :: dB ( nc ) real ( rk ) :: B ( nc ) integer :: i , p real ( rk ) :: Xth_i , Xth_i1 , Xth_ip , Xth_ip1 , Xth_last real ( rk ) :: B_curr ( nc ) real ( rk ) :: dB_curr ( nc ) B = 0.0_rk dB = 0.0_rk ! Degree 0 initialization do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_last = knot ( size ( knot )) ! if ((Xt >= Xth_i .and. Xt < Xth_i1) .or. (Xt == Xth_last .and. Xt == Xth_i1)) then if (( Xt >= Xth_i . and . Xt < Xth_i1 ) . or . ( abs ( Xt - Xth_last ) < 2.0_rk * epsilon ( 0.0_rk ) . and . abs ( Xt - Xth_i1 ) < 2.0_rk * epsilon ( 0.0_rk ))) then B ( i ) = 1.0_rk dB ( i ) = 0.0_rk end if end do ! Recursion for higher degrees do p = 1 , degree B_curr = 0.0_rk dB_curr = 0.0_rk do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) ! if (Xth_ip /= Xth_i) then if ( abs ( Xth_ip - Xth_i ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * B ( i ) dB_curr ( i ) = B ( i ) / ( Xth_ip - Xth_i ) + ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * dB ( i ) end if ! if (i < nc .and. Xth_ip1 /= Xth_i1) then if ( i < nc . and . abs ( Xth_ip1 - Xth_i1 ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = B_curr ( i ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * B ( i + 1 ) dB_curr ( i ) = dB_curr ( i ) - B ( i + 1 ) / ( Xth_ip1 - Xth_i1 ) + & ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * dB ( i + 1 ) end if end do B = B_curr dB = dB_curr end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_2der_A ( Xt , knot , nc , degree , d2B , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( out ) :: d2B ( nc ) real ( rk ), intent ( out ) :: dB ( nc ) real ( rk ), intent ( out ) :: B ( nc ) integer :: i , p real ( rk ) :: Xth_i , Xth_i1 , Xth_ip , Xth_ip1 , Xth_last real ( rk ) :: B_curr ( nc ) real ( rk ) :: dB_curr ( nc ) real ( rk ) :: d2B_curr ( nc ) B = 0.0_rk dB = 0.0_rk d2B = 0.0_rk ! Degree 0 initialization do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_last = knot ( size ( knot )) ! if ((Xt >= Xth_i .and. Xt < Xth_i1) .or. (Xt == Xth_last .and. Xt == Xth_i1)) then if (( Xt >= Xth_i . and . Xt < Xth_i1 ) . or . ( abs ( Xt - Xth_last ) < 2.0_rk * epsilon ( 0.0_rk ) . and . abs ( Xt - Xth_i1 ) < 2.0_rk * epsilon ( 0.0_rk ))) then B ( i ) = 1.0_rk dB ( i ) = 0.0_rk d2B ( i ) = 0.0_rk end if end do ! Recursion for higher degrees do p = 1 , degree B_curr = 0.0_rk dB_curr = 0.0_rk d2B_curr = 0.0_rk do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) ! if (Xth_ip /= Xth_i) then if ( abs ( Xth_ip - Xth_i ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * B ( i ) dB_curr ( i ) = B ( i ) / ( Xth_ip - Xth_i ) + ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * dB ( i ) d2B_curr ( i ) = ( 2 * dB ( i ) + ( Xt - Xth_i ) * d2B ( i )) / ( Xth_ip - Xth_i ) end if ! if (i < nc .and. Xth_ip1 /= Xth_i1) then if ( i < nc . and . abs ( Xth_ip1 - Xth_i1 ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = B_curr ( i ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * B ( i + 1 ) dB_curr ( i ) = dB_curr ( i ) - B ( i + 1 ) / ( Xth_ip1 - Xth_i1 ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * dB ( i + 1 ) d2B_curr ( i ) = d2B_curr ( i ) - ( 2 * dB ( i + 1 ) - ( Xth_ip1 - Xt ) * d2B ( i + 1 )) / ( Xth_ip1 - Xth_i1 ) end if end do B = B_curr dB = dB_curr d2B = d2B_curr end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_2der_B ( Xt , knot , nc , degree , d2B , dB ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( out ) :: d2B ( nc ) real ( rk ), intent ( out ) :: dB ( nc ) real ( rk ) :: B ( nc ) integer :: i , p real ( rk ) :: Xth_i , Xth_i1 , Xth_ip , Xth_ip1 , Xth_last real ( rk ) :: B_curr ( nc ) real ( rk ) :: dB_curr ( nc ) real ( rk ) :: d2B_curr ( nc ) B = 0.0_rk dB = 0.0_rk d2B = 0.0_rk ! Degree 0 initialization do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_last = knot ( size ( knot )) ! if ((Xt >= Xth_i .and. Xt < Xth_i1) .or. (Xt == Xth_last .and. Xt == Xth_i1)) then if (( Xt >= Xth_i . and . Xt < Xth_i1 ) . or . ( abs ( Xt - Xth_last ) < 2.0_rk * epsilon ( 0.0_rk ) . and . abs ( Xt - Xth_i1 ) < 2.0_rk * epsilon ( 0.0_rk ))) then B ( i ) = 1.0_rk dB ( i ) = 0.0_rk d2B ( i ) = 0.0_rk end if end do ! Recursion for higher degrees do p = 1 , degree B_curr = 0.0_rk dB_curr = 0.0_rk d2B_curr = 0.0_rk do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) ! if (Xth_ip /= Xth_i) then if ( abs ( Xth_ip - Xth_i ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * B ( i ) dB_curr ( i ) = B ( i ) / ( Xth_ip - Xth_i ) + ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * dB ( i ) d2B_curr ( i ) = ( 2 * dB ( i ) + ( Xt - Xth_i ) * d2B ( i )) / ( Xth_ip - Xth_i ) end if ! if (i < nc .and. Xth_ip1 /= Xth_i1) then if ( i < nc . and . abs ( Xth_ip1 - Xth_i1 ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = B_curr ( i ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * B ( i + 1 ) dB_curr ( i ) = dB_curr ( i ) - B ( i + 1 ) / ( Xth_ip1 - Xth_i1 ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * dB ( i + 1 ) d2B_curr ( i ) = d2B_curr ( i ) - ( 2 * dB ( i + 1 ) - ( Xth_ip1 - Xt ) * d2B ( i + 1 )) / ( Xth_ip1 - Xth_i1 ) end if end do B = B_curr dB = dB_curr d2B = d2B_curr end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_2der_C ( Xt , knot , nc , degree , d2B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( out ) :: d2B ( nc ) real ( rk ) :: dB ( nc ) real ( rk ) :: B ( nc ) integer :: i , p real ( rk ) :: Xth_i , Xth_i1 , Xth_ip , Xth_ip1 , Xth_last real ( rk ) :: B_curr ( nc ) real ( rk ) :: dB_curr ( nc ) real ( rk ) :: d2B_curr ( nc ) B = 0.0_rk dB = 0.0_rk d2B = 0.0_rk ! Degree 0 initialization do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_last = knot ( size ( knot )) ! if ((Xt >= Xth_i .and. Xt < Xth_i1) .or. (Xt == Xth_last .and. Xt == Xth_i1)) then if (( Xt >= Xth_i . and . Xt < Xth_i1 ) . or . ( abs ( Xt - Xth_last ) < 2.0_rk * epsilon ( 0.0_rk ) . and . abs ( Xt - Xth_i1 ) < 2.0_rk * epsilon ( 0.0_rk ))) then B ( i ) = 1.0_rk dB ( i ) = 0.0_rk d2B ( i ) = 0.0_rk end if end do ! Recursion for higher degrees do p = 1 , degree B_curr = 0.0_rk dB_curr = 0.0_rk d2B_curr = 0.0_rk do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) ! if (Xth_ip /= Xth_i) then if ( abs ( Xth_ip - Xth_i ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * B ( i ) dB_curr ( i ) = B ( i ) / ( Xth_ip - Xth_i ) + ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * dB ( i ) d2B_curr ( i ) = ( 2 * dB ( i ) + ( Xt - Xth_i ) * d2B ( i )) / ( Xth_ip - Xth_i ) end if ! if (i < nc .and. Xth_ip1 /= Xth_i1) then if ( i < nc . and . abs ( Xth_ip1 - Xth_i1 ) > 2.0_rk * epsilon ( 0.0_rk )) then B_curr ( i ) = B_curr ( i ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * B ( i + 1 ) dB_curr ( i ) = dB_curr ( i ) - B ( i + 1 ) / ( Xth_ip1 - Xth_i1 ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * dB ( i + 1 ) d2B_curr ( i ) = d2B_curr ( i ) - ( 2 * dB ( i + 1 ) - ( Xth_ip1 - Xt ) * d2B ( i + 1 )) / ( Xth_ip1 - Xth_i1 ) end if end do B = B_curr dB = dB_curr d2B = d2B_curr end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bernstein ( Xt , nc ) result ( B ) real ( rk ), intent ( in ) :: Xt integer , intent ( in ) :: nc real ( rk ), allocatable :: B (:) integer :: p , degree degree = nc - 1 allocate ( B ( nc ), source = 0.0_rk ) do concurrent ( p = 0 : degree ) B ( p + 1 ) = gamma ( real ( nc , kind = rk )) / ( gamma ( real ( p + 1 , kind = rk )) * gamma ( real ( nc - p , kind = rk ))) ! if (Xt == 0.0_rk .and. p == 0) then if ( abs ( Xt ) < 2.0_rk * epsilon ( 0.0_rk ) . and . p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( 1.0_rk - Xt ) ** ( degree - p ) ! else if (Xt == 0.0_rk .and. degree-p == 0) then else if ( abs ( Xt ) < 2.0_rk * epsilon ( 0.0_rk ) . and . degree - p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) else B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) * ( 1.0_rk - Xt ) ** ( degree - p ) end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron_t1_t1 ( u , v ) result ( w ) real ( rk ), intent ( in ), contiguous :: u (:), v (:) real ( rk ) :: w ( size ( u ) * size ( v )) integer :: i , j , n n = size ( v ) do concurrent ( i = 1 : size ( u ), j = 1 : n ) w (( i - 1 ) * n + j ) = u ( i ) * v ( j ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron_t1_t2 ( u , A ) result ( B ) real ( rk ), intent ( in ), contiguous :: u (:) real ( rk ), intent ( in ), contiguous :: A (:,:) real ( rk ) :: B ( size ( u ) * size ( A , 1 ), size ( A , 2 )) integer :: i , j , k , m , r , c m = size ( u ) r = size ( A , 1 ) c = size ( A , 2 ) do concurrent ( i = 1 : m , j = 1 : r , k = 1 : c ) B (( i - 1 ) * r + j , k ) = u ( i ) * A ( j , k ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron3 ( u , v , w ) result ( out ) real ( rk ), intent ( in ), contiguous :: u (:), v (:), w (:) real ( rk ) :: out ( size ( u ) * size ( v ) * size ( w )) integer :: i , j , k , nv , nw nv = size ( v ) nw = size ( w ) do concurrent ( i = 1 : size ( u ), j = 1 : nv , k = 1 : nw ) out ((( i - 1 ) * nv + j - 1 ) * nw + k ) = u ( i ) * v ( j ) * w ( k ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron_eye ( A , dim ) result ( B ) real ( rk ), intent ( in ), contiguous :: A (:,:) integer , intent ( in ) :: dim real ( rk ) :: B ( size ( A , 1 ) * dim , size ( A , 2 ) * dim ) integer :: i , j , r B = 0.0_rk do concurrent ( i = 1 : size ( A , 1 ), j = 1 : size ( A , 2 )) do r = 1 , dim B (( i - 1 ) * dim + r , ( j - 1 ) * dim + r ) = A ( i , j ) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid2 ( X_dir1 , X_dir2 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , i , j s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) allocate ( Xt ( s1 * s2 , 2 )) do concurrent ( j = 1 : s2 , i = 1 : s1 ) Xt (( j - 1 ) * s1 + i , 1 ) = X_dir1 ( i ) Xt (( j - 1 ) * s1 + i , 2 ) = X_dir2 ( j ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid3 ( X_dir1 , X_dir2 , X_dir3 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:), X_dir3 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , s3 , i , j , k s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) s3 = size ( X_dir3 ) allocate ( Xt ( s1 * s2 * s3 , 3 )) do concurrent ( k = 1 : s3 , j = 1 : s2 , i = 1 : s1 ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 1 ) = X_dir1 ( i ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 2 ) = X_dir2 ( j ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 3 ) = X_dir3 ( k ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function repelem ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) integer , intent ( in ), contiguous :: b (:) real ( rk ) :: c ( sum ( b )) integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function linspace ( a , b , n ) result ( x ) real ( rk ), intent ( in ) :: a , b integer , intent ( in ) :: n real ( rk ), allocatable :: x (:) integer :: i if ( n < 1 ) error stop \"linspace: n must be >= 1\" allocate ( x ( n )) if ( n == 1 ) then x ( 1 ) = a else do concurrent ( i = 1 : n ) x ( i ) = a + ( i - 1 ) * ( b - a ) / real ( n - 1 , rk ) end do end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_L ( nnode , p ) result ( elemConn ) integer , intent ( in ) :: nnode integer , intent ( in ) :: p integer , allocatable :: elemConn (:,:) integer :: i integer , allocatable :: nodes (:) if ( mod ( nnode - 1 , p ) /= 0 ) error stop 'cmp_elemConn_C0_L: nnode-1 must be divisible by p' allocate ( elemConn ( ( nnode - 1 ) / p , p + 1 )) nodes = [( i , i = 1 , nnode )] do concurrent ( i = 1 : nnode - p : p ) elemConn (( i - 1 ) / p + 1 , :) = reshape ( nodes ( i : i + p ), [ p + 1 ]) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_S ( nnode1 , nnode2 , p1 , p2 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 , p1 , p2 integer , allocatable :: elemConn (:,:) integer :: i , j , nelem1 , nelem2 , nnel integer , allocatable :: nodes (:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode2-1 must be divisible by p2' nelem1 = ( nnode1 - 1 ) / p1 nelem2 = ( nnode2 - 1 ) / p2 nnel = ( p1 + 1 ) * ( p2 + 1 ) allocate ( elemConn ( nelem1 * nelem2 , nnel )) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 )], [ nnode1 , nnode2 ]) #if defined(__NVCOMPILER) do i = 1 , nnode1 - p1 , p1 do j = 1 , nnode2 - p2 , p2 elemConn ((( j - 1 ) / p2 ) * nelem1 + ( i - 1 ) / p1 + 1 , :) = reshape ( nodes ( i : i + p1 , j : j + p2 ), [ nnel ]) end do end do #else do concurrent ( j = 1 : nnode2 - p2 : p2 , i = 1 : nnode1 - p1 : p1 ) elemConn ((( j - 1 ) / p2 ) * nelem1 + ( i - 1 ) / p1 + 1 , :) = reshape ( nodes ( i : i + p1 , j : j + p2 ), [ nnel ]) end do #endif end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 , nnode3 , p1 , p2 , p3 integer , allocatable :: elemConn (:,:) integer :: i , j , k , nnel , nelem1 , nelem2 , nelem3 integer , allocatable :: nodes (:,:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode2-1 must be divisible by p2' if ( mod ( nnode3 - 1 , p3 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode3-1 must be divisible by p3' nelem1 = ( nnode1 - 1 ) / p1 nelem2 = ( nnode2 - 1 ) / p2 nelem3 = ( nnode3 - 1 ) / p3 nnel = ( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 ) allocate ( elemConn ( nelem1 * nelem2 * nelem3 , nnel )) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 * nnode3 )], [ nnode1 , nnode2 , nnode3 ]) #if defined(__NVCOMPILER) do k = 1 , nnode3 - p3 , p3 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 elemConn ((( k - 1 ) / p3 ) * ( nelem1 * nelem2 ) + (( j - 1 ) / p2 ) * nelem1 + (( i - 1 ) / p1 ) + 1 , :) = reshape ( nodes ( i : i + p1 , j : j + p2 , k : k + p3 ), [ nnel ]) end do end do end do #else do concurrent ( k = 1 : nnode3 - p3 : p3 , j = 1 : nnode2 - p2 : p2 , i = 1 : nnode1 - p1 : p1 ) elemConn ((( k - 1 ) / p3 ) * ( nelem1 * nelem2 ) + (( j - 1 ) / p2 ) * nelem1 + (( i - 1 ) / p1 ) + 1 , :) = reshape ( nodes ( i : i + p1 , j : j + p2 , k : k + p3 ), [ nnel ]) end do #endif end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_L ( nnode , p , Xth , vecKnot_mul , elemConn ) integer , intent ( in ) :: p , nnode integer , intent ( in ), contiguous :: vecKnot_mul (:) real ( rk ), intent ( in ), contiguous :: Xth (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:) integer :: i , m , nnel , nelem nnel = p + 1 nelem = size ( Xth ) - 1 allocate ( nodes ( nnode )) nodes = [( i , i = 1 , nnode )] allocate ( elemConn ( nelem , nnel )) do concurrent ( i = 1 : nelem ) m = - p + sum ( vecKnot_mul ( 1 : i )) elemConn ( i ,:) = nodes ( m : m + p ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_S ( nnode1 , nnode2 , p1 , p2 , & Xth1 , Xth2 , vecKnot_mul1 , vecKnot_mul2 , elemConn ) integer , intent ( in ) :: p1 , p2 , nnode1 , nnode2 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:), nodes_vec (:) integer :: nnd_total , i , j , l , m , n , nnel1 , nnel2 , nelem1 , nelem2 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem = nelem1 * nelem2 nnd_total = nnode1 * nnode2 allocate ( nodes_vec ( nnd_total )) nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec , [ nnode1 , nnode2 ]) allocate ( elemConn ( nelem , nnel1 * nnel2 )) #if defined(__NVCOMPILER) do j = 1 , nelem2 do i = 1 , nelem1 m = - p1 + sum ( vecKnot_mul1 ( 1 : i )) n = - p2 + sum ( vecKnot_mul2 ( 1 : j )) l = ( j - 1 ) * nelem1 + i elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 ), [ nnel1 * nnel2 ]) end do end do #else do concurrent ( j = 1 : nelem2 , i = 1 : nelem1 ) m = - p1 + sum ( vecKnot_mul1 ( 1 : i )) n = - p2 + sum ( vecKnot_mul2 ( 1 : j )) l = ( j - 1 ) * nelem1 + i elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 ), [ nnel1 * nnel2 ]) end do #endif end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ,& Xth1 , Xth2 , Xth3 , vecKnot_mul1 , vecKnot_mul2 , vecKnot_mul3 , elemConn ) integer , intent ( in ) :: p1 , p2 , p3 , nnode1 , nnode2 , nnode3 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:), vecKnot_mul3 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:), Xth3 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:,:), nodes_vec (:) integer :: nnd_total , i , j , k , l , nnel1 , nnel2 , nnel3 , nnel , m , n , o , nelem1 , nelem2 , nelem3 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnel3 = p3 + 1 nnd_total = nnode1 * nnode2 * nnode3 allocate ( nodes_vec ( nnd_total )) nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 , nnode3 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem3 = size ( Xth3 ) - 1 nelem = nelem1 * nelem2 * nelem3 nnel = nnel1 * nnel2 * nnel3 allocate ( elemConn ( nelem , nnel )) #if defined(__NVCOMPILER) do k = 1 , nelem3 do j = 1 , nelem2 do i = 1 , nelem1 o = - p3 + sum ( vecKnot_mul3 ( 1 : k )) n = - p2 + sum ( vecKnot_mul2 ( 1 : j )) m = - p1 + sum ( vecKnot_mul1 ( 1 : i )) l = ( k - 1 ) * nelem1 * nelem2 + ( j - 1 ) * nelem1 + i elemConn ( l , :) = reshape ( nodes ( m : m + p1 , n : n + p2 , o : o + p3 ), [ nnel ] ) end do end do end do #else do concurrent ( k = 1 : nelem3 , j = 1 : nelem2 , i = 1 : nelem1 ) o = - p3 + sum ( vecKnot_mul3 ( 1 : k )) n = - p2 + sum ( vecKnot_mul2 ( 1 : j )) m = - p1 + sum ( vecKnot_mul1 ( 1 : i )) l = ( k - 1 ) * nelem1 * nelem2 + ( j - 1 ) * nelem1 + i elemConn ( l , :) = reshape ( nodes ( m : m + p1 , n : n + p2 , o : o + p3 ), [ nnel ] ) end do #endif end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity1 ( knot ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) integer , allocatable :: multiplicity (:) integer :: i , count count = 1 do i = 2 , size ( knot ) ! if (knot(i) /= knot(i-1)) count = count + 1 if ( abs ( knot ( i ) - knot ( i - 1 )) > 2.0_rk * epsilon ( 0.0_rk )) count = count + 1 end do allocate ( multiplicity ( count )) multiplicity ( 1 ) = 1 count = 1 do i = 2 , size ( knot ) ! if (knot(i) /= knot(i-1)) then if ( abs ( knot ( i ) - knot ( i - 1 )) > 2.0_rk * epsilon ( 0.0_rk )) then count = count + 1 multiplicity ( count ) = 1 else multiplicity ( count ) = multiplicity ( count ) + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity2 ( knot , Xth ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ) :: Xth integer :: multiplicity integer :: i , count , size_knot size_knot = size ( knot ) multiplicity = 0 i = 1 do while ( i <= size_knot ) ! if (knot(i) == Xth) then if ( abs ( knot ( i ) - Xth ) < 2.0_rk * epsilon ( 0.0_rk )) then count = 1 ! do while (i + count <= size_knot .and. knot(i + count) == Xth) do while (( i + count ) <= size_knot ) if ( abs ( knot ( i + count ) - Xth ) >= 2.0_rk * epsilon ( 0.0_rk )) exit count = count + 1 end do if ( count > multiplicity ) then multiplicity = count end if i = i + count else i = i + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_knot_vector ( Xth_dir , degree , continuity ) result ( knot ) real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), allocatable :: knot (:) knot = repelem ( Xth_dir , ( degree - continuity )) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knot_A_5_1 ( p , UP , Pw , u , k , s , r , nq , UQ , Qw , T ) integer , intent ( in ) :: p , k , s , r real ( rk ), intent ( in ), contiguous :: UP ( 0 :), Pw ( 0 :,:) real ( rk ), intent ( in ) :: u real ( rk ), allocatable , intent ( out ) :: UQ (:), Qw (:,:) integer , intent ( out ) :: nq real ( rk ), allocatable , intent ( out ), optional :: T (:,:) real ( rk ), allocatable :: Rw (:,:) real ( rk ) :: alpha integer :: i , j , L , mp , d , np , Lf , bw d = size ( Pw , 2 ) np = size ( Pw , 1 ) - 1 mp = np + p + 1 nq = np + r allocate ( UQ ( 0 : mp + r )) allocate ( Qw ( 0 : nq , 1 : d )) allocate ( Rw ( 0 : p , 1 : d )) UQ ( 0 : k ) = UP ( 0 : k ) UQ ( k + 1 : k + r ) = u UQ ( k + 1 + r : mp + r ) = UP ( k + 1 : mp ) Qw ( 0 : k - p , :) = Pw ( 0 : k - p , :) Qw ( k - s + r : np + r , :) = Pw ( k - s : np , :) Rw ( 0 : p - s , :) = Pw ( k - p : k - s , :) if ( present ( T )) then allocate ( T ( 0 : nq , 0 : np ), source = 0.0_rk ) do concurrent ( i = 0 : k - p ) T ( i , i ) = 1.0_rk end do do concurrent ( i = k - s + r : nq ) T ( i , i - r ) = 1.0_rk end do Lf = k - p + r bw = p - s do concurrent ( i = 0 : bw ) T ( Lf + i , k - p + i ) = 1.0_rk end do end if do j = 1 , r L = k - p + j do i = 0 , p - j - s alpha = ( u - UP ( L + i )) / ( UP ( i + k + 1 ) - UP ( L + i )) Rw ( i , :) = alpha * Rw ( i + 1 , :) + ( 1.0_rk - alpha ) * Rw ( i , :) if ( present ( T )) then T ( Lf + i , :) = alpha * T ( Lf + i + 1 , :) + ( 1.0_rk - alpha ) * T ( Lf + i , :) end if end do Qw ( L , :) = Rw ( 0 , :) Qw ( k + r - j - s , :) = Rw ( p - j - s , :) if ( present ( T )) then T ( L , :) = T ( Lf + 0 , :) T ( k + r - j - s , :) = T ( Lf + ( p - j - s ), :) end if end do Qw ( L + 1 : k - s - 1 , :) = Rw ( 1 : k - s - 1 - L , :) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function findspan ( n , degree , Xth , knot ) result ( s ) integer , intent ( in ) :: n , degree real ( rk ), intent ( in ) :: Xth real ( rk ), intent ( in ), contiguous :: knot (:) integer :: s integer :: low , high , mid ! if (Xth == knot(n+2)) then if ( abs ( Xth - knot ( n + 2 )) < 2.0_rk * epsilon ( 0.0_rk )) then s = n return end if low = degree high = n + 1 mid = ( low + high ) / 2 do while ( Xth < knot ( mid + 1 ) . or . Xth >= knot ( mid + 2 )) if ( Xth < knot ( mid + 1 )) then high = mid else low = mid end if mid = ( low + high ) / 2 end do s = mid end function !=============================================================================== !=============================================================================== !> author:  Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree_A_5_9 ( t , knot , degree , Xcw , nc_new , knot_new , Xcw_new , Tmap ) integer , intent ( in ) :: t real ( rk ), intent ( in ), contiguous :: Xcw (:,:), knot (:) integer , intent ( in ) :: degree integer , intent ( out ) :: nc_new real ( rk ), allocatable , intent ( out ) :: Xcw_new (:,:), knot_new (:) real ( rk ), allocatable , intent ( out ), optional :: Tmap (:,:) real ( rk ), allocatable :: bezalfs (:,:), bpts (:,:), ebpts (:,:), Nextbpts (:,:), alfs (:) real ( rk ), allocatable :: bC (:,:), ebC (:,:), NextbC (:,:) ! only used if Tmap present real ( rk ) :: iinv , alpha1 , alpha2 , Xth1 , Xth2 , numer , den , alpha3 integer :: n , lbz , rbz , sv , tr , kj , first , knoti , last , d , nc integer :: i , j , q , s , m , ph , ph2 , mpi , mh , r , a , b , Xcwi , oldr , mul integer , allocatable :: mlp (:) nc = size ( Xcw , 1 ) d = size ( Xcw , 2 ) mlp = compute_multiplicity ( knot ) mlp = mlp + t nc_new = sum ( mlp ) - ( mlp ( 1 ) - 1 ) - 1 allocate ( Xcw_new ( nc_new , d ), source = 0.0_rk ) allocate ( bezalfs ( degree + 1 , degree + t + 1 ), source = 0.0_rk ) allocate ( bpts ( degree + 1 , d ), source = 0.0_rk ) allocate ( ebpts ( degree + t + 1 , d ), source = 0.0_rk ) allocate ( Nextbpts ( degree + 1 , d ), source = 0.0_rk ) allocate ( alfs ( degree ), source = 0.0_rk ) if ( present ( Tmap )) then allocate ( Tmap ( nc_new , nc ), source = 0.0_rk ) allocate ( bC ( degree + 1 , nc ), ebC ( degree + t + 1 , nc ), NextbC ( degree + 1 , nc ), source = 0.0_rk ) end if n = nc - 1 m = n + degree + 1 ph = degree + t ph2 = ph / 2 bezalfs ( 1 , 1 ) = 1.0_rk bezalfs ( degree + 1 , ph + 1 ) = 1.0_rk do i = 1 , ph2 iinv = 1.0_rk / bincoeff ( ph , i ) mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = iinv * bincoeff ( degree , j ) * bincoeff ( t , i - j ) end do end do do i = ph2 + 1 , ph - 1 mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = bezalfs ( degree - j + 1 , ph - i + 1 ) end do end do mh = ph knoti = ph + 1 r = - 1 a = degree b = degree + 1 Xcwi = 1 Xth1 = knot ( 1 ) Xcw_new ( 1 ,:) = Xcw ( 1 ,:) if ( present ( Tmap )) Tmap ( 1 , 1 ) = 1.0_rk allocate ( knot_new ( sum ( mlp )), source = 0.0_rk ) knot_new ( 1 : ph + 1 ) = Xth1 do i = 0 , degree bpts ( i + 1 ,:) = Xcw ( i + 1 ,:) if ( present ( Tmap )) bC ( i + 1 , i + 1 ) = 1.0_rk end do do while ( b < m ) i = b do while ( b < m . and . abs ( knot ( b + 1 ) - knot ( b + 2 )) < 2.0_rk * epsilon ( 0.0_rk )) b = b + 1 if ( b + 2 > size ( knot )) exit end do mul = b - i + 1 mh = mh + mul + t Xth2 = knot ( b + 1 ) oldr = r r = degree - mul lbz = merge (( oldr + 2 ) / 2 , 1 , oldr > 0 ) rbz = merge ( ph - ( r + 1 ) / 2 , ph , r > 0 ) if ( r > 0 ) then numer = Xth2 - Xth1 do q = degree , mul + 1 , - 1 alfs ( q - mul ) = numer / ( knot ( a + q + 1 ) - Xth1 ) end do do j = 1 , r sv = r - j ; s = mul + j do q = degree , s , - 1 bpts ( q + 1 ,:) = ( 1.0_rk - alfs ( q - s + 1 )) * bpts ( q ,:) + alfs ( q - s + 1 ) * bpts ( q + 1 ,:) if ( present ( Tmap )) bC ( q + 1 ,:) = ( 1.0_rk - alfs ( q - s + 1 )) * bC ( q ,:) + alfs ( q - s + 1 ) * bC ( q + 1 ,:) end do Nextbpts ( sv + 1 ,:) = bpts ( degree + 1 ,:) if ( present ( Tmap )) NextbC ( sv + 1 ,:) = bC ( degree + 1 ,:) end do end if do i = lbz , ph ebpts ( i + 1 ,:) = 0.0_rk if ( present ( Tmap )) ebC ( i + 1 ,:) = 0.0_rk mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi ebpts ( i + 1 ,:) = ebpts ( i + 1 ,:) + bezalfs ( j + 1 , i + 1 ) * bpts ( j + 1 ,:) if ( present ( Tmap )) ebC ( i + 1 ,:) = ebC ( i + 1 ,:) + bezalfs ( j + 1 , i + 1 ) * bC ( j + 1 ,:) end do end do if ( oldr > 1 ) then first = knoti - 2 last = knoti den = Xth2 - Xth1 alpha3 = floor (( Xth2 - knot ( knoti )) / den ) do tr = 1 , oldr - 1 i = first j = last kj = j - knoti + 1 do while ( j - i > tr ) if ( i < Xcwi ) then alpha1 = ( Xth2 - knot ( i + 1 )) / ( Xth1 - knot ( i + 1 )) Xcw_new ( i + 1 ,:) = ( 1.0_rk - alpha1 ) * Xcw_new ( i ,:) + alpha1 * Xcw_new ( i + 1 ,:) if ( present ( Tmap )) Tmap ( i + 1 ,:) = ( 1.0_rk - alpha1 ) * Tmap ( i ,:) + alpha1 * Tmap ( i + 1 ,:) end if if ( j >= lbz ) then if ( j - tr <= knoti - ph + oldr ) then alpha2 = ( Xth2 - knot_new ( j - tr + 1 )) / den ebpts ( kj + 1 ,:) = alpha2 * ebpts ( kj + 1 ,:) + ( 1.0_rk - alpha2 ) * ebpts ( kj + 2 ,:) if ( present ( Tmap )) ebC ( kj + 1 ,:) = alpha2 * ebC ( kj + 1 ,:) + ( 1.0_rk - alpha2 ) * ebC ( kj + 2 ,:) else ebpts ( kj + 1 ,:) = ( 1.0_rk - alpha3 ) * ebpts ( kj + 2 ,:) + alpha3 * ebpts ( kj + 1 ,:) if ( present ( Tmap )) ebC ( kj + 1 ,:) = ( 1.0_rk - alpha3 ) * ebC ( kj + 2 ,:) + alpha3 * ebC ( kj + 1 ,:) end if end if i = i + 1 ; j = j - 1 ; kj = kj - 1 end do first = first - 1 last = last + 1 end do end if if ( a /= degree ) then do i = 0 , ph - oldr - 1 knot_new ( knoti + 1 ) = Xth1 knoti = knoti + 1 end do end if do j = lbz , rbz Xcw_new ( Xcwi + 1 ,:) = ebpts ( j + 1 ,:) if ( present ( Tmap )) Tmap ( Xcwi + 1 ,:) = ebC ( j + 1 ,:) Xcwi = Xcwi + 1 end do if ( b < m ) then do j = 0 , r - 1 bpts ( j + 1 ,:) = Nextbpts ( j + 1 ,:) if ( present ( Tmap )) bC ( j + 1 ,:) = NextbC ( j + 1 ,:) end do do j = r , degree bpts ( j + 1 ,:) = Xcw ( b - degree + j + 1 ,:) if ( present ( Tmap )) then bC ( j + 1 ,:) = 0.0_rk bC ( j + 1 , b - degree + j + 1 ) = 1.0_rk end if end do a = b b = b + 1 Xth1 = Xth2 else do i = 0 , ph knot_new ( knoti + i + 1 ) = Xth2 end do end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure elemental function bincoeff ( n , k ) result ( b ) integer , intent ( in ) :: n , k real ( rk ) :: b b = floor ( 0.5_rk + exp ( factln ( n ) - factln ( k ) - factln ( n - k ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure elemental function factln ( n ) result ( f ) integer , intent ( in ) :: n real ( rk ) :: f if ( n <= 1 ) then f = 0.0_rk return end if f = log ( gamma ( real ( n + 1 , rk ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function hexahedron_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ), contiguous :: L (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy , dz integer :: i , j , k dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) dz = L ( 3 ) / real ( nc ( 3 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) do concurrent ( k = 0 : nc ( 3 ) - 1 , j = 0 : nc ( 2 ) - 1 , i = 0 : nc ( 1 ) - 1 ) Xc ( i + j * nc ( 1 ) + k * nc ( 1 ) * nc ( 2 ) + 1 , 1 ) = real ( i , rk ) * dx Xc ( i + j * nc ( 1 ) + k * nc ( 1 ) * nc ( 2 ) + 1 , 2 ) = real ( j , rk ) * dy Xc ( i + j * nc ( 1 ) + k * nc ( 1 ) * nc ( 2 ) + 1 , 3 ) = real ( k , rk ) * dz end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function tetragon_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ), contiguous :: L (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy integer :: i , j dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ), 3 )) do concurrent ( j = 0 : nc ( 2 ) - 1 , i = 0 : nc ( 1 ) - 1 ) Xc ( i + j * nc ( 1 ) + 1 , 1 ) = real ( i , rk ) * dx Xc ( i + j * nc ( 1 ) + 1 , 2 ) = real ( j , rk ) * dy Xc ( i + j * nc ( 1 ) + 1 , 3 ) = 0.0_rk end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots_A_5_8 ( p , knot , Pw , u , r , s , num , t , knot_new , Pw_new ) real ( rk ), intent ( in ) :: u integer , intent ( in ) :: p , r , s , num real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Pw (:,:) real ( rk ), allocatable , intent ( out ) :: knot_new (:) real ( rk ), allocatable , intent ( out ) :: Pw_new (:,:) real ( rk ), allocatable :: Pw_copy (:,:), knot_copy (:) integer , intent ( out ) :: t real ( rk ) :: tol , alfi , alfj real ( rk ), allocatable :: temp (:,:) integer :: i , j , ii , jj , remflag , off , first , last , ord , fout , m , k , n , nc , d , tt d = size ( Pw , 2 ) nc = size ( Pw , 1 ) n = nc m = n + p + 1 ord = p + 1 fout = ( 2 * r - s - p ) / 2 last = r - s first = r - p Pw_copy = Pw knot_copy = knot ! TODO: tol = 1.0e-6_rk * minval ( Pw (:, d )) / ( 1.0_rk + maxval ( sqrt ( sum ( Pw ** 2 , 2 )))) allocate ( temp ( 2 * p + 1 , d ), source = 0.0_rk ) t = 0 do tt = 0 , num - 1 off = first - 1 temp ( 1 ,:) = Pw_copy ( off ,:) temp ( last + 1 - off + 1 ,:) = Pw_copy ( last + 1 ,:) i = first j = last ii = 1 jj = last - off remflag = 0 do while ( j - i > t ) alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) alfj = ( u - knot_copy ( j - t )) / ( knot_copy ( j + ord ) - knot_copy ( j - t )) temp ( ii + 1 ,:) = ( Pw_copy ( i ,:) - ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:)) / alfi temp ( jj + 1 ,:) = ( Pw_copy ( j ,:) - alfj * temp ( jj + 1 + 1 ,:)) / ( 1.0_rk - alfj ) i = i + 1 ii = ii + 1 j = j - 1 jj = jj - 1 end do if ( j - i <= t ) then if ( norm2 ( temp ( ii - 1 + 1 ,:) - temp ( jj + 1 + 1 ,:)) <= tol ) then remflag = 1 else alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) if ( norm2 ( Pw_copy ( i ,:) - ( alfi * temp ( ii + t + 1 + 1 ,:) + ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:))) <= tol ) then remflag = 1 end if end if end if if ( remflag == 0 ) then exit else i = first j = last do while ( j - i > t ) Pw_copy ( i ,:) = temp ( i - off + 1 ,:) Pw_copy ( j ,:) = temp ( j - off + 1 ,:) i = i + 1 j = j - 1 end do end if first = first - 1 last = last + 1 t = t + 1 end do if ( t == 0 ) then return end if do k = r + 1 , m knot_copy ( k - t ) = knot_copy ( k ) end do j = fout i = j do k = 1 , t - 1 if ( mod ( k , 2 ) == 1 ) then i = i + 1 else j = j - 1 end if end do do k = i + 1 , n Pw_copy ( j ,:) = Pw_copy ( k ,:) j = j + 1 end do knot_new = knot_copy ( 1 : size ( knot_copy ) - t ) Pw_new = Pw_copy ( 1 : size ( Pw_copy , 1 ) - t ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_integer ( vec ) result ( output ) integer , intent ( in ), contiguous :: vec (:) integer , allocatable :: output (:) integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) if ( vec ( i ) == output ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_real ( vec ) result ( output ) real ( rk ), intent ( in ), contiguous :: vec (:) real ( rk ), allocatable :: output (:) integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) ! if (vec(i) == output(j)) then if ( abs ( vec ( i ) - output ( j )) < 2.0_rk * epsilon ( 0.0_rk )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function rotation ( alpha , beta , theta ) result ( R ) real ( rk ), intent ( in ) :: alpha , beta , theta real ( rk ) :: R ( 3 , 3 ) R ( 1 , 1 ) = cosd ( beta ) * cosd ( theta ) R ( 2 , 1 ) = cosd ( beta ) * sind ( theta ) R ( 3 , 1 ) = - sind ( beta ) R ( 1 , 2 ) = sind ( alpha ) * sind ( beta ) * cosd ( theta ) - cosd ( alpha ) * sind ( theta ) R ( 2 , 2 ) = sind ( alpha ) * sind ( beta ) * sind ( theta ) + cosd ( alpha ) * cosd ( theta ) R ( 3 , 2 ) = sind ( alpha ) * cosd ( beta ) R ( 1 , 3 ) = cosd ( alpha ) * sind ( beta ) * cosd ( theta ) + sind ( alpha ) * sind ( theta ) R ( 2 , 3 ) = cosd ( alpha ) * sind ( beta ) * sind ( theta ) - sind ( alpha ) * cosd ( theta ) R ( 3 , 3 ) = cosd ( alpha ) * cosd ( beta ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function det ( A ) result ( detA ) real ( rk ), intent ( in ), contiguous :: A (:,:) real ( rk ) :: detA if ( size ( A , 1 ) == size ( A , 2 )) then select case ( size ( A , 1 )) case ( 2 ) detA = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) case ( 3 ) detA = & + A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) )& - A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 ) )& + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) ) end select elseif ( size ( A , 1 ) == 3 . and . size ( A , 2 ) == 2 ) then detA = & + A ( 1 , 1 ) * ( A ( 2 , 2 ) * 1.0_rk - A ( 3 , 2 ) * 1.0_rk )& - A ( 1 , 2 ) * ( A ( 2 , 1 ) * 1.0_rk - A ( 3 , 1 ) * 1.0_rk )& + 1.0_rk * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 3 , 1 ) * A ( 2 , 2 ) ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause recursive pure function inv ( A ) result ( A_inv ) real ( rk ), intent ( in ), contiguous :: A (:,:) real ( rk ), allocatable :: A_inv (:,:) integer :: m , n m = size ( A , 1 ) n = size ( A , 2 ) if ( m == n ) then select case ( m ) case ( 2 ) allocate ( A_inv ( m , n )) A_inv ( 1 , 1 ) = A ( 2 , 2 ) A_inv ( 1 , 2 ) = - A ( 1 , 2 ) A_inv ( 2 , 1 ) = - A ( 2 , 1 ) A_inv ( 2 , 2 ) = A ( 1 , 1 ) A_inv = A_inv / det ( A ) case ( 3 ) allocate ( A_inv ( m , n )) A_inv ( 1 , 1 ) = A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) A_inv ( 1 , 2 ) = A ( 1 , 3 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 3 ) A_inv ( 1 , 3 ) = A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 ) A_inv ( 2 , 1 ) = A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 ) A_inv ( 2 , 2 ) = A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 ) A_inv ( 2 , 3 ) = A ( 1 , 3 ) * A ( 2 , 1 ) - A ( 1 , 1 ) * A ( 2 , 3 ) A_inv ( 3 , 1 ) = A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) A_inv ( 3 , 2 ) = A ( 1 , 2 ) * A ( 3 , 1 ) - A ( 1 , 1 ) * A ( 3 , 2 ) A_inv ( 3 , 3 ) = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) A_inv = A_inv / det ( A ) case default A_inv = solve ( A , eye ( m )) end select elseif ( m > n ) then allocate ( A_inv ( n , m )) A_inv = transpose ( A ) A_inv = matmul ( inv ( matmul ( A_inv , A )), A_inv ) elseif ( m < n ) then allocate ( A_inv ( n , m )) A_inv = transpose ( A ) A_inv = matmul ( A_inv , inv ( matmul ( A , A_inv ))) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function eye ( n ) result ( I ) integer , intent ( in ) :: n real ( rk ), allocatable :: I (:,:) ! local variables integer :: k allocate ( I ( n , n ), source = 0.0_rk ) do concurrent ( k = 1 : n ) I ( k , k ) = 1.0_rk end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function dyad_t1_t1 ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) real ( rk ), intent ( in ), contiguous :: b (:) real ( rk ), allocatable :: c (:,:) integer :: i allocate ( c ( size ( a ), size ( b ))) do concurrent ( i = 1 : size ( c , 1 )) c ( i , :) = a ( i ) * b (:) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_1D ( interval , degree , Xksi , Wksi ) real ( rk ), intent ( in ), contiguous :: interval (:) integer , intent ( in ) :: degree real ( rk ), allocatable , intent ( out ) :: Xksi (:), Wksi (:) allocate ( Xksi ( degree + 1 ), Wksi ( degree + 1 )) call gauss_legendre ( Xksi , Wksi , interval ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_2D ( interval1 , interval2 , degree , Xksi , Wksi ) real ( rk ), intent ( in ), contiguous :: interval1 (:), interval2 (:) integer , intent ( in ), contiguous :: degree (:) real ( rk ), allocatable , intent ( out ) :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: Xksi1 (:), Wksi1 (:), Xksi2 (:), Wksi2 (:) allocate ( Xksi1 ( degree ( 1 ) + 1 ), Wksi1 ( degree ( 1 ) + 1 )) allocate ( Xksi2 ( degree ( 2 ) + 1 ), Wksi2 ( degree ( 2 ) + 1 )) call gauss_legendre ( Xksi1 , Wksi1 , interval1 ) call gauss_legendre ( Xksi2 , Wksi2 , interval2 ) call ndgrid ( Xksi1 , Xksi2 , Xksi ) Wksi = kron ( Wksi1 , Wksi2 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_3D ( interval1 , interval2 , interval3 , degree , Xksi , Wksi ) real ( rk ), intent ( in ), contiguous :: interval1 (:), interval2 (:), interval3 (:) integer , intent ( in ), contiguous :: degree (:) real ( rk ), allocatable , intent ( out ) :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: Xksi1 (:), Wksi1 (:), Xksi2 (:), Wksi2 (:), Xksi3 (:), Wksi3 (:) allocate ( Xksi1 ( degree ( 1 ) + 1 ), Wksi1 ( degree ( 1 ) + 1 )) allocate ( Xksi2 ( degree ( 2 ) + 1 ), Wksi2 ( degree ( 2 ) + 1 )) allocate ( Xksi3 ( degree ( 3 ) + 1 ), Wksi3 ( degree ( 3 ) + 1 )) call gauss_legendre ( Xksi1 , Wksi1 , interval1 ) call gauss_legendre ( Xksi2 , Wksi2 , interval2 ) call gauss_legendre ( Xksi3 , Wksi3 , interval3 ) call ndgrid ( Xksi1 , Xksi2 , Xksi3 , Xksi ) Wksi = kron ( kron ( Wksi3 , Wksi2 ), Wksi1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre ( x , w , interval ) real ( rk ), intent ( out ) :: x (:), w (:) real ( rk ), intent ( in ), contiguous :: interval (:) real ( rk ) :: xi , delta , p_next , dp_next , p_prev , p_curr , dp_prev , dp_curr , midpoint , half_length integer :: i , j , k , n real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), parameter :: tol = 4.0_rk * epsilon ( 1.0_rk ) integer , parameter :: maxit = 100 logical :: converged if ( interval ( 1 ) >= interval ( 2 )) error stop \"gauss_legendre: Invalid interval, interval(1) must be less than interval(2)\" n = size ( x ) ! Gauss-Legendre points are symmetric, only compute half do concurrent ( i = 1 :( n + 1 ) / 2 ) ! Initial guess (Chebyshev approximation) xi = - cos ( pi * ( i - 0.25_rk ) / ( n + 0.5_rk )) ! Newton iteration j = 0 converged = . false . do while (. not . converged . and . j < maxit ) j = j + 1 ! Compute Legendre polynomial and derivative via recurrence p_prev = 1.0_rk ! P_0(xi) p_curr = xi ! P_1(xi) dp_prev = 0.0_rk ! P_0d(xi) dp_curr = 1.0_rk ! P_1d(xi) do k = 2 , n p_next = (( 2 * k - 1 ) * xi * p_curr - ( k - 1 ) * p_prev ) / k dp_next = (( 2 * k - 1 ) * ( xi * dp_curr + p_curr ) - ( k - 1 ) * dp_prev ) / k p_prev = p_curr p_curr = p_next dp_prev = dp_curr dp_curr = dp_next end do ! Newton correction delta = - p_curr / dp_curr xi = xi + delta ! Check for convergence converged = ( abs ( delta ) <= tol * abs ( xi )) end do #if defined(__NVCOMPILER) ! if (.not. converged) error stop \"gauss_legendre: Newton iteration did not converge\" #else if (. not . converged ) error stop \"gauss_legendre: Newton iteration did not converge\" #endif ! Store symmetric nodes and weights x ( i ) = xi x ( n + 1 - i ) = - xi w ( i ) = 2.0_rk / (( 1.0_rk - xi ** 2 ) * dp_curr ** 2 ) w ( n + 1 - i ) = w ( i ) end do ! Transform from [-1,1] to [interval(1), interval(2)] midpoint = 0.5_rk * ( interval ( 1 ) + interval ( 2 )) half_length = 0.5_rk * ( interval ( 2 ) - interval ( 1 )) x = midpoint + half_length * x w = half_length * w end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_vtk_legacy ( filename , points , elemConn , vtkCellType , point_data , field_names , encoding ) character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous :: points (:,:) integer , intent ( in ), contiguous :: elemConn (:,:) ! for VTK_POLY_LINE all rows have same nn integer , intent ( in ) :: vtkCellType real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) ! [npoints, nfields] character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer :: i , j , ne , np , nn , n , nunit character ( len = 6 ) :: encoding_ integer , parameter :: dp = kind ( 1.0d0 ) logical :: is_polyline ne = size ( elemConn , 1 ) nn = size ( elemConn , 2 ) np = size ( points , 1 ) n = ne * ( nn + 1 ) is_polyline = ( vtkCellType == 4 ) ! VTK_POLY_LINE if ( present ( encoding )) then select case ( trim ( encoding )) case ( 'ascii' ) encoding_ = 'ASCII' case ( 'binary' ) encoding_ = 'BINARY' case default error stop 'Invalid encoding type. Use \"ASCII\" or \"BINARY\".' end select else encoding_ = 'BINARY' end if if ( trim ( encoding_ ) == 'ASCII' ) then open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' if ( is_polyline ) then write ( nunit , '(a)' ) 'DATASET POLYDATA' else write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' end if write ( nunit , '(a,1x,g0,1x,a)' ) 'POINTS' , np , 'double' if ( size ( points , 2 ) == 2 ) then write ( nunit , '(g0,1x,g0,1x,g0)' ) ( points ( i , 1 ), points ( i , 2 ), 0.0_rk , i = 1 , np ) elseif ( size ( points , 2 ) == 3 ) then write ( nunit , '(g0,1x,g0,1x,g0)' ) ( points ( i , 1 ), points ( i , 2 ), points ( i , 3 ) , i = 1 , np ) else error stop 'Invalid dimension for points.' end if if ( is_polyline ) then write ( nunit , '(a,1x,g0,1x,g0)' ) 'LINES' , ne , n do i = 1 , ne write ( nunit , '(g0, *(1x,g0))' ) nn , ( elemConn ( i , j ) - 1 , j = 1 , nn ) end do else write ( nunit , '(a,1x,g0,1x,g0)' ) 'CELLS' , ne , n select case ( nn ) case ( 2 ) write ( nunit , '(g0,1x,g0,1x,g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , ne ) case ( 4 ) write ( nunit , '(g0,1x,g0,1x,g0,1x,g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , ne ) case ( 8 ) write ( nunit , '(g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , ne ) case default error stop 'Invalid number of nodes per element.' end select write ( nunit , '(a,1x,g0)' ) 'CELL_TYPES' , ne write ( nunit , '(g0)' ) ( vtkCellType , i = 1 , ne ) end if if ( present ( point_data ) . and . present ( field_names )) then write ( nunit , '(a,1x,g0)' ) 'POINT_DATA' , size ( point_data , 1 ) do i = 1 , size ( point_data , 2 ) write ( nunit , '(a,1x,a,1x,a)' ) 'SCALARS' , trim ( field_names ( i )), 'double' write ( nunit , '(a)' ) 'LOOKUP_TABLE default' write ( nunit , '(g0)' ) ( point_data ( j , i ), j = 1 , size ( point_data , 1 )) end do end if close ( nunit ) end if if ( trim ( encoding_ ) == 'BINARY' ) then open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'BINARY' if ( is_polyline ) then write ( nunit , '(a)' ) 'DATASET POLYDATA' else write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' end if close ( nunit ) open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0,1x,a)' ) 'POINTS' , np , 'double' close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = \"stream\" , form = \"unformatted\" ,& action = \"write\" , convert = \"big_endian\" , status = \"unknown\" ) if ( size ( points , 2 ) == 2 ) then write ( nunit ) ( real ( points ( i , 1 ), dp ), real ( points ( i , 2 ), dp ), real ( 0.0_rk , dp ) , i = 1 , np ) else if ( size ( points , 2 ) == 3 ) then write ( nunit ) ( real ( points ( i , 1 ), dp ), real ( points ( i , 2 ), dp ), real ( points ( i , 3 ), dp ) , i = 1 , np ) else error stop 'Invalid dimension for points.' end if close ( nunit ) if ( is_polyline ) then open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0,1x,g0)' ) 'LINES' , ne , n close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = \"stream\" , form = \"unformatted\" ,& action = \"write\" , convert = \"big_endian\" , status = \"unknown\" ) write ( nunit ) ( nn , ( elemConn ( i , j ) - 1 , j = 1 , nn ), i = 1 , ne ) close ( nunit ) else open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0,1x,g0)' ) 'CELLS' , ne , n close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = \"stream\" , form = \"unformatted\" ,& action = \"write\" , convert = \"big_endian\" , status = \"unknown\" ) select case ( nn ) case ( 2 ) write ( nunit )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , ne ) case ( 4 ) write ( nunit )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , ne ) case ( 8 ) write ( nunit )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , ne ) case default error stop 'Invalid number of nodes per element.' end select close ( nunit ) open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0)' ) 'CELL_TYPES' , ne close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = \"stream\" , form = \"unformatted\" ,& action = \"write\" , convert = \"big_endian\" , status = \"unknown\" ) write ( nunit ) ( vtkCellType , i = 1 , ne ) close ( nunit ) end if if ( present ( point_data ) . and . present ( field_names )) then open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0)' ) 'POINT_DATA' , size ( point_data , 1 ) close ( nunit ) do i = 1 , size ( point_data , 2 ) open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,a,1x,a)' ) 'SCALARS' , trim ( field_names ( i )), 'double' write ( nunit , '(a)' ) 'LOOKUP_TABLE default' close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = 'stream' , form = 'unformatted' , & action = 'write' , convert = 'big_endian' , status = 'unknown' ) write ( nunit ) ( real ( point_data ( j , i ), dp ), j = 1 , size ( point_data , 1 )) close ( nunit ) end do end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function solve ( A , B ) result ( X ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), allocatable :: X (:,:) integer :: n , m , i , j , k , p real ( rk ), allocatable :: L (:,:), Y (:,:) real ( rk ) :: sum p = size ( A , 1 ) n = size ( A , 2 ) m = size ( B , 2 ) if ( p /= size ( B , 1 )) error stop \"solve: A and B row mismatch\" allocate ( L ( n , n ), Y ( n , m ), X ( n , m ), source = 0.0_rk ) do i = 1 , n do j = 1 , i sum = A ( i , j ) do k = 1 , j - 1 sum = sum - L ( i , k ) * L ( j , k ) end do if ( i == j ) then if ( sum <= 0.0_rk ) error stop \"solve: Matrix not positive definite\" L ( i , j ) = sqrt ( sum ) else L ( i , j ) = sum / L ( j , j ) end if end do end do ! Forward substitution: L·Y = AtB do j = 1 , m do i = 1 , n sum = B ( i , j ) do k = 1 , i - 1 sum = sum - L ( i , k ) * Y ( k , j ) end do Y ( i , j ) = sum / L ( i , i ) end do end do ! Backward substitution: Lᵗ·X = Y do j = 1 , m do i = n , 1 , - 1 sum = Y ( i , j ) do k = i + 1 , n sum = sum - L ( k , i ) * X ( k , j ) end do X ( i , j ) = sum / L ( i , i ) end do end do end function !=============================================================================== end module forcad_utils","tags":"","url":"sourcefile/forcad_utils.f90.html"},{"title":"cmp_volume.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_volume.f90~~EfferentGraph sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape real ( rk ) :: volume real ( rk ) :: Xc ( 8 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 2.0_rk ] Xc ( 6 ,:) = [ 2.0_rk , 0.0_rk , 2.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 2.0_rk , 2.0_rk ] Xc ( 8 ,:) = [ 2.0_rk , 2.0_rk , 2.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_volume ( volume ) print * , volume end program","tags":"","url":"sourcefile/cmp_volume.f90.html"},{"title":"forcad_nurbs_surface.F90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_surface.f90~~EfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_surface.f90~~AfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. module forcad_nurbs_surface use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , tetragon_Xc , & elemConn_Cn , unique , rotation , det , inv , gauss_leg , export_vtk_legacy , basis_bspline_2der use fordebug , only : debug implicit none private public nurbs_surface , compute_Tgc , compute_dTgc !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_surface real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc(1)*nc(2)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: Xt (:,:) !! Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) integer , private :: degree ( 2 ) !! Degree (order) of the surface integer , private :: nc ( 2 ) !! Number of control points in each direction integer , private :: ng ( 2 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity type ( debug ) :: err !! 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined contains procedure , private :: set1 !!> Set knot vectors, control points and weights for the NURBS surface object procedure , private :: set2 !!> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights procedure , private :: set3 !!> Set Bezier or Rational Bezier surface using control points and weights procedure , private :: set4 !!> Set NURBS surface using degree, number of control points, control points and weights generic :: set => set1 , set2 , set3 , set4 !!> Set NURBS surface procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure , private :: get_nc_dir !!> Get number of control points in a specific direction procedure , private :: get_nc_all !!> Get number of control points in all directions generic :: get_nc => get_nc_all , get_nc_dir !!> Get number of control points procedure :: cmp_degree !!> Compute degree of the NURBS surface procedure , private :: get_degree_all !!> Get degree of the NURBS surface in both directions procedure , private :: get_degree_dir !!> Get degree of the NURBS surface in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS surface procedure :: finalize !!> Finalize the NURBS surface object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem_Xth !!> Generate connectivity for parameter points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: export_Xth !!> Export parameter space to VTK file procedure :: export_Xth_in_Xg !!> Export parameter space in geometry points to VTK file procedure :: export_iges !!> Export the NURBS surface to IGES format procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knot vector procedure :: get_continuity !!> Compute and return the continuity of the NURBS surface procedure :: cmp_nc !!> Compute number of required control points procedure , private :: basis_vector !!> Compute the basis functions of the NURBS surface procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS surface generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS surface procedure , private :: derivative_vector !!> Compute the derivative of the NURBS surface procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS surface generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS surface procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS surface procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS surface generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS surface procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate degree procedure :: is_rational !!> Check if the NURBS surface is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS surface (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS surface (Minimization - Newtons method) procedure :: ansatz !!> Compute the shape functions, derivative of shape functions and dA procedure :: cmp_area !!> Compute the area of the NURBS surface procedure :: lsq_fit_bspline !!> Fit B-spline surface to structured data points using least squares procedure :: lsq_fit_nurbs !!> Fit NURBS surface to structured data points using least squares ! Shapes procedure :: set_tetragon !!> Set a tetragon procedure :: set_ring !!> Set a ring procedure :: set_half_ring !!> Set a half ring procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg module procedure compute_Xg_nurbs_2d module procedure compute_Xg_bspline_2d module procedure compute_Xg_nurbs_2d_1point module procedure compute_Xg_bspline_2d_1point end interface interface compute_Tgc module procedure compute_Tgc_nurbs_2d_vector module procedure compute_Tgc_bspline_2d_vector module procedure compute_Tgc_nurbs_2d_scalar module procedure compute_Tgc_bspline_2d_scalar end interface interface compute_dTgc module procedure compute_dTgc_nurbs_2d_vector module procedure compute_dTgc_bspline_2d_vector module procedure compute_dTgc_nurbs_2d_scalar module procedure compute_dTgc_bspline_2d_scalar end interface interface compute_d2Tgc module procedure compute_d2Tgc_nurbs_2d_vector module procedure compute_d2Tgc_bspline_2d_vector module procedure compute_d2Tgc_nurbs_2d_scalar module procedure compute_d2Tgc_bspline_2d_scalar end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vectors, control points and weights for the NURBS surface object. pure subroutine set1 ( this , knot1 , knot2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % knot1 )) then if ( size ( this % knot1 ) /= size ( knot1 )) deallocate ( this % knot1 ) end if if ( allocated ( this % knot2 )) then if ( size ( this % knot2 ) /= size ( knot2 )) deallocate ( this % knot2 ) end if if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % knot1 = knot1 this % knot2 = knot2 call this % cmp_degree () call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set1' ,& suggestion = 'Provide Wc with size(Wc) == nc(1)*nc(2).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , degree , continuity1 , continuity2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:) real ( rk ), intent ( in ), contiguous , optional :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % degree = degree call this % cmp_nc () if ( present ( Xc )) then if ( size ( Xc , 1 ) /= this % nc ( 1 ) * this % nc ( 2 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_surface' , & message = 'Control points size mismatch in set2' ,& location = 'set2' , & suggestion = 'size(Xc,1) must equal nc(1)*nc(2).' ) return end if end if if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_surface' , & message = 'Weights size mismatch in set2' ,& location = 'set2' , & suggestion = 'size(Wc) must equal nc(1)*nc(2).' ) return end if end if if ( present ( Xc )) then if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc end if if ( present ( Wc )) then if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier surface using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc this % nc = nc if ( allocated ( this % knot1 )) then if ( size ( this % knot1 ) /= 2 * this % nc ( 1 )) then deallocate ( this % knot1 ) allocate ( this % knot1 ( 2 * this % nc ( 1 ))) end if else allocate ( this % knot1 ( 2 * this % nc ( 1 ))) end if this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) then if ( size ( this % knot2 ) /= 2 * this % nc ( 2 )) then deallocate ( this % knot2 ) allocate ( this % knot2 ( 2 * this % nc ( 2 ))) end if else allocate ( this % knot2 ( 2 * this % nc ( 2 ))) end if this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set3' ,& suggestion = 'Provide Wc with size(Wc) == nc(1)*nc(2).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set4 ( this , degree , nc , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) integer :: m ( 2 ), i if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc this % nc = nc this % degree = degree m = nc + degree + 1 if ( allocated ( this % knot1 )) then if ( size ( this % knot1 ) /= m ( 1 )) then deallocate ( this % knot1 ) allocate ( this % knot1 ( m ( 1 ))) end if else allocate ( this % knot1 ( m ( 1 ))) end if this % knot1 ( 1 : degree ( 1 ) + 1 ) = 0.0_rk this % knot1 ( degree ( 1 ) + 2 : m ( 1 ) - degree ( 1 ) - 1 ) = [( real ( i , rk ) / ( m ( 1 ) - 2 * degree ( 1 ) - 1 ), i = 1 , m ( 1 ) - 2 * degree ( 1 ) - 2 )] this % knot1 ( m ( 1 ) - degree ( 1 ): m ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) then if ( size ( this % knot2 ) /= m ( 2 )) then deallocate ( this % knot2 ) allocate ( this % knot2 ( m ( 2 ))) end if else allocate ( this % knot2 ( m ( 2 ))) end if this % knot2 ( 1 : degree ( 2 ) + 1 ) = 0.0_rk this % knot2 ( degree ( 2 ) + 2 : m ( 2 ) - degree ( 2 ) - 1 ) = [( real ( i , rk ) / ( m ( 2 ) - 2 * degree ( 2 ) - 1 ), i = 1 , m ( 2 ) - 2 * degree ( 2 ) - 2 )] this % knot2 ( m ( 2 ) - degree ( 2 ): m ( 2 )) = 1.0_rk if ( present ( Wc )) then if ( size ( Wc ) /= nc ( 1 ) * nc ( 2 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set4' ,& suggestion = 'Provide Wc with size(Wc) == nc(1)*nc(2).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , Xt1 , Xt2 , Xt ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), contiguous , intent ( in ), optional :: Xt (:,:) integer :: i if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Control points are not set.' ,& location = 'create' ,& suggestion = 'Call set(...) first before create().' ) return end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Knot vector is not set.' ,& location = 'create' ,& suggestion = 'Call set(...) first before create().' ) return end if if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= size ( Xt1 )) deallocate ( this % Xt1 ) end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] end if if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= size ( Xt2 )) deallocate ( this % Xt2 ) end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] end if if ( present ( Xt )) then this % Xt = Xt else this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt ) end if if ( allocated ( this % Xg )) then if ( size ( this % Xg , 1 ) /= this % ng ( 1 ) * this % ng ( 2 ) . or . size ( this % Xg , 2 ) /= size ( this % Xc , 2 )) then deallocate ( this % Xg ) end if end if if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), contiguous , intent ( in ) :: Xt (:) real ( rk ), allocatable :: Xg (:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 )) then error stop 'Knot vector(s) is/are not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid direction for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid direction for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS surface is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS surface is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if (. not . this % err % ok ) return if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_surface ), intent ( in ) :: this integer :: ng ( 2 ) if (. not . this % err % ok ) return ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this , dir ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: dir integer , allocatable :: m1 (:), m2 (:) if (. not . this % err % ok ) return if ( present ( dir )) then if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 else call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Invalid direction for degree.' ,& location = 'cmp_degree' ,& suggestion = 'Check the direction argument.' ) return end if else m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer :: degree ( 2 ) if (. not . this % err % ok ) return degree = this % degree end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree if (. not . this % err % ok ) return if ( dir == 1 ) then degree = this % degree ( 1 ) else if ( dir == 2 ) then degree = this % degree ( 2 ) else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if (. not . this % err % ok ) return if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if (. not . this % err % ok ) return if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_surface ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xth ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( size ( unique ( this % knot1 )), size ( unique ( this % knot2 )), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( size ( unique ( this % knot1 )), size ( unique ( this % knot2 )), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename , point_data , field_names , encoding ) class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Control points are not set.' ,& location = 'export_Xc' ,& suggestion = 'Call set(...) first before exporting.' ) return end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if call export_vtk_legacy ( filename = filename , points = this % Xc , elemConn = elemConn , vtkCellType = 9 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename , point_data , field_names , encoding ) class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return if (. not . allocated ( this % Xg )) then call this % err % set (& code = 104 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Geometry points are not set.' ,& location = 'export_Xg' ,& suggestion = 'Generate Xg by calling create(...) before exporting.' ) return end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if call export_vtk_legacy ( filename = filename , points = this % Xg , elemConn = elemConn , vtkCellType = 9 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth ( this , filename , point_data , field_names , encoding ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Xth (:,:), Xth1 (:), Xth2 (:) if (. not . this % err % ok ) return elemConn = this % cmp_elem_Xth () Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) call ndgrid ( Xth1 , Xth2 , Xth ) call export_vtk_legacy ( filename = filename , points = Xth , elemConn = elemConn , vtkCellType = 9 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth_in_Xg ( this , filename , res , encoding ) class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename integer , intent ( in ), optional :: res character ( len =* ), intent ( in ), optional :: encoding integer :: ne_u , ne_v , ne_total , np , j , i , m , s , r , o , a , b , t , g , offsetP , line_nodes integer :: res_min , dim , N1sp , N2sp , L , N , res1 , res2 real ( rk ), allocatable :: U1 (:), U2 (:) real ( rk ), allocatable :: U1r (:), U2r (:) real ( rk ), allocatable :: Xt_all (:,:), Xg_all (:,:) integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Control points are not set.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Call set(...) first before exporting.' ) return end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Knot vector is not set.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Call set(...) first before exporting.' ) return end if res_min = 10 if ( present ( res )) res_min = max ( 2 , res ) U1 = unique ( this % knot1 ) if ( size ( U1 ) < 2 ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'knot1 needs >= 2 unique values.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the knot vector for sufficient unique values.' ) return end if U2 = unique ( this % knot2 ) if ( size ( U2 ) < 2 ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'knot2 needs >= 2 unique values.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the knot vector for sufficient unique values.' ) return end if N1sp = size ( U1 ) - 1 N2sp = size ( U2 ) - 1 L = N1sp if ( N2sp > 0 ) then a = L b = N2sp do t = mod ( a , b ) if ( t == 0 ) exit a = b b = t end do g = b L = ( L / g ) * N2sp end if L = L * max ( 1 , res_min - 1 ) N = L + 1 res1 = L / N1sp + 1 res2 = L / N2sp + 1 dim = size ( this % Xc , 2 ) if ( dim < 2 . or . dim > 3 ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Invalid geometry dimension.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the geometry dimension before exporting the NURBS surface.' ) return end if ! Allocate refined knot vectors allocate ( U1r ( ( size ( U1 ) - 1 ) * ( res1 - 1 ) + 1 )) allocate ( U2r ( ( size ( U2 ) - 1 ) * ( res2 - 1 ) + 1 )) do s = 1 , size ( U1 ) - 1 o = ( s - 1 ) * ( res1 - 1 ) do r = 1 , res1 U1r ( o + r ) = U1 ( s ) + ( U1 ( s + 1 ) - U1 ( s )) * real ( r - 1 , rk ) / real ( res1 - 1 , rk ) end do end do do s = 1 , size ( U2 ) - 1 o = ( s - 1 ) * ( res2 - 1 ) do r = 1 , res2 U2r ( o + r ) = U2 ( s ) + ( U2 ( s + 1 ) - U2 ( s )) * real ( r - 1 , rk ) / real ( res2 - 1 , rk ) end do end do if ( size ( U1r ) /= N . or . size ( U2r ) /= N ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Refinement size mismatch.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the refinement process for consistency.' ) return end if ! total element count and node count ne_u = size ( U2 ) ne_v = size ( U1 ) ne_total = size ( U2 ) + size ( U1 ) np = ne_total * N ! Allocate global arrays allocate ( Xt_all ( np , 2 ), Xg_all ( np , dim ), elemConn ( ne_total , N )) ! build all parametric points offsetP = 0 line_nodes = N ! dir-1: u varies (v=U2(j), w=U3(k)) do concurrent ( j = 1 : size ( U2 )) Xt_all ( offsetP + ( j - 1 ) * line_nodes + 1 : offsetP + j * line_nodes , 1 ) = U1r Xt_all ( offsetP + ( j - 1 ) * line_nodes + 1 : offsetP + j * line_nodes , 2 ) = U2 ( j ) end do offsetP = offsetP + ne_u * line_nodes ! dir-2: v varies (u=U1(i), w=U3(k)) do concurrent ( i = 1 : size ( U1 )) Xt_all ( offsetP + ( i - 1 ) * line_nodes + 1 : offsetP + i * line_nodes , 1 ) = U1 ( i ) Xt_all ( offsetP + ( i - 1 ) * line_nodes + 1 : offsetP + i * line_nodes , 2 ) = U2r end do ! compute global points if ( this % is_rational ()) then Xg_all = compute_Xg ( Xt_all , this % knot1 , this % knot2 , this % degree , this % nc , [ np , 1 ], this % Xc , this % Wc ) else Xg_all = compute_Xg ( Xt_all , this % knot1 , this % knot2 , this % degree , this % nc , [ np , 1 ], this % Xc ) end if ! connectivity do concurrent ( l = 1 : ne_total , m = 1 : N ) elemConn ( l , m ) = ( l - 1 ) * N + m end do ! write VTK file call export_vtk_legacy ( filename = filename , points = Xg_all , elemConn = elemConn , vtkCellType = 4 , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_iges ( this , filename ) use forIGES , only : Gsection_t , Dentry_t , entity128_t , DElist_t , PElist_t ,& makeSsection , makeGsection , makeDPsections , writeIGESfile , wp class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename type ( Gsection_t ) :: G type ( Dentry_t ) :: D type ( entity128_t ) :: surf128 type ( DElist_t ) :: Dlist type ( PElist_t ) :: Plist character ( 80 ), allocatable :: Ssection (:), Gsection (:), Dsection (:), Psection (:), Ssec_out (:) real ( wp ) :: X ( 0 : this % degree ( 1 ), 0 : this % degree ( 2 )), Y ( 0 : this % degree ( 1 ), 0 : this % degree ( 2 )), Z ( 0 : this % degree ( 1 ), 0 : this % degree ( 2 )), W ( 0 : this % degree ( 1 ), 0 : this % degree ( 2 )), S ( - this % degree ( 1 ): 1 + this % degree ( 1 )), T ( - this % degree ( 2 ): 1 + this % degree ( 2 )) integer :: i , j , idx integer :: K1 , K2 , M1 , M2 , N1 , N2 , prop3 real ( wp ) :: U ( 0 : 1 ), V ( 0 : 1 ) if (. not . this % err % ok ) return ! Parameters consistent with the IGES definition K1 = this % degree ( 1 ) K2 = this % degree ( 2 ) M1 = this % degree ( 1 ) M2 = this % degree ( 2 ) ! Compute required N1 and N2 based on IGES standard N1 = 1 + K1 - M1 N2 = 1 + K2 - M2 ! Copy knots explicitly, matching IGES indexing exactly do i = - M1 , N1 + K1 S ( i ) = real ( this % knot1 ( i + M1 + 1 ), kind = wp ) end do do i = - M2 , N2 + K2 T ( i ) = real ( this % knot2 ( i + M2 + 1 ), kind = wp ) end do ! Correctly map control points and weights if ( this % is_rational ()) then do j = 0 , K2 do i = 0 , K1 idx = j * this % nc ( 1 ) + i + 1 X ( i , j ) = real ( this % Xc ( idx , 1 ), kind = wp ) Y ( i , j ) = real ( this % Xc ( idx , 2 ), kind = wp ) Z ( i , j ) = real ( this % Xc ( idx , 3 ), kind = wp ) W ( i , j ) = real ( this % Wc ( idx ), kind = wp ) end do end do prop3 = 1 ! Rational surface else do j = 0 , K2 do i = 0 , K1 idx = j * this % nc ( 1 ) + i + 1 X ( i , j ) = real ( this % Xc ( idx , 1 ), kind = wp ) Y ( i , j ) = real ( this % Xc ( idx , 2 ), kind = wp ) Z ( i , j ) = real ( this % Xc ( idx , 3 ), kind = wp ) W ( i , j ) = real ( 1.0_rk , kind = wp ) end do end do prop3 = 0 ! b-Spline surface end if U = real ([ minval ( this % knot1 ), maxval ( this % knot1 )], kind = wp ) V = real ([ minval ( this % knot2 ), maxval ( this % knot2 )], kind = wp ) ! Initialize IGES entity 128 (Rational B-spline Surface) call surf128 % init (& DEP = 1 ,& form = 0 ,& K1 = K1 ,& K2 = K2 ,& M1 = M1 ,& M2 = M2 ,& PROP1 = 0 ,& PROP2 = 0 ,& PROP3 = prop3 ,& PROP4 = 0 ,& PROP5 = 0 ,& S = S ,& T = T ,& W = W ,& X = X ,& Y = Y ,& Z = Z ,& U = U ,& V = V ) ! Directory entry call D % init ( entity_type = 128 , param_data = 1 , transformation_matrix = 0 , form_number = 0 ) ! Create entity and directory lists call Dlist % init () call Plist % init () call Dlist % append ( D ) call Plist % append ( surf128 ) ! Global section initialization call G % init ( filename = filename ) ! S-section description allocate ( Ssection ( 1 )) Ssection ( 1 ) = 'ForCAD' ! Create IGES sections call makeSsection ( Ssection , Ssec_out ) call makeGsection ( G , Gsection ) call makeDPsections ( Dlist , Plist , Dsection , Psection ) ! Write IGES file call writeIGESfile ( filename , Ssec_out , Gsection , Dsection , Psection ) ! Cleanup call Dlist % delete () call Plist % delete () end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc ()) end if else call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Control points are not set.' ,& location = 'modify_Xc' ,& suggestion = 'Call set(...) before modifying it.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot1 ) . and . allocated ( this % knot2 )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( nc = this % nc , Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else call this % err % set (& code = 105 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Weights are not set.' ,& location = 'modify_Wc' ,& suggestion = 'Pass Wc when calling set(...), before modifying weights.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if (. not . this % err % ok ) return if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if (. not . this % err % ok ) return if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this , dir ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: dir if (. not . this % err % ok ) return if ( present ( dir )) then if ( dir == 1 ) then if (. not . allocated ( this % knot1 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then if (. not . allocated ( this % knot2 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if else call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Invalid direction for computing number of control points.' ,& location = 'cmp_nc' ,& suggestion = 'Use dir=1 or dir=2 to specify the direction.' ) return end if else if (. not . allocated ( this % knot1 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if if (. not . allocated ( this % knot2 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_all ( this ) result ( nc ) class ( nurbs_surface ), intent ( in ) :: this integer :: nc ( 2 ) if (. not . this % err % ok ) return nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_dir ( this , dir ) result ( nc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if (. not . this % err % ok ) return if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res1 , res2 , Xt1 , Xt2 , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= size ( Xt1 )) then deallocate ( this % Xt1 ) end if end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= size ( Xt2 )) then deallocate ( this % Xt2 ) end if end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc , elem ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS if ( present ( elem )) then associate ( Wce => this % Wc ( elem )) call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , Wce , dTgc , Tgc , elem ) end associate else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc , dTgc , Tgc ) end if else ! B-Spline call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , dTgc , Tgc , elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res1 , res2 , Xt1 , Xt2 , d2Tgc , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= size ( Xt1 )) then deallocate ( this % Xt1 ) end if end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= size ( Xt2 )) then deallocate ( this % Xt2 ) end if end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res1 , res2 , Xt1 , Xt2 , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= size ( Xt1 )) then deallocate ( this % Xt1 ) end if end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= size ( Xt2 )) then deallocate ( this % Xt2 ) end if end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author:  Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r , B , Bs ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), contiguous , intent ( in ) :: Xth (:) integer , contiguous , intent ( in ) :: r (:) real ( rk ), allocatable , optional , intent ( out ) :: B (:,:) real ( rk ), allocatable , optional , intent ( out ) :: Bs (:,:) integer :: k , i , s , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:), H (:,:) integer :: nc_old ( 2 ), dim , ncp_old , n1_old real ( rk ), allocatable :: Wc_old (:) real ( rk ), allocatable :: A1 (:,:), A_re_loc (:,:) if (. not . this % err % ok ) return dim = size ( this % Xc , 2 ) if ( present ( B ) . or . present ( Bs )) then nc_old = this % nc ncp_old = size ( this % Xc , 1 ) if ( this % is_rational ()) then allocate ( Wc_old ( ncp_old )) Wc_old = this % Wc end if select case ( dir ) case ( 1 ) n1_old = nc_old ( 1 ) case ( 2 ) n1_old = nc_old ( 2 ) case default call this % err % set ( 100 , 1 , 'forcad_nurbs_surface' , 'Invalid direction for inserting knots.' , & 'insert_knots' , 'Use dir=1 or dir=2.' ) return end select allocate ( A1 ( n1_old , n1_old ), source = 0.0_rk ) do concurrent ( j = 1 : n1_old ) A1 ( j , j ) = 1.0_rk end do end if select case ( dir ) case ( 1 ) if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( j = 1 : size ( this % Xc , 1 )) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 ) ]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xcw ) H = reshape ( Xcw , [ ( n_new + 1 ) * this % nc ( 2 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do j = 1 , dim C (:, j ) = C (:, j ) / W (:) end do call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = C , Wc = W ) end associate deallocate ( H ) end do else Xc = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ) * dim ]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xc ) H = reshape ( Xc , [ ( n_new + 1 ) * this % nc ( 2 ), dim ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = H ) deallocate ( H ) end do end if case ( 2 ) if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( j = 1 : size ( this % Xc , 1 )) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 ) ]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xcw ) Xc3 = reshape ( Xcw , [ n_new + 1 , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , dim + 1 ], order = [ 2 , 1 , 3 ]) H = reshape ( Xc3 , [ this % nc ( 1 ) * ( n_new + 1 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do j = 1 , dim C (:, j ) = C (:, j ) / W (:) end do call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = C , Wc = W ) end associate deallocate ( H ) end do else Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * dim ]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xc ) Xc3 = reshape ( Xc , [ n_new + 1 , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , dim ], order = [ 2 , 1 , 3 ]) H = reshape ( Xc3 , [ this % nc ( 1 ) * ( n_new + 1 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = H ) deallocate ( H ) end do end if case default call this % err % set ( 100 , 1 , 'forcad_nurbs_surface' , 'Invalid direction for inserting knots.' , & 'insert_knots' , 'Use dir=1 or dir=2.' ) return end select if ( present ( B ) . or . present ( Bs )) then block real ( rk ), allocatable :: S_loc (:,:) integer :: nc1 , nc2 , n1_new , mS , nS , i1 , j1 , i2 , i2_old , i2_new , ii , c nc1 = this % nc ( 1 ) nc2 = this % nc ( 2 ) select case ( dir ) case ( 1 ) n1_new = this % nc ( 1 ) mS = n1_new * nc2 nS = nc_old ( 1 ) * nc2 allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i2 = 0 : nc2 - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : n1_new , A1 ( i1 , j1 ) /= 0.0_rk ) S_loc ( i2 * n1_new + i1 , i2 * nc_old ( 1 ) + j1 ) = A1 ( i1 , j1 ) * Wc_old ( i2 * nc_old ( 1 ) + j1 ) / this % Wc ( i2 * n1_new + i1 ) end do else do concurrent ( i2 = 0 : nc2 - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : n1_new , A1 ( i1 , j1 ) /= 0.0_rk ) S_loc ( i2 * n1_new + i1 , i2 * nc_old ( 1 ) + j1 ) = A1 ( i1 , j1 ) end do end if case ( 2 ) n1_new = this % nc ( 2 ) mS = n1_new * nc1 nS = nc_old ( 2 ) * nc1 allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i2_old = 1 : nc_old ( 2 ), i2_new = 1 : n1_new , ii = 0 : nc1 - 1 , A1 ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * nc1 , ii + 1 + ( i2_old - 1 ) * nc1 ) = A1 ( i2_new , i2_old ) * Wc_old ( ii + 1 + ( i2_old - 1 ) * nc1 ) / this % Wc ( ii + 1 + ( i2_new - 1 ) * nc1 ) end do else do concurrent ( i2_old = 1 : nc_old ( 2 ), i2_new = 1 : n1_new , ii = 0 : nc1 - 1 , A1 ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * nc1 , ii + 1 + ( i2_old - 1 ) * nc1 ) = A1 ( i2_new , i2_old ) end do end if end select if ( present ( B )) then allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = S_loc end do end if if ( present ( Bs )) then call move_alloc ( S_loc , Bs ) else deallocate ( S_loc ) end if end block end if end subroutine !=============================================================================== !=============================================================================== !> author:  Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t , B , Bs ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable , optional , intent ( out ) :: B (:,:) real ( rk ), allocatable , optional , intent ( out ) :: Bs (:,:) integer :: n1_new real ( rk ), allocatable :: knot_new (:) real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), H (:,:), Xc3 (:,:,:) real ( rk ), allocatable :: Tdir (:,:) integer :: nc_old ( 2 ), dim , ncp_old , mS , nS , c real ( rk ), allocatable :: Wc_old (:), S_loc (:,:) integer :: i1 , j1 , i2 , i2_old , i2_new , ii if (. not . this % err % ok ) return dim = size ( this % Xc , 2 ) if ( present ( B ) . or . present ( Bs )) then nc_old = this % nc ncp_old = size ( this % Xc , 1 ) if ( this % is_rational ()) then allocate ( Wc_old ( ncp_old )) Wc_old = this % Wc end if end if select case ( dir ) case ( 1 ) if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( i1 = 1 : size ( this % Xc , 1 )) Xcw ( i1 , 1 : dim ) = this % Xc ( i1 , 1 : dim ) * this % Wc ( i1 ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 ) ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , n1_new , knot_new , Xcw_new , Tdir ) H = reshape ( Xcw_new , [ n1_new * this % nc ( 2 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do i1 = 1 , dim C (:, i1 ) = C (:, i1 ) / W (:) end do call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = C , Wc = W ) end associate deallocate ( H , Xcw , Xcw_new ) else Xc = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , n1_new , knot_new , Xcw_new , Tdir ) H = reshape ( Xcw_new , [ n1_new * this % nc ( 2 ), dim ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = H ) deallocate ( H , Xc , Xcw_new ) end if case ( 2 ) if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( i1 = 1 : size ( this % Xc , 1 )) Xcw ( i1 , 1 : dim ) = this % Xc ( i1 , 1 : dim ) * this % Wc ( i1 ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 ) ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , n1_new , knot_new , Xcw_new , Tdir ) Xc3 = reshape ( Xcw_new , [ n1_new , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n1_new , dim + 1 ], order = [ 2 , 1 , 3 ]) H = reshape ( Xc3 , [ this % nc ( 1 ) * n1_new , dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do i1 = 1 , dim C (:, i1 ) = C (:, i1 ) / W (:) end do call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = C , Wc = W ) end associate deallocate ( H , Xcw , Xcw_new , Xc3 ) else Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , n1_new , knot_new , Xcw_new , Tdir ) Xc3 = reshape ( Xcw_new , [ n1_new , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n1_new , dim ], order = [ 2 , 1 , 3 ]) H = reshape ( Xc3 , [ this % nc ( 1 ) * n1_new , dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = H ) deallocate ( H , Xc , Xc3 , Xcw_new ) end if case default call this % err % set ( 100 , 1 , 'forcad_nurbs_surface' , 'Invalid direction for elevating degree.' , & 'elevate_degree' , 'Use dir=1 or dir=2.' ) return end select if ( present ( B ) . or . present ( Bs )) then select case ( dir ) case ( 1 ) mS = this % nc ( 1 ) * this % nc ( 2 ) nS = nc_old ( 1 ) * this % nc ( 2 ) allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i2 = 0 : this % nc ( 2 ) - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : this % nc ( 1 ), Tdir ( i1 , j1 ) /= 0.0_rk ) S_loc ( i2 * this % nc ( 1 ) + i1 , i2 * nc_old ( 1 ) + j1 ) = Tdir ( i1 , j1 ) * Wc_old ( i2 * nc_old ( 1 ) + j1 ) / this % Wc ( i2 * this % nc ( 1 ) + i1 ) end do else do concurrent ( i2 = 0 : this % nc ( 2 ) - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : this % nc ( 1 ), Tdir ( i1 , j1 ) /= 0.0_rk ) S_loc ( i2 * this % nc ( 1 ) + i1 , i2 * nc_old ( 1 ) + j1 ) = Tdir ( i1 , j1 ) end do end if case ( 2 ) mS = this % nc ( 2 ) * this % nc ( 1 ) nS = nc_old ( 2 ) * this % nc ( 1 ) allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i2_old = 1 : nc_old ( 2 ), i2_new = 1 : this % nc ( 2 ), ii = 0 : this % nc ( 1 ) - 1 , Tdir ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * this % nc ( 1 ), ii + 1 + ( i2_old - 1 ) * this % nc ( 1 )) = Tdir ( i2_new , i2_old ) * Wc_old ( ii + 1 + ( i2_old - 1 ) * this % nc ( 1 )) / this % Wc ( ii + 1 + ( i2_new - 1 ) * this % nc ( 1 )) end do else do concurrent ( i2_old = 1 : nc_old ( 2 ), i2_new = 1 : this % nc ( 2 ), ii = 0 : this % nc ( 1 ) - 1 , Tdir ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * this % nc ( 1 ), ii + 1 + ( i2_old - 1 ) * this % nc ( 1 )) = Tdir ( i2_new , i2_old ) end do end if end select if ( present ( Bs )) call move_alloc ( S_loc , Bs ) if ( present ( B )) then if (. not . present ( Bs )) then allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = S_loc end do deallocate ( S_loc ) else allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = Bs end do end if end if if ( allocated ( Wc_old )) deallocate ( Wc_old ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_surface ), intent ( in ) :: this logical :: r if (. not . this % err % ok ) return r = . false . if ( allocated ( this % Wc )) then ! if (any(this%Wc /= this%Wc(1))) then if ( any ( abs ( this % Wc - this % Wc ( 1 )) > 2.0_rk * epsilon ( 0.0_rk ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn_Xc_vis )) then if ( size ( this % elemConn_Xc_vis , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn_Xc_vis , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn_Xc_vis ) end if end if this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn_Xc_vis )) then if ( size ( this % elemConn_Xc_vis , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn_Xc_vis , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn_Xc_vis ) end if end if this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn )) then if ( size ( this % elemConn , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn ) end if end if this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:) if (. not . this % err % ok ) return if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) ! if (this%knot1(k+1) == Xth(i)) then if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( d + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * ( nc_new ), d + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * ( nc_new ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) ! if (this%knot1(k+1) == Xth(i)) then if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * d ], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc_new = reshape ( Xc_new ,[( this % nc ( 2 )) * ( nc_new ), d ], order = [ 1 , 2 ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) ! if (this%knot2(k+1) == Xth(i)) then if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * ( d + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc3 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , d + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), d + 1 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 1 ), 1 : d )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 1 ))) do j = 1 , ( nc_new ) * this % nc ( 1 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) ! if (this%knot2(k+1) == Xth(i)) then if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc3 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , d ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new ) end if end do end if else call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Invalid direction for removing knots.' ,& location = 'remove_knots' ,& suggestion = 'Use dir=1 or dir=2 to specify the direction.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_tetragon ( this , L , nc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: L (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return call this % set ( nc = nc , Xc = tetragon_Xc ( L , nc ), Wc = Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ),& this % degree ( 1 ), this % degree ( 2 ),& unique ( this % knot1 ), unique ( this % knot2 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i if (. not . this % err % ok ) return do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i if (. not . this % err % ok ) return do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: vec (:) integer :: i if (. not . this % err % ok ) return do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: vec (:) integer :: i if (. not . this % err % ok ) return do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg , vtkfile_Xth_in_Xg ) class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len =* ), intent ( in ), optional :: vtkfile_Xth_in_Xg #ifndef NOSHOW_PYVISTA block character ( len = 3000 ) :: pyvista_script if (. not . this % err % ok ) return pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"Xg = Xg.clean(tolerance=1e-12)\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=1,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    smooth_shading=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels([point_coords],[label],font_size=14,text_color='black',show_points=False,fill_shape=False,shape=None)\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag): actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag): actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):  actor_Xg.SetVisibility(flag)\" // achar ( 10 ) if ( present ( vtkfile_Xth_in_Xg )) then pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"Xth = pv.read('\" // trim ( vtkfile_Xth_in_Xg ) // \"')\" // achar ( 10 ) // & \"actor_Xth = p.add_mesh(\" // achar ( 10 ) // & \"    Xth,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    color='magenta',\" // achar ( 10 ) // & \"    line_width=2,\" // achar ( 10 ) // & \"    opacity=0.8\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"def Xth_toggle_vis(flag): actor_Xth.SetVisibility(flag)\" end if pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xcp_toggle_vis, value=True, color_on='red',    size=25, position=(0, y_pos - 1*25))\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xcw_toggle_vis, value=True, color_on='yellow', size=25, position=(0, y_pos - 2*25))\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xg_toggle_vis,  value=True, color_on='cyan',   size=25, position=(0, y_pos - 3*25))\" // achar ( 10 ) // & \"p.add_text('Xc (Points)',             position=(28, y_pos - 1*25), font_size=8, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text('Xc (Control geometry)',   position=(28, y_pos - 2*25), font_size=8, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text('Xg (Geometry)',           position=(28, y_pos - 3*25), font_size=8, color='black', font='times')\" if ( present ( vtkfile_Xth_in_Xg )) then pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xth_toggle_vis, value=True, color_on='magenta', size=25, position=(0, y_pos - 4*25))\" // achar ( 10 ) // & \"p.add_text('Xth (Parameter)', position=(28, y_pos - 4*25), font_size=8, color='black', font='times')\" end if pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text('https://github.com/gha3mi/forcad', position=(0.0, 0.0), font_size=7, color='blue', font='times')\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" // achar ( 10 ) // & \"p.deep_clean()\" // achar ( 10 ) // & \"del p\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end block #endif end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_ring ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i if (. not . this % err % ok ) return ! Define control points for ring allocate ( Xc ( 14 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 7 , 1 : 2 ) = Xc ( 1 : 7 , 1 : 2 ) * radius1 Xc ( 8 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 11 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 12 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 13 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 14 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 8 : 14 , 1 : 2 ) = Xc ( 8 : 14 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i if (. not . this % err % ok ) return ! Define control points for C-shape allocate ( Xc ( 10 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 8 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_ring ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i if (. not . this % err % ok ) return ! Define control points for half ring allocate ( Xc ( 10 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 8 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), intent ( out ), optional :: nearest_Xg ( size ( point_Xg )) real ( rk ), intent ( out ), optional :: nearest_Xt ( 2 ) integer , intent ( out ), optional :: id integer :: id_ , i real ( rk ), allocatable :: distances (:) if (. not . this % err % ok ) return allocate ( distances ( this % ng ( 1 ) * this % ng ( 2 ))) #if defined(__NVCOMPILER) do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) #else do concurrent ( i = 1 : this % ng ( 1 ) * this % ng ( 2 )) #endif distances ( i ) = norm2 ( this % Xg ( i ,:) - point_Xg ) end do ! replaced minloc due to NVFortran bug #if defined(__NVCOMPILER) id_ = 1 do i = 2 , size ( distances ) if ( distances ( i ) < distances ( id_ )) id_ = i end do #else id_ = minloc ( distances , dim = 1 ) #endif if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt ( 2 ) real ( rk ), intent ( out ), optional :: nearest_Xg ( size ( this % Xc , 2 )) real ( rk ) :: obj , obj_trial , grad ( 2 ), hess ( 2 , 2 ), dk ( 2 ) real ( rk ) :: alphak , alpha_max , alpha_i , tau , beta , eps real ( rk ) :: lower_bounds ( 2 ), upper_bounds ( 2 ), xt ( 2 ) real ( rk ), allocatable :: Tgc (:), dTgc (:,:), d2Tgc (:,:) real ( rk ) :: Xg ( size ( this % Xc , 2 )), xk ( 2 ), xkn ( 2 ) integer :: k , l , i logical :: convergenz type ( nurbs_surface ) :: copy_this if (. not . this % err % ok ) return alphak = 0.0_rk dk = 0.0_rk k = 0 eps = 1 0.0_rk * tiny ( 1.0_rk ) ! bounds lower_bounds = [ minval ( this % knot1 ), minval ( this % knot2 )] upper_bounds = [ maxval ( this % knot1 ), maxval ( this % knot2 )] ! initial guess (coarse search) copy_this = this call copy_this % create ( 10 , 10 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! clamp initial guess to bounds xk = max ( min ( xk , upper_bounds ), lower_bounds ) xkn = xk convergenz = . false . do while (. not . convergenz . and . k < maxit ) ! objective, gradient, hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc unused obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! small epsilon to avoid divide-by-zero grad ( 1 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 1 ), this % Xc )) grad ( 2 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 2 ), this % Xc )) hess ( 1 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 2 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ), 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 1 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 2 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ), 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 ! debug print '(i3,1x,2e20.10,1x,e20.10)' , k , xk , norm2 ( grad ) if ( norm2 ( grad ) <= tol . or . ( k > 0 . and . norm2 ( xk - xkn ) <= tol )) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else ! Newton step dk = - matmul ( inv ( hess ), grad ) ! Backtracking-Armijo with feasibility (box constraints) tau = 0.5_rk beta = 1.0e-4_rk ! compute maximum feasible step so xk + alpha*dk stays in [lower_bounds, upper_bounds] alpha_max = 1.0_rk do i = 1 , 2 if ( dk ( i ) > 0.0_rk ) then if ( upper_bounds ( i ) > xk ( i )) then alpha_i = ( upper_bounds ( i ) - xk ( i )) / dk ( i ) alpha_max = min ( alpha_max , max ( 0.0_rk , alpha_i )) else alpha_max = 0.0_rk end if else if ( dk ( i ) < 0.0_rk ) then if ( lower_bounds ( i ) < xk ( i )) then alpha_i = ( lower_bounds ( i ) - xk ( i )) / dk ( i ) alpha_max = min ( alpha_max , max ( 0.0_rk , alpha_i )) else alpha_max = 0.0_rk end if end if end do if ( alpha_max <= eps ) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) exit end if alphak = min ( 1.0_rk , alpha_max ) l = 0 do if ( alphak <= eps . or . l >= 50 ) exit xt = xk + alphak * dk ! feasible since alphak ≤ alpha_max obj_trial = norm2 ( this % cmp_Xg ( xt ) - point_Xg ) + 0.001_rk if ( obj_trial <= obj + alphak * beta * dot_product ( grad , dk )) exit alphak = min ( tau * alphak , alpha_max ) ! shrink but stay feasible l = l + 1 end do xkn = xk if ( alphak > eps ) then xk = xk + alphak * dk end if ! clamp updated iterate xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ansatz ( this , ie , ig , Tgc , dTgc_dXg , dA , ngauss ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: ie , ig real ( rk ), intent ( out ) :: dA real ( rk ), allocatable , intent ( out ) :: Tgc (:), dTgc_dXg (:,:) integer , intent ( in ), optional :: ngauss ( 2 ) real ( rk ), allocatable :: Xth (:,:), Xth_e (:,:), Xth_eT (:,:), Xc_eT (:,:), Xth1 (:), Xth2 (:), Xksi (:,:), Wksi (:) integer , allocatable :: elem_th (:,:), elem_c (:,:), elem_ce (:) type ( nurbs_surface ) :: th , th_e real ( rk ), allocatable :: dTtth_dXksi (:,:), Ttth (:), dTgc_dXt (:,:), Xt (:), dXt_dXksi (:,:), dXg_dXt (:,:) real ( rk ), allocatable :: dXg_dXksi (:,:) !! Jacobian matrix real ( rk ) :: det_dXg_dXksi !! Determinant of the Jacobian matrix real ( rk ) :: Xksii ( 2 ) if (. not . this % err % ok ) return if ( present ( ngauss )) then call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], ngauss - 1 , Xksi , Wksi ) else call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], this % degree , Xksi , Wksi ) end if Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) call ndgrid ( Xth1 , Xth2 , Xth ) call th % set ([ 0.0_rk , Xth1 , 1.0_rk ], [ 0.0_rk , Xth2 , 1.0_rk ], Xth ) elem_th = th % cmp_elem () elem_c = this % cmp_elem () Xth_e = Xth ( elem_th ( ie ,:),:) call th_e % set ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xth_e ) Xth_eT = transpose ( Xth_e ) elem_ce = elem_c ( ie ,:) Xc_eT = transpose ( this % Xc ( elem_ce ,:)) Xksii = Xksi ( ig ,:) call th_e % derivative ( Xksii , dTtth_dXksi , Ttth ) Xt = matmul ( Xth_eT , Ttth ) dXt_dXksi = matmul ( Xth_eT , dTtth_dXksi ) call this % derivative ( Xt , dTgc_dXt , Tgc , elem_ce ) dXg_dXt = matmul ( Xc_eT , dTgc_dXt ) dTgc_dXg = matmul ( dTgc_dXt , inv ( dXg_dXt )) dXg_dXksi = matmul ( dXg_dXt , dXt_dXksi ) det_dXg_dXksi = det ( dXg_dXksi ) dA = det_dXg_dXksi * Wksi ( ig ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_area ( this , area , ngauss ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( out ) :: area integer , intent ( in ), optional :: ngauss ( 2 ) real ( rk ), allocatable :: Tgc (:), dTgc_dXg (:,:) integer :: ie , ig integer :: ngauss_ ( 2 ) real ( rk ) :: dA , dA_ig if (. not . this % err % ok ) return if ( present ( ngauss )) then ngauss_ = ngauss else ngauss_ = this % degree + 1 end if area = 0.0_rk #if defined(__NVCOMPILER) do ie = 1 , size ( this % cmp_elem (), 1 ) #else do concurrent ( ie = 1 : size ( this % cmp_elem (), 1 )) reduce ( + : area ) #endif dA = 0.0_rk do ig = 1 , product ( ngauss_ ) call this % ansatz ( ie , ig , Tgc , dTgc_dXg , dA_ig , ngauss_ ) dA = dA + dA_ig end do area = area + dA end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Tgc_2d ( Xti , knot1 , knot2 , nc , degree , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xti (:) real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) integer , intent ( in ), contiguous :: degree (:), nc (:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Tgc ( nc ( 1 ) * nc ( 2 )) real ( rk ) :: tmp integer :: i Tgc = kron (& basis_bspline ( Xti ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xti ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) tmp = dot_product ( Tgc , Wc ) do concurrent ( i = 1 : nc ( 1 ) * nc ( 2 )) Tgc ( i ) = ( Tgc ( i ) * Wc ( i )) / tmp end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_2d ( Xt , knot1 , knot2 , degree , nc , ng , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: nc (:) integer , intent ( in ), contiguous , optional :: ng (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) real ( rk ) :: Xti ( size ( Xt , 2 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Xg ( ng_ , size ( Xc , 2 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( Xti ) #endif Xti = Xt ( i ,:) Xg ( i ,:) = matmul ( cmp_Tgc_2d ( Xti , knot1 , knot2 , nc , degree , Wc ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_2d_1point ( Xt , knot1 , knot2 , degree , nc , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Xg ( size ( Xc , 2 )) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_2d ( Xt , knot1 , knot2 , degree , nc , ng , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Xg ( ng_ , size ( Xc , 2 ))) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Xg ( i ,:) = matmul ( kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))),& Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_2d_1point ( Xt , knot1 , knot2 , degree , nc , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ) :: Xg ( size ( Xc , 2 )) Xg = matmul ( kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))),& Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ) :: dBi ( nc ( 1 ) * nc ( 2 ), 2 ), Bi ( nc ( 1 ) * nc ( 2 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( dTgc ( ng_ , nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( ng_ , nc ( 1 ) * nc ( 2 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , dB1 , dB2 , Bi , dBi ) #endif call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> If `elem` is not present: `Wc` refers to the full weight vector. !> If `elem` is present:     `Wc` refers to the element-local weight vector (`Wce`). pure subroutine compute_dTgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ), allocatable :: dBi (:,:), Bi (:) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( nc ( 1 ) * nc ( 2 ))) allocate ( dBi ( nc ( 1 ) * nc ( 2 ), 2 ), Bi ( nc ( 1 ) * nc ( 2 ))) Bi = kron ( B2 , B1 ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) else allocate ( dTgc ( size ( elem ), 2 ), Tgc ( size ( elem ))) allocate ( dBi ( size ( elem ), 2 ), Bi ( size ( elem ))) associate ( Biall => kron ( B2 , B1 )) Bi = Biall ( elem ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) end associate associate ( dB1all => kron ( B2 , dB1 ), dB2all => kron ( dB2 , B1 )) dBi (:, 1 ) = dB1all ( elem ) dBi (:, 2 ) = dB2all ( elem ) end associate dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( dTgc ( ng_ , nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( ng_ , nc ( 1 ) * nc ( 2 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , dB1 , dB2 ) #endif call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) Tgc ( i ,:) = kron ( B2 , B1 ) dTgc ( i ,:, 1 ) = kron ( B2 , dB1 ) dTgc ( i ,:, 2 ) = kron ( dB2 , B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dTgc1 ( nc ( 1 )), dTgc2 ( nc ( 2 )) real ( rk ) :: Tgc1 ( nc ( 1 )), Tgc2 ( nc ( 2 )) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dTgc1 , Tgc1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dTgc2 , Tgc2 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 )) Tgc = kron ( Tgc2 , Tgc1 ) dTgc (:, 1 ) = kron ( Tgc2 , dTgc1 ) dTgc (:, 2 ) = kron ( dTgc2 , Tgc1 ) else allocate ( dTgc ( size ( elem ), 2 )) associate ( B => kron ( Tgc2 , Tgc1 )) Tgc = B ( elem ) end associate associate ( dB1 => kron ( Tgc2 , dTgc1 ), dB2 => kron ( dTgc2 , Tgc1 )) dTgc (:, 1 ) = dB1 ( elem ) dTgc (:, 2 ) = dB2 ( elem ) end associate end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ), allocatable :: Tgci (:), dTgci (:) real ( rk ) :: d2Bi ( 2 * nc ( 1 ) * nc ( 2 ), 2 ), dBi ( nc ( 1 ) * nc ( 2 ), 2 ), Bi ( nc ( 1 ) * nc ( 2 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( d2Tgc ( ng_ , 2 * nc ( 1 ) * nc ( 2 ), 2 )) ! allocate(Bi(nc(1)*nc(2)), dBi(nc(1)*nc(2), 2), d2Bi(2*nc(1)*nc(2), 2)) allocate ( Tgci ( nc ( 1 ) * nc ( 2 )), dTgci ( nc ( 1 ) * nc ( 2 ))) allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 )), dTgc ( ng_ , nc ( 1 ) * nc ( 2 ), 2 )) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , dB1 , dB2 , Bi , dBi , d2Bi ) #endif call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) * Wc - 2.0_rk * dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) * Wc & - dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) * Wc - dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) * Wc - 2.0_rk * dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ), Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ), allocatable :: d2Bi (:,:), dBi (:,:), Bi (:) allocate ( Bi ( nc ( 1 ) * nc ( 2 )), dBi ( nc ( 1 ) * nc ( 2 ), 2 ), d2Bi ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 )), dTgc ( nc ( 1 ) * nc ( 2 ), 2 ), d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) * Wc - 2.0_rk * dTgc (:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) * Wc - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) * Wc - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) * Wc - 2.0_rk * dTgc (:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ), Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( d2Tgc ( ng_ , 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( dTgc ( ng_ , nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , dB1 , dB2 , d2B1 , d2B2 ) #endif call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Tgc ( i ,:) = kron ( B2 , B1 ) dTgc ( i ,:, 1 ) = kron ( B2 , dB1 ) dTgc ( i ,:, 2 ) = kron ( dB2 , B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) allocate ( d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Tgc = kron ( B2 , B1 ) dTgc (:, 1 ) = kron ( B2 , dB1 ) dTgc (:, 2 ) = kron ( dB2 , B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ) :: Tgci ( nc ( 1 ) * nc ( 2 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( Tgci ) #endif Tgci = kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: ng ( 2 ) real ( rk ), allocatable :: Tgc (:,:) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ))) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Tgc ( i ,:) = kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine lsq_fit_bspline ( this , Xt , Xdata , ndata ) use forcad_interface , only : solve class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:,:), Xdata (:,:) integer , intent ( in ) :: ndata ( 2 ) real ( rk ), allocatable :: T (:,:), Tt (:,:), TtT (:,:), TtX (:,:) integer :: i , n if (. not . this % err % ok ) return if ( this % nc ( 1 ) > ndata ( 1 )) then call this % err % set (& code = 106 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Invalid number of control points in the first direction.' ,& location = 'lsq_fit_bspline' ,& suggestion = 'Ensure that the number of control points does not exceed the number of data points.' ) return end if if ( this % nc ( 1 ) > ndata ( 1 )) then call this % err % set (& code = 106 ,& severity = 1 ,& category = 'forcad_nurbs_surface' ,& message = 'Invalid number of control points in the second direction.' ,& location = 'lsq_fit_bspline' ,& suggestion = 'Ensure that the number of control points does not exceed the number of data points.' ) return end if n = ndata ( 1 ) * ndata ( 2 ) allocate ( T ( n , this % nc ( 1 ) * this % nc ( 2 ))) #if defined(__NVCOMPILER) || (defined(__GFORTRAN__) && (__GNUC__ < 15 || (__GNUC__ == 15 && __GNUC_MINOR__ < 1))) do i = 1 , n #else do concurrent ( i = 1 : n ) #endif T ( i ,:) = kron (& basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 ))) end do Tt = transpose ( T ) TtT = matmul ( Tt , T ) TtX = matmul ( Tt , Xdata ) this % Xc = solve ( TtT , TtX ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine lsq_fit_nurbs ( this , Xt , Xdata , ndata , maxit , tol , lambda_xc , mu0 , reg_logw ) use forcad_interface , only : solve class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: Xdata (:,:) integer , intent ( in ) :: ndata ( 2 ) integer , intent ( in ), optional :: maxit real ( rk ), intent ( in ), optional :: tol real ( rk ), intent ( in ), optional :: lambda_xc real ( rk ), intent ( in ), optional :: mu0 real ( rk ), intent ( in ), optional :: reg_logw real ( rk ), allocatable :: Bmat (:,:), S (:), T (:,:), TtT (:,:), TtX (:,:), C (:,:), R (:,:) real ( rk ), allocatable :: Jacv (:,:), Jac_red (:,:), rvec (:), JtJ (:,:), Jtr (:,:), delta_u (:,:), delta_v (:), v (:) real ( rk ) :: tol_ , lamx_ , mu , regw , epss , cost_prev , cost_now integer :: dim_ , it , maxit_ , n , ncp , nvar , i , j , k if (. not . this % err % ok ) return dim_ = size ( Xdata , 2 ) n = ndata ( 1 ) * ndata ( 2 ) ncp = this % nc ( 1 ) * this % nc ( 2 ) nvar = ncp - 1 maxit_ = 30 tol_ = epsilon ( 0.0_rk ) lamx_ = 0.0_rk mu = sqrt ( epsilon ( 0.0_rk )) regw = sqrt ( epsilon ( 0.0_rk )) epss = 1 0.0_rk * epsilon ( 0.0_rk ) if ( present ( maxit )) maxit_ = maxit if ( present ( tol )) tol_ = tol if ( present ( lambda_xc )) lamx_ = lambda_xc if ( present ( mu0 )) mu = mu0 if ( present ( reg_logw )) regw = reg_logw if ( this % nc ( 1 ) > ndata ( 1 )) then call this % err % set ( code = 106 , severity = 1 , category = 'forcad_nurbs_surface' , & message = 'Too few data points in dir-1 for requested control points.' , & location = 'lsq_fit_nurbs' , & suggestion = 'Use nc(1) <= ndata(1).' ) return end if if ( this % nc ( 2 ) > ndata ( 2 )) then call this % err % set ( code = 106 , severity = 1 , category = 'forcad_nurbs_surface' , & message = 'Too few data points in dir-2 for requested control points.' , & location = 'lsq_fit_nurbs' , & suggestion = 'Use nc(2) <= ndata(2).' ) return end if if ( n <= 0 . or . ncp < 2 ) then call this % err % set ( code = 106 , severity = 1 , category = 'forcad_nurbs_surface' , & message = 'Invalid sizes for LSQ fitting.' , location = 'lsq_fit_nurbs' , & suggestion = 'Check ndata and nc.' ) return end if allocate ( Bmat ( n , ncp )) #if defined(__NVCOMPILER) || (defined(__GFORTRAN__) && (__GNUC__ < 15 || (__GNUC__ == 15 && __GNUC_MINOR__ < 1))) do i = 1 , n #else do concurrent ( i = 1 : n ) #endif Bmat ( i ,:) = kron ( & basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )), & basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) ) end do if ( allocated ( this % Wc ) . and . size ( this % Wc ) == ncp ) then ! keep as is else allocate ( this % Wc ( ncp ), source = 1.0_rk ) end if allocate ( v ( ncp )) v = log ( max ( this % Wc , epss )) this % Wc = exp ( v - sum ( v ) / real ( ncp , rk )) allocate ( S ( n ), T ( n , ncp ), C ( n , dim_ ), R ( n , dim_ )) allocate ( TtT ( ncp , ncp ), TtX ( ncp , dim_ )) allocate ( Jacv ( n * dim_ , ncp ), rvec ( n * dim_ )) allocate ( Jac_red ( n * dim_ , nvar )) allocate ( JtJ ( nvar , nvar ), Jtr ( nvar , 1 ), delta_u ( nvar , 1 ), delta_v ( ncp )) cost_prev = huge ( 1.0_rk ) do it = 1 , maxit_ #if defined(__NVCOMPILER) do i = 1 , n S ( i ) = dot_product ( Bmat ( i ,:), this % Wc ) if ( abs ( S ( i )) < epss ) S ( i ) = sign ( epss , S ( i )) T ( i ,:) = Bmat ( i ,:) * ( this % Wc / S ( i )) end do #else do concurrent ( i = 1 : n ) S ( i ) = dot_product ( Bmat ( i ,:), this % Wc ) if ( abs ( S ( i )) < epss ) S ( i ) = sign ( epss , S ( i )) T ( i ,:) = Bmat ( i ,:) * ( this % Wc / S ( i )) end do #endif TtT = matmul ( transpose ( T ), T ) if ( lamx_ > 0.0_rk ) then do concurrent ( j = 1 : ncp ) TtT ( j , j ) = TtT ( j , j ) + lamx_ end do end if TtX = matmul ( transpose ( T ), Xdata ) this % Xc = solve ( TtT , TtX ) C = matmul ( T , this % Xc ) R = C - Xdata cost_now = norm2 ( R ) / real ( n * dim_ , rk ) if ( cost_prev - cost_now <= tol_ * max ( 1.0_rk , cost_prev )) exit cost_prev = cost_now do concurrent ( k = 1 : dim_ , i = 1 : n ) rvec (( k - 1 ) * n + i ) = R ( i , k ) end do do concurrent ( j = 1 : ncp , k = 1 : dim_ , i = 1 : n ) Jacv (( k - 1 ) * n + i , j ) = ( this % Wc ( j ) * Bmat ( i , j ) / S ( i ) ) * ( this % Xc ( j , k ) - C ( i , k ) ) end do do concurrent ( j = 1 : nvar ) Jac_red (:, j ) = Jacv (:, j ) - Jacv (:, ncp ) end do JtJ = matmul ( transpose ( Jac_red ), Jac_red ) Jtr (:, 1 ) = matmul ( transpose ( Jac_red ), rvec ) do concurrent ( j = 1 : nvar ) JtJ ( j , j ) = JtJ ( j , j ) + mu + regw end do delta_u = - solve ( JtJ , Jtr ) delta_v ( 1 : nvar ) = delta_u (:, 1 ) delta_v ( ncp ) = - sum ( delta_u (:, 1 )) v = v + delta_v this % Wc = exp ( v - sum ( v ) / real ( ncp , rk )) mu = max ( epsilon ( 0.0_rk ), 0.3_rk * mu ) end do end subroutine !=============================================================================== end module forcad_nurbs_surface","tags":"","url":"sourcefile/forcad_nurbs_surface.f90.html"},{"title":"example_ppm3.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm3.f90~~EfferentGraph sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm3 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap , wp use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 2 ]) call shape % translate_Xc ([ 0.01_rk , 0.01_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , real ( 0.0_rk , kind = wp ), real ( 2.2_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 2 ]) call shape % translate_Xc ([ 0.51_rk , 0.01_rk , 0.0_rk ]) call shape % modify_Xc ( 0.24_rk , 2 , 2 ) call shape % modify_Xc ( 0.26_rk , 5 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 3 ]) call shape % translate_Xc ([ 0.01_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.26_rk , 3 , 1 ) call shape % modify_Xc ( 0.24_rk , 4 , 1 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 3 ]) call shape % translate_Xc ([ 0.51_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.7_rk , 1 , 2 ) call shape % modify_Xc ( 0.7_rk , 3 , 2 ) call shape % modify_Xc ( 0.8_rk , 7 , 2 ) call shape % modify_Xc ( 0.8_rk , 9 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm3' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","url":"sourcefile/example_ppm3.f90.html"},{"title":"forcad_nurbs_curve.F90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_curve.f90~~EfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_curve.f90~~AfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. module forcad_nurbs_curve use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , elemConn_C0 , ndgrid , compute_multiplicity , compute_knot_vector , basis_bspline_der ,& insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , dyad , gauss_leg , export_vtk_legacy , basis_bspline_2der use fordebug , only : debug implicit none private public nurbs_curve , compute_Tgc , compute_dTgc !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_curve real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc, dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng, dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc]) real ( rk ), allocatable , private :: Xt (:) !! Evaluation points (1D array: [ng]) real ( rk ), allocatable , private :: knot (:) !! Knot vector (1D array) integer , private :: degree !! Degree (order) of the curve integer , private :: nc !! Number of control points integer , private :: ng !! Number of geometry points integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity type ( debug ) :: err !! 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined contains procedure , private :: set1 !!> Set knot vector, control points and weights for the NURBS curve object procedure , private :: set1a procedure , private :: set2 !!> Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights procedure , private :: set3 !!> Set Bezier or Rational Bezier curve using control points and weights procedure , private :: set4 !!> Set NURBS curve using degree, number of control points, control points and weights generic :: set => set1 , set1a , set2 , set3 , set4 !!> Set NURBS curve procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: cmp_degree !!> Compute degree of the NURBS curve procedure :: get_degree !!> Get degree of the NURBS curve procedure :: finalize !!> Finalize the NURBS curve object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem_Xth !!> Generate connectivity for parameter points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: export_Xth !!> Export parameter space to VTK file procedure :: export_iges !!> Export the NURBS curve to an IGES file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knots procedure :: get_continuity !!> Compute and return the continuity of the curve procedure :: cmp_nc !!> Compute number of required control points procedure :: get_nc !!> Get number of control points procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the curve procedure , private :: basis_vector !!> Compute the basis functions of the NURBS curve procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS curve generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS curve procedure , private :: derivative_vector !!> Compute the derivative of the NURBS curve procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS curve generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS curve procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS curve procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS curve generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS curve procedure :: is_rational !!> Check if the NURBS curve is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS curve (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS curve (Minimization - Newtons method) procedure :: ansatz !!> Compute the shape functions, derivative of shape functions and dL procedure :: cmp_length !!> Compute the length of the NURBS curve procedure :: lsq_fit_bspline !!> Fit B-spline curve to structured data points using least squares procedure :: lsq_fit_nurbs !!> Fit NURBS curve to structured data points using least squares ! Shapes procedure :: set_circle !!> Set a circle procedure :: set_half_circle !!> Set a half circle procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg module procedure compute_Xg_nurbs_1d module procedure compute_Xg_bspline_1d module procedure compute_Xg_nurbs_1d_1point module procedure compute_Xg_bspline_1d_1point end interface interface compute_Tgc module procedure compute_Tgc_nurbs_1d_vector module procedure compute_Tgc_bspline_1d_vector module procedure compute_Tgc_nurbs_1d_scalar module procedure compute_Tgc_bspline_1d_scalar end interface interface compute_dTgc module procedure compute_dTgc_nurbs_1d_vector module procedure compute_dTgc_bspline_1d_vector module procedure compute_dTgc_nurbs_1d_scalar module procedure compute_dTgc_bspline_1d_scalar end interface interface compute_d2Tgc module procedure compute_d2Tgc_nurbs_1d_vector module procedure compute_d2Tgc_bspline_1d_vector module procedure compute_d2Tgc_nurbs_1d_scalar module procedure compute_d2Tgc_bspline_1d_scalar end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vector, control points and weights for the NURBS curve object. pure subroutine set1 ( this , knot , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % knot )) then if ( size ( this % knot ) /= size ( knot )) deallocate ( this % knot ) end if if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % knot = knot call this % cmp_degree () this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set1' ,& suggestion = 'Provide Wc with size(Wc) == size(Xc,1).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vector, control points and weights for the NURBS curve object. pure subroutine set1a ( this , knot , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Xc (:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % knot )) then if ( size ( this % knot ) /= size ( knot )) deallocate ( this % knot ) end if if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc ) . or . size ( this % Xc , 2 ) /= 3 ) then deallocate ( this % Xc ) allocate ( this % Xc ( size ( Xc ), 3 ), source = 0.0_rk ) end if else allocate ( this % Xc ( size ( Xc ), 3 ), source = 0.0_rk ) end if this % knot = knot call this % cmp_degree () this % Xc (:, 1 ) = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set1a' ,& suggestion = 'Provide Wc with size(Wc) == size(Xc,1).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. pure subroutine set2 ( this , Xth_dir , degree , continuity , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), intent ( in ), contiguous , optional :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % knot )) deallocate ( this % knot ) this % knot = compute_knot_vector ( Xth_dir , degree , continuity ) this % degree = degree call this % cmp_nc () if ( present ( Xc )) then if ( size ( Xc , 1 ) /= this % nc ) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_curve' , & message = 'Control points size mismatch in set2' ,& location = 'set2' , & suggestion = 'size(Xc,1) must equal computed nc.' ) return end if end if if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_curve' , & message = 'Weights size mismatch in set2' ,& location = 'set2' , & suggestion = 'size(Wc) must equal computed nc.' ) return end if end if if ( present ( Xc )) then if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc end if if ( present ( Wc )) then if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier curve using control points and weights. pure subroutine set3 ( this , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( allocated ( this % knot )) then if ( size ( this % knot ) /= 2 * this % nc ) then deallocate ( this % knot ) allocate ( this % knot ( 2 * this % nc )) end if else allocate ( this % knot ( 2 * this % nc )) end if this % knot ( 1 : this % nc ) = 0.0_rk this % knot ( this % nc + 1 : 2 * this % nc ) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set3' ,& suggestion = 'Provide Wc with size(Wc) == size(Xc,1).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set4 ( this , degree , nc , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) integer :: m , i if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc this % nc = nc this % degree = degree ! Size of knot vectors m = nc + degree + 1 if ( allocated ( this % knot )) then if ( size ( this % knot ) /= m ) then deallocate ( this % knot ) allocate ( this % knot ( m )) end if else allocate ( this % knot ( m )) end if this % knot ( 1 : degree + 1 ) = 0.0_rk this % knot ( degree + 2 : m - degree - 1 ) = [( real ( i , rk ) / ( m - 2 * degree - 1 ), i = 1 , m - 2 * degree - 2 )] this % knot ( m - degree : m ) = 1.0_rk if ( present ( Wc )) then if ( size ( Wc ) /= nc ) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set4' ,& suggestion = 'Provide Wc with size(Wc) == nc.' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res , Xt ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) integer :: i if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Control points are not set.' ,& location = 'create' ,& suggestion = 'Call set(...) first before create().' ) return end if if (. not . allocated ( this % knot )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Knot vector is not set.' ,& location = 'create' ,& suggestion = 'Call set(...) first before create().' ) return end if ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) then if ( size ( this % Xt ) /= size ( Xt )) deallocate ( this % Xt ) end if this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) then if ( size ( this % Xt ) /= res ) then deallocate ( this % Xt ) allocate ( this % Xt ( res )) end if else allocate ( this % Xt ( res )) end if this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt ) ! Allocate memory for geometry points if ( allocated ( this % Xg )) then if ( size ( this % Xg , 1 ) /= this % ng . or . size ( this % Xg , 2 ) /= size ( this % Xc , 2 )) deallocate ( this % Xg ) end if if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable :: Xg (:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS curve is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS curve is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this ) result ( Xt ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xt (:) if (. not . this % err % ok ) return if ( allocated ( this % Xt )) then Xt = this % Xt else error stop 'Parameter values are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_curve ), intent ( in ) :: this integer :: ng if (. not . this % err % ok ) return ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this ) class ( nurbs_curve ), intent ( inout ) :: this integer , allocatable :: m (:) if (. not . this % err % ok ) return m = this % get_multiplicity () this % degree = m ( 1 ) - 1 end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree ( this ) result ( degree ) class ( nurbs_curve ), intent ( in ) :: this integer :: degree if (. not . this % err % ok ) return degree = this % degree end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: knot (:) if (. not . this % err % ok ) return if ( allocated ( this % knot )) then knot = this % knot else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , i ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: i real ( rk ) :: knot if (. not . this % err % ok ) return if ( allocated ( this % knot )) then if ( i < 1 . or . i > size ( this % knot )) then error stop 'Invalid index for knot vector.' else knot = this % knot ( i ) end if else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_curve ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( this % nc , p ) else elemConn = elemConn_C0 ( this % nc , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( this % ng , p ) else elemConn = elemConn_C0 ( this % ng , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xth ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( size ( unique ( this % knot )), p ) else elemConn = elemConn_C0 ( size ( unique ( this % knot )), 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename , point_data , field_names , encoding ) class ( nurbs_curve ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Control points are not set.' ,& location = 'export_Xc' ,& suggestion = 'Call set(...) first before exporting.' ) return end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if call export_vtk_legacy ( filename = filename , points = this % Xc , elemConn = elemConn , vtkCellType = 3 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename , point_data , field_names , encoding ) class ( nurbs_curve ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xg )) then call this % err % set (& code = 104 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Geometry points are not set.' ,& location = 'export_Xg' ,& suggestion = 'Generate Xg by calling create(...) before exporting.' ) return end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if call export_vtk_legacy ( filename = filename , points = this % Xg , elemConn = elemConn , vtkCellType = 3 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth ( this , filename , point_data , field_names , encoding ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Xth (:,:), Xth1 (:), Xth2 (:), Xth3 (:) if (. not . this % err % ok ) return elemConn = this % cmp_elem_Xth () Xth1 = unique ( this % knot ) Xth2 = [ 0.0_rk ] Xth3 = [ 0.0_rk ] call ndgrid ( Xth1 , Xth2 , Xth3 , Xth ) call export_vtk_legacy ( filename = filename , points = Xth , elemConn = elemConn , vtkCellType = 3 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_iges ( this , filename ) use forIGES , only : Gsection_t , Dentry_t , entity126_t , DElist_t , PElist_t ,& makeSsection , makeGsection , makeDPsections , writeIGESfile , wp class ( nurbs_curve ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename type ( Gsection_t ) :: G type ( Dentry_t ) :: D type ( entity126_t ) :: curve126 type ( DElist_t ) :: Dlist type ( PElist_t ) :: Plist character ( 80 ), allocatable :: Ssection (:), Gsection (:), Dsection (:), Psection (:), Ssec_out (:) integer :: i , K , M , N , prop3 real ( wp ) :: T ( - this % degree : 1 + this % degree ), X ( 0 : this % degree ), Y ( 0 : this % degree ), Z ( 0 : this % degree ), W ( 0 : this % degree ), V ( 0 : 1 ) real ( wp ) :: XNORM , YNORM , ZNORM if (. not . this % err % ok ) return ! Parameters for IGES knot vector K = this % degree M = this % degree N = 1 + K - M ! Copy your knot vector to IGES indexing do i = - M , N + K T ( i ) = real ( this % knot ( i + M + 1 ), kind = wp ) end do ! Copy control points if ( this % is_rational ()) then do i = 0 , K X ( i ) = real ( this % Xc ( i + 1 , 1 ), kind = wp ) Y ( i ) = real ( this % Xc ( i + 1 , 2 ), kind = wp ) Z ( i ) = real ( this % Xc ( i + 1 , 3 ), kind = wp ) W ( i ) = real ( this % Wc ( i + 1 ), kind = wp ) end do prop3 = 1 else do i = 0 , K X ( i ) = real ( this % Xc ( i + 1 , 1 ), kind = wp ) Y ( i ) = real ( this % Xc ( i + 1 , 2 ), kind = wp ) Z ( i ) = real ( this % Xc ( i + 1 , 3 ), kind = wp ) W ( i ) = real ( 1.0_rk , kind = wp ) end do prop3 = 0 end if XNORM = real ( 0.0_rk , kind = wp ) YNORM = real ( 0.0_rk , kind = wp ) ZNORM = real ( 0.0_rk , kind = wp ) V = real ([ minval ( this % knot ), maxval ( this % knot )], kind = wp ) ! Initialize IGES entity126 (Rational B-spline Curve) call curve126 % init (& DEP = 1 ,& form = 0 ,& K = K ,& M = M ,& PROP1 = 0 ,& PROP2 = 0 ,& PROP3 = prop3 ,& PROP4 = 0 ,& T = T ,& W = W ,& X = X ,& Y = Y ,& Z = Z ,& V = V ,& XNORM = XNORM ,& YNORM = YNORM ,& ZNORM = ZNORM ) ! Directory entry call D % init ( entity_type = 126 , param_data = 1 , transformation_matrix = 0 , form_number = 0 ) ! Entity and directory lists call Dlist % init () call Plist % init () call Dlist % append ( D ) call Plist % append ( curve126 ) ! Global section call G % init ( filename = filename ) ! S-section description allocate ( Ssection ( 1 )) Ssection ( 1 ) = 'ForCAD' ! Create IGES sections call makeSsection ( Ssection , Ssec_out ) call makeGsection ( G , Gsection ) call makeDPsections ( Dlist , Plist , Dsection , Psection ) ! Write IGES file call writeIGESfile ( filename , Ssec_out , Gsection , Dsection , Psection ) ! Cleanup call Dlist % delete () call Plist % delete () end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot = this % get_knot (), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot = this % get_knot (), Xc = this % get_Xc ()) end if else call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Control points are not set.' ,& location = 'modify_Xc' ,& suggestion = 'Call set(...) before modifying it.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot )) then call this % set ( knot = this % get_knot (), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else call this % err % set (& code = 105 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Weights are not set.' ,& location = 'modify_Wc' ,& suggestion = 'Pass Wc when calling set(...), before modifying weights.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this ) result ( m ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: m (:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this ) result ( c ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: c (:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else c = this % degree - compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this ) class ( nurbs_curve ), intent ( inout ) :: this if (. not . this % err % ok ) return this % nc = sum ( compute_multiplicity ( this % knot )) - this % degree - 1 end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( nurbs_curve ), intent ( in ) :: this integer :: nc if (. not . this % err % ok ) return nc = this % nc end function !=============================================================================== !=============================================================================== !> author:  Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , Xth , r , B , Bs ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), contiguous , intent ( in ) :: Xth (:) integer , contiguous , intent ( in ) :: r (:) real ( rk ), allocatable , optional , intent ( out ) :: B (:,:) real ( rk ), allocatable , optional , intent ( out ) :: Bs (:,:) integer :: i , j , k , s , n_new , dim , n_old , mS , nS , c real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), knot_new (:), H (:,:) real ( rk ), allocatable :: Wc_old (:), S_loc (:,:), A1 (:,:), A_re_loc (:,:) if (. not . this % err % ok ) return dim = size ( this % Xc , 2 ) if ( present ( B ) . or . present ( Bs )) then n_old = size ( this % Xc , 1 ) if ( this % is_rational ()) then allocate ( Wc_old ( n_old )); Wc_old = this % Wc end if allocate ( A1 ( n_old , n_old ), source = 0.0_rk ) do concurrent ( j = 1 : n_old ) A1 ( j , j ) = 1.0_rk end do end if if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( j = 1 : size ( this % Xc , 1 )) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) do i = 1 , size ( Xth ) k = findspan ( size ( this % Xc , 1 ) - 1 , this % degree , Xth ( i ), this % knot ) if ( abs ( this % knot ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree , this % knot , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree , this % knot , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xcw ) H = reshape ( Xcw , [ n_new + 1 , dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do j = 1 , dim C (:, j ) = C (:, j ) / W (:) end do call this % set ( knot = knot_new , Xc = C , Wc = W ) end associate deallocate ( H ) end do else Xc = this % Xc do i = 1 , size ( Xth ) k = findspan ( size ( Xc , 1 ) - 1 , this % degree , Xth ( i ), this % knot ) if ( abs ( this % knot ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree , this % knot , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree , this % knot , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xc ) call this % set ( knot = knot_new , Xc = Xc ) end do end if if ( present ( B ) . or . present ( Bs )) then mS = size ( this % Xc , 1 ) nS = size ( A1 , 2 ) allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do i = 1 , mS do j = 1 , nS if ( A1 ( i , j ) /= 0.0_rk ) S_loc ( i , j ) = A1 ( i , j ) * Wc_old ( j ) / this % Wc ( i ) end do end do else S_loc = A1 end if if ( present ( B )) then allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = S_loc end do end if if ( present ( Bs )) then call move_alloc ( S_loc , Bs ) else deallocate ( S_loc ) end if if ( allocated ( Wc_old )) deallocate ( Wc_old ) end if end subroutine !=============================================================================== !=============================================================================== !> author:  Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , t , B , Bs ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: t real ( rk ), allocatable , optional , intent ( out ) :: B (:,:) real ( rk ), allocatable , optional , intent ( out ) :: Bs (:,:) integer :: dim , mS , nS , c , i , nc_new real ( rk ), allocatable :: knot_new (:) real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:) real ( rk ), allocatable :: Tdir (:,:), Wc_old (:), S_loc (:,:) if (. not . this % err % ok ) return dim = size ( this % Xc , 2 ) if ( present ( B ) . or . present ( Bs )) then if ( this % is_rational ()) then allocate ( Wc_old ( size ( this % Xc , 1 ))) Wc_old = this % Wc end if end if if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( i = 1 : size ( this % Xc , 1 )) Xcw ( i , 1 : dim ) = this % Xc ( i , 1 : dim ) * this % Wc ( i ) end do Xcw (:, dim + 1 ) = this % Wc (:) call elevate_degree_A_5_9 ( t , this % knot , this % degree , Xcw , nc_new , knot_new , Xcw_new , Tdir ) associate ( C => Xcw_new (:, 1 : dim ), W => Xcw_new (:, dim + 1 )) do i = 1 , dim C (:, i ) = C (:, i ) / W (:) end do call this % set ( knot = knot_new , Xc = C , Wc = W ) end associate deallocate ( Xcw , Xcw_new ) else Xc = this % Xc call elevate_degree_A_5_9 ( t , this % knot , this % degree , Xc , nc_new , knot_new , Xcw_new , Tdir ) call this % set ( knot = knot_new , Xc = Xcw_new ) deallocate ( Xc , Xcw_new ) end if if ( present ( B ) . or . present ( Bs )) then mS = size ( this % Xc , 1 ) nS = size ( Tdir , 2 ) allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do i = 1 , mS S_loc ( i ,:) = Tdir ( i ,:) * ( Wc_old (:) / this % Wc ( i ) ) end do else S_loc = Tdir end if if ( present ( B )) then allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = S_loc end do end if if ( present ( Bs )) then call move_alloc ( S_loc , Bs ) else deallocate ( S_loc ) end if if ( allocated ( Wc_old )) deallocate ( Wc_old ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res , Xt , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) then if ( size ( Xt , 1 ) /= size ( this % Xt , 1 )) deallocate ( this % Xt ) end if this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) then if ( size ( this % Xt , 1 ) /= res ) then deallocate ( this % Xt ) allocate ( this % Xt ( res )) end if else allocate ( this % Xt ( res )) end if this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc , elem ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS if ( present ( elem )) then associate ( Wce => this % Wc ( elem )) call compute_dTgc ( Xt , this % knot , this % degree , this % nc , Wce , dTgc , Tgc , elem ) end associate else call compute_dTgc ( Xt , this % knot , this % degree , this % nc , this % Wc , dTgc , Tgc , elem ) end if else ! B-Spline call compute_dTgc ( Xt , this % knot , this % degree , this % nc , dTgc , Tgc , elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) then if ( size ( Xt , 1 ) /= size ( this % Xt , 1 )) deallocate ( this % Xt ) end if this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) then if ( size ( this % Xt , 1 ) /= res ) then deallocate ( this % Xt ) allocate ( this % Xt ( res )) end if else allocate ( this % Xt ( res )) end if this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) then if ( size ( Xt , 1 ) /= size ( this % Xt , 1 )) deallocate ( this % Xt ) end if this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) then if ( size ( this % Xt , 1 ) /= res ) then deallocate ( this % Xt ) allocate ( this % Xt ( res )) end if else allocate ( this % Xt ( res )) end if this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot , this % degree , this % nc , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_curve ), intent ( in ) :: this logical :: r if (. not . this % err % ok ) return r = . false . if ( allocated ( this % Wc )) then ! if (any(this%Wc /= this%Wc(1))) then if ( any ( abs ( this % Wc - this % Wc ( 1 )) > 2.0_rk * epsilon ( 0.0_rk ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn_Xc_vis )) then if ( size ( this % elemConn_Xc_vis , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn_Xc_vis , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn_Xc_vis ) end if end if this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn_Xg_vis )) then if ( size ( this % elemConn_Xg_vis , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn_Xg_vis , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn_Xg_vis ) end if end if this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn )) then if ( size ( this % elemConn , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn ) end if end if this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , Xth , r ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , nc_new , t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) ! if (this%knot(k+1) == Xth(i)) then if ( abs ( this % knot ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) call remove_knots_A_5_8 (& this % degree ,& this % knot ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) allocate ( Xc_new ( nc_new , d )) allocate ( Wc_new ( nc_new )) do j = 1 , nc_new Xc_new ( j ,:) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) if ( allocated ( Xcw_new )) deallocate ( Xcw_new ) if ( allocated ( Xc_new )) deallocate ( Xc_new ) if ( allocated ( Wc_new )) deallocate ( Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) ! if (this%knot(k+1) == Xth(i)) then if ( abs ( this % knot ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 call remove_knots_A_5_8 (& this % degree ,& this % knot ,& this % Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( t == 0 ) then ! no change else call this % set ( knot = knot_new , Xc = Xc_new ) end if end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_circle ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i if (. not . this % err % ok ) return ! Define control points for circle allocate ( Xc ( 7 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i if (. not . this % err % ok ) return ! Define control points for C-shape allocate ( Xc ( 5 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return call elemConn_Cn ( this % nc , this % degree , unique ( this % knot ), this % get_multiplicity (),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i if (. not . this % err % ok ) return do i = 1 , this % nc this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i if (. not . this % err % ok ) return do i = 1 , this % ng this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: vec (:) integer :: i if (. not . this % err % ok ) return do i = 1 , this % nc this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: vec (:) integer :: i if (. not . this % err % ok ) return do i = 1 , this % ng this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg ) class ( nurbs_curve ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg if (. not . this % err % ok ) return #ifndef NOSHOW_PYVISTA block character ( len = 3000 ) :: pyvista_script pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"Xg = Xg.clean(tolerance=1e-12)\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=7,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    smooth_shading=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels(\" // achar ( 10 ) // & \"        [point_coords],\" // achar ( 10 ) // & \"        [label],\" // achar ( 10 ) // & \"        font_size=14,\" // achar ( 10 ) // & \"        text_color='black',\" // achar ( 10 ) // & \"        show_points=False,\" // achar ( 10 ) // & \"        fill_shape=False,\" // achar ( 10 ) // & \"        shape=None,\" // achar ( 10 ) // & \"    )\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xg.SetVisibility(flag)\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcp_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='red',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 1 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcw_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='yellow',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 2 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xg_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='cyan',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 3 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Points)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 1 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Control geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 2 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xg (Geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 3 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'https://github.com/gha3mi/forcad',\" // achar ( 10 ) // & \"    position=(0.0, 0.0),\" // achar ( 10 ) // & \"    font_size=7,\" // achar ( 10 ) // & \"    color='blue',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" // achar ( 10 ) // & \"p.deep_clean()\" // achar ( 10 ) // & \"del p\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end block #endif end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_circle ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i if (. not . this % err % ok ) return ! Define control points for half circle allocate ( Xc ( 5 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), intent ( out ), optional :: nearest_Xg ( size ( point_Xg )) real ( rk ), intent ( out ), optional :: nearest_Xt integer , intent ( out ), optional :: id integer :: id_ , i real ( rk ), allocatable :: distances (:) if (. not . this % err % ok ) return allocate ( distances ( this % ng )) #if defined(__NVCOMPILER) do i = 1 , this % ng #else do concurrent ( i = 1 : this % ng ) #endif distances ( i ) = norm2 ( this % Xg ( i ,:) - point_Xg ) end do ! replaced minloc due to NVFortran bug #if defined(__NVCOMPILER) id_ = 1 do i = 2 , size ( distances ) if ( distances ( i ) < distances ( id_ )) id_ = i end do #else id_ = minloc ( distances , dim = 1 ) #endif if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt real ( rk ), intent ( out ), optional :: nearest_Xg ( size ( this % Xc , 2 )) real ( rk ) :: xk , xkn , obj , obj_trial , grad , hess , dk , alphak real ( rk ) :: tau , beta , eps , lower_bounds , upper_bounds , alpha_max , alpha_i , xt real ( rk ) :: Xg ( size ( this % Xc , 2 )) real ( rk ), allocatable :: Tgc (:), dTgc (:), d2Tgc (:) integer :: k , l logical :: convergenz type ( nurbs_curve ) :: copy_this if (. not . this % err % ok ) return dk = 0.0_rk k = 0 eps = 1 0.0_rk * tiny ( 1.0_rk ) ! bounds lower_bounds = minval ( this % knot ) upper_bounds = maxval ( this % knot ) ! initial guess (coarse search) copy_this = this call copy_this % create ( 10 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! clamp initial guess to bounds xk = max ( min ( xk , upper_bounds ), lower_bounds ) xkn = xk convergenz = . false . do while (. not . convergenz . and . k < maxit ) ! objective, gradient, hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc unused obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! small epsilon to avoid divide-by-zero grad = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc , this % Xc )) hess = dot_product ( matmul ( dTgc , this % Xc ) - ( Xg - point_Xg ) / obj * grad , matmul ( dTgc , this % Xc )) / obj & + dot_product (( Xg - point_Xg ) / obj , matmul ( d2Tgc , this % Xc )) ! debug print '(i3,1x,e20.10,1x,e20.10)' , k , xk , abs ( grad ) if ( abs ( grad ) <= tol . or . ( k > 0 . and . abs ( xk - xkn ) <= tol )) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else ! Newton step dk = - grad / hess ! Backtracking-Armijo with feasibility tau = 0.5_rk beta = 1.0e-4_rk ! maximum feasible step so xk + alpha*dk stays within [lower_bounds, upper_bounds] if ( dk > 0.0_rk ) then if ( upper_bounds > xk ) then alpha_i = ( upper_bounds - xk ) / dk alpha_max = max ( 0.0_rk , alpha_i ) else alpha_max = 0.0_rk end if else if ( dk < 0.0_rk ) then if ( lower_bounds < xk ) then alpha_i = ( lower_bounds - xk ) / dk alpha_max = max ( 0.0_rk , alpha_i ) else alpha_max = 0.0_rk end if else alpha_max = 0.0_rk end if if ( alpha_max <= eps ) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) exit end if alphak = min ( 1.0_rk , alpha_max ) l = 0 do if ( alphak <= eps . or . l >= 50 ) exit xt = xk + alphak * dk ! feasible since alphak ≤ alpha_max obj_trial = norm2 ( this % cmp_Xg ( xt ) - point_Xg ) + 0.001_rk if ( obj_trial <= obj + alphak * beta * grad * dk ) exit alphak = min ( tau * alphak , alpha_max ) ! shrink but stay feasible l = l + 1 end do xkn = xk if ( alphak > eps ) then xk = xk + alphak * dk end if ! clamp updated iterate xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ansatz ( this , ie , ig , Tgc , dTgc_dXg , dL , ngauss ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: ie , ig real ( rk ), intent ( out ) :: dL real ( rk ), allocatable , intent ( out ) :: Tgc (:), dTgc_dXg (:,:) integer , intent ( in ), optional :: ngauss real ( rk ), allocatable :: Xth (:), Xth_e (:), Xc_eT (:,:), Xksi (:), Wksi (:) integer , allocatable :: elem_th (:,:), elem_c (:,:), elem_ce (:) type ( nurbs_curve ) :: th , th_e real ( rk ), allocatable :: dTtth_dXksi (:), Ttth (:), dTgc_dXt (:), dXg_dXt (:) real ( rk ) :: Xt , dXt_dXksi real ( rk ), allocatable :: dXg_dXksi (:) !! Jacobian matrix real ( rk ) :: det_dXg_dXksi !! Determinant of the Jacobian matrix if (. not . this % err % ok ) return if ( present ( ngauss )) then call gauss_leg ([ 0.0_rk , 1.0_rk ], ngauss - 1 , Xksi , Wksi ) else call gauss_leg ([ 0.0_rk , 1.0_rk ], this % degree , Xksi , Wksi ) end if Xth = unique ( this % knot ) call th % set ([ 0.0_rk , Xth , 1.0_rk ], Xth ) elem_th = th % cmp_elem () elem_c = this % cmp_elem () Xth_e = Xth ( elem_th ( ie ,:)) call th_e % set ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xth_e ) elem_ce = elem_c ( ie ,:) Xc_eT = transpose ( this % Xc ( elem_ce ,:)) call th_e % derivative ( Xksi ( ig ), dTtth_dXksi , Ttth ) Xt = dot_product ( Xth_e , Ttth ) dXt_dXksi = dot_product ( Xth_e , dTtth_dXksi ) call this % derivative ( Xt , dTgc_dXt , Tgc , elem_ce ) dXg_dXt = matmul ( Xc_eT , dTgc_dXt ) dTgc_dXg = dyad ( dTgc_dXt , dXg_dXt ) / norm2 ( dXg_dXt ) dXg_dXksi = dXg_dXt * dXt_dXksi det_dXg_dXksi = norm2 ( dXg_dXksi ) dL = det_dXg_dXksi * Wksi ( ig ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_length ( this , length , ngauss ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( out ) :: length integer , intent ( in ), optional :: ngauss real ( rk ), allocatable :: Tgc (:), dTgc_dXg (:,:) integer :: ie , ig , ngauss_ real ( rk ) :: dL , dL_ig if (. not . this % err % ok ) return if ( present ( ngauss )) then ngauss_ = ngauss else ngauss_ = this % degree + 1 end if length = 0.0_rk #if defined(__NVCOMPILER) || (defined(__GFORTRAN__) && (__GNUC__ < 15 || (__GNUC__ == 15 && __GNUC_MINOR__ < 1))) do ie = 1 , size ( this % cmp_elem (), 1 ) #else do concurrent ( ie = 1 : size ( this % cmp_elem (), 1 )) reduce ( + : length ) #endif dL = 0.0_rk do ig = 1 , ngauss_ call this % ansatz ( ie , ig , Tgc , dTgc_dXg , dL_ig , ngauss_ ) dL = dL + dL_ig end do length = length + dL end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Tgc_1d ( Xti , knot , nc , degree , Wc ) result ( Tgc ) real ( rk ), intent ( in ) :: Xti real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree , nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Tgc ( nc ) real ( rk ) :: tmp integer :: i Tgc = basis_bspline ( Xti , knot , nc , degree ) tmp = dot_product ( Tgc , Wc ) do concurrent ( i = 1 : nc ) Tgc ( i ) = ( Tgc ( i ) * Wc ( i )) / tmp end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_1d ( Xt , knot , degree , nc , ng , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) integer :: i , ng_ if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( Xg ( ng_ , size ( Xc , 2 )), source = 0.0_rk ) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Xg ( i ,:) = matmul ( cmp_Tgc_1d ( Xt ( i ), knot , nc , degree , Wc ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_1d_1point ( Xt , knot , degree , nc , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Xg ( size ( Xc , 2 )) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_1d ( Xt , knot , degree , nc , ng , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i , ng_ if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( Xg ( ng_ , size ( Xc , 2 ))) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Xg ( i ,:) = matmul ( basis_bspline ( Xt ( i ), knot , nc , degree ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_1d_1point ( Xt , knot , degree , nc , Xc ) result ( Xg ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ) :: Xg ( size ( Xc , 2 )) Xg = matmul ( basis_bspline ( Xt , knot , nc , degree ), Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: d2Bi ( nc ), dBi ( nc ), Bi ( nc ) integer :: i , ng_ if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( d2Tgc ( ng_ , nc ), dTgc ( ng_ , nc ), Tgc ( ng_ , nc )) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( d2Bi , dBi , Bi ) #endif call basis_bspline_2der ( Xt ( i ), knot , nc , degree , d2Bi , dBi , Bi ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc ( i ,:) = ( dBi * Wc - Tgc ( i ,:) * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) d2Tgc ( i ,:) = ( d2Bi * Wc - 2.0_rk * dTgc ( i ,:) * dot_product ( dBi , Wc ) - Tgc ( i ,:) * dot_product ( d2Bi , Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: d2Bi (:), dBi (:), Bi (:) allocate ( d2Tgc ( nc ), dTgc ( nc ), Tgc ( nc ), d2Bi ( nc ), dBi ( nc ), Bi ( nc )) call basis_bspline_2der ( Xt , knot , nc , degree , d2Bi , dBi , Bi ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc = ( dBi * Wc - Tgc * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) d2Tgc = ( d2Bi * Wc - 2.0_rk * dTgc * dot_product ( dBi , Wc ) - Tgc * dot_product ( d2Bi , Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_1d_vector ( Xt , knot , degree , nc , ng , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i , ng_ real ( rk ) :: Xti , d2Tgci ( nc ), dTgci ( nc ), Tgci ( nc ) if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( d2Tgc ( ng_ , nc ), dTgc ( ng_ , nc ), Tgc ( ng_ , nc )) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( Xti , d2Tgci , dTgci , Tgci ) #endif Xti = Xt ( i ) call basis_bspline_2der ( Xti , knot , nc , degree , d2Tgci , dTgci , Tgci ) d2Tgc ( i ,:) = d2Tgci dTgc ( i ,:) = dTgci Tgc ( i ,:) = Tgci end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_1d_scalar ( Xt , knot , degree , nc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) allocate ( d2Tgc ( nc ), dTgc ( nc ), Tgc ( nc )) call basis_bspline_2der ( Xt , knot , nc , degree , d2Tgc , dTgc , Tgc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dBi ( nc ), Bi ( nc ) integer :: i , ng_ if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( dTgc ( ng_ , nc ), Tgc ( ng_ , nc )) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( dBi , Bi ) #endif call basis_bspline_der ( Xt ( i ), knot , nc , degree , dBi , Bi ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc ( i ,:) = ( dBi * Wc - Tgc ( i ,:) * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc , dTgc , Tgc , elem ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dBi ( nc ), Bi ( nc ) call basis_bspline_der ( Xt , knot , nc , degree , dBi , Bi ) if (. not . present ( elem )) then allocate ( dTgc ( nc ), Tgc ( nc )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc = ( dBi * Wc - Tgc * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) else allocate ( dTgc ( size ( elem )), Tgc ( size ( elem ))) Tgc = Bi ( elem ) * ( Wc / ( dot_product ( Bi ( elem ), Wc ))) dTgc = ( dBi ( elem ) * Wc - Tgc * dot_product ( dBi ( elem ), Wc ) ) / dot_product ( Bi ( elem ), Wc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_1d_vector ( Xt , knot , degree , nc , ng , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i , ng_ real ( rk ) :: Xti , dTgci ( nc ), Tgci ( nc ) if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( dTgc ( ng_ , nc ), Tgc ( ng_ , nc )) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( Xti , dTgci , Tgci ) #endif Xti = Xt ( i ) call basis_bspline_der ( Xti , knot , nc , degree , dTgci , Tgci ) dTgc ( i ,:) = dTgci Tgc ( i ,:) = Tgci end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_1d_scalar ( Xt , knot , degree , nc , dTgc , Tgc , elem ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: dB (:), B (:) if (. not . present ( elem )) then allocate ( dTgc ( nc ), Tgc ( nc )) call basis_bspline_der ( Xt , knot , nc , degree , dTgc , Tgc ) else allocate ( dB ( size ( elem )), B ( size ( elem ))) call basis_bspline_der ( Xt , knot , nc , degree , dB , B ) Tgc = B ( elem ) dTgc = dB ( elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i , ng_ if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( Tgc ( ng_ , nc ), Tgci ( nc )) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Tgci = basis_bspline ( Xt ( i ), knot , nc , degree ) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc ) result ( Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_1d_vector ( Xt , knot , degree , nc , ng ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: ng real ( rk ), allocatable :: Tgc (:,:) integer :: i , ng_ if ( present ( ng )) then ng_ = ng else ng_ = size ( Xt , 1 ) end if allocate ( Tgc ( ng_ , nc )) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Tgc ( i ,:) = basis_bspline ( Xt ( i ), knot , nc , degree ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_1d_scalar ( Xt , knot , degree , nc ) result ( Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine lsq_fit_bspline ( this , Xt , Xdata , ndata ) use forcad_interface , only : solve class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:), Xdata (:,:) integer , intent ( in ) :: ndata real ( rk ), allocatable :: T (:,:), Tt (:,:), TtT (:,:), TtX (:,:) integer :: i if (. not . this % err % ok ) return if ( this % nc > ndata ) then call this % err % set (& code = 106 ,& severity = 1 ,& category = 'forcad_nurbs_curve' ,& message = 'Too few data points for the requested number of control points.' ,& location = 'lsq_fit_bspline' ,& suggestion = 'Use nc <= ndata: reduce nc or increase the number of data points.' ) return end if allocate ( T ( ndata , this % nc )) #if defined(__NVCOMPILER) do i = 1 , ndata #else do concurrent ( i = 1 : ndata ) #endif T ( i ,:) = basis_bspline ( Xt ( i ), this % knot , this % nc , this % degree ) end do Tt = transpose ( T ) TtT = matmul ( Tt , T ) TtX = matmul ( Tt , Xdata ) this % Xc = solve ( TtT , TtX ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine lsq_fit_nurbs ( this , Xt , Xdata , ndata , maxit , tol , lambda_xc , mu0 , reg_logw ) use forcad_interface , only : solve class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: Xdata (:,:) integer , intent ( in ) :: ndata integer , intent ( in ), optional :: maxit real ( rk ), intent ( in ), optional :: tol real ( rk ), intent ( in ), optional :: lambda_xc real ( rk ), intent ( in ), optional :: mu0 real ( rk ), intent ( in ), optional :: reg_logw real ( rk ), allocatable :: Bmat (:,:), S (:), T (:,:), TtT (:,:), TtX (:,:), C (:,:), R (:,:), v (:) real ( rk ), allocatable :: Jacv (:,:), Jac_red (:,:), rvec (:), JtJ (:,:), Jtr (:,:), delta_u (:,:), delta_v (:) real ( rk ) :: tol_ , lamx_ , mu , regw , epss , cost_prev , cost_now integer :: dim_ , it , maxit_ , nvar , i , j , k if (. not . this % err % ok ) return if ( this % nc > ndata ) then call this % err % set ( code = 106 , severity = 1 , category = 'forcad_nurbs_curve' , & message = 'Too few data points for the requested number of control points.' , & location = 'lsq_fit_nurbs' , & suggestion = 'Use nc <= ndata: reduce nc or increase number of data points.' ) return end if if ( this % nc < 2 ) error stop 'lsq_fit_nurbs: nc must be at least 2' dim_ = size ( Xdata , 2 ) maxit_ = 30 tol_ = epsilon ( 0.0_rk ) lamx_ = 0.0_rk mu = sqrt ( epsilon ( 0.0_rk )) regw = sqrt ( epsilon ( 0.0_rk )) epss = 1 0.0_rk * epsilon ( 0.0_rk ) if ( present ( maxit )) maxit_ = maxit if ( present ( tol )) tol_ = tol if ( present ( lambda_xc )) lamx_ = lambda_xc if ( present ( mu0 )) mu = mu0 if ( present ( reg_logw )) regw = reg_logw allocate ( Bmat ( ndata , this % nc )) #if defined(__NVCOMPILER) do i = 1 , ndata Bmat ( i ,:) = basis_bspline ( Xt ( i ), this % knot , this % nc , this % degree ) end do #else do concurrent ( i = 1 : ndata ) Bmat ( i ,:) = basis_bspline ( Xt ( i ), this % knot , this % nc , this % degree ) end do #endif if ( allocated ( this % Wc ) . and . size ( this % Wc ) == this % nc ) then ! this%Wc = this%Wc else allocate ( this % Wc ( this % nc ), source = 1.0_rk ) end if v = log ( max ( this % Wc , epss )) this % Wc = exp ( v - sum ( v ) / real ( this % nc , rk )) nvar = this % nc - 1 allocate ( S ( ndata ), T ( ndata , this % nc ), C ( ndata , dim_ ), R ( ndata , dim_ )) allocate ( TtT ( this % nc , this % nc ), TtX ( this % nc , dim_ )) allocate ( Jacv ( ndata * dim_ , this % nc ), rvec ( ndata * dim_ )) allocate ( Jac_red ( ndata * dim_ , nvar )) allocate ( JtJ ( nvar , nvar ), Jtr ( nvar , 1 ), delta_u ( nvar , 1 ), delta_v ( this % nc )) cost_prev = huge ( 1.0_rk ) do it = 1 , maxit_ #if defined(__NVCOMPILER) do i = 1 , ndata S ( i ) = dot_product ( Bmat ( i ,:), this % Wc ) if ( abs ( S ( i )) < epss ) S ( i ) = sign ( epss , S ( i )) T ( i ,:) = Bmat ( i ,:) * ( this % Wc / S ( i )) end do #else do concurrent ( i = 1 : ndata ) S ( i ) = dot_product ( Bmat ( i ,:), this % Wc ) if ( abs ( S ( i )) < epss ) S ( i ) = sign ( epss , S ( i )) T ( i ,:) = Bmat ( i ,:) * ( this % Wc / S ( i )) end do #endif TtT = matmul ( transpose ( T ), T ) if ( lamx_ > 0.0_rk ) then do concurrent ( j = 1 : this % nc ) TtT ( j , j ) = TtT ( j , j ) + lamx_ end do end if TtX = matmul ( transpose ( T ), Xdata ) this % Xc = solve ( TtT , TtX ) C = matmul ( T , this % Xc ) R = C - Xdata cost_now = norm2 ( R ) / real ( ndata * dim_ , rk ) if ( cost_prev - cost_now <= tol_ * max ( 1.0_rk , cost_prev )) exit cost_prev = cost_now do concurrent ( k = 1 : dim_ , i = 1 : ndata ) rvec (( k - 1 ) * ndata + i ) = R ( i , k ) end do do concurrent ( j = 1 : this % nc , k = 1 : dim_ , i = 1 : ndata ) Jacv (( k - 1 ) * ndata + i , j ) = ( this % Wc ( j ) * Bmat ( i , j ) / S ( i ) ) * ( this % Xc ( j , k ) - C ( i , k ) ) end do do concurrent ( j = 1 : nvar ) Jac_red (:, j ) = Jacv (:, j ) - Jacv (:, this % nc ) end do JtJ = matmul ( transpose ( Jac_red ), Jac_red ) Jtr (:, 1 ) = matmul ( transpose ( Jac_red ), rvec ) do concurrent ( j = 1 : nvar ) JtJ ( j , j ) = JtJ ( j , j ) + mu + regw end do delta_u = - solve ( JtJ , Jtr ) delta_v ( 1 : nvar ) = delta_u (:, 1 ) delta_v ( this % nc ) = - sum ( delta_u (:, 1 )) v = v + delta_v this % Wc = exp ( v - sum ( v ) / real ( this % nc , rk )) mu = max ( epsilon ( 0.0_rk ), 0.3_rk * mu ) end do end subroutine !=============================================================================== end module forcad_nurbs_curve","tags":"","url":"sourcefile/forcad_nurbs_curve.f90.html"},{"title":"example_bend_pipe.f90 – ForCAD","text":"This file depends on sourcefile~~example_bend_pipe.f90~~EfferentGraph sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Example program demonstrating how to bend a straight pipe-like NURBS volume into a circular arc. !> !> The program: !>   Creates a straight pipe segment (as a ring extruded in z), !>   Refines the shape, !>   Applies bending with different bend angles (90°, 270°, 360°), !>   Exports the resulting NURBS volumes to VTK, !>   Displays the geometry. program example_bend_pipe use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: ring !! Straight pipe ring type ( nurbs_volume ) :: shape !! Bent pipe shape real ( rk ), parameter :: c ( 3 ) = [ 0.0_rk , 0.0_rk , 0.0_rk ] !! Center of the ring. real ( rk ), parameter :: r1 = 0.3_rk !! Inner radius of the pipe. real ( rk ), parameter :: r2 = 0.5_rk !! Outer radius of the pipe. real ( rk ), parameter :: l = 1.0_rk !! Length of the straight segment. real ( rk ), parameter :: rb = 1.5_rk !! Bend radius. real ( rk ), parameter :: a ( 3 ) = [ 9 0.0_rk , 27 0.0_rk , 36 0.0_rk ] !! Bend angles (degrees). ! Initialize a straight pipe ring call ring % set_ring ( c , r1 , r2 , l ) ! Refine the pipe ring call ring % elevate_degree ( 3 , 1 ) call ring % insert_knots ( dir = 3 , Xth = [ 0.1_rk , 0.2_rk , 0.3_rk , 0.4_rk , 0.5_rk , 0.6_rk , 0.7_rk , 0.8_rk , 0.9_rk ], r = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ]) call ring % elevate_degree ( 3 , 5 ) !=============================================================================== ! Apply bending with angle 90° ! Set the shape shape = ring ! Build the bend pipe shape call bend_pipe ( shape , c , l , rb , a ( 1 )) ! Create the NURBS volume call shape % create ( 30 , 40 , 80 ) ! Export the NURBS volume to VTK files call shape % export_Xc ( \"vtk/bend_pipe_pipe90_Xc.vtk\" ) call shape % export_Xg ( \"vtk/bend_pipe_pipe90_Xg.vtk\" ) call shape % export_Xth_in_Xg ( \"vtk/bend_pipe_pipe90_Xth.vtk\" ) ! Show the NURBS volume call shape % show ( \"vtk/bend_pipe_pipe90_Xc.vtk\" , \"vtk/bend_pipe_pipe90_Xg.vtk\" , \"vtk/bend_pipe_pipe90_Xth.vtk\" ) !=============================================================================== ! Apply bending with angle 270° ! Set the shape shape = ring ! Build the bend pipe shape call bend_pipe ( shape , c , l , rb , a ( 2 )) ! Create the NURBS volume call shape % create ( 30 , 40 , 80 ) ! Export the NURBS volume to VTK files call shape % export_Xc ( \"vtk/bend_pipe_pipe270_Xc.vtk\" ) call shape % export_Xg ( \"vtk/bend_pipe_pipe270_Xg.vtk\" ) call shape % export_Xth_in_Xg ( \"vtk/bend_pipe_pipe270_Xth.vtk\" ) ! Show the NURBS volume call shape % show ( \"vtk/bend_pipe_pipe270_Xc.vtk\" , \"vtk/bend_pipe_pipe270_Xg.vtk\" , \"vtk/bend_pipe_pipe270_Xth.vtk\" ) !=============================================================================== ! Apply bending with angle 360° ! Set the shape shape = ring ! Build the bend pipe shape call bend_pipe ( shape , c , l , rb , a ( 3 )) ! Create the NURBS volume call shape % create ( 30 , 40 , 80 ) ! Export the NURBS volume to VTK files call shape % export_Xc ( \"vtk/bend_pipe_pipe360_Xc.vtk\" ) call shape % export_Xg ( \"vtk/bend_pipe_pipe360_Xg.vtk\" ) call shape % export_Xth_in_Xg ( \"vtk/bend_pipe_pipe360_Xth.vtk\" ) ! Show the NURBS volume call shape % show ( \"vtk/bend_pipe_pipe360_Xc.vtk\" , \"vtk/bend_pipe_pipe360_Xg.vtk\" , \"vtk/bend_pipe_pipe360_Xth.vtk\" ) contains !=============================================================================== !> Bend a straight pipe-like NURBS volume into a circular arc. !> Each control point \\mathbf{X}_c=(x,y,z) is transformed relative !> to the center \\mathbf{c}=(c_x,c_y,c_z). !> Let the total bend angle in degrees be \\alpha&#94;\\circ (input), !> and define the total bend angle in radians !>  !>   \\alpha_{\\max} = \\frac{\\pi}{180}\\,\\alpha&#94;\\circ . !>  !> For each control point: !>  !>   \\rho = \\sqrt{(x-c_x)&#94;2+(y-c_y)&#94;2},\\quad !>   \\phi = \\operatorname{atan2}(y-c_y,\\,x-c_x),\\quad !>   Z = z - c_z , !>  !>  !>   \\theta(Z) = \\alpha_{\\max}\\,\\min\\!\\bigl(1,\\max\\!\\bigl(0,\\tfrac{Z}{L}\\bigr)\\bigr) . !>  !> Mapping: !>  !>   x' = c_x + (\\rho\\cos\\phi + R_b)\\cos\\theta,\\quad !>   y' = c_y + (\\rho\\cos\\phi + R_b)\\sin\\theta,\\quad !>   z' = c_z + \\rho\\sin\\phi . !>  !> Knots and weights are preserved; only the control lattice is updated. pure subroutine bend_pipe ( this , center , length , rbend , angle_deg ) type ( nurbs_volume ), intent ( inout ) :: this !! NURBS volume to be bent. real ( rk ), intent ( in ) :: center ( 3 ) !! Pipe center coordinates (c_x,c_y,c_z). real ( rk ), intent ( in ) :: length !! Length of the straight pipe segment before bending. real ( rk ), intent ( in ) :: rbend !! Bend radius R_b, i.e. distance from the bend centerline. real ( rk ), intent ( in ) :: angle_deg !! Bend angle in degrees \\alpha&#94;\\circ. real ( rk ), allocatable :: Xc (:,:), X4 (:,:,:,:) integer :: nc ( 3 ), i , j , k , dim real ( rk ) :: x0 , y0 , z0 , theta , cth , sth , rho , phi , ang_tot real ( rk ), parameter :: pi = acos ( - 1.0_rk ) Xc = this % get_Xc () dim = size ( Xc , 2 ) nc = this % get_nc () X4 = reshape ( Xc , [ nc ( 1 ), nc ( 2 ), nc ( 3 ), dim ]) ang_tot = angle_deg * pi / 18 0.0_rk do k = 1 , nc ( 3 ) z0 = X4 ( 1 , 1 , k , 3 ) - center ( 3 ) theta = ang_tot * max ( 0.0_rk , min ( 1.0_rk , z0 / length )) cth = cos ( theta ) sth = sin ( theta ) do j = 1 , nc ( 2 ) do i = 1 , nc ( 1 ) x0 = X4 ( i , j , k , 1 ) - center ( 1 ) y0 = X4 ( i , j , k , 2 ) - center ( 2 ) rho = sqrt ( x0 * x0 + y0 * y0 ) phi = merge ( atan2 ( y0 , x0 ), 0.0_rk , rho > 0.0_rk ) X4 ( i , j , k , 1 ) = center ( 1 ) + ( rho * cos ( phi ) + rbend ) * cth X4 ( i , j , k , 2 ) = center ( 2 ) + ( rho * cos ( phi ) + rbend ) * sth X4 ( i , j , k , 3 ) = center ( 3 ) + rho * sin ( phi ) end do end do end do Xc = reshape ( X4 , [ product ( nc ), dim ]) if ( this % is_rational ()) then call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc , this % get_Wc ()) else call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc ) end if end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_bend_pipe.f90.html"},{"title":"fdm_curve.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_curve.f90~~EfferentGraph sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_test_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: curve !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector real ( rk ) :: Xtp , tol , Xt , Xtm real ( rk ), allocatable :: Tgc (:), dTgc (:), Tgcp (:), dTgcp (:), Tgcm (:), dTgcm (:), d2Tgc (:), d2Tgcp (:), d2Tgcm (:) !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 1.1_rk , 1.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call curve % set ( knot , Xc , Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call curve % create ( res = 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- tol = 1.0e-6_rk Xt = 0.5_rk call curve % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) Xtm = Xt - tol call curve % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt + tol call curve % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 (( Tgc - Tgcm ) / tol - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 (( Tgcp - Tgcm ) / ( 2.0_rk * tol ) - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 (( Tgcp - Tgc ) / tol - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 (( dTgc - dTgcm ) / tol - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 (( dTgcp - dTgcm ) / ( 2.0_rk * tol ) - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 (( dTgcp - dTgc ) / tol - d2Tgc ) !> Finalize the NURBS curve object call curve % finalize () deallocate ( Xc , Wc ) !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points for the NURBS curve object. !> Wc is optional call curve % set ( knot , Xc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call curve % create ( res = 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- tol = 1.0e-6_rk Xt = 0.5_rk call curve % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) Xtm = Xt - tol call curve % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt + tol call curve % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 (( Tgc - Tgcm ) / tol - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 (( Tgcp - Tgcm ) / ( 2.0_rk * tol ) - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 (( Tgcp - Tgc ) / tol - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 (( dTgc - dTgcm ) / tol - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 (( dTgcp - dTgcm ) / ( 2.0_rk * tol ) - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 (( dTgcp - dTgc ) / tol - d2Tgc ) !> Finalize the NURBS curve object call curve % finalize () deallocate ( Xc ) end program","tags":"","url":"sourcefile/fdm_curve.f90.html"},{"title":"fdm_elevate_and_insert_2d.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_elevate_and_insert_2d.f90~~EfferentGraph sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_elevate_and_insert_2d use forcad , only : rk , nurbs_surface use forcad_utils , only : linspace , kron_eye use fortime , only : timer implicit none type ( nurbs_surface ) :: sh0 , shr , shfd real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xc0 (:,:), Xp (:,:), Xm (:,:) real ( rk ), allocatable :: Xcp_vec (:), Xcm_vec (:) real ( rk ), allocatable :: knot1 (:), knot2 (:) real ( rk ), allocatable :: S1 (:,:), S2 (:,:) real ( rk ), allocatable :: S3 (:,:), S4 (:,:) real ( rk ), allocatable :: Bs (:,:), B (:,:), Bfd (:,:) real ( rk ), allocatable :: u1 (:), u2 (:) integer , allocatable :: r1 (:), r2 (:) real ( rk ) :: rel_err integer :: dim , nc0 , ndof_old , ndof_new , i , d , idx type ( timer ) :: t real ( rk ), parameter :: tol = 1e-5_rk !! tolerance of finite differences integer , parameter :: dg1 = 3 , dg2 = 2 !! degrees to elevate integer , parameter :: n1 = 5 , n2 = 4 !! number of knots to insert !> set control points Xc = generate_Xc ( 5.0_rk ) !> set weights allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 0.5_rk !> set knot vectors knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> set NURBS surface call shr % set ( knot1 , knot2 , Xc , Wc ) !> deallocate temporary arrays deallocate ( Xc , Wc , knot1 , knot2 ) !> copy initial NURBS surface (before refinement) sh0 = shr !> get initial control points, dimension, number of control points and degrees of freedom Xc0 = sh0 % get_Xc () dim = size ( Xc0 , 2 ) nc0 = size ( Xc0 , 1 ) ndof_old = nc0 * dim !> elevate degree in two directions and get sensitivities (Bs: in compact form, memory efficient) call t % timer_start () call shr % elevate_degree ( 1 , dg1 , Bs = S1 ) call shr % elevate_degree ( 2 , dg2 , Bs = S2 ) call t % timer_stop () !> set knot vectors to insert u1 = linspace ( 0.0_rk , 1.0_rk , n1 + 2 ) u1 = u1 ( 2 : n1 + 1 ) u2 = linspace ( 0.0_rk , 1.0_rk , n2 + 2 ) u2 = u2 ( 2 : n2 + 1 ) !> multiplicities of knots to insert allocate ( r1 ( size ( u1 )), source = 2 ) allocate ( r2 ( size ( u2 )), source = 1 ) !> insert knots in three directions and get sensitivities (Bs: in compact form, memory efficient) call t % timer_start () call shr % insert_knots ( 1 , u1 , r1 , Bs = S3 ) call shr % insert_knots ( 2 , u2 , r2 , Bs = S4 ) call t % timer_stop () !> compute global sensitivities (dXc_old/dXc_new) call t % timer_start () Bs = matmul ( S4 , matmul ( S3 , matmul ( S2 , S1 ))) B = kron_eye ( Bs , dim ) call t % timer_stop () !> start finite difference computations ndof_new = size ( shr % get_Xc (), 1 ) * dim allocate ( Xp ( nc0 , dim ), Xm ( nc0 , dim )) allocate ( Xcp_vec ( ndof_new ), Xcm_vec ( ndof_new )) allocate ( Bfd ( ndof_new , ndof_old )) do idx = 1 , ndof_old Xp = Xc0 Xm = Xc0 i = ( idx - 1 ) / dim + 1 d = mod ( idx - 1 , dim ) + 1 Xp ( i , d ) = Xp ( i , d ) + tol Xm ( i , d ) = Xm ( i , d ) - tol call shfd % set ( sh0 % get_knot ( 1 ), sh0 % get_knot ( 2 ), Xp , sh0 % get_Wc ()) call shfd % elevate_degree ( 1 , dg1 ) call shfd % elevate_degree ( 2 , dg2 ) call shfd % insert_knots ( 1 , u1 , r1 ) call shfd % insert_knots ( 2 , u2 , r2 ) Xcp_vec = reshape ( transpose ( shfd % get_Xc ()), [ ndof_new ]) call shfd % set ( sh0 % get_knot ( 1 ), sh0 % get_knot ( 2 ), Xm , sh0 % get_Wc ()) call shfd % elevate_degree ( 1 , dg1 ) call shfd % elevate_degree ( 2 , dg2 ) call shfd % insert_knots ( 1 , u1 , r1 ) call shfd % insert_knots ( 2 , u2 , r2 ) Xcm_vec = reshape ( transpose ( shfd % get_Xc ()), [ ndof_new ]) Bfd (:, idx ) = ( Xcp_vec - Xcm_vec ) * ( 0.5_rk / tol ) end do !> compute relative error between finite difference and analytical sensitivities rel_err = norm2 ( Bfd - B ) / norm2 ( Bfd ) print '(a)' , '--- CENTRAL FDM vs Analytic (elevate + insert) ---' print '(a,i0)' , '  ndof_old     = ' , ndof_old print '(a,i0)' , '  ndof_new     = ' , ndof_new print '(a,1pe12.4)' , '  ||B||_2      = ' , norm2 ( B ) print '(a,1pe12.4)' , '  ||Bfd||_2    = ' , norm2 ( Bfd ) print '(a,1pe12.4)' , '  ||B-Bfd||_2  = ' , norm2 ( Bfd - B ) print '(a,1pe12.4)' , '  rel l2 error = ' , rel_err !> finalize call shr % finalize () call sh0 % finalize () call shfd % finalize () contains pure function generate_Xc ( L ) result ( cp ) real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: cp (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( cp ( 4 , 3 )) cp ( 1 ,:) = [ L2 , - L2 , 0.0_rk ] cp ( 2 ,:) = [ - L2 , - L2 , 0.0_rk ] cp ( 3 ,:) = [ L2 , L2 , 0.0_rk ] cp ( 4 ,:) = [ - L2 , L2 , 0.0_rk ] end function end program","tags":"","url":"sourcefile/fdm_elevate_and_insert_2d.f90.html"},{"title":"shape_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_2d.f90~~EfferentGraph sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a ring shape with inner radius 1.0 and outer radius 2.0. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_2d_Xc.vtk' , 'vtk/shape_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_ring_2d.f90.html"},{"title":"example_twist_taper.f90 – ForCAD","text":"This file depends on sourcefile~~example_twist_taper.f90~~EfferentGraph sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Example program demonstrating how to apply a **progressive twist** and **linear taper** !> to a hexahedral NURBS volume along its axial (z) direction. !> !> The program: !>   Creates a straight hexahedral block (control points `nc = [7,7,9]` over a box of size `L`), !>   Copies it to `shape`, !>   Applies a z-dependent twist up to \\alpha_{\\max}&#94;\\circ = `twist_deg` and a linear taper to factor `taper`, !>   Exports the resulting NURBS volume to VTK, !>   Displays the geometry. program example_twist_taper use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape , hexa real ( rk ), parameter :: L ( 3 ) = [ 1.0_rk , 1.0_rk , 3.0_rk ] !! Domain extents in x,y,z. integer , parameter :: nc ( 3 ) = [ 7 , 7 , 9 ] !! Control point counts per direction. real ( rk ), parameter :: twist_deg = 36 0.0_rk !! Total twist angle (degrees) at the top face. real ( rk ), parameter :: taper = 0.1_rk !! Target in-plane scale at the top face (0<`taper`≤1). ! Initialize a straight hexahedral block call hexa % set_hexahedron ( L = L , nc = nc ) ! Work on a copy shape = hexa ! Build the twisted and tapered shape call build_twist_taper ( shape , Length = L , nc = nc , twist_deg = twist_deg , taper = taper ) ! Create the NURBS volume sampling call shape % create ( 30 , 30 , 80 ) ! Export the NURBS volume to VTK files call shape % export_Xc ( \"vtk/example_twist_taper_Xc.vtk\" ) call shape % export_Xg ( \"vtk/example_twist_taper_Xg.vtk\" ) call shape % export_Xth_in_Xg ( \"vtk/example_twist_taper_Xth_in_Xg.vtk\" , res = 30 ) ! Show the NURBS volume call shape % show ( \"vtk/example_twist_taper_Xc.vtk\" , \"vtk/example_twist_taper_Xg.vtk\" , \"vtk/example_twist_taper_Xth_in_Xg.vtk\" ) contains !=============================================================================== !> Apply a **z-progressive twist** and **linear taper** to a NURBS hexahedron. !> !> Let the control points be indexed by k=1,\\dots,n_c&#94;{(z)} along z. !> Define the normalized axial coordinate !>  !>   t(k) = \\begin{cases} !>     \\dfrac{k-1}{n_c&#94;{(z)}-1}, & n_c&#94;{(z)} > 1,\\4pt] !>     0, & \\text{otherwise}, !>   \\end{cases} !>  !> which varies from 0 at the bottom face to 1 at the top face. !> !> The total twist angle (in radians) at level t is !>  !>   \\theta(t) = \\Bigl(\\dfrac{\\pi}{180}\\Bigr)\\,\\texttt{twist\\_deg}\\; t , !>  !> i.e. a linear ramp from 0 to \\alpha_{\\max} = (\\pi/180)\\,\\texttt{twist\\_deg}. !> !> The in-plane (x–y) **taper scale** is chosen linear in t: !>  !>   s_{xy}(t) = (1-\\texttt{taper})(1-t) + \\texttt{taper}, !>  !> so s_{xy}(0)=1 at the bottom and s_{xy}(1)=\\texttt{taper} at the top (shrinking if \\texttt{taper}<1). !> !> For each control point \\mathbf{X}_c=(x,y,z), first shift to the in-plane !> centroid \\mathbf{c}_{xy}=(c_x,c_y) of the box, !> apply the scale s_{xy}(t) and rotation by \\theta(t) about \\mathbf{c}_{xy}, !> and keep z unchanged: !>  !>   \\begin{bmatrix}x'\\\\y'\\end{bmatrix} !>   = \\begin{bmatrix}c_x\\\\c_y\\end{bmatrix} !>     + s_{xy}(t)\\, !>       \\begin{bmatrix}\\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta\\end{bmatrix} !>       \\!\\left(\\begin{bmatrix}x\\\\y\\end{bmatrix}-\\begin{bmatrix}c_x\\\\c_y\\end{bmatrix}\\right), !>   \\qquad !>   z' = z . !>  !> !>  Knots are preserved; only the control points are updated. pure subroutine build_twist_taper ( this , Length , nc , twist_deg , taper ) type ( nurbs_volume ), intent ( inout ) :: this !! Volume to be transformed. real ( rk ), intent ( in ) :: Length ( 3 ) !! Box lengths (L_x,L_y,L_z). integer , intent ( in ) :: nc ( 3 ) !! Control points sizes. real ( rk ), intent ( in ) :: twist_deg !! Total twist at top face (degrees). real ( rk ), intent ( in ) :: taper !! In-plane scale at top face (0<`taper`≤1). real ( rk ), allocatable :: Xc (:,:), X4 (:,:,:,:) real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ) :: t , ang , sxy , ca , sa , x , y , cx , cy integer :: i , j , k , dim Xc = this % get_Xc () dim = size ( Xc , 2 ) X4 = reshape ( Xc , [ nc ( 1 ), nc ( 2 ), nc ( 3 ), dim ]) cx = 0.5_rk * Length ( 1 ) cy = 0.5_rk * Length ( 2 ) do k = 1 , nc ( 3 ) t = merge ( real ( k - 1 , rk ) / real ( max ( 1 , nc ( 3 ) - 1 ), rk ), 0.0_rk , nc ( 3 ) > 1 ) ang = ( twist_deg * pi / 18 0.0_rk ) * t sxy = ( 1.0_rk - taper ) * ( 1.0_rk - t ) + taper ca = cos ( ang ) sa = sin ( ang ) do j = 1 , nc ( 2 ) do i = 1 , nc ( 1 ) x = ( X4 ( i , j , k , 1 ) - cx ) * sxy y = ( X4 ( i , j , k , 2 ) - cy ) * sxy X4 ( i , j , k , 1 ) = cx + ca * x - sa * y X4 ( i , j , k , 2 ) = cy + sa * x + ca * y end do end do end do Xc = reshape ( X4 , [ product ( nc ), dim ]) if ( this % is_rational ()) then call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc , this % get_Wc ()) else call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc ) end if end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_twist_taper.f90.html"},{"title":"example_toroidal_pipe.f90 – ForCAD","text":"This file depends on sourcefile~~example_toroidal_pipe.f90~~EfferentGraph sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Example program demonstrating how to sweep a straight, pipe-like NURBS volume !> onto a **toroidal pipe** (donut) with an optional **progressive cross-section twist** !> and a **sinusoidal wobble in the global z-direction** as it travels around the torus. !> !> The program: !>   Creates a straight pipe segment (ring extruded along z), !>   Refines it along the axial direction (knot insertion + degree elevation), !>   Maps the control points onto a torus of major radius `R`, !>   Applies a cross-section twist of `twist_turns` full rotations over one loop, !>   Superimposes a vertical wobble z_\\text{off}(s) = A_z\\sin(2\\pi\\,n_\\text{waves}\\,s + \\varphi), !>   Exports the resulting NURBS volume to VTK and displays it, !>   Prints the approximate enclosed volume (Gaussian integration). program example_toroidal_pipe use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: ring !! straight pipe segment type ( nurbs_volume ) :: shape !! toroidal pipe shape ! Straight ring (pipe) parameters real ( rk ), parameter :: center ( 3 ) = [ 0.0_rk , 0.0_rk , 0.0_rk ] !! center of the ring real ( rk ), parameter :: r1 = 0.12_rk !! inner radius real ( rk ), parameter :: r2 = 0.20_rk !! outer radius real ( rk ), parameter :: length = 1.0_rk !! length of the pipe ! Toroid mapping parameters real ( rk ), parameter :: R = 1.00_rk !! major radius real ( rk ), parameter :: twist_turns = 1.0_rk !! cross-section twist (turns over full loop) ! z-sine wobble parameters (global Z offset around the torus) real ( rk ), parameter :: Az = 0.1_rk !! amplitude of vertical wobble integer , parameter :: nwaves_z = 6 !! number of sine waves per full loop real ( rk ), parameter :: phase_z = 0.1_rk !! phase shift (radians) ! Refinement along z (dir=3) integer , parameter :: Nref = 30 integer :: i ! Make a straight pipe ring call ring % set_ring ( center = center , radius1 = r1 , radius2 = r2 , length = length ) ! Refine along z (keep C&#94;{p-1}) call ring % insert_knots ( dir = 3 , Xth = [( real ( i , rk ) / real ( Nref + 1 , rk ), i = 1 , Nref )], r = [( 1 , i = 1 , Nref )]) call ring % elevate_degree ( 3 , 5 ) ! Map onto a torus with twist + z-sine wobble shape = ring call map_to_torus_sineZ ( shape , c = center , R = R , twist_turns = twist_turns , Az = Az , nwaves_z = nwaves_z , phase_z = phase_z ) ! Export the NURBS volume to VTK files call shape % create ( 30 , 30 , 120 ) call shape % export_Xc ( \"vtk/example_toroidal_pipe_Xc.vtk\" ) call shape % export_Xg ( \"vtk/example_toroidal_pipe_Xg.vtk\" ) call shape % export_Xth_in_Xg ( \"vtk/example_toroidal_pipe_Xth.vtk\" , res = 24 ) ! Show the resulting VTK files call shape % show ( \"vtk/example_toroidal_pipe_Xc.vtk\" , \"vtk/example_toroidal_pipe_Xg.vtk\" , \"vtk/example_toroidal_pipe_Xth.vtk\" ) contains !=============================================================================== !> Map a straight pipe (ring extruded in z) onto a **toroidal pipe** with: !>   • cross-section twist: \\phi' = \\phi + 2\\pi\\,(\\texttt{twist\\_turns})\\,s, !>   • vertical wobble: z_\\text{off}(s) = A_z \\sin(2\\pi\\,n_\\text{waves}\\,s + \\varphi). !> !> Parameterization: !> For the axial (k) index, define !>  !>    s(k) = \\begin{cases} !>      \\dfrac{k-1}{n_c&#94;{(z)}-1}, & n_c&#94;{(z)} > 1,\\4pt] !>      0, & \\text{otherwise}, !>    \\end{cases} !>  !> and the torus angle (here one full loop since \\theta=2\\pi s): !>  !>   \\theta(s) = 2\\pi\\,s . !>  !> !> For each control point \\mathbf{X}_c=(x,y,z), relative to \\mathbf{c}=(c_x,c_y,c_z), !> set \\rho=\\sqrt{(x-c_x)&#94;2+(y-c_y)&#94;2}, \\phi=\\mathrm{atan2}(y-c_y,x-c_x), then !> \\phi'=\\phi+ 2\\pi(\\texttt{twist\\_turns})\\,s. !> !> Mapping onto a torus of major radius R: !>  !> \\begin{aligned} !>   X &= c_x + \\bigl(R + \\rho\\cos\\phi'\\bigr)\\cos\\theta,\\\\ !>   Y &= c_y + \\bigl(R + \\rho\\cos\\phi'\\bigr)\\sin\\theta,\\\\ !>   Z &= c_z + \\rho\\sin\\phi' + z_\\text{off}(s), \\qquad !>       z_\\text{off}(s) = A_z \\sin\\!\\bigl(2\\pi\\,n_\\text{waves}\\,s + \\varphi\\bigr). !> \\end{aligned} !>  !> !> Knots/weights are preserved; only the control points are updated. pure subroutine map_to_torus_sineZ ( this , c , R , twist_turns , Az , nwaves_z , phase_z ) type ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: c ( 3 ), R integer , intent ( in ) :: nwaves_z real ( rk ), intent ( in ) :: twist_turns , Az , phase_z real ( rk ), allocatable :: Xc (:,:), X4 (:,:,:,:) integer :: nc ( 3 ), i , j , k , dim real ( rk ) :: s , theta , x0 , y0 , rho , phi , phip , X , Y , Z , z_off real ( rk ), parameter :: pi = acos ( - 1.0_rk ) Xc = this % get_Xc (); dim = size ( Xc , 2 ) nc = this % get_nc () X4 = reshape ( Xc , [ nc ( 1 ), nc ( 2 ), nc ( 3 ), dim ]) do k = 1 , nc ( 3 ) s = merge ( real ( k - 1 , rk ) / real ( max ( 1 , nc ( 3 ) - 1 ), rk ), 0._rk , nc ( 3 ) > 1 ) theta = 2.0_rk * pi * s z_off = Az * sin ( 2.0_rk * pi * real ( nwaves_z , rk ) * s + phase_z ) do j = 1 , nc ( 2 ) do i = 1 , nc ( 1 ) x0 = X4 ( i , j , k , 1 ) - c ( 1 ) y0 = X4 ( i , j , k , 2 ) - c ( 2 ) rho = sqrt ( x0 * x0 + y0 * y0 ) phi = merge ( atan2 ( y0 , x0 ), 0._rk , rho > 0._rk ) phip = phi + 2.0_rk * pi * twist_turns * s X = c ( 1 ) + ( R + rho * cos ( phip )) * cos ( theta ) Y = c ( 2 ) + ( R + rho * cos ( phip )) * sin ( theta ) Z = c ( 3 ) + rho * sin ( phip ) + z_off X4 ( i , j , k , 1 ) = X X4 ( i , j , k , 2 ) = Y X4 ( i , j , k , 3 ) = Z end do end do end do Xc = reshape ( X4 , [ product ( nc ), dim ]) if ( this % is_rational ()) then call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc , this % get_Wc ()) else call this % set ( this % get_knot ( 1 ), this % get_knot ( 2 ), this % get_knot ( 3 ), Xc ) end if end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_toroidal_pipe.f90.html"},{"title":"put_to_nurbs.f90 – ForCAD","text":"This file depends on sourcefile~~put_to_nurbs.f90~~EfferentGraph sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_put_to_nurbs use forcad , only : rk , nurbs_volume use forcad_utils , only : hexahedron_Xc implicit none type ( nurbs_volume ) :: control_shape real ( rk ), allocatable :: X (:,:) integer , allocatable :: elem (:,:) integer :: i , nunit !> You can create your shape or use a predefined one !> Read coordinates from file allocate ( X ( 23200 , 3 )) open ( newunit = nunit , file = 'example/put_to_nurbs_X.txt' ) do i = 1 , 23200 read ( nunit , * ) X ( i , 1 ), X ( i , 2 ), X ( i , 3 ) end do close ( nunit ) !> Read element connectivities from file allocate ( elem ( 20577 , 8 )) open ( newunit = nunit , file = 'example/put_to_nurbs_elem.txt' ) do i = 1 , 20577 read ( nunit , * ) elem ( i , 1 ), elem ( i , 2 ), elem ( i , 4 ), elem ( i , 3 ), elem ( i , 5 ), elem ( i , 6 ), elem ( i , 8 ), elem ( i , 7 ) end do close ( nunit ) !> Set a control shape that will be used to put the shape into !> The contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points !> By modifying the control shape you can modify the shape call control_shape % set ( nc = [ 10 , 5 , 3 ], Xc = hexahedron_Xc ( L = [ 10 0.0_rk , 4 0.0_rk , 1 0.0_rk ], nc = [ 10 , 5 , 3 ])) !> Map the shape into the shape call control_shape % put_to_nurbs ( X , elem ) !> Deallocate local variables deallocate ( X , elem ) !> Export the shape and the control shape to vtk files call control_shape % export_Xc ( 'vtk/control_shape.vtk' ) call control_shape % export_Xg ( 'vtk/shape.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call control_shape % show ( 'vtk/control_shape.vtk' , 'vtk/shape.vtk' ) !> Finalize the control shape call control_shape % finalize () end program","tags":"","url":"sourcefile/put_to_nurbs.f90.html"},{"title":"fdm_elevate_and_insert_1d.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_elevate_and_insert_1d.f90~~EfferentGraph sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_elevate_and_insert_1d use forcad , only : rk , nurbs_curve use forcad_utils , only : linspace , kron_eye use fortime , only : timer implicit none type ( nurbs_curve ) :: sh0 , shr , shfd real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xc0 (:,:), Xp (:,:), Xm (:,:) real ( rk ), allocatable :: Xcp_vec (:), Xcm_vec (:) real ( rk ), allocatable :: knot (:) real ( rk ), allocatable :: S1 (:,:), S2 (:,:) real ( rk ), allocatable :: Bs (:,:), B (:,:), Bfd (:,:) real ( rk ), allocatable :: u (:) integer , allocatable :: r (:) real ( rk ) :: rel_err integer :: dim , nc0 , ndof_old , ndof_new , i , d , idx type ( timer ) :: t real ( rk ), parameter :: tol = 1e-5_rk !! tolerance of finite differences integer , parameter :: tdeg = 3 !! degrees to elevate integer , parameter :: nins = 5 !! number of knots to insert !> set control points Xc = generate_Xc ( 5.0_rk ) !> set weights allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 0.5_rk !> set knot vector knot = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> set NURBS curve call shr % set ( knot , Xc , Wc ) !> deallocate temporary arrays deallocate ( Xc , Wc , knot ) !> copy initial NURBS curve (before refinement) sh0 = shr !> get initial control points, dimension, number of control points and degrees of freedom Xc0 = sh0 % get_Xc () dim = size ( Xc0 , 2 ) nc0 = size ( Xc0 , 1 ) ndof_old = nc0 * dim !> elevate degree and get sensitivities (Bs: in compact form, memory efficient) call t % timer_start () call shr % elevate_degree ( tdeg , Bs = S1 ) call t % timer_stop () !> set knot vectors to insert u = linspace ( 0.0_rk , 1.0_rk , nins + 2 ) u = u ( 2 : nins + 1 ) !> multiplicities of knots to insert allocate ( r ( size ( u )), source = 2 ) !> insert knots and get sensitivities (Bs: in compact form, memory efficient) call t % timer_start () call shr % insert_knots ( u , r , Bs = S2 ) call t % timer_stop () !> compute global sensitivities (dXc_old/dXc_new) call t % timer_start () Bs = matmul ( S2 , S1 ) B = kron_eye ( Bs , dim ) call t % timer_stop () !> get new degrees of freedom (after refinement) ndof_new = size ( shr % get_Xc (), 1 ) * dim !> start finite difference computations allocate ( Xp ( nc0 , dim ), Xm ( nc0 , dim )) allocate ( Xcp_vec ( ndof_new ), Xcm_vec ( ndof_new )) allocate ( Bfd ( ndof_new , ndof_old )) do idx = 1 , ndof_old Xp = Xc0 Xm = Xc0 i = ( idx - 1 ) / dim + 1 d = mod ( idx - 1 , dim ) + 1 Xp ( i , d ) = Xp ( i , d ) + tol Xm ( i , d ) = Xm ( i , d ) - tol call shfd % set ( sh0 % get_knot (), Xp , sh0 % get_Wc ()) call shfd % elevate_degree ( tdeg ) call shfd % insert_knots ( u , r ) Xcp_vec = reshape ( transpose ( shfd % get_Xc ()), [ ndof_new ]) call shfd % set ( sh0 % get_knot (), Xm , sh0 % get_Wc ()) call shfd % elevate_degree ( tdeg ) call shfd % insert_knots ( u , r ) Xcm_vec = reshape ( transpose ( shfd % get_Xc ()), [ ndof_new ]) Bfd (:, idx ) = ( Xcp_vec - Xcm_vec ) * ( 0.5_rk / tol ) end do !> compute relative error between finite difference and analytical sensitivities rel_err = norm2 ( Bfd - B ) / norm2 ( Bfd ) print '(a)' , '--- CENTRAL FDM vs Analytic (elevate + insert) ---' print '(a,i0)' , '  ndof_old     = ' , ndof_old print '(a,i0)' , '  ndof_new     = ' , ndof_new print '(a,1pe12.4)' , '  ||B||_2      = ' , norm2 ( B ) print '(a,1pe12.4)' , '  ||Bfd||_2    = ' , norm2 ( Bfd ) print '(a,1pe12.4)' , '  ||B-Bfd||_2  = ' , norm2 ( Bfd - B ) print '(a,1pe12.4)' , '  rel l2 error = ' , rel_err !> finalize call shr % finalize () call sh0 % finalize () call shfd % finalize () contains pure function generate_Xc ( L ) result ( control_points ) real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 2 , 3 )) control_points ( 1 ,:) = [ - L2 , 0.0_rk , 0.0_rk ] control_points ( 2 ,:) = [ L2 , 0.0_rk , 0.0_rk ] end function end program","tags":"","url":"sourcefile/fdm_elevate_and_insert_1d.f90.html"},{"title":"example_ppm2.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm2.f90~~EfferentGraph sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm2 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap , wp use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.0_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , real ( 0.0_rk , kind = wp ), real ( 2.2_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.08_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.01_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 9 0.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.22_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 0.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm2' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","url":"sourcefile/example_ppm2.f90.html"},{"title":"cmp_length.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_length.f90~~EfferentGraph sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_length use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape real ( rk ) :: length real ( rk ) :: Xc ( 2 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] call shape % set (& knot = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_length ( length ) print * , length end program","tags":"","url":"sourcefile/cmp_length.f90.html"},{"title":"cmp_area.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_area.f90~~EfferentGraph sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_area use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape real ( rk ) :: area real ( rk ) :: Xc ( 4 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_area ( area ) print * , area end program","tags":"","url":"sourcefile/cmp_area.f90.html"},{"title":"forcad_nurbs_volume.F90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_volume.f90~~EfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_volume.f90~~AfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_bend_pipe.f90 example_bend_pipe.f90 sourcefile~example_bend_pipe.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_helix_pipe.f90 example_helix_pipe.f90 sourcefile~example_helix_pipe.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_2d.f90 example_plate_hole_1_2d.f90 sourcefile~example_plate_hole_1_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_1_3d.f90 example_plate_hole_1_3d.f90 sourcefile~example_plate_hole_1_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_2d.f90 example_plate_hole_2_2d.f90 sourcefile~example_plate_hole_2_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_2_3d.f90 example_plate_hole_2_3d.f90 sourcefile~example_plate_hole_2_3d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_2d.f90 example_plate_hole_4_2d.f90 sourcefile~example_plate_hole_4_2d.f90->sourcefile~forcad.f90 sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_toroidal_pipe.f90 example_toroidal_pipe.f90 sourcefile~example_toroidal_pipe.f90->sourcefile~forcad.f90 sourcefile~example_twist_taper.f90 example_twist_taper.f90 sourcefile~example_twist_taper.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_1d.f90 fdm_elevate_and_insert_1d.f90 sourcefile~fdm_elevate_and_insert_1d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_2d.f90 fdm_elevate_and_insert_2d.f90 sourcefile~fdm_elevate_and_insert_2d.f90->sourcefile~forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_2d.f90 lsq_fit_bspline_2d.f90 sourcefile~lsq_fit_bspline_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_bspline_3d.f90 lsq_fit_bspline_3d.f90 sourcefile~lsq_fit_bspline_3d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_2d.f90 lsq_fit_nurbs_2d.f90 sourcefile~lsq_fit_nurbs_2d.f90->sourcefile~forcad.f90 sourcefile~lsq_fit_nurbs_3d.f90 lsq_fit_nurbs_3d.f90 sourcefile~lsq_fit_nurbs_3d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~poisson_iga_solver_3d.f90 poisson_iga_solver_3d.f90 sourcefile~poisson_iga_solver_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. module forcad_nurbs_volume use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , det , inv , gauss_leg , export_vtk_legacy , basis_bspline_2der use fordebug , only : debug implicit none private public nurbs_volume , compute_Tgc , compute_dTgc !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_volume real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2)*nc(3), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2)*ng(3), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for the control points (1D array: [nc(1)*nc(2)*nc(3)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: Xt3 (:) !! Evaluation parameter values in the third direction (1D array: [ng(3)]) real ( rk ), allocatable , private :: Xt (:,:) !! Evaluation parameter values (2D array: [ng(1)*ng(2)*ng(3), dim] real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) real ( rk ), allocatable , private :: knot3 (:) !! Knot vector in the third direction (1D array) integer , private :: degree ( 3 ) !! Degree (order) of the volume integer , private :: nc ( 3 ) !! Number of control points in each direction integer , private :: ng ( 3 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity type ( debug ) :: err !! 101: size mismatch (weights vs control points), 102: missing control points, 103: missing knot vector, 104: missing geometry points, 105: missing weights, 106: lsq fit underdetermined contains procedure , private :: set1 !!> Set knot vectors, control points and weights for the NURBS volume object procedure , private :: set2 !!> Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights procedure , private :: set3 !!> Set Bezier or Rational Bezier volume using control points and weights procedure , private :: set4 !!> Set NURBS volume using degree, number of control points, control points and weights generic :: set => set1 , set2 , set3 , set4 !!> Set NURBS volume procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure , private :: get_nc_dir !!> Get number of control points in a specific direction procedure , private :: get_nc_all !!> Get number of control points in all directions generic :: get_nc => get_nc_all , get_nc_dir !!> Get number of control points procedure :: cmp_degree !!> Compute degree of the NURBS volume procedure , private :: get_degree_all !!> Get degree of the NURBS volume in all directions procedure , private :: get_degree_dir !!> Get degree of the NURBS volume in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS volume procedure :: finalize !!> Finalize the NURBS volume object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem_Xth !!> Generate connectivity for parameter points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: export_Xth !!> Export parameter space to VTK file procedure :: export_Xth_in_Xg !!> Export parameter space in geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knots procedure :: get_continuity !!> Compute and return the continuity of the NURBS volume procedure :: cmp_nc !!> Compute number of required control points procedure , private :: basis_vector !!> Compute the basis functions of the NURBS volume procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS volume generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS volume procedure , private :: derivative_vector !!> Compute the derivative of the NURBS volume procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS volume generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS volume procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS volume procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS volume generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS volume procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the NURBS volume procedure :: is_rational !!> Check if the NURBS volume is rational procedure :: put_to_nurbs !!> Put a shape to a NURBS volume procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS volume (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS volume (Minimization - Newtons method) procedure :: ansatz !!> Compute the shape functions, derivative of shape functions and dV procedure :: cmp_volume !!> Compute the volume of the NURBS volume procedure :: lsq_fit_bspline !!> Fit B-spline volume to structured data points using least squares procedure :: lsq_fit_nurbs !!> Fit NURBS volume to structured data points using least squares ! Faces procedure :: cmp_elemFace_Xc_vis !!> Compute faces of the control points procedure :: cmp_elemFace_Xg_vis !!> Compute faces of the geometry points procedure :: cmp_elemFace !!> Compute faces of the IGA elements procedure :: cmp_degreeFace !!> Compute degrees of the faces ! Shapes procedure :: set_hexahedron !!> Set a hexahedron procedure :: set_ring !!> Set a ring procedure :: set_half_ring !!> Set a half ring procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg module procedure compute_Xg_nurbs_3d module procedure compute_Xg_bspline_3d module procedure compute_Xg_nurbs_3d_1point module procedure compute_Xg_bspline_3d_1point end interface interface compute_Tgc module procedure compute_Tgc_nurbs_3d_vector module procedure compute_Tgc_bspline_3d_vector module procedure compute_Tgc_nurbs_3d_scalar module procedure compute_Tgc_bspline_3d_scalar end interface interface compute_dTgc module procedure compute_dTgc_nurbs_3d_vector module procedure compute_dTgc_bspline_3d_vector module procedure compute_dTgc_nurbs_3d_scalar module procedure compute_dTgc_bspline_3d_scalar end interface interface compute_d2Tgc module procedure compute_d2Tgc_nurbs_3d_vector module procedure compute_d2Tgc_bspline_3d_vector module procedure compute_d2Tgc_nurbs_3d_scalar module procedure compute_d2Tgc_bspline_3d_scalar end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set1 ( this , knot1 , knot2 , knot3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % knot1 )) then if ( size ( this % knot1 ) /= size ( knot1 )) deallocate ( this % knot1 ) end if if ( allocated ( this % knot2 )) then if ( size ( this % knot2 ) /= size ( knot2 )) deallocate ( this % knot2 ) end if if ( allocated ( this % knot3 )) then if ( size ( this % knot3 ) /= size ( knot3 )) deallocate ( this % knot3 ) end if if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % knot1 = knot1 this % knot2 = knot2 this % knot3 = knot3 call this % cmp_degree () call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set1' ,& suggestion = 'Provide Wc with size(Wc) == nc(1)*nc(2)*nc(3).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , Xth_dir3 , degree , continuity1 , continuity2 , continuity3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:), Xth_dir3 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:), continuity3 (:) real ( rk ), intent ( in ), contiguous , optional :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % knot3 = compute_knot_vector ( Xth_dir3 , degree ( 3 ), continuity3 ) this % degree ( 1 ) = degree ( 1 ) this % degree ( 2 ) = degree ( 2 ) this % degree ( 3 ) = degree ( 3 ) call this % cmp_nc () if ( present ( Xc )) then if ( size ( Xc , 1 ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_volume' , & message = 'Control points size mismatch in set2' ,& location = 'set2' , & suggestion = 'size(Xc,1) must equal nc(1)*nc(2)*nc(3).' ) return end if end if if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_volume' , & message = 'Weights size mismatch in set2' ,& location = 'set2' , & suggestion = 'size(Wc) must equal nc(1)*nc(2)*nc(3).' ) return end if end if if ( present ( Xc )) then if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= size ( Xc , 1 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc end if if ( present ( Wc )) then if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier volume using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= nc ( 1 ) * nc ( 2 ) * nc ( 3 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc this % nc = nc if ( allocated ( this % knot1 )) then if ( size ( this % knot1 ) /= 2 * nc ( 1 )) then deallocate ( this % knot1 ) allocate ( this % knot1 ( 2 * this % nc ( 1 ))) end if else allocate ( this % knot1 ( 2 * this % nc ( 1 ))) end if this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) then if ( size ( this % knot2 ) /= 2 * nc ( 2 )) then deallocate ( this % knot2 ) allocate ( this % knot2 ( 2 * this % nc ( 2 ))) end if else allocate ( this % knot2 ( 2 * this % nc ( 2 ))) end if this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk if ( allocated ( this % knot3 )) then if ( size ( this % knot3 ) /= 2 * nc ( 3 )) then deallocate ( this % knot3 ) allocate ( this % knot3 ( 2 * this % nc ( 3 ))) end if else allocate ( this % knot3 ( 2 * this % nc ( 3 ))) end if this % knot3 ( 1 : this % nc ( 3 )) = 0.0_rk this % knot3 ( this % nc ( 3 ) + 1 : 2 * this % nc ( 3 )) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set3' ,& suggestion = 'Provide Wc with size(Wc) == nc(1)*nc(2)*nc(3).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set4 ( this , degree , nc , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) integer :: m ( 3 ), i if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( size ( this % Xc , 1 ) /= nc ( 1 ) * nc ( 2 ) * nc ( 3 ) . or . size ( this % Xc , 2 ) /= size ( Xc , 2 )) deallocate ( this % Xc ) end if this % Xc = Xc this % nc = nc this % degree = degree ! Size of knot vectors m = nc + degree + 1 if ( allocated ( this % knot1 )) then if ( size ( this % knot1 ) /= m ( 1 )) then deallocate ( this % knot1 ) allocate ( this % knot1 ( m ( 1 ))) end if else allocate ( this % knot1 ( m ( 1 ))) end if this % knot1 ( 1 : degree ( 1 ) + 1 ) = 0.0_rk this % knot1 ( degree ( 1 ) + 2 : m ( 1 ) - degree ( 1 ) - 1 ) = [( real ( i , rk ) / ( m ( 1 ) - 2 * degree ( 1 ) - 1 ), i = 1 , m ( 1 ) - 2 * degree ( 1 ) - 2 )] this % knot1 ( m ( 1 ) - degree ( 1 ): m ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) then if ( size ( this % knot2 ) /= m ( 2 )) then deallocate ( this % knot2 ) allocate ( this % knot2 ( m ( 2 ))) end if else allocate ( this % knot2 ( m ( 2 ))) end if this % knot2 ( 1 : degree ( 2 ) + 1 ) = 0.0_rk this % knot2 ( degree ( 2 ) + 2 : m ( 2 ) - degree ( 2 ) - 1 ) = [( real ( i , rk ) / ( m ( 2 ) - 2 * degree ( 2 ) - 1 ), i = 1 , m ( 2 ) - 2 * degree ( 2 ) - 2 )] this % knot2 ( m ( 2 ) - degree ( 2 ): m ( 2 )) = 1.0_rk if ( allocated ( this % knot3 )) then if ( size ( this % knot3 ) /= m ( 3 )) then deallocate ( this % knot3 ) allocate ( this % knot3 ( m ( 3 ))) end if else allocate ( this % knot3 ( m ( 3 ))) end if this % knot3 ( 1 : degree ( 3 ) + 1 ) = 0.0_rk this % knot3 ( degree ( 3 ) + 2 : m ( 3 ) - degree ( 3 ) - 1 ) = [( real ( i , rk ) / ( m ( 3 ) - 2 * degree ( 3 ) - 1 ), i = 1 , m ( 3 ) - 2 * degree ( 3 ) - 2 )] this % knot3 ( m ( 3 ) - degree ( 3 ): m ( 3 )) = 1.0_rk if ( present ( Wc )) then if ( size ( Wc ) /= nc ( 1 ) * nc ( 2 ) * nc ( 3 )) then call this % err % set (& code = 101 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Weights length mismatch: size(Wc) must equal number of control points.' ,& location = 'set4' ,& suggestion = 'Provide Wc with size(Wc) == nc(1)*nc(2)*nc(3).' ) return else if ( allocated ( this % Wc )) then if ( size ( this % Wc ) /= size ( Wc )) deallocate ( this % Wc ) end if this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Xt ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), intent ( in ), contiguous , optional :: Xt (:,:) integer :: i if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Control points are not set.' ,& location = 'create' ,& suggestion = 'Call set(...) first before create().' ) return end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 ) . or . . not . allocated ( this % knot3 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'create' ,& suggestion = 'Call set(...) first before create().' ) return end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= size ( Xt1 )) deallocate ( this % Xt1 ) end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= size ( Xt2 )) deallocate ( this % Xt2 ) end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) then if ( size ( this % Xt3 ) /= size ( Xt3 )) deallocate ( this % Xt3 ) end if this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) then if ( size ( this % Xt3 ) /= res3 ) then deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) end if else allocate ( this % Xt3 ( res3 )) end if this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if if ( present ( Xt )) then this % Xt = Xt else ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , this % Xt ) end if if ( allocated ( this % Xg )) then if ( size ( this % Xg , 1 ) /= product ( this % ng ) . or . size ( this % Xg , 2 ) /= size ( this % Xc , 2 )) then deallocate ( this % Xg ) allocate ( this % Xg ( product ( this % ng ), size ( this % Xc , 2 ))) end if else allocate ( this % Xg ( product ( this % ng ), size ( this % Xc , 2 ))) end if if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable :: Xg (:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 ) . or . . not . allocated ( this % knot3 )) then error stop 'Knot vector(s) is/are not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid direction for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if (. not . this % err % ok ) return if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid direction for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS volume is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS volume is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if (. not . this % err % ok ) return if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % Xt3 )) then Xt = this % Xt3 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_volume ), intent ( in ) :: this integer :: ng ( 3 ) if (. not . this % err % ok ) return ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this , dir ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: dir integer , allocatable :: m1 (:), m2 (:), m3 (:) if (. not . this % err % ok ) return if ( present ( dir )) then if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 else if ( dir == 3 ) then m3 = this % get_multiplicity ( 3 ) this % degree ( 3 ) = m3 ( 1 ) - 1 else call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid direction for degree.' ,& location = 'cmp_degree' ,& suggestion = 'Check the direction argument.' ) return end if else m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 m3 = this % get_multiplicity ( 3 ) this % degree ( 3 ) = m3 ( 1 ) - 1 end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer :: degree ( 3 ) if (. not . this % err % ok ) return degree ( 1 ) = this % degree ( 1 ) degree ( 2 ) = this % degree ( 2 ) degree ( 3 ) = this % degree ( 3 ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree if (. not . this % err % ok ) return if ( dir == 1 ) then degree = this % degree ( 1 ) else if ( dir == 2 ) then degree = this % degree ( 2 ) else if ( dir == 3 ) then degree = this % degree ( 3 ) else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if (. not . this % err % ok ) return if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then knot = this % knot3 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if (. not . this % err % ok ) return if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then if ( i < 1 . or . i > size ( this % knot3 )) then error stop 'Invalid index for knot vector.' else knot = this % knot3 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_volume ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xth ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if (. not . this % err % ok ) return if ( present ( p )) then elemConn = elemConn_C0 ( size ( unique ( this % knot1 )), size ( unique ( this % knot2 )), size ( unique ( this % knot3 )), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( size ( unique ( this % knot1 )), size ( unique ( this % knot2 )), size ( unique ( this % knot3 )), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename , point_data , field_names , encoding ) class ( nurbs_volume ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Control points are not set.' ,& location = 'export_Xc' ,& suggestion = 'Call set(...) first before exporting.' ) return end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if call export_vtk_legacy ( filename = filename , points = this % Xc , elemConn = elemConn , vtkCellType = 12 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename , point_data , field_names , encoding ) class ( nurbs_volume ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return ! check if (. not . allocated ( this % Xg )) then call this % err % set (& code = 104 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Geometry points are not set.' ,& location = 'export_Xg' ,& suggestion = 'Generate Xg by calling create(...) before exporting.' ) return end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if call export_vtk_legacy ( filename = filename , points = this % Xg , elemConn = elemConn , vtkCellType = 12 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth ( this , filename , point_data , field_names , encoding ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ), contiguous , optional :: point_data (:,:) character ( len =* ), intent ( in ), contiguous , optional :: field_names (:) character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Xth (:,:), Xth1 (:), Xth2 (:), Xth3 (:) if (. not . this % err % ok ) return elemConn = this % cmp_elem_Xth () Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) Xth3 = unique ( this % knot3 ) call ndgrid ( Xth1 , Xth2 , Xth3 , Xth ) call export_vtk_legacy ( filename = filename , points = Xth , elemConn = elemConn , vtkCellType = 12 , & point_data = point_data , field_names = field_names , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth_in_Xg ( this , filename , res , encoding ) class ( nurbs_volume ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename integer , intent ( in ), optional :: res ! min points per span (>=2) character ( len =* ), intent ( in ), optional :: encoding integer :: a , b , t , s , o , r , res_min , dim , i , j , k , ne_total , np , line_idx , m , N1sp , N2sp , N3sp , L , N , res1 , res2 , res3 , offsetP real ( rk ), allocatable :: U1 (:), U2 (:), U3 (:) ! unique knots real ( rk ), allocatable :: U1r (:), U2r (:), U3r (:) ! refined per dir (length N) real ( rk ), allocatable :: Xt_all (:,:), Xg_all (:,:) ! batched params & geometry integer , allocatable :: elemConn (:,:) ! [ne_total, N] if (. not . this % err % ok ) return if (. not . allocated ( this % Xc )) then call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Control points are not set.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Call set(...) first before exporting.' ) return end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 ) . or . . not . allocated ( this % knot3 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Call set(...) first before exporting.' ) return end if res_min = 10 if ( present ( res )) res_min = max ( 2 , res ) U1 = unique ( this % knot1 ) if ( size ( U1 ) < 2 ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'knot1 needs >= 2 unique values.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the knot vector for sufficient unique values.' ) return end if U2 = unique ( this % knot2 ) if ( size ( U2 ) < 2 ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'knot2 needs >= 2 unique values.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the knot vector for sufficient unique values.' ) return end if U3 = unique ( this % knot3 ) if ( size ( U3 ) < 2 ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'knot3 needs >= 2 unique values.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the knot vector for sufficient unique values.' ) return end if ! spans per direction N1sp = size ( U1 ) - 1 N2sp = size ( U2 ) - 1 N3sp = size ( U3 ) - 1 L = N1sp a = L b = N2sp do t = mod ( a , b ) if ( t == 0 ) exit a = b b = t end do L = ( L / b ) * N2sp a = L b = N3sp do t = mod ( a , b ) if ( t == 0 ) exit a = b b = t end do L = ( L / b ) * N3sp L = L * max ( 1 , res_min - 1 ) N = L + 1 res1 = L / N1sp + 1 res2 = L / N2sp + 1 res3 = L / N3sp + 1 dim = size ( this % Xc , 2 ) if ( dim < 2 . or . dim > 3 ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid geometry dimension.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the geometry dimension before exporting the NURBS volume.' ) return end if ! Allocate refined knot vectors allocate ( U1r ( ( size ( U1 ) - 1 ) * ( res1 - 1 ) + 1 )) allocate ( U2r ( ( size ( U2 ) - 1 ) * ( res2 - 1 ) + 1 )) allocate ( U3r ( ( size ( U3 ) - 1 ) * ( res3 - 1 ) + 1 )) do s = 1 , size ( U1 ) - 1 o = ( s - 1 ) * ( res1 - 1 ) do r = 1 , res1 U1r ( o + r ) = U1 ( s ) + ( U1 ( s + 1 ) - U1 ( s )) * real ( r - 1 , rk ) / real ( res1 - 1 , rk ) end do end do do s = 1 , size ( U2 ) - 1 o = ( s - 1 ) * ( res2 - 1 ) do r = 1 , res2 U2r ( o + r ) = U2 ( s ) + ( U2 ( s + 1 ) - U2 ( s )) * real ( r - 1 , rk ) / real ( res2 - 1 , rk ) end do end do do s = 1 , size ( U3 ) - 1 o = ( s - 1 ) * ( res3 - 1 ) do r = 1 , res3 U3r ( o + r ) = U3 ( s ) + ( U3 ( s + 1 ) - U3 ( s )) * real ( r - 1 , rk ) / real ( res3 - 1 , rk ) end do end do if ( size ( U1r ) /= N . or . size ( U2r ) /= N . or . size ( U3r ) /= N ) then call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Refinement size mismatch.' ,& location = 'export_Xth_in_Xg' ,& suggestion = 'Check the refinement process for consistency.' ) return end if ! total element count and node count ne_total = size ( U2 ) * size ( U3 ) + size ( U1 ) * size ( U3 ) + size ( U1 ) * size ( U2 ) np = ne_total * N ! Allocate global arrays allocate ( Xt_all ( np , 3 ), Xg_all ( np , dim ), elemConn ( ne_total , N )) ! build all parametric points line_idx = 0 offsetP = 0 ! dir-1: u varies (v=U2(j), w=U3(k)) do k = 1 , size ( U3 ) do j = 1 , size ( U2 ) line_idx = line_idx + 1 Xt_all ( offsetP + 1 : offsetP + N , 1 ) = U1r Xt_all ( offsetP + 1 : offsetP + N , 2 ) = U2 ( j ) Xt_all ( offsetP + 1 : offsetP + N , 3 ) = U3 ( k ) offsetP = offsetP + N end do end do ! dir-2: v varies (u=U1(i), w=U3(k)) do k = 1 , size ( U3 ) do i = 1 , size ( U1 ) line_idx = line_idx + 1 Xt_all ( offsetP + 1 : offsetP + N , 1 ) = U1 ( i ) Xt_all ( offsetP + 1 : offsetP + N , 2 ) = U2r Xt_all ( offsetP + 1 : offsetP + N , 3 ) = U3 ( k ) offsetP = offsetP + N end do end do ! dir-3: w varies (u=U1(i), v=U2(j)) do j = 1 , size ( U2 ) do i = 1 , size ( U1 ) line_idx = line_idx + 1 Xt_all ( offsetP + 1 : offsetP + N , 1 ) = U1 ( i ) Xt_all ( offsetP + 1 : offsetP + N , 2 ) = U2 ( j ) Xt_all ( offsetP + 1 : offsetP + N , 3 ) = U3r offsetP = offsetP + N end do end do ! compute global points if ( this % is_rational ()) then Xg_all = compute_Xg ( Xt_all , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , & [ np , 1 , 1 ], this % Xc , this % Wc ) else Xg_all = compute_Xg ( Xt_all , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , & [ np , 1 , 1 ], this % Xc ) end if ! connectivity do concurrent ( l = 1 : ne_total , m = 1 : N ) elemConn ( l , m ) = ( l - 1 ) * N + m end do ! write VTK file call export_vtk_legacy ( filename = filename , points = Xg_all , elemConn = elemConn , vtkCellType = 4 , encoding = encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if (. not . this % err % ok ) return if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc ()) end if else call this % err % set (& code = 102 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Control points are not set.' ,& location = 'modify_Xc' ,& suggestion = 'Call set(...) before modifying it.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if (. not . this % err % ok ) return if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot1 ) . and . allocated ( this % knot2 ) . and . allocated ( this % knot3 )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( nc = this % nc , Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else call this % err % set (& code = 105 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Weights are not set.' ,& location = 'modify_Wc' ,& suggestion = 'Pass Wc when calling set(...), before modifying weights.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if (. not . this % err % ok ) return if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if (. not . this % err % ok ) return if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else c = this % degree ( 3 ) - compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this , dir ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: dir if (. not . this % err % ok ) return if ( present ( dir )) then if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 3 ) = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if else call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid direction for computing number of control points.' ,& location = 'cmp_nc' ,& suggestion = 'Use dir=1 or dir=2 to specify the direction.' ) return end if else ! check if (. not . allocated ( this % knot1 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if ! check if (. not . allocated ( this % knot2 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if ! check if (. not . allocated ( this % knot3 )) then call this % err % set (& code = 103 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Knot vector is not set.' ,& location = 'cmp_nc' ,& suggestion = 'Call set(...) first before computing nc.' ) return else this % nc ( 3 ) = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_all ( this ) result ( nc ) class ( nurbs_volume ), intent ( in ) :: this integer :: nc ( 3 ) if (. not . this % err % ok ) return nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_dir ( this , dir ) result ( nc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if (. not . this % err % ok ) return if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( Xt1 , 1 ) /= size ( this % Xt1 , 1 )) deallocate ( this % Xt1 ) end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 , 1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( Xt2 , 1 ) /= size ( this % Xt2 , 1 )) deallocate ( this % Xt2 ) end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 , 1 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) then if ( size ( Xt3 , 1 ) /= size ( this % Xt3 , 1 )) deallocate ( this % Xt3 ) end if this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) then if ( size ( this % Xt3 , 1 ) /= res3 ) then deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) end if else allocate ( this % Xt3 ( res3 )) end if this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc , elem ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS if ( present ( elem )) then associate ( Wce => this % Wc ( elem )) call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , Wce , dTgc , Tgc , elem ) end associate else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc , dTgc , Tgc ) end if else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , dTgc , Tgc , elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , d2Tgc , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( Xt1 , 1 ) /= size ( this % Xt1 , 1 )) deallocate ( this % Xt1 ) end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 , 1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( Xt2 , 1 ) /= size ( this % Xt2 , 1 )) deallocate ( this % Xt2 ) end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 , 1 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) then if ( size ( Xt3 , 1 ) /= size ( this % Xt3 , 1 )) deallocate ( this % Xt3 ) end if this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) then if ( size ( this % Xt3 , 1 ) /= res3 ) then deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) end if else allocate ( this % Xt3 ( res3 )) end if this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) if (. not . this % err % ok ) return ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) then if ( size ( Xt1 , 1 ) /= size ( this % Xt1 , 1 )) deallocate ( this % Xt1 ) end if this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) then if ( size ( this % Xt1 , 1 ) /= res1 ) then deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) end if else allocate ( this % Xt1 ( res1 )) end if this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) then if ( size ( Xt2 , 1 ) /= size ( this % Xt2 , 1 )) deallocate ( this % Xt2 ) end if this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) then if ( size ( this % Xt2 , 1 ) /= res2 ) then deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) end if else allocate ( this % Xt2 ( res2 )) end if this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) then if ( size ( Xt3 , 1 ) /= size ( this % Xt3 , 1 )) deallocate ( this % Xt3 ) end if this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) then if ( size ( this % Xt3 , 1 ) /= res3 ) then deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) end if else allocate ( this % Xt3 ( res3 )) end if this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc ) else Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) if (. not . this % err % ok ) return if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc ) else Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r , B , Bs ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), contiguous , intent ( in ) :: Xth (:) integer , contiguous , intent ( in ) :: r (:) real ( rk ), allocatable , optional , intent ( out ) :: B (:,:) real ( rk ), allocatable , optional , intent ( out ) :: Bs (:,:) integer :: k , i , s , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:), H (:,:) integer :: nc_old ( 3 ), dim , ncp_old , n1_old real ( rk ), allocatable :: Wc_old (:) real ( rk ), allocatable :: A1 (:,:), A_re_loc (:,:) if (. not . this % err % ok ) return dim = size ( this % Xc , 2 ) if ( present ( B ) . or . present ( Bs )) then nc_old = this % nc ncp_old = size ( this % Xc , 1 ) if ( this % is_rational ()) then allocate ( Wc_old ( ncp_old )) Wc_old = this % Wc end if select case ( dir ) case ( 1 ) n1_old = nc_old ( 1 ) case ( 2 ) n1_old = nc_old ( 2 ) case ( 3 ) n1_old = nc_old ( 3 ) case default call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid direction for inserting knots.' ,& location = 'insert_knots' ,& suggestion = 'Use dir=1 or dir=2 or dir=3 to specify the direction.' ) return end select allocate ( A1 ( n1_old , n1_old ), source = 0.0_rk ) do concurrent ( j = 1 : n1_old ) A1 ( j , j ) = 1.0_rk end do end if if ( dir == 1 ) then if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( j = 1 : size ( this % Xc , 1 )) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 )]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xcw ) H = reshape ( Xcw , [ ( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do j = 1 , dim C (:, j ) = C (:, j ) / H (:, dim + 1 ) end do call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = C , Wc = W ) end associate deallocate ( H ) end do else Xc = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 1 ), this % knot1 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xc ) H = reshape ( Xc , [( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), dim ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = H ) deallocate ( H ) end do end if elseif ( dir == 2 ) then if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( j = 1 : size ( this % Xc , 1 )) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 )]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xcw ) Xc4 = reshape ( Xcw , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do j = 1 , dim C (:, j ) = C (:, j ) / W (:) end do call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = C , Wc = W ) end associate deallocate ( H ) end do else Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 2 ), this % knot2 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xc ) Xc4 = reshape ( Xc , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = H ) deallocate ( H ) end do end if elseif ( dir == 3 ) then if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( j = 1 : size ( this % Xc , 1 )) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 )]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( abs ( this % knot3 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 3 ), this % knot3 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 3 ), this % knot3 , Xcw , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xcw ) Xc4 = reshape ( Xcw , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do j = 1 , dim C (:, j ) = C (:, j ) / W (:) end do call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = C , Wc = W ) end associate deallocate ( H ) end do else Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( abs ( this % knot3 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if if ( present ( B ) . or . present ( Bs )) then call insert_knot_A_5_1 ( this % degree ( 3 ), this % knot3 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new , A_re_loc ) A1 = matmul ( A_re_loc , A1 ) else call insert_knot_A_5_1 ( this % degree ( 3 ), this % knot3 , Xc , Xth ( i ), k , s , r ( i ), n_new , knot_new , Xcw_new ) end if call move_alloc ( Xcw_new , Xc ) Xc4 = reshape ( Xc , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , dim ], order = [ 3 , 2 , 1 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = H ) deallocate ( H ) end do end if else call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid direction for inserting knots.' ,& location = 'insert_knots' ,& suggestion = 'Use dir=1 or dir=2 or dir=3 to specify the direction.' ) return end if if ( present ( B ) . or . present ( Bs )) then block real ( rk ), allocatable :: S_loc (:,:) integer :: nc1 , nc2 , nc3 , n1_new integer :: i1 , j1 , i2 , i3 , i2_old , i2_new , ii , i3_old , i3_new integer :: mS , nS , c nc1 = this % nc ( 1 ) nc2 = this % nc ( 2 ) nc3 = this % nc ( 3 ) select case ( dir ) case ( 1 ) n1_new = this % nc ( 1 ) mS = n1_new * nc2 * nc3 nS = nc_old ( 1 ) * nc2 * nc3 allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i3 = 0 : nc3 - 1 , i2 = 0 : nc2 - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : n1_new , A1 ( i1 , j1 ) /= 0.0_rk ) S_loc (( i3 * nc2 + i2 ) * n1_new + i1 ,( i3 * nc2 + i2 ) * nc_old ( 1 ) + j1 ) = A1 ( i1 , j1 ) * Wc_old (( i3 * nc2 + i2 ) * nc_old ( 1 ) + j1 ) / this % Wc (( i3 * nc2 + i2 ) * n1_new + i1 ) end do else do concurrent ( i3 = 0 : nc3 - 1 , i2 = 0 : nc2 - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : n1_new , A1 ( i1 , j1 ) /= 0.0_rk ) S_loc (( i3 * nc2 + i2 ) * n1_new + i1 ,( i3 * nc2 + i2 ) * nc_old ( 1 ) + j1 ) = A1 ( i1 , j1 ) end do end if case ( 2 ) n1_new = this % nc ( 2 ) mS = n1_new * nc1 * nc3 nS = nc_old ( 2 ) * nc1 * nc3 allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i3 = 0 : nc3 - 1 , i2_old = 1 : nc_old ( 2 ), i2_new = 1 : n1_new , ii = 0 : nc1 - 1 , A1 ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * nc1 + i3 * nc1 * n1_new , ii + 1 + ( i2_old - 1 ) * nc1 + i3 * nc1 * nc_old ( 2 )) = A1 ( i2_new , i2_old ) * Wc_old ( ii + 1 + ( i2_old - 1 ) * nc1 + i3 * nc1 * nc_old ( 2 )) / this % Wc ( ii + 1 + ( i2_new - 1 ) * nc1 + i3 * nc1 * n1_new ) end do else do concurrent ( i3 = 0 : nc3 - 1 , i2_old = 1 : nc_old ( 2 ), i2_new = 1 : n1_new , ii = 0 : nc1 - 1 , A1 ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * nc1 + i3 * nc1 * n1_new , ii + 1 + ( i2_old - 1 ) * nc1 + i3 * nc1 * nc_old ( 2 )) = A1 ( i2_new , i2_old ) end do end if case ( 3 ) n1_new = this % nc ( 3 ) mS = n1_new * nc1 * nc2 nS = nc_old ( 3 ) * nc1 * nc2 allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i3_old = 1 : nc_old ( 3 ), i3_new = 1 : n1_new , i2 = 0 : nc2 - 1 , ii = 0 : nc1 - 1 , A1 ( i3_new , i3_old ) /= 0.0_rk ) S_loc ( ii + 1 + i2 * nc1 + ( i3_new - 1 ) * nc1 * nc2 , ii + 1 + i2 * nc1 + ( i3_old - 1 ) * nc1 * nc2 ) = A1 ( i3_new , i3_old ) * Wc_old ( ii + 1 + i2 * nc1 + ( i3_old - 1 ) * nc1 * nc2 ) / this % Wc ( ii + 1 + i2 * nc1 + ( i3_new - 1 ) * nc1 * nc2 ) end do else do concurrent ( i3_old = 1 : nc_old ( 3 ), i3_new = 1 : n1_new , i2 = 0 : nc2 - 1 , ii = 0 : nc1 - 1 , A1 ( i3_new , i3_old ) /= 0.0_rk ) S_loc ( ii + 1 + i2 * nc1 + ( i3_new - 1 ) * nc1 * nc2 , ii + 1 + i2 * nc1 + ( i3_old - 1 ) * nc1 * nc2 ) = A1 ( i3_new , i3_old ) end do end if end select if ( present ( B )) then allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = S_loc end do end if if ( present ( Bs )) then call move_alloc ( S_loc , Bs ) else deallocate ( S_loc ) end if end block end if end subroutine !=============================================================================== !=============================================================================== !> author:  Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t , B , Bs ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable , optional , intent ( out ) :: B (:,:) real ( rk ), allocatable , optional , intent ( out ) :: Bs (:,:) integer :: n1_new real ( rk ), allocatable :: knot_new (:) real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), H (:,:), Xc4 (:,:,:,:) real ( rk ), allocatable :: Tdir (:,:) integer :: nc_old ( 3 ), dim , ncp_old , mS , nS , c real ( rk ), allocatable :: Wc_old (:), S_loc (:,:) integer :: i1 , j1 , i2 , i3 , i2_old , i2_new , ii , i3_old , i3_new if (. not . this % err % ok ) return dim = size ( this % Xc , 2 ) if ( present ( B ) . or . present ( Bs )) then nc_old = this % nc ncp_old = size ( this % Xc , 1 ) if ( this % is_rational ()) then allocate ( Wc_old ( ncp_old )); Wc_old = this % Wc end if end if select case ( dir ) case ( 1 ) if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( i1 = 1 : size ( this % Xc , 1 )) Xcw ( i1 , 1 : dim ) = this % Xc ( i1 , 1 : dim ) * this % Wc ( i1 ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 ) ]) if ( present ( B ) . or . present ( Bs )) then call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , n1_new , knot_new , Xcw_new , Tdir ) else call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , n1_new , knot_new , Xcw_new ) end if H = reshape ( Xcw_new , [ n1_new * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do i1 = 1 , dim C (:, i1 ) = C (:, i1 ) / W (:) end do call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = C , Wc = W ) end associate deallocate ( H , Xcw , Xcw_new ) else Xc = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ]) if ( present ( B ) . or . present ( Bs )) then call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , n1_new , knot_new , Xcw_new , Tdir ) else call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , n1_new , knot_new , Xcw_new ) end if H = reshape ( Xcw_new , [ n1_new * this % nc ( 2 ) * this % nc ( 3 ), dim ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = H ) deallocate ( H , Xc , Xcw_new ) end if case ( 2 ) if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( i1 = 1 : size ( this % Xc , 1 )) Xcw ( i1 , 1 : dim ) = this % Xc ( i1 , 1 : dim ) * this % Wc ( i1 ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 ) ]) if ( present ( B ) . or . present ( Bs )) then call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , n1_new , knot_new , Xcw_new , Tdir ) else call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , n1_new , knot_new , Xcw_new ) end if Xc4 = reshape ( Xcw_new , [ n1_new , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n1_new , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * n1_new * this % nc ( 3 ), dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do i1 = 1 , dim C (:, i1 ) = C (:, i1 ) / W (:) end do call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = C , Wc = W ) end associate deallocate ( H , Xcw , Xcw_new , Xc4 ) else Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) if ( present ( B ) . or . present ( Bs )) then call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , n1_new , knot_new , Xcw_new , Tdir ) else call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , n1_new , knot_new , Xcw_new ) end if Xc4 = reshape ( Xcw_new , [ n1_new , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n1_new , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * n1_new * this % nc ( 3 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = H ) deallocate ( H , Xc , Xc4 , Xcw_new ) end if case ( 3 ) if ( this % is_rational ()) then allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do concurrent ( i1 = 1 : size ( this % Xc , 1 )) Xcw ( i1 , 1 : dim ) = this % Xc ( i1 , 1 : dim ) * this % Wc ( i1 ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 ) ]) if ( present ( B ) . or . present ( Bs )) then call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xcw , n1_new , knot_new , Xcw_new , Tdir ) else call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xcw , n1_new , knot_new , Xcw_new ) end if Xc4 = reshape ( Xcw_new , [ n1_new , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n1_new , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * n1_new , dim + 1 ]) associate ( C => H (:, 1 : dim ), W => H (:, dim + 1 )) do i1 = 1 , dim C (:, i1 ) = C (:, i1 ) / W (:) end do call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = C , Wc = W ) end associate deallocate ( H , Xcw , Xcw_new , Xc4 ) else Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) if ( present ( B ) . or . present ( Bs )) then call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xc , n1_new , knot_new , Xcw_new , Tdir ) else call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xc , n1_new , knot_new , Xcw_new ) end if Xc4 = reshape ( Xcw_new , [ n1_new , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n1_new , dim ], order = [ 3 , 2 , 1 , 4 ]) H = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * n1_new , dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = H ) deallocate ( H , Xc , Xc4 , Xcw_new ) end if case default call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid direction for elevating degree.' ,& location = 'elevate_degree' ,& suggestion = 'Use dir=1 or dir=2 or dir=3 to specify the direction.' ) return end select if ( present ( B ) . or . present ( Bs )) then select case ( dir ) case ( 1 ) mS = this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) nS = nc_old ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i3 = 0 : this % nc ( 3 ) - 1 , i2 = 0 : this % nc ( 2 ) - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : this % nc ( 1 ), Tdir ( i1 , j1 ) /= 0.0_rk ) S_loc (( i3 * this % nc ( 2 ) + i2 ) * this % nc ( 1 ) + i1 ,( i3 * this % nc ( 2 ) + i2 ) * nc_old ( 1 ) + j1 ) = Tdir ( i1 , j1 ) * Wc_old (( i3 * this % nc ( 2 ) + i2 ) * nc_old ( 1 ) + j1 ) / this % Wc (( i3 * this % nc ( 2 ) + i2 ) * this % nc ( 1 ) + i1 ) end do else do concurrent ( i3 = 0 : this % nc ( 3 ) - 1 , i2 = 0 : this % nc ( 2 ) - 1 , j1 = 1 : nc_old ( 1 ), i1 = 1 : this % nc ( 1 ), Tdir ( i1 , j1 ) /= 0.0_rk ) S_loc (( i3 * this % nc ( 2 ) + i2 ) * this % nc ( 1 ) + i1 ,( i3 * this % nc ( 2 ) + i2 ) * nc_old ( 1 ) + j1 ) = Tdir ( i1 , j1 ) end do end if case ( 2 ) mS = this % nc ( 2 ) * this % nc ( 1 ) * this % nc ( 3 ) nS = nc_old ( 2 ) * this % nc ( 1 ) * this % nc ( 3 ) allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i3 = 0 : this % nc ( 3 ) - 1 , i2_old = 1 : nc_old ( 2 ), i2_new = 1 : this % nc ( 2 ), ii = 0 : this % nc ( 1 ) - 1 , Tdir ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * this % nc ( 1 ) + i3 * this % nc ( 1 ) * this % nc ( 2 ), ii + 1 + ( i2_old - 1 ) * this % nc ( 1 ) + i3 * this % nc ( 1 ) * nc_old ( 2 )) = Tdir ( i2_new , i2_old ) * Wc_old ( ii + 1 + ( i2_old - 1 ) * this % nc ( 1 ) + i3 * this % nc ( 1 ) * nc_old ( 2 )) / this % Wc ( ii + 1 + ( i2_new - 1 ) * this % nc ( 1 ) + i3 * this % nc ( 1 ) * this % nc ( 2 )) end do else do concurrent ( i3 = 0 : this % nc ( 3 ) - 1 , i2_old = 1 : nc_old ( 2 ), i2_new = 1 : this % nc ( 2 ), ii = 0 : this % nc ( 1 ) - 1 , Tdir ( i2_new , i2_old ) /= 0.0_rk ) S_loc ( ii + 1 + ( i2_new - 1 ) * this % nc ( 1 ) + i3 * this % nc ( 1 ) * this % nc ( 2 ), ii + 1 + ( i2_old - 1 ) * this % nc ( 1 ) + i3 * this % nc ( 1 ) * nc_old ( 2 )) = Tdir ( i2_new , i2_old ) end do end if case ( 3 ) mS = this % nc ( 3 ) * this % nc ( 1 ) * this % nc ( 2 ) nS = nc_old ( 3 ) * this % nc ( 1 ) * this % nc ( 2 ) allocate ( S_loc ( mS , nS ), source = 0.0_rk ) if ( this % is_rational ()) then do concurrent ( i3_old = 1 : nc_old ( 3 ), i3_new = 1 : this % nc ( 3 ), i2 = 0 : this % nc ( 2 ) - 1 , ii = 0 : this % nc ( 1 ) - 1 , Tdir ( i3_new , i3_old ) /= 0.0_rk ) S_loc ( ii + 1 + i2 * this % nc ( 1 ) + ( i3_new - 1 ) * this % nc ( 1 ) * this % nc ( 2 ), ii + 1 + i2 * this % nc ( 1 ) + ( i3_old - 1 ) * this % nc ( 1 ) * this % nc ( 2 )) = Tdir ( i3_new , i3_old ) * Wc_old ( ii + 1 + i2 * this % nc ( 1 ) + ( i3_old - 1 ) * this % nc ( 1 ) * this % nc ( 2 )) / this % Wc ( ii + 1 + i2 * this % nc ( 1 ) + ( i3_new - 1 ) * this % nc ( 1 ) * this % nc ( 2 )) end do else do concurrent ( i3_old = 1 : nc_old ( 3 ), i3_new = 1 : this % nc ( 3 ), i2 = 0 : this % nc ( 2 ) - 1 , ii = 0 : this % nc ( 1 ) - 1 , Tdir ( i3_new , i3_old ) /= 0.0_rk ) S_loc ( ii + 1 + i2 * this % nc ( 1 ) + ( i3_new - 1 ) * this % nc ( 1 ) * this % nc ( 2 ), ii + 1 + i2 * this % nc ( 1 ) + ( i3_old - 1 ) * this % nc ( 1 ) * this % nc ( 2 )) = Tdir ( i3_new , i3_old ) end do end if end select if ( present ( Bs )) then call move_alloc ( S_loc , Bs ) end if if ( present ( B )) then if (. not . present ( Bs )) then allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = S_loc end do deallocate ( S_loc ) else allocate ( B ( mS * dim , nS * dim ), source = 0.0_rk ) do c = 1 , dim B ( c : mS * dim : dim , c : nS * dim : dim ) = Bs end do end if end if if ( allocated ( Wc_old )) deallocate ( Wc_old ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_volume ), intent ( in ) :: this logical :: r if (. not . this % err % ok ) return r = . false . if ( allocated ( this % Wc )) then ! if (any(this%Wc /= this%Wc(1))) then if ( any ( abs ( this % Wc - this % Wc ( 1 )) > 2.0_rk * epsilon ( 0.0_rk ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn_Xc_vis )) then if ( size ( this % elemConn_Xc_vis , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn_Xc_vis , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn_Xc_vis ) end if end if this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn_Xg_vis )) then if ( size ( this % elemConn_Xg_vis , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn_Xg_vis , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn_Xg_vis ) end if end if this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if (. not . this % err % ok ) return if ( allocated ( this % elemConn )) then if ( size ( this % elemConn , 1 ) /= size ( elemConn , 1 ) . or . size ( this % elemConn , 2 ) /= size ( elemConn , 2 )) then deallocate ( this % elemConn ) end if end if this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_hexahedron ( this , L , nc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: L (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if (. not . this % err % ok ) return if ( present ( Wc )) then call this % set ( nc , hexahedron_Xc ( L , nc ), Wc ) else call this % set ( nc , hexahedron_Xc ( L , nc )) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine put_to_nurbs ( this , X , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: X (:,:) integer , intent ( in ), contiguous , optional :: elemConn (:,:) real ( rk ), allocatable :: Xt (:,:) real ( rk ) :: min_X1 , max_X1 , min_X2 , max_X2 , min_X3 , max_X3 if (. not . this % err % ok ) return ! Normalize the X coordinates to the range of knot vectors allocate ( Xt ( size ( X , 1 ), size ( X , 2 ))) min_X1 = minval ( X (:, 1 )) max_X1 = maxval ( X (:, 1 )) min_X2 = minval ( X (:, 2 )) max_X2 = maxval ( X (:, 2 )) min_X3 = minval ( X (:, 3 )) max_X3 = maxval ( X (:, 3 )) Xt (:, 1 ) = ( X (:, 1 ) - min_X1 ) / ( max_X1 - min_X1 ) * ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) + this % knot1 ( 1 ) Xt (:, 2 ) = ( X (:, 2 ) - min_X2 ) / ( max_X2 - min_X2 ) * ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) + this % knot2 ( 1 ) Xt (:, 3 ) = ( X (:, 3 ) - min_X3 ) / ( max_X3 - min_X3 ) * ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) + this % knot3 ( 1 ) if ( this % is_rational ()) then this % Xg = compute_Xg ( Xt = Xt , knot1 = this % knot1 , knot2 = this % knot2 , knot3 = this % knot3 , degree = this % degree , nc = this % nc , Xc = this % Xc , Wc = this % Wc ) else this % Xg = compute_Xg ( Xt = Xt , knot1 = this % knot1 , knot2 = this % knot2 , knot3 = this % knot3 , degree = this % degree , nc = this % nc , Xc = this % Xc ) end if if ( present ( elemConn )) call this % set_elem_Xg_vis ( elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:) if (. not . this % err % ok ) return if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) ! if (this%knot1(k+1) == Xth(i)) then if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( d + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), d + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , ( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) ! if (this%knot1(k+1) == Xth(i)) then if ( abs ( this % knot1 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc_new = reshape ( Xc_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), d ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) ! if (this%knot2(k+1) == Xth(i)) then if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( d + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) ! if (this%knot2(k+1) == Xth(i)) then if ( abs ( this % knot2 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if end do end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) ! if (this%knot3(k+1) == Xth(i)) then if ( abs ( this % knot3 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( d + 1 )]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) ! if (this%knot3(k+1) == Xth(i)) then if ( abs ( this % knot3 ( k + 1 ) - Xth ( i )) < 2.0_rk * epsilon ( 0.0_rk )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , d ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new ) end if end do end if else call this % err % set (& code = 100 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid direction for removing knots.' ,& location = 'remove_knots' ,& suggestion = 'Use dir=1 or dir=2 or dir=3 to specify the direction.' ) return end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) if (. not . this % err % ok ) return call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ),& this % degree ( 1 ), this % degree ( 2 ), this % degree ( 3 ),& unique ( this % knot1 ), unique ( this % knot2 ), unique ( this % knot3 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ), this % get_multiplicity ( 3 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i if (. not . this % err % ok ) return do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i if (. not . this % err % ok ) return do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: vec (:) integer :: i if (. not . this % err % ok ) return do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: vec (:) integer :: i if (. not . this % err % ok ) return do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg , vtkfile_Xth_in_Xg ) class ( nurbs_volume ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len =* ), intent ( in ), optional :: vtkfile_Xth_in_Xg #ifndef NOSHOW_PYVISTA block character ( len = 3000 ) :: pyvista_script if (. not . this % err % ok ) return pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"Xg = Xg.clean(tolerance=1e-12)\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=1,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    smooth_shading=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels([point_coords],[label],font_size=14,text_color='black',show_points=False,fill_shape=False,shape=None)\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag): actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag): actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):  actor_Xg.SetVisibility(flag)\" // achar ( 10 ) if ( present ( vtkfile_Xth_in_Xg )) then pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"Xth = pv.read('\" // trim ( vtkfile_Xth_in_Xg ) // \"')\" // achar ( 10 ) // & \"actor_Xth = p.add_mesh(\" // achar ( 10 ) // & \"    Xth,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    color='magenta',\" // achar ( 10 ) // & \"    line_width=2,\" // achar ( 10 ) // & \"    opacity=0.7\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"def Xth_toggle_vis(flag): actor_Xth.SetVisibility(flag)\" end if pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xcp_toggle_vis, value=True, color_on='red',    size=25, position=(0, y_pos - 1*25))\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xcw_toggle_vis, value=True, color_on='yellow', size=25, position=(0, y_pos - 2*25))\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xg_toggle_vis,  value=True, color_on='cyan',   size=25, position=(0, y_pos - 3*25))\" // achar ( 10 ) // & \"p.add_text('Xc (Points)',             position=(28, y_pos - 1*25), font_size=8, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text('Xc (Control geometry)',   position=(28, y_pos - 2*25), font_size=8, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text('Xg (Geometry)',           position=(28, y_pos - 3*25), font_size=8, color='black', font='times')\" if ( present ( vtkfile_Xth_in_Xg )) then pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"p.add_checkbox_button_widget(Xth_toggle_vis, value=True, color_on='magenta', size=25, position=(0, y_pos - 4*25))\" // achar ( 10 ) // & \"p.add_text('Xth (Parameter)', position=(28, y_pos - 4*25), font_size=8, color='black', font='times')\" end if pyvista_script = trim ( adjustl ( pyvista_script )) // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text('https://github.com/gha3mi/forcad', position=(0.0, 0.0), font_size=7, color='blue', font='times')\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" // achar ( 10 ) // & \"p.deep_clean()\" // achar ( 10 ) // & \"del p\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end block #endif end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_ring ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i if (. not . this % err % ok ) return ! Define control points for ring allocate ( Xc ( 28 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 7 , 1 : 2 ) = Xc ( 1 : 7 , 1 : 2 ) * radius1 Xc ( 8 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 11 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 12 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 13 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 14 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 8 : 14 , 1 : 2 ) = Xc ( 8 : 14 , 1 : 2 ) * radius2 Xc ( 15 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 16 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 17 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 18 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 19 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 20 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), length ] Xc ( 21 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 15 : 21 , 1 : 2 ) = Xc ( 15 : 21 , 1 : 2 ) * radius1 Xc ( 22 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 23 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 24 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 25 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 26 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 27 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), length ] Xc ( 28 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 22 : 28 , 1 : 2 ) = Xc ( 22 : 28 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i if (. not . this % err % ok ) return ! Define control points for C-shape allocate ( Xc ( 20 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 8 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 Xc ( 11 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 12 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 13 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 14 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 15 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 11 : 15 , 1 : 2 ) = Xc ( 11 : 15 , 1 : 2 ) * radius1 Xc ( 16 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 17 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 18 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 19 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 20 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 16 : 20 , 1 : 2 ) = Xc ( 16 : 20 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_ring ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i if (. not . this % err % ok ) return ! Define control points for half ring allocate ( Xc ( 20 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 8 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 Xc ( 11 ,:) = [ 0.5_rk , 0.0_rk , length ] Xc ( 12 ,:) = [ 0.5_rk , 0.5_rk , length ] Xc ( 13 ,:) = [ 0.0_rk , 0.5_rk , length ] Xc ( 14 ,:) = [ - 0.5_rk , 0.5_rk , length ] Xc ( 15 ,:) = [ - 0.5_rk , 0.0_rk , length ] Xc ( 11 : 15 , 1 : 2 ) = Xc ( 11 : 15 , 1 : 2 ) * radius1 Xc ( 16 ,:) = [ 0.5_rk , 0.0_rk , length ] Xc ( 17 ,:) = [ 0.5_rk , 0.5_rk , length ] Xc ( 18 ,:) = [ 0.0_rk , 0.5_rk , length ] Xc ( 19 ,:) = [ - 0.5_rk , 0.5_rk , length ] Xc ( 20 ,:) = [ - 0.5_rk , 0.0_rk , length ] Xc ( 16 : 20 , 1 : 2 ) = Xc ( 16 : 20 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), intent ( out ), optional :: nearest_Xg ( size ( point_Xg )) real ( rk ), intent ( out ), optional :: nearest_Xt ( 3 ) integer , intent ( out ), optional :: id integer :: id_ , i real ( rk ), allocatable :: distances (:) if (. not . this % err % ok ) return allocate ( distances ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ))) #if defined(__NVCOMPILER) do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) #else do concurrent ( i = 1 : this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 )) #endif distances ( i ) = norm2 ( this % Xg ( i ,:) - point_Xg ) end do ! replaced minloc due to NVFortran bug #if defined(__NVCOMPILER) id_ = 1 do i = 2 , size ( distances ) if ( distances ( i ) < distances ( id_ )) id_ = i end do #else id_ = minloc ( distances , dim = 1 ) #endif if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt ( 3 ) real ( rk ), intent ( out ), optional :: nearest_Xg ( size ( this % Xc , 2 )) real ( rk ) :: obj , obj_trial , grad ( 3 ), hess ( 3 , 3 ), dk ( 3 ) real ( rk ) :: alphak , alpha_max , alpha_i , tau , beta , eps real ( rk ) :: lower_bounds ( 3 ), upper_bounds ( 3 ), xt ( 3 ) real ( rk ), allocatable :: Tgc (:), dTgc (:,:), d2Tgc (:,:) real ( rk ) :: Xg ( size ( this % Xc , 2 )), xk ( 3 ), xkn ( 3 ) integer :: k , l , i logical :: convergenz type ( nurbs_volume ) :: copy_this if (. not . this % err % ok ) return alphak = 0.0_rk dk = 0.0_rk k = 0 eps = 1 0.0_rk * tiny ( 1.0_rk ) ! bounds lower_bounds = [ minval ( this % knot1 ), minval ( this % knot2 ), minval ( this % knot3 )] upper_bounds = [ maxval ( this % knot1 ), maxval ( this % knot2 ), maxval ( this % knot3 )] ! initial guess (coarse search) copy_this = this call copy_this % create ( 50 , 50 , 50 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! clamp initial guess to bounds xk = max ( min ( xk , upper_bounds ), lower_bounds ) xkn = xk convergenz = . false . do while (. not . convergenz . and . k < maxit ) ! objective, gradient, hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc unused obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! small epsilon to avoid divide-by-zero grad ( 1 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 1 ), this % Xc )) grad ( 2 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 2 ), this % Xc )) grad ( 3 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 3 ), this % Xc )) hess ( 1 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 2 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 3 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 1 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 2 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 3 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 1 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 hess ( 2 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 hess ( 3 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 ! debug print '(i3,1x,3e20.10,1x,e20.10)' , k , xk , norm2 ( grad ) if ( norm2 ( grad ) <= tol . or . ( k > 0 . and . norm2 ( xk - xkn ) <= tol )) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else ! Newton step dk = - matmul ( inv ( hess ), grad ) ! Backtracking-Armijo with feasibility (box constraints) tau = 0.5_rk beta = 1.0e-4_rk ! compute maximum feasible step so xk + alpha*dk stays in [lower_bounds, upper_bounds] alpha_max = 1.0_rk do i = 1 , 3 if ( dk ( i ) > 0.0_rk ) then if ( upper_bounds ( i ) > xk ( i )) then alpha_i = ( upper_bounds ( i ) - xk ( i )) / dk ( i ) alpha_max = min ( alpha_max , max ( 0.0_rk , alpha_i )) else alpha_max = 0.0_rk end if else if ( dk ( i ) < 0.0_rk ) then if ( lower_bounds ( i ) < xk ( i )) then alpha_i = ( lower_bounds ( i ) - xk ( i )) / dk ( i ) alpha_max = min ( alpha_max , max ( 0.0_rk , alpha_i )) else alpha_max = 0.0_rk end if end if end do if ( alpha_max <= eps ) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) exit end if alphak = min ( 1.0_rk , alpha_max ) l = 0 do if ( alphak <= eps . or . l >= 50 ) exit xt = xk + alphak * dk ! feasible since alphak ≤ alpha_max obj_trial = norm2 ( this % cmp_Xg ( xt ) - point_Xg ) + 0.001_rk if ( obj_trial <= obj + alphak * beta * dot_product ( grad , dk )) exit alphak = min ( tau * alphak , alpha_max ) ! shrink but stay feasible l = l + 1 end do xkn = xk if ( alphak > eps ) then xk = xk + alphak * dk end if ! clamp updated iterate xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k if (. not . this % err % ok ) return !> number of nodes in each direction n = this % degree + 1 select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace_Xc_vis ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k if (. not . this % err % ok ) return !> number of nodes in each direction n = [ 2 , 2 , 2 ] select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xc_vis ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace_Xg_vis ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k if (. not . this % err % ok ) return !> number of nodes in each direction n = [ 2 , 2 , 2 ] select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xg_vis ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_degreeFace ( this , face ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: face integer :: degree ( 3 ) if (. not . this % err % ok ) return select case ( face ) case ( 1 ) degree = [ this % degree ( 1 ), this % degree ( 2 ), 0 ] case ( 2 ) degree = [ this % degree ( 1 ), this % degree ( 2 ), 0 ] case ( 3 ) degree = [ this % degree ( 1 ), 0 , this % degree ( 3 )] case ( 4 ) degree = [ this % degree ( 1 ), 0 , this % degree ( 3 )] case ( 5 ) degree = [ 0 , this % degree ( 2 ), this % degree ( 3 )] case ( 6 ) degree = [ 0 , this % degree ( 2 ), this % degree ( 3 )] case default error stop 'Invalid face number' end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ansatz ( this , ie , ig , Tgc , dTgc_dXg , dV , ngauss ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: ie , ig real ( rk ), intent ( out ) :: dV real ( rk ), allocatable , intent ( out ) :: Tgc (:), dTgc_dXg (:,:) integer , intent ( in ), optional :: ngauss ( 3 ) real ( rk ), allocatable :: Xth (:,:), Xth_e (:,:), Xth_eT (:,:), Xc_eT (:,:), Xth1 (:), Xth2 (:), Xth3 (:), Xksi (:,:), Wksi (:) integer , allocatable :: elem_th (:,:), elem_c (:,:), elem_ce (:) type ( nurbs_volume ) :: th , th_e real ( rk ), allocatable :: dTtth_dXksi (:,:), Ttth (:), dTgc_dXt (:,:), Xt (:), dXt_dXksi (:,:), dXg_dXt (:,:) real ( rk ), allocatable :: dXg_dXksi (:,:) !! Jacobian matrix real ( rk ) :: det_dXg_dXksi !! Determinant of the Jacobian matrix real ( rk ) :: Xksii ( 3 ) if (. not . this % err % ok ) return if ( present ( ngauss )) then call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], ngauss - 1 , Xksi , Wksi ) else call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], this % degree , Xksi , Wksi ) end if Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) Xth3 = unique ( this % knot3 ) call ndgrid ( Xth1 , Xth2 , Xth3 , Xth ) call th % set ([ 0.0_rk , Xth1 , 1.0_rk ], [ 0.0_rk , Xth2 , 1.0_rk ], [ 0.0_rk , Xth3 , 1.0_rk ], Xth ) elem_th = th % cmp_elem () elem_c = this % cmp_elem () Xth_e = Xth ( elem_th ( ie ,:),:) call th_e % set ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xth_e ) Xth_eT = transpose ( Xth_e ) elem_ce = elem_c ( ie ,:) Xc_eT = transpose ( this % Xc ( elem_ce ,:)) Xksii = Xksi ( ig ,:) call th_e % derivative ( Xksii , dTtth_dXksi , Ttth ) Xt = matmul ( Xth_eT , Ttth ) dXt_dXksi = matmul ( Xth_eT , dTtth_dXksi ) call this % derivative ( Xt , dTgc_dXt , Tgc , elem_ce ) dXg_dXt = matmul ( Xc_eT , dTgc_dXt ) dTgc_dXg = matmul ( dTgc_dXt , inv ( dXg_dXt )) dXg_dXksi = matmul ( dXg_dXt , dXt_dXksi ) det_dXg_dXksi = det ( dXg_dXksi ) dV = det_dXg_dXksi * Wksi ( ig ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_volume ( this , volume , ngauss ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( out ) :: volume integer , intent ( in ), optional :: ngauss ( 3 ) real ( rk ), allocatable :: Tgc (:), dTgc_dXg (:,:) integer :: ie , ig integer :: ngauss_ ( 3 ) real ( rk ) :: dV , dV_ig if (. not . this % err % ok ) return if ( present ( ngauss )) then ngauss_ = ngauss else ngauss_ = this % degree + 1 end if volume = 0.0_rk #if defined(__NVCOMPILER) do ie = 1 , size ( this % cmp_elem (), 1 ) #else do concurrent ( ie = 1 : size ( this % cmp_elem (), 1 )) reduce ( + : volume ) #endif dV = 0.0_rk do ig = 1 , product ( ngauss_ ) call this % ansatz ( ie , ig , Tgc , dTgc_dXg , dV_ig , ngauss_ ) dV = dV + dV_ig end do volume = volume + dV end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Tgc_3d ( Xti , knot1 , knot2 , knot3 , nc , degree , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xti (:) real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) real ( rk ), intent ( in ), contiguous :: knot3 (:) integer , intent ( in ) :: degree ( 3 ), nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )) real ( rk ) :: tmp integer :: i Tgc = kron ( basis_bspline ( Xti ( 3 ), knot3 , nc ( 3 ), degree ( 3 )),& kron (& basis_bspline ( Xti ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xti ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) tmp = dot_product ( Tgc , Wc ) do concurrent ( i = 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 )) Tgc ( i ) = ( Tgc ( i ) * Wc ( i )) / tmp end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_3d ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) real ( rk ) :: Xti ( size ( Xt , 2 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Xg ( ng_ , size ( Xc , 2 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( Xti ) #endif Xti = Xt ( i ,:) Xg ( i ,:) = matmul ( cmp_Tgc_3d ( Xti , knot1 , knot2 , knot3 , nc , degree , Wc ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_3d_1point ( Xt , knot1 , knot2 , knot3 , degree , nc , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Xg ( size ( Xc , 2 )) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )),& kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_3d ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Xg ( ng_ , size ( Xc , 2 ))) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Xg ( i ,:) = matmul ( kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))),& Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_3d_1point ( Xt , knot1 , knot2 , knot3 , degree , nc , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ) :: Xg ( size ( Xc , 2 )) Xg = matmul ( kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))),& Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ) :: dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( dTgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , B3 , dB1 , dB2 , dB3 , Bi , dBi ) #endif call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> If `elem` is not present: `Wc` refers to the full weight vector. !> If `elem` is present:     `Wc` refers to the element-local weight vector (`Wce`). pure subroutine compute_dTgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ), allocatable :: dBi (:,:), Bi (:) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) else allocate ( dTgc ( size ( elem ), 3 )) allocate ( Tgc ( size ( elem ))) allocate ( dBi ( size ( elem ), 3 ), Bi ( size ( elem ))) associate ( Biall => kron ( B3 , kron ( B2 , B1 ))) Bi = Biall ( elem ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) end associate associate ( dB1all => kron ( kron ( B3 , B2 ), dB1 ), dB2all => kron ( kron ( B3 , dB2 ), B1 ), dB3all => kron ( kron ( dB3 , B2 ), B1 )) dBi (:, 1 ) = dB1all ( elem ) dBi (:, 2 ) = dB2all ( elem ) dBi (:, 3 ) = dB3all ( elem ) end associate dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( dTgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , B3 , dB1 , dB2 , dB3 ) #endif call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Tgc ( i ,:) = kron ( B3 , kron ( B2 , B1 )) dTgc ( i ,:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc ( i ,:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc ( i ,:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), contiguous , optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( B3 , kron ( B2 , B1 )) dTgc (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) else allocate ( dTgc ( size ( elem ), 3 )) allocate ( Tgc ( size ( elem ))) associate ( B => kron ( B3 , kron ( B2 , B1 ))) Tgc = B ( elem ) end associate associate ( dB1 => kron ( kron ( B3 , B2 ), dB1 ), dB2 => kron ( kron ( B3 , dB2 ), B1 ), dB3 => kron ( kron ( dB3 , B2 ), B1 )) dTgc (:, 1 ) = dB1 ( elem ) dTgc (:, 2 ) = dB2 ( elem ) dTgc (:, 3 ) = dB3 ( elem ) end associate end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ), allocatable :: Tgci (:), dTgci (:) real ( rk ) :: d2Bi ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Tgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dTgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( d2Tgc ( ng_ , 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , B3 , dB1 , dB2 , dB3 , d2B1 , d2B2 , d2B3 , Bi , dBi , d2Bi ) #endif call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - 2.0_rk * dTgc ( i , :, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - 2.0_rk * dTgc ( i , :, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - 2.0_rk * dTgc ( i , :, 3 ) * dot_product ( dBi (:, 3 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ), allocatable :: d2Bi (:,:), dBi (:,:), Bi (:) allocate ( Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), d2Bi ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( d2Tgc ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - 2.0_rk * dTgc (:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - 2.0_rk * dTgc (:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc (:, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc (:, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - 2.0_rk * dTgc (:, 3 ) * dot_product ( dBi (:, 3 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i , ng_ real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( d2Tgc ( ng_ , 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( B1 , B2 , B3 , dB1 , dB2 , dB3 , d2B1 , d2B2 , d2B3 ) #endif call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Tgc ( i ,:) = kron ( B3 , kron ( B2 , B1 )) dTgc ( i ,:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc ( i ,:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc ( i ,:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) allocate ( d2Tgc ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Tgc = kron ( B3 , kron ( B2 , B1 )) dTgc (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ) :: Tgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) #if defined(__NVCOMPILER) || defined(__GFORTRAN__) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) local ( Tgci ) #endif Tgci = kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: ng ( 3 ) real ( rk ), allocatable :: Tgc (:,:) integer :: i , ng_ if ( present ( ng )) then ng_ = product ( ng ) else ng_ = size ( Xt , 1 ) end if allocate ( Tgc ( ng_ , nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) #if defined(__NVCOMPILER) do i = 1 , ng_ #else do concurrent ( i = 1 : ng_ ) #endif Tgc ( i ,:) = kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine lsq_fit_bspline ( this , Xt , Xdata , ndata ) use forcad_interface , only : solve class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:,:), Xdata (:,:) integer , intent ( in ) :: ndata ( 3 ) real ( rk ), allocatable :: T (:,:), Tt (:,:), TtT (:,:), TtX (:,:) integer :: i , n if (. not . this % err % ok ) return if ( this % nc ( 1 ) > ndata ( 1 )) then call this % err % set (& code = 106 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid number of control points in the first direction.' ,& location = 'lsq_fit_bspline' ,& suggestion = 'Ensure that the number of control points does not exceed the number of data points.' ) return end if if ( this % nc ( 2 ) > ndata ( 2 )) then call this % err % set (& code = 106 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid number of control points in the second direction.' ,& location = 'lsq_fit_bspline' ,& suggestion = 'Ensure that the number of control points does not exceed the number of data points.' ) return end if if ( this % nc ( 3 ) > ndata ( 3 )) then call this % err % set (& code = 106 ,& severity = 1 ,& category = 'forcad_nurbs_volume' ,& message = 'Invalid number of control points in the third direction.' ,& location = 'lsq_fit_bspline' ,& suggestion = 'Ensure that the number of control points does not exceed the number of data points.' ) return end if n = ndata ( 1 ) * ndata ( 2 ) * ndata ( 3 ) allocate ( T ( n , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) #if defined(__NVCOMPILER) || (defined(__GFORTRAN__) && (__GNUC__ < 15 || (__GNUC__ == 15 && __GNUC_MINOR__ < 1))) do i = 1 , n #else do concurrent ( i = 1 : n ) #endif T ( i ,:) = kron (& basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )))) end do Tt = transpose ( T ) TtT = matmul ( Tt , T ) TtX = matmul ( Tt , Xdata ) this % Xc = solve ( TtT , TtX ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine lsq_fit_nurbs ( this , Xt , Xdata , ndata , maxit , tol , lambda_xc , mu0 , reg_logw ) use forcad_interface , only : solve class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: Xdata (:,:) integer , intent ( in ) :: ndata ( 3 ) integer , intent ( in ), optional :: maxit real ( rk ), intent ( in ), optional :: tol real ( rk ), intent ( in ), optional :: lambda_xc real ( rk ), intent ( in ), optional :: mu0 real ( rk ), intent ( in ), optional :: reg_logw real ( rk ), allocatable :: Bmat (:,:), S (:), T (:,:), TtT (:,:), TtX (:,:), C (:,:), R (:,:) real ( rk ), allocatable :: Jacv (:,:), Jac_red (:,:), rvec (:), JtJ (:,:), Jtr (:,:), delta_u (:,:), delta_v (:), v (:) real ( rk ) :: tol_ , lamx_ , mu , regw , epss , cost_prev , cost_now integer :: dim_ , it , maxit_ , n , ncp , nvar , i , j , k if (. not . this % err % ok ) return dim_ = size ( Xdata , 2 ) n = ndata ( 1 ) * ndata ( 2 ) * ndata ( 3 ) ncp = this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) nvar = ncp - 1 maxit_ = 30 tol_ = epsilon ( 0.0_rk ) lamx_ = 0.0_rk mu = sqrt ( epsilon ( 0.0_rk )) regw = sqrt ( epsilon ( 0.0_rk )) epss = 1 0.0_rk * epsilon ( 0.0_rk ) if ( present ( maxit )) maxit_ = maxit if ( present ( tol )) tol_ = tol if ( present ( lambda_xc )) lamx_ = lambda_xc if ( present ( mu0 )) mu = mu0 if ( present ( reg_logw )) regw = reg_logw if ( this % nc ( 1 ) > ndata ( 1 )) then call this % err % set ( 1 , 106 , 'forcad_nurbs_volume' , 'Too few samples in dir-1.' , 'lsq_fit_nurbs' , 'Use nc(1) <= ndata(1).' ) return end if if ( this % nc ( 2 ) > ndata ( 2 )) then call this % err % set ( 1 , 106 , 'forcad_nurbs_volume' , 'Too few samples in dir-2.' , 'lsq_fit_nurbs' , 'Use nc(2) <= ndata(2).' ) return end if if ( this % nc ( 3 ) > ndata ( 3 )) then call this % err % set ( 1 , 106 , 'forcad_nurbs_volume' , 'Too few samples in dir-3.' , 'lsq_fit_nurbs' , 'Use nc(3) <= ndata(3).' ) return end if if ( n <= 0 . or . ncp < 2 ) then call this % err % set ( 1 , 106 , 'forcad_nurbs_volume' , 'Invalid sizes for LSQ fitting.' , 'lsq_fit_nurbs' , 'Check ndata and nc.' ) return end if allocate ( Bmat ( n , ncp )) #if defined(__NVCOMPILER) || (defined(__GFORTRAN__) && (__GNUC__ < 15 || (__GNUC__ == 15 && __GNUC_MINOR__ < 1))) do i = 1 , n #else do concurrent ( i = 1 : n ) #endif Bmat ( i ,:) = kron ( & basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )), & kron ( basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )), & basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) ) ) end do if ( allocated ( this % Wc ) . and . size ( this % Wc ) == ncp ) then ! keep as is else allocate ( this % Wc ( ncp ), source = 1.0_rk ) end if allocate ( v ( ncp )) v = log ( max ( this % Wc , epss )) this % Wc = exp ( v - sum ( v ) / real ( ncp , rk )) allocate ( S ( n ), T ( n , ncp ), C ( n , dim_ ), R ( n , dim_ )) allocate ( TtT ( ncp , ncp ), TtX ( ncp , dim_ )) allocate ( Jacv ( n * dim_ , ncp ), rvec ( n * dim_ )) allocate ( Jac_red ( n * dim_ , nvar )) allocate ( JtJ ( nvar , nvar ), Jtr ( nvar , 1 ), delta_u ( nvar , 1 ), delta_v ( ncp )) cost_prev = huge ( 1.0_rk ) do it = 1 , maxit_ #if defined(__NVCOMPILER) do i = 1 , n S ( i ) = dot_product ( Bmat ( i ,:), this % Wc ) if ( abs ( S ( i )) < epss ) S ( i ) = sign ( epss , S ( i )) T ( i ,:) = Bmat ( i ,:) * ( this % Wc / S ( i )) end do #else do concurrent ( i = 1 : n ) S ( i ) = dot_product ( Bmat ( i ,:), this % Wc ) if ( abs ( S ( i )) < epss ) S ( i ) = sign ( epss , S ( i )) T ( i ,:) = Bmat ( i ,:) * ( this % Wc / S ( i )) end do #endif TtT = matmul ( transpose ( T ), T ) if ( lamx_ > 0.0_rk ) then do concurrent ( j = 1 : ncp ) TtT ( j , j ) = TtT ( j , j ) + lamx_ end do end if TtX = matmul ( transpose ( T ), Xdata ) this % Xc = solve ( TtT , TtX ) C = matmul ( T , this % Xc ) R = C - Xdata cost_now = norm2 ( R ) / real ( n * dim_ , rk ) if ( cost_prev - cost_now <= tol_ * max ( 1.0_rk , cost_prev )) exit cost_prev = cost_now do concurrent ( k = 1 : dim_ , i = 1 : n ) rvec (( k - 1 ) * n + i ) = R ( i , k ) end do do concurrent ( j = 1 : ncp , k = 1 : dim_ , i = 1 : n ) Jacv (( k - 1 ) * n + i , j ) = ( this % Wc ( j ) * Bmat ( i , j ) / S ( i ) ) * ( this % Xc ( j , k ) - C ( i , k ) ) end do do concurrent ( j = 1 : nvar ) Jac_red (:, j ) = Jacv (:, j ) - Jacv (:, ncp ) end do JtJ = matmul ( transpose ( Jac_red ), Jac_red ) Jtr (:, 1 ) = matmul ( transpose ( Jac_red ), rvec ) do concurrent ( j = 1 : nvar ) JtJ ( j , j ) = JtJ ( j , j ) + mu + regw end do delta_u = - solve ( JtJ , Jtr ) delta_v ( 1 : nvar ) = delta_u (:, 1 ) delta_v ( ncp ) = - sum ( delta_u (:, 1 )) v = v + delta_v this % Wc = exp ( v - sum ( v ) / real ( ncp , rk )) mu = max ( epsilon ( 0.0_rk ), 0.3_rk * mu ) end do end subroutine !=============================================================================== end module forcad_nurbs_volume","tags":"","url":"sourcefile/forcad_nurbs_volume.f90.html"},{"title":"lsq_fit_bspline_1d.f90 – ForCAD","text":"This file depends on sourcefile~~lsq_fit_bspline_1d.f90~~EfferentGraph sourcefile~lsq_fit_bspline_1d.f90 lsq_fit_bspline_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~lsq_fit_bspline_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program lsq_fit_bspline_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: bsp integer :: n , i real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xdata (:,:) real ( rk ), allocatable :: Xt (:) real ( rk ), allocatable :: Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = 42 ! create parametric grid points allocate ( Xt ( n )) do concurrent ( i = 1 : n ) Xt ( i ) = real ( i - 1 , rk ) / real ( n - 1 , rk ) end do ! data points to be fitted allocate ( Xdata ( n , 3 )) do i = 1 , n Xdata ( i , 1 ) = Xt ( i ) Xdata ( i , 2 ) = 0.3_rk * sin ( 4.0_rk * pi * Xt ( i )) Xdata ( i , 3 ) = 0.3_rk * cos ( 4.0_rk * pi * Xt ( i )) end do ! set up B-Spline curve ! Xth_dir(1) = minval(Xt), Xth_dir(2) = maxval(Xt) call bsp % set (& degree = 5 ,& Xth_dir = [ 0.0_rk , 0.1_rk , 0.2_rk , 0.3_rk , 0.4_rk , 0.5_rk , 0.6_rk , 0.7_rk , 0.8_rk , 0.9_rk , 1.0_rk ],& continuity = [ - 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , - 1 ]) print '(a)' , \"========================================\" print '(a)' , \"B-Spline Curve Configuration\" print '(a)' , \"----------------------------------------\" print '(a,i0,a)' , \"Degrees    : \" , bsp % get_degree () print '(a,i0,a)' , \"Control pts: \" , bsp % get_nc () print '(a,i0,a)' , \"Data grid  : \" , n print '(a)' , \"----------------------------------------\" print '(a)' , \"Continuity\" print '(a,*(i3,1x))' , \"  dir1:\" , bsp % get_continuity () print '(a)' , \"----------------------------------------\" print '(a)' , \"Knot vectors\" print '(a,*(f5.2,1x))' , \"  dir1:\" , bsp % get_knot () print '(a)' , \"========================================\" print '(a)' , \"Fitting least squares curve...\" call bsp % lsq_fit_bspline ( Xt , Xdata , n ) print '(a)' , \"Fitting complete.\" ! create B-Spline curve call bsp % create ( Xt = Xt ) Xg_eval = bsp % get_Xg () ! Compute errors err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / max ( norm2 ( Xdata (:, 1 )), epsilon ( 0.0_rk ) ) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / max ( norm2 ( Xdata (:, 2 )), epsilon ( 0.0_rk ) ) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / max ( norm2 ( Xdata (:, 3 )), epsilon ( 0.0_rk ) ) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) print '(a)' , \"========================================\" print '(a)' , \"Fitting Error Report\" print '(a)' , \"----------------------------------------\" print '(a,e13.6)' , \"Rel. error (dir1):\" , err1 print '(a,e13.6)' , \"Rel. error (dir2):\" , err2 print '(a,e13.6)' , \"Rel. error (dir3):\" , err3 print '(a,e13.6)' , \"Total RMS error  :\" , rms print '(a)' , \"========================================\" ! Export results call bsp % export_Xc ( \"vtk/lsq_fit_bspline_1d_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/lsq_fit_bspline_1d_Xg.vtk\" ) call bsp % show ( \"vtk/lsq_fit_bspline_1d_Xc.vtk\" , \"vtk/lsq_fit_bspline_1d_Xg.vtk\" ) end program","tags":"","url":"sourcefile/lsq_fit_bspline_1d.f90.html"},{"title":"shape_C_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_2d.f90~~EfferentGraph sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_2d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_2d_Xc.vtk' , 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_c_2d.f90.html"},{"title":"lsq_fit_nurbs_1d.f90 – ForCAD","text":"This file depends on sourcefile~~lsq_fit_nurbs_1d.f90~~EfferentGraph sourcefile~lsq_fit_nurbs_1d.f90 lsq_fit_nurbs_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~lsq_fit_nurbs_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program lsq_fit_nurbs_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nrb integer :: n , i real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), allocatable :: Xdata (:,:) real ( rk ), allocatable :: Xt (:) real ( rk ), allocatable :: Xg_eval (:,:) real ( rk ) :: err1 , err2 , err3 , rms n = 100 ! create parametric grid points allocate ( Xt ( n )) do concurrent ( i = 1 : n ) Xt ( i ) = real ( i - 1 , rk ) / real ( n - 1 , rk ) end do ! data points to be fitted allocate ( Xdata ( n , 3 )) do concurrent ( i = 1 : n ) Xdata ( i , 1 ) = 0.0_rk + 1.0_rk * cos ( 2.0_rk * pi * Xt ( i ) ) Xdata ( i , 2 ) = 0.0_rk + 1.0_rk * sin ( 2.0_rk * pi * Xt ( i ) ) Xdata ( i , 3 ) = 0.0_rk end do call nrb % set (& degree = 7 ,& Xth_dir = [ 0.0_rk , 0.1_rk , 0.2_rk , 0.3_rk , 0.4_rk , 0.5_rk , 0.6_rk , 0.7_rk , 0.8_rk , 0.9_rk , 1.0_rk ],& continuity = [ - 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , - 1 ]) print '(a)' , \"========================================\" print '(a)' , \"NURBS Curve Configuration\" print '(a)' , \"----------------------------------------\" print '(a,i0,a)' , \"Degrees    : \" , nrb % get_degree () print '(a,i0,a)' , \"Control pts: \" , nrb % get_nc () print '(a,i0,a)' , \"Data grid  : \" , n print '(a)' , \"----------------------------------------\" print '(a)' , \"Continuity\" print '(a,*(i3,1x))' , \"  dir1:\" , nrb % get_continuity () print '(a)' , \"----------------------------------------\" print '(a)' , \"Knot vectors\" print '(a,*(f5.2,1x))' , \"  dir1:\" , nrb % get_knot () print '(a)' , \"========================================\" print '(a)' , \"Fitting least squares curve...\" call nrb % lsq_fit_nurbs (& Xt = Xt , & Xdata = Xdata , & ndata = n , & maxit = 100 , & tol = sqrt ( epsilon ( 0.0_rk )), & lambda_xc = sqrt ( epsilon ( 0.0_rk )), & reg_logw = sqrt ( epsilon ( 0.0_rk )) ) print '(a)' , \"Fitting complete.\" ! create NURBS curve call nrb % create ( Xt = Xt ) Xg_eval = nrb % get_Xg () ! Compute errors err1 = norm2 ( Xg_eval (:, 1 ) - Xdata (:, 1 )) / max ( norm2 ( Xdata (:, 1 )), epsilon ( 0.0_rk ) ) err2 = norm2 ( Xg_eval (:, 2 ) - Xdata (:, 2 )) / max ( norm2 ( Xdata (:, 2 )), epsilon ( 0.0_rk ) ) err3 = norm2 ( Xg_eval (:, 3 ) - Xdata (:, 3 )) / max ( norm2 ( Xdata (:, 3 )), epsilon ( 0.0_rk ) ) rms = sqrt (( err1 ** 2 + err2 ** 2 + err3 ** 2 ) / 3.0_rk ) print '(a)' , \"========================================\" print '(a)' , \"Fitting Error Report\" print '(a)' , \"----------------------------------------\" print '(a,e13.6)' , \"Rel. error (dir1):\" , err1 print '(a,e13.6)' , \"Rel. error (dir2):\" , err2 print '(a,e13.6)' , \"Rel. error (dir3):\" , err3 print '(a,e13.6)' , \"Total RMS error  :\" , rms print '(a)' , \"========================================\" ! Export results call nrb % export_Xc ( \"vtk/lsq_fit_bspline_1d_Xc.vtk\" ) call nrb % export_Xg ( \"vtk/lsq_fit_bspline_1d_Xg.vtk\" ) call nrb % show ( \"vtk/lsq_fit_bspline_1d_Xc.vtk\" , \"vtk/lsq_fit_bspline_1d_Xg.vtk\" ) end program","tags":"","url":"sourcefile/lsq_fit_nurbs_1d.f90.html"},{"title":"poisson_iga_solver_2d.f90 – ForCAD","text":"This file depends on sourcefile~~poisson_iga_solver_2d.f90~~EfferentGraph sourcefile~poisson_iga_solver_2d.f90 poisson_iga_solver_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~poisson_iga_solver_2d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Solves the 2D Poisson problem using Isogeometric Analysis (IGA). !> !> This code solves the equation: !>  !>   -\\Delta u = f \\quad \\text{in } \\Omega, \\qquad u = 0 \\quad \\text{on } \\partial \\Omega !>  !> using a B-spline surface on a rectangular domain. !> !> The solution is discretized using tensor-product B-spline basis functions !> over a structured control net. The global linear system is assembled and !> solved using a basic internal Cholesky solver. !> !> The resulting solution is exported to VTK format for visualization. !> !> The L2 error norm with respect to the exact solution !> is computed and printed. !> !> @note !> This implementation uses B-spline geometry (no rational weights), hence the surface is not a full NURBS. !> @endnote !> !> @warning \"Slow solver\" !> The solver uses an internal Cholesky factorization which is not optimized. For large systems, consider replacing it with a more scalable external solver. !> @endwarning !> program poisson_iga_solver_2d use forcad , only : rk , nurbs_surface use forcad_utils , only : solve use fortime , only : timer implicit none type ( nurbs_surface ) :: surf !! NURBS surface object real ( rk ), parameter :: pi = acos ( - 1.0_rk ) !! Constant  \\pi  integer :: ie !! Element index integer :: ig !! Quadrature (Gauss) point index integer :: i !! Generic loop index integer :: nelem !! Number of elements integer :: nnelem !! Number of local nodes per element integer :: nc ( 2 ) !! Number of control points in each direction integer :: nct !! Total number of control points integer :: res ( 2 ) !! Visualization resolution integer :: dof !! Degrees of freedom per control point (1 for scalar field) integer :: ndof !! Total degrees of freedom integer :: m ( 2 ) !! Mode numbers  (m_1, m_2)  for source and exact solution integer :: ki ( 2 ) !! Number of knots to insert in each direction integer , allocatable :: elem (:,:) !! Element connectivity matrix integer , allocatable :: elem_e (:) !! Local connectivity of current element integer , allocatable :: dirichlet_id (:) !! Indices for Dirichlet boundary conditions real ( rk ), allocatable :: K (:,:) !! Global stiffness matrix  K  real ( rk ), allocatable :: b (:) !! Global right-hand side vector  b  real ( rk ), allocatable :: Xc (:,:) !! Control point coordinates real ( rk ), allocatable :: Xg (:) !! Physical coordinates at quadrature point real ( rk ), allocatable :: T (:) !! Basis function values at quadrature point real ( rk ), allocatable :: dT (:,:) !! Derivatives of basis functions at quadrature point real ( rk ), allocatable :: X (:,:) !! Global solution vector  X  real ( rk ), allocatable :: u_h (:,:) !! Interpolated solution field  u(x,y)  on grid real ( rk ) :: dA !! Differential element area  \\text{d}A = J \\cdot w  real ( rk ) :: l2_error !! L2 error norm accumulator  \\|u_h - u\\|&#94;2  real ( rk ) :: L ( 2 ) !! Domain size  (L_1, L_2) \\in \\mathbb{R}&#94;2  character ( len = 256 ) :: filename !! Filename for VTK export type ( timer ) :: ti !! Timer object for performance measurement !> Domain size and number of control points L = [ 1.0_rk , 1.0_rk ] nc = [ 10 , 10 ] !> Number knots to insert in each direction ki = [ 8 , 8 ] !> Mode numbers for the source term and exact solution m = [ 2 , 2 ] !> Resolution of the visualization grid res = [ 50 , 50 ] !> filename for VTK export filename = \"vtk/poisson_iga_solver_2d\" !> Construct the NURBS surface !> For simplicity, set_tetragon creates a rectangular surface with uniform knot spacing !> For more complex geometries, use surf%set() with knots, continuity,... call surf % set_tetragon ( L = L , nc = nc ) !> Insert knots in the first and second directions call surf % insert_knots ( 1 , [( real ( i , rk ) / real ( ki ( 1 ), rk ), i = 1 , ki ( 1 ) - 1 )], [( 1 , i = 1 , ki ( 1 ) - 1 )]) call surf % insert_knots ( 2 , [( real ( i , rk ) / real ( ki ( 2 ), rk ), i = 1 , ki ( 2 ) - 1 )], [( 1 , i = 1 , ki ( 2 ) - 1 )]) !> Extract geometry and mesh structure Xc = surf % get_Xc () elem = surf % cmp_elem () nct = product ( surf % get_nc ()) nelem = size ( elem , 1 ) nnelem = size ( elem , 2 ) dof = 1 ndof = dof * nct print '(a,g0,\",\",g0)' , \"Degree (dir1, dir2)                  : \" , surf % get_degree ( 1 ), surf % get_degree ( 2 ) print '(a,g0,\"x\",g0)' , \"Control net size (dir1 x dir2)       : \" , nc ( 1 ), nc ( 2 ) print '(a,g0)' , \"Total control points                 : \" , nct print '(a,g0)' , \"Number of elements                   : \" , nelem print '(a,g0)' , \"Degrees of freedom (DoFs)            : \" , ndof print '(a,g0,\" x \",g0)' , \"Domain size (L1, L2)                 : \" , L ( 1 ), L ( 2 ) print '(a,g0,\",\",g0)' , \"Mode numbers (m1, m2)                : \" , m ( 1 ), m ( 2 ) print '(a,g0,\",\",g0)' , \"Knot insertion (dir1, dir2)          : \" , ki ( 1 ), ki ( 2 ) print '(a,g0,\"x\",g0)' , \"Visualization resolution (res1, res2): \" , res ( 1 ), res ( 2 ) !> Assemble global stiffness matrix and load vector allocate ( K ( nct , nct ), b ( nct ), source = 0.0_rk ) call ti % timer_start () !$omp parallel do private(ie, ig, elem_e, T, dT, Xg, dA) shared(K, b) do ie = 1 , nelem elem_e = elem ( ie , :) do ig = 1 , nnelem call surf % ansatz ( ie , ig , T , dT , dA ) Xg = matmul ( T , Xc ( elem_e ,:)) !$omp critical b ( elem_e ) = b ( elem_e ) + T * source_term ( Xg , L , m ) * dA K ( elem_e , elem_e ) = K ( elem_e , elem_e ) + matmul ( dT , transpose ( dT )) * dA !$omp end critical end do end do !$omp end parallel do call ti % timer_stop ( message = \"Assembly                             : \" ) !> Apply homogeneous Dirichlet boundary conditions call ti % timer_start () allocate ( dirichlet_id ( 0 )) do i = 1 , nct if (& abs ( Xc ( i , 1 )) < 1e-12_rk . or . abs ( Xc ( i , 1 ) - L ( 1 )) < 1e-12_rk . or . & abs ( Xc ( i , 2 )) < 1e-12_rk . or . abs ( Xc ( i , 2 ) - L ( 2 )) < 1e-12_rk ) then dirichlet_id = [ dirichlet_id , i ] end if end do K ( dirichlet_id , :) = 0.0_rk K (:, dirichlet_id ) = 0.0_rk b ( dirichlet_id ) = 0.0_rk do concurrent ( i = 1 : size ( dirichlet_id )) K ( dirichlet_id ( i ), dirichlet_id ( i )) = 1.0_rk end do call ti % timer_stop ( message = \"Boundary conditions                  : \" ) !> Solve the linear system K·X = b call ti % timer_start () X = solve ( K , reshape ( b , [ nct , 1 ])) call ti % timer_stop ( message = \"System solution                      : \" ) !> Export solution at control points to VTK call surf % export_Xc ( filename = trim ( filename ) // \".vtk\" , point_data = reshape ( X , [ nct , 1 ]), field_names = [ \"u\" ]) !> Interpolate solution and export field call surf % create ( res1 = res ( 1 ), res2 = res ( 2 )) call surf % basis ( Tgc = u_h ) u_h = matmul ( u_h , reshape ( X (:, 1 ), [ nct , 1 ])) call surf % export_Xg ( filename = trim ( filename ) // \"_interp.vtk\" , point_data = u_h , field_names = [ \"u\" ]) !> Compute the L2 error norm call ti % timer_start () l2_error = 0.0_rk do ie = 1 , nelem elem_e = elem ( ie , :) do ig = 1 , nnelem call surf % ansatz ( ie , ig , T , dT , dA ) Xg = matmul ( T , Xc ( elem_e ,:)) l2_error = l2_error + ( dot_product ( T , X ( elem_e , 1 )) - exact_solution ( Xg , L , m )) ** 2 * dA end do end do call ti % timer_stop ( message = \"L2 error evaluation                  : \" ) print '(a,1pe11.4)' , \"L2 error norm                        = \" , sqrt ( l2_error ) print '(a,a,a,a)' , trim ( filename ) // \".vtk\" , \" and \" , trim ( filename ) // \"_interp.vtk\" , \" exported\" call surf % finalize () ! deallocate(K, b, Xc, Xg, T, dT, X, u_h) contains !> Computes the source function  f(x,y) = \\sin(m_1 \\pi x / L_1) \\sin(m_2 \\pi y / L_2)  pure function source_term ( p , d , n ) result ( f ) real ( rk ), intent ( in ) :: p ( 2 ) !! Coordinates (x, y) real ( rk ), intent ( in ) :: d ( 2 ) !! Domain size (L1, L2) integer , intent ( in ) :: n ( 2 ) !! Mode numbers (m1, m2) real ( rk ) :: f f = sin ( n ( 1 ) * pi * p ( 1 ) / d ( 1 )) * sin ( n ( 2 ) * pi * p ( 2 ) / d ( 2 )) end function !> Computes the exact solution corresponding to the source term !> !>  !> u(x, y) = \\frac{1}{\\lambda} \\sin(m_1 \\pi x / L_1) \\sin(m_2 \\pi y / L_2) !> \\quad\\text{where}\\quad !> \\lambda = \\left( \\frac{m_1 \\pi}{L_1} \\right)&#94;2 + \\left( \\frac{m_2 \\pi}{L_2} \\right)&#94;2 !>  pure function exact_solution ( p , d , n ) result ( u ) real ( rk ), intent ( in ) :: p ( 2 ) !! Coordinates (x, y) real ( rk ), intent ( in ) :: d ( 2 ) !! Domain size (L1, L2) integer , intent ( in ) :: n ( 2 ) !! Mode numbers (m1, m2) real ( rk ) :: u , lam lam = ( n ( 1 ) * pi / d ( 1 )) ** 2 + ( n ( 2 ) * pi / d ( 2 )) ** 2 u = ( 1.0_rk / lam ) * sin ( n ( 1 ) * pi * p ( 1 ) / d ( 1 )) * sin ( n ( 2 ) * pi * p ( 2 ) / d ( 2 )) end function end program","tags":"","url":"sourcefile/poisson_iga_solver_2d.f90.html"},{"title":"example_volume_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_volume_1.f90~~EfferentGraph sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","url":"sourcefile/example_volume_1.f90.html"},{"title":"demo_curve.f90 – ForCAD","text":"This file depends on sourcefile~~demo_curve.f90~~EfferentGraph sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve. !> It sets up control points and weights, generates the curve, and exports the control points !> and the curve to VTK files at various stages. program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","url":"sourcefile/demo_curve.f90.html"},{"title":"example_plate_hole_4_3d.f90 – ForCAD","text":"This file depends on sourcefile~~example_plate_hole_4_3d.f90~~EfferentGraph sourcefile~example_plate_hole_4_3d.f90 example_plate_hole_4_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_plate_hole_4_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_plate_hole_4_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: plate_hole real ( rk ), allocatable :: Xc (:,:) real ( rk ), allocatable :: Wc (:) real ( rk ), parameter :: radius1 = 2.5_rk real ( rk ), parameter :: radius2 = 3.5_rk real ( rk ), parameter :: length = 5.0_rk real ( rk ), parameter :: height = 5.0_rk real ( rk ), parameter :: width = 0.5_rk call set_Xc_Wc ( 'ellipse' , [ radius1 , radius2 , length , height , width ], Xc , Wc ) call plate_hole % set (& knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 0.5_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ,& Wc = Wc & ) call plate_hole % create ( 31 , 31 , 5 ) call plate_hole % export_Xc ( \"vtk/plate_hole_4_3d_Xc.vtk\" ) call plate_hole % export_Xg ( \"vtk/plate_hole_4_3d_Xg.vtk\" ) call plate_hole % export_Xth_in_Xg ( \"vtk/plate_hole_4_3d_Xth.vtk\" ) call plate_hole % show ( \"vtk/plate_hole_4_3d_Xc.vtk\" , \"vtk/plate_hole_4_3d_Xg.vtk\" , \"vtk/plate_hole_4_3d_Xth.vtk\" ) contains !=============================================================================== pure subroutine set_Xc_Wc ( tp , params , X_c , W_c ) character ( len =* ), intent ( in ) :: tp real ( rk ), intent ( in ), contiguous :: params (:) real ( rk ), allocatable , intent ( out ) :: X_c (:,:) real ( rk ), allocatable , intent ( out ) :: W_c (:) real ( rk ) :: r1 , r2 , l , w , h select case ( tp ) case ( 'circle' ) r1 = params ( 1 ) l = params ( 3 ) h = params ( 4 ) w = params ( 5 ) if ( r1 < 0.0_rk ) error stop 'Radius must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' if ( w < 0.0_rk ) error stop 'Width must be positive' allocate ( X_c ( 12 * 2 , 3 )) X_c ( 1 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 2 , 1 : 2 ) = [ - r1 , r1 * tand ( 2 2.5_rk )] X_c ( 3 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), r1 ] X_c ( 4 , 1 : 2 ) = [ 0.0_rk , r1 ] X_c ( 5 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 6 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r1 + ( h - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 7 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 8 , 1 : 2 ) = [ 0.0_rk , ( r1 + ( h - r1 ) / 2.0_rk )] X_c ( 9 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 10 , 1 : 2 ) = [ - l , h ] X_c ( 11 , 1 : 2 ) = [ - l , h ] X_c ( 12 , 1 : 2 ) = [ 0.0_rk , h ] X_c ( 13 : 24 , 1 : 2 ) = X_c ( 1 : 12 , 1 : 2 ) X_c ( 1 : 12 , 3 ) = 0.0_rk X_c ( 13 : 24 , 3 ) = w allocate ( W_c ( 12 * 2 ), source = 1.0_rk ) W_c ([ 2 , 3 , 14 , 15 ]) = ( 1.0_rk + 1.0_rk / sqrt ( 2.0_rk )) / 2.0_rk case ( 'ellipse' ) r1 = params ( 1 ) r2 = params ( 2 ) l = params ( 3 ) h = params ( 4 ) w = params ( 5 ) if ( r1 < 0.0_rk ) error stop 'Radius1 must be positive' if ( r2 < 0.0_rk ) error stop 'Radius2 must be positive' if ( l < 0.0_rk ) error stop 'Length must be positive' if ( h < 0.0_rk ) error stop 'Height must be positive' if ( w < 0.0_rk ) error stop 'Width must be positive' allocate ( X_c ( 12 * 2 , 3 )) X_c ( 1 , 1 : 2 ) = [ - r1 , 0.0_rk ] X_c ( 2 , 1 : 2 ) = [ - r1 , r2 * tand ( 2 2.5_rk )] X_c ( 3 , 1 : 2 ) = [ - r1 * tand ( 2 2.5_rk ), r2 ] X_c ( 4 , 1 : 2 ) = [ 0.0_rk , r2 ] X_c ( 5 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), 0.0_rk ] X_c ( 6 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ), ( r2 + ( h - r2 ) / 2.0_rk ) * tand ( 1 6.7_rk )] X_c ( 7 , 1 : 2 ) = [ - ( r1 + ( l - r1 ) / 2.0_rk ) * tand ( 1 6.7_rk ), ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 8 , 1 : 2 ) = [ 0.0_rk , ( r2 + ( h - r2 ) / 2.0_rk )] X_c ( 9 , 1 : 2 ) = [ - l , 0.0_rk ] X_c ( 10 , 1 : 2 ) = [ - l , h ] X_c ( 11 , 1 : 2 ) = [ - l , h ] X_c ( 12 , 1 : 2 ) = [ 0.0_rk , h ] X_c ( 13 : 24 , 1 : 2 ) = X_c ( 1 : 12 , 1 : 2 ) X_c ( 1 : 12 , 3 ) = 0.0_rk X_c ( 13 : 24 , 3 ) = w allocate ( W_c ( 12 * 2 ), source = 1.0_rk ) W_c ([ 2 , 3 , 14 , 15 ]) = cosd ( 2 2.5_rk ) case default error stop 'set_Xc_Wc: Invalid type. Valid types are: circle, ellipse' end select end subroutine !=============================================================================== end program","tags":"","url":"sourcefile/example_plate_hole_4_3d.f90.html"},{"title":"example_ppm1.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm1.f90~~EfferentGraph sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm1 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap , wp use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , real ( 0.0_rk , kind = wp ), real ( 2.2_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.08_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.01_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.22_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm1' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","url":"sourcefile/example_ppm1.f90.html"},{"title":"fdm_elevate_and_insert_3d.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_elevate_and_insert_3d.f90~~EfferentGraph sourcefile~fdm_elevate_and_insert_3d.f90 fdm_elevate_and_insert_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~fdm_elevate_and_insert_3d.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_elevate_and_insert_3d use forcad , only : rk , nurbs_volume use forcad_utils , only : linspace , kron_eye use fortime , only : timer implicit none type ( nurbs_volume ) :: sh0 , shr , shfd real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xc0 (:,:), Xp (:,:), Xm (:,:) real ( rk ), allocatable :: Xcp_vec (:), Xcm_vec (:) real ( rk ), allocatable :: knot1 (:), knot2 (:), knot3 (:) real ( rk ), allocatable :: S1 (:,:), S2 (:,:), S3 (:,:) real ( rk ), allocatable :: S4 (:,:), S5 (:,:), S6 (:,:) real ( rk ), allocatable :: Bs (:,:), B (:,:), Bfd (:,:) real ( rk ), allocatable :: u1 (:), u2 (:), u3 (:) integer , allocatable :: r1 (:), r2 (:), r3 (:) real ( rk ) :: rel_err integer :: dim , nc0 , ndof_old , ndof_new , i , d , idx type ( timer ) :: t real ( rk ), parameter :: tol = 1e-5_rk !! tolerance of finite differences integer , parameter :: dg1 = 4 , dg2 = 3 , dg3 = 2 !! degrees to elevate integer , parameter :: n1 = 2 , n2 = 3 , n3 = 4 !! number of knots to insert !> set control points Xc = generate_Xc ( 5.0_rk ) !> set weights allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 0.5_rk !> set knot vectors knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> set NURBS volume call shr % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> deallocate temporary arrays deallocate ( Xc , Wc , knot1 , knot2 , knot3 ) !> copy initial NURBS volume (before refinement) sh0 = shr !> get initial control points, dimension, number of control points and degrees of freedom Xc0 = sh0 % get_Xc () dim = size ( Xc0 , 2 ) nc0 = size ( Xc0 , 1 ) ndof_old = nc0 * dim !> elevate degree in three directions and get sensitivities (Bs: in compact form, memory efficient) call t % timer_start () call shr % elevate_degree ( 1 , dg1 , Bs = S1 ) call shr % elevate_degree ( 2 , dg2 , Bs = S2 ) call shr % elevate_degree ( 3 , dg3 , Bs = S3 ) call t % timer_stop () !> set knot vectors to insert u1 = linspace ( 0.0_rk , 1.0_rk , n1 + 2 ) u1 = u1 ( 2 : n1 + 1 ) u2 = linspace ( 0.0_rk , 1.0_rk , n2 + 2 ) u2 = u2 ( 2 : n2 + 1 ) u3 = linspace ( 0.0_rk , 1.0_rk , n3 + 2 ) u3 = u3 ( 2 : n3 + 1 ) !> multiplicities of knots to insert allocate ( r1 ( size ( u1 )), source = 2 ) allocate ( r2 ( size ( u2 )), source = 1 ) allocate ( r3 ( size ( u3 )), source = 2 ) !> insert knots in three directions and get sensitivities (Bs: in compact form, memory efficient) call t % timer_start () call shr % insert_knots ( 1 , u1 , r1 , Bs = S4 ) call shr % insert_knots ( 2 , u2 , r2 , Bs = S5 ) call shr % insert_knots ( 3 , u3 , r3 , Bs = S6 ) call t % timer_stop () !> compute global sensitivities (dXc_old/dXc_new) call t % timer_start () Bs = matmul ( S6 , matmul ( S5 , matmul ( S4 , matmul ( S3 , matmul ( S2 , S1 ))))) B = kron_eye ( Bs , dim ) call t % timer_stop () !> get new degrees of freedom (after refinement) ndof_new = size ( shr % get_Xc (), 1 ) * dim !> start finite difference computations allocate ( Xp ( nc0 , dim ), Xm ( nc0 , dim )) allocate ( Xcp_vec ( ndof_new ), Xcm_vec ( ndof_new )) allocate ( Bfd ( ndof_new , ndof_old )) do idx = 1 , ndof_old Xp = Xc0 Xm = Xc0 i = ( idx - 1 ) / dim + 1 d = mod ( idx - 1 , dim ) + 1 Xp ( i , d ) = Xp ( i , d ) + tol Xm ( i , d ) = Xm ( i , d ) - tol call shfd % set ( sh0 % get_knot ( 1 ), sh0 % get_knot ( 2 ), sh0 % get_knot ( 3 ), Xp , sh0 % get_Wc ()) call shfd % elevate_degree ( 1 , dg1 ) call shfd % elevate_degree ( 2 , dg2 ) call shfd % elevate_degree ( 3 , dg3 ) call shfd % insert_knots ( 1 , u1 , r1 ) call shfd % insert_knots ( 2 , u2 , r2 ) call shfd % insert_knots ( 3 , u3 , r3 ) Xcp_vec = reshape ( transpose ( shfd % get_Xc ()), [ ndof_new ]) call shfd % set ( sh0 % get_knot ( 1 ), sh0 % get_knot ( 2 ), sh0 % get_knot ( 3 ), Xm , sh0 % get_Wc ()) call shfd % elevate_degree ( 1 , dg1 ) call shfd % elevate_degree ( 2 , dg2 ) call shfd % elevate_degree ( 3 , dg3 ) call shfd % insert_knots ( 1 , u1 , r1 ) call shfd % insert_knots ( 2 , u2 , r2 ) call shfd % insert_knots ( 3 , u3 , r3 ) Xcm_vec = reshape ( transpose ( shfd % get_Xc ()), [ ndof_new ]) Bfd (:, idx ) = ( Xcp_vec - Xcm_vec ) * ( 0.5_rk / tol ) end do !> compute relative error between finite difference and analytical sensitivities rel_err = norm2 ( Bfd - B ) / norm2 ( Bfd ) print '(a)' , '--- CENTRAL FDM vs Analytic (elevate + insert) ---' print '(a,i0)' , '  ndof_old     = ' , ndof_old print '(a,i0)' , '  ndof_new     = ' , ndof_new print '(a,1pe12.4)' , '  ||B||_2      = ' , norm2 ( B ) print '(a,1pe12.4)' , '  ||Bfd||_2    = ' , norm2 ( Bfd ) print '(a,1pe12.4)' , '  ||B-Bfd||_2  = ' , norm2 ( Bfd - B ) print '(a,1pe12.4)' , '  rel l2 error = ' , rel_err !> finalize call shr % finalize () call sh0 % finalize () call shfd % finalize () contains pure function generate_Xc ( L ) result ( control_points ) real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function end program","tags":"","url":"sourcefile/fdm_elevate_and_insert_3d.f90.html"},{"title":"test_utils.f90 – ForCAD","text":"This file depends on sourcefile~~test_utils.f90~~EfferentGraph sourcefile~test_utils.f90 test_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~test_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~test_utils.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Author: Seyed Ali Ghasemi !> License: BSD 3-Clause !> Unit test program for `forcad_utils`. !> using ForUnitTest: https://github.com/gha3mi/forunittest program test_forcad_utils use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , basis_bspline_der , basis_bspline_2der , & basis_bernstein , compute_multiplicity , ndgrid , dyad , kron , unique , findspan , & compute_knot_vector , insert_knot_A_5_1 , remove_knots_A_5_8 , elevate_degree_A_5_9 , & hexahedron_Xc , tetragon_Xc , elemConn_C0 , elemConn_Cn , rotation , det , inv , gauss_leg , & export_vtk_legacy , solve , repelem , linspace , eye , kron_eye use forunittest , only : unit_tests implicit none type ( unit_tests ) :: ut real ( rk ) :: Xt integer :: nc , degree real ( rk ) :: knot ( 7 ) real ( rk ) :: B4 ( 4 ), dB ( 4 ), d2B ( 4 ), A4 ( 2 , 2 ) real ( rk ) :: B_ref ( 4 ), dB_ref ( 4 ), d2B_ref ( 4 ) real ( rk ) :: u ( 2 ), v ( 2 ), w ( 4 ) real ( rk ), allocatable :: u2 (:), v2 (:), w2 (:) real ( rk ) :: A2x2 ( 2 , 2 ), Bk ( 4 , 2 ) real ( rk ), allocatable :: A (:), vec (:), M (:,:) real ( rk ), allocatable :: X1 (:), X2 (:), X3 (:) real ( rk ), allocatable :: Xt2 (:,:), Xt3 (:,:) real ( rk ), allocatable :: R (:,:), R_expected (:,:) real ( rk ), allocatable :: knot_in (:), knot_out (:), Pw (:,:), Qw (:,:) real ( rk ), allocatable :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: K3 (:), K2 (:), K1 (:), out (:) integer , allocatable :: conn1D (:,:), conn2D (:,:), conn3D (:,:) integer :: nq , p , rr , s , k character ( len =* ), parameter :: vtk_file = \"vtk/test_output.vtk\" real ( rk ), allocatable :: A2 (:,:), A_inv (:,:) ! Initialize unit tests call ut % initialize ( n = 57 ) ! ---------------------------- ! Test: basis_bspline ! ---------------------------- degree = 2 nc = 4 knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 0.5_rk , 1.0_rk , 1.0_rk , 1.0_rk ] Xt = 0.5_rk B4 = basis_bspline ( Xt , knot , nc , degree ) B_ref = [ 0.0_rk , 0.5_rk , 0.5_rk , 0.0_rk ] call ut % test ( 1 )% check ( & name = \"basis_bspline\" , & res = B4 , & expected = B_ref , & msg = \"Partition of unity and shape check\" , & group = \"basis\" ) call ut % test ( 2 )% check ( & name = \"basis_sum\" , & res = sum ( B4 ), & expected = 1.0_rk , & msg = \"Partition of unity\" , & group = \"basis\" ) call basis_bspline_der ( Xt , knot , nc , degree , dB , B4 ) dB_ref = [ 0.0_rk , - 2.0_rk , 2.0_rk , 0.0_rk ] call ut % test ( 3 )% check ( & name = \"basis_bspline_der\" , & res = dB , & expected = dB_ref , & msg = \"1st derivative shape check\" , & group = \"basis_der\" ) call basis_bspline_der ( Xt , knot , nc , degree , dB ) call ut % test ( 4 )% check ( & name = \"basis_bspline_der_B\" , & res = dB , & expected = dB_ref , & msg = \"1st derivative alternate\" , & group = \"basis_der\" ) call basis_bspline_2der ( Xt , knot , nc , degree , d2B , dB , B4 ) d2B_ref = [ 0.0_rk , 4.0_rk , - 1 2.0_rk , 8.0_rk ] call ut % test ( 5 )% check ( & name = \"basis_bspline_2der_A\" , & res = d2B , & expected = d2B_ref , & msg = \"2nd derivative shape check A\" , & group = \"basis_2der\" ) call basis_bspline_2der ( Xt , knot , nc , degree , d2B , dB ) call ut % test ( 6 )% check ( & name = \"basis_bspline_2der_B\" , & res = d2B , & expected = d2B_ref , & msg = \"2nd derivative shape check B\" , & group = \"basis_2der\" ) call basis_bspline_2der ( Xt , knot , nc , degree , d2B ) call ut % test ( 7 )% check ( & name = \"basis_bspline_2der_C\" , & res = d2B , & expected = d2B_ref , & msg = \"2nd derivative shape check C\" , & group = \"basis_2der\" ) Xt = - 0.1_rk B4 = basis_bspline ( Xt , knot , nc , degree ) call ut % test ( 8 )% check ( & name = \"basis_out_of_bounds_low\" , & res = sum ( B4 ), & expected = 0.0_rk , & msg = \"Out-of-bounds left\" , & group = \"bounds\" ) Xt = 1.1_rk B4 = basis_bspline ( Xt , knot , nc , degree ) call ut % test ( 9 )% check ( & name = \"basis_out_of_bounds_high\" , & res = sum ( B4 ), & expected = 0.0_rk , & msg = \"Out-of-bounds right\" , & group = \"bounds\" ) ! ---------------------------- ! Test: basis_bernstein ! ---------------------------- call ut % test ( 10 )% check ( & name = \"basis_bernstein_sum\" , & res = sum ( basis_bernstein ( 0.3_rk , 3 )), & expected = 1.0_rk , & msg = \"Bernstein basis partition of unity\" , & group = \"bernstein\" ) ! ---------------------------- ! Test: compute_multiplicity ! ---------------------------- call ut % test ( 11 )% check ( & name = \"compute_multiplicity1\" , & res = compute_multiplicity ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ]), & expected = [ 2 , 2 ], & msg = \"Multiplicity vector\" , & group = \"multiplicity\" ) call ut % test ( 12 )% check ( & name = \"compute_multiplicity2\" , & res = compute_multiplicity ([ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ], 1.0_rk ), & expected = 3 , & msg = \"Multiplicity at value\" , & group = \"multiplicity\" ) ! ---------------------------- ! Test: ndgrid ! ---------------------------- X1 = [ 1.0_rk , 2.0_rk ] X2 = [ 1 0.0_rk , 2 0.0_rk ] X3 = [ 10 0.0_rk ] call ndgrid ( X1 , X2 , Xt2 ) call ndgrid ( X1 , X2 , X3 , Xt3 ) call ut % test ( 13 )% check ( & name = \"ndgrid2_shape\" , & res = shape ( Xt2 ), & expected = [ 4 , 2 ], & msg = \"ndgrid2 shape\" , & group = \"ndgrid\" ) call ut % test ( 14 )% check ( & name = \"ndgrid3_value\" , & res = Xt3 (:, 3 ), & expected = [ 10 0.0_rk , 10 0.0_rk , 10 0.0_rk , 10 0.0_rk ], & msg = \"ndgrid3 constant Z\" , & group = \"ndgrid\" ) ! ---------------------------- ! Test: dyad ! ---------------------------- A = [ 1.0_rk , 2.0_rk ] vec = [ 3.0_rk , 4.0_rk , 5.0_rk ] M = dyad ( A , vec ) call ut % test ( 15 )% check ( & name = \"dyad_check\" , & res = M , & expected = reshape ([ 3.0_rk , 6.0_rk , 4.0_rk , 8.0_rk , 5.0_rk , 1 0.0_rk ], [ 2 , 3 ]), & msg = \"Outer product a .dyad. b\" , & group = \"dyad\" ) ! ---------------------------- ! Test: kron ! ---------------------------- u = [ 1.0_rk , 2.0_rk ] v = [ 3.0_rk , 4.0_rk ] w = kron ( u , v ) call ut % test ( 16 )% check ( & name = \"kron_vector\" , & res = w , & expected = [ 3.0_rk , 4.0_rk , 6.0_rk , 8.0_rk ], & msg = \"u .kron. v\" , & group = \"kron\" ) A2x2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]) Bk = kron ( u , A2x2 ) call ut % test ( 17 )% check ( & name = \"kron_matrix\" , & res = Bk , & expected = reshape ([ 1.0_rk , 2.0_rk , 2.0_rk , 4.0_rk , 3.0_rk , 4.0_rk , 6.0_rk , 8.0_rk ], [ 4 , 2 ]), & msg = \"u .kron. A\" , & group = \"kron\" ) ! ---------------------------- ! Test: unique ! ---------------------------- call ut % test ( 18 )% check ( & name = \"unique_integer\" , & res = unique ([ 1 , 2 , 2 , 3 , 1 , 4 ]), & expected = [ 1 , 2 , 3 , 4 ], & msg = \"Unique integers\" , & group = \"unique\" ) call ut % test ( 19 )% check ( & name = \"unique_real\" , & res = unique ([ 1.0_rk , 1.0_rk + 1e-16_rk , 2.0_rk , 1.0_rk , 3.0_rk ]), & expected = [ 1.0_rk , 2.0_rk , 3.0_rk ], & msg = \"Unique real with tolerance\" , & group = \"unique\" ) ! ---------------------------- ! Test: findspan ! ---------------------------- call ut % test ( 20 )% check ( & name = \"findspan_middle\" , & res = findspan ( 4 , 2 , 0.5_rk , knot ), & expected = 3 , & msg = \"Find span index at Xt=0.5\" , & group = \"findspan\" ) ! ---------------------------- ! Test: compute_knot_vector ! ---------------------------- call ut % test ( 21 )% check ( & name = \"compute_knot_vector\" , & res = compute_knot_vector ([ 0.0_rk , 1.0_rk , 2.0_rk ], 2 , [ - 1 , 1 , - 1 ]), & expected = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 2.0_rk , 2.0_rk , 2.0_rk ], & msg = \"Knot vector construction\" , & group = \"knot\" ) ! ---------------------------- ! Test: repelem ! ---------------------------- call ut % test ( 22 )% check ( & name = \"repelem\" , & res = repelem ([ 1.0_rk , 2.0_rk , 3.0_rk ], [ 2 , 1 , 3 ]), & expected = [ 1.0_rk , 1.0_rk , 2.0_rk , 3.0_rk , 3.0_rk , 3.0_rk ], & msg = \"Repeat vector elements\" , & group = \"repelem\" ) ! ---------------------------- ! Test: hexahedron_Xc ! ---------------------------- call ut % test ( 23 )% check ( & name = \"hexahedron_Xc_shape\" , & res = shape ( hexahedron_Xc ([ 1.0_rk , 1.0_rk , 1.0_rk ], [ 2 , 2 , 2 ])), & expected = [ 8 , 3 ], & msg = \"3D grid shape\" , & group = \"geometry\" ) ! ---------------------------- ! Test: tetragon_Xc ! ---------------------------- call ut % test ( 24 )% check ( & name = \"tetragon_Xc_shape\" , & res = shape ( tetragon_Xc ([ 1.0_rk , 1.0_rk ], [ 2 , 2 ])), & expected = [ 4 , 3 ], & msg = \"2D grid shape\" , & group = \"geometry\" ) ! ---------------------------- ! Test: rotation ! ---------------------------- call ut % test ( 25 )% check ( & name = \"rotation_identity\" , & res = rotation ( 0.0_rk , 0.0_rk , 0.0_rk ), & expected = reshape ([ 1.0_rk , 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk ], [ 3 , 3 ]), & msg = \"Rotation(0,0,0) = I\" , & group = \"rotation\" ) ! ---------------------------- ! Test: det ! ---------------------------- call ut % test ( 26 )% check ( & name = \"det_2x2\" , & res = det ( reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ])), & expected = - 2.0_rk , & msg = \"Determinant 2x2\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv ! ---------------------------- call ut % test ( 27 )% check ( & name = \"inv_2x2\" , & res = inv ( reshape ([ 4.0_rk , 7.0_rk , 2.0_rk , 6.0_rk ], [ 2 , 2 ])), & expected = reshape ([ 0.6_rk , - 0.7_rk , - 0.2_rk , 0.4_rk ], [ 2 , 2 ]), & msg = \"Inverse of 2x2\" , & group = \"matrix\" ) ! ---------------------------- ! Test: solve ! ---------------------------- A4 = reshape ([ 4.0_rk , 1.0_rk , 1.0_rk , 3.0_rk ], [ 2 , 2 ]) R_expected = reshape ([ 1.0_rk / 1 1.0_rk , 7.0_rk / 1 1.0_rk ], [ 2 , 1 ]) R = solve ( A4 , reshape ([ 1.0_rk , 2.0_rk ], [ 2 , 1 ])) call ut % test ( 28 )% check ( & name = \"solve_linear_system\" , & res = R , & expected = R_expected , & msg = \"Solving A.X = B\" , & group = \"matrix\" ) ! ---------------------------- ! Test: insert_knot_A_5_1 ! ---------------------------- p = 2 rr = 1 s = 1 k = 3 allocate ( knot_in ( 0 : 6 )) knot_in = [ 0.0_rk , 0.0_rk , 0.0_rk , 0.5_rk , 1.0_rk , 1.0_rk , 1.0_rk ] allocate ( Pw ( 0 : 2 , 1 : 2 )) Pw ( 0 ,:) = [ 0.0_rk , 0.0_rk ] Pw ( 1 ,:) = [ 0.5_rk , 0.5_rk ] Pw ( 2 ,:) = [ 1.0_rk , 1.0_rk ] call insert_knot_A_5_1 ( p , knot_in , Pw , 0.5_rk , k , s , rr , nq , knot_out , Qw ) call ut % test ( 29 )% check ( & name = \"insert_knot_A_5_1_nq\" , & res = nq , & expected = 3 , & msg = \"Inserted knot, new number of control points\" , & group = \"insert_knot\" ) ! ---------------------------- ! Test: elevate_degree_A_5_9 ! ---------------------------- deallocate ( knot_in , knot_out , Pw , Qw ) knot_in = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] allocate ( Pw ( 1 : 2 , 1 : 2 )) Pw ( 1 ,:) = [ 0.0_rk , 0.0_rk ] Pw ( 2 ,:) = [ 0.5_rk , 0.5_rk ] call elevate_degree_A_5_9 ( t = 1 , knot = knot_in , degree = 1 , Xcw = Pw , nc_new = nc , knot_new = knot_out , Xcw_new = Qw ) call ut % test ( 30 )% check ( & name = \"elevate_degree_nc\" , & res = nc , & expected = 3 , & msg = \"New number of control points after elevation\" , & group = \"elevate_degree\" ) ! ---------------------------- ! Test: gauss_legendre_1D ! ---------------------------- call gauss_leg ([ 0.0_rk , 1.0_rk ], 2 , Xksi = vec , Wksi = A ) call ut % test ( 31 )% check ( & name = \"gauss_legendre_1D_pts\" , & res = size ( vec ), & expected = 3 , & msg = \"Number of Gauss points (1D)\" , & group = \"quadrature\" ) ! ---------------------------- ! Test: gauss_legendre_2D ! ---------------------------- call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 2 , 2 ], Xksi = Xksi , Wksi = Wksi ) call ut % test ( 32 )% check ( & name = \"gauss_legendre_2D_shape\" , & res = shape ( Xksi ), & expected = [ 9 , 2 ], & msg = \"Gauss points shape (2D)\" , & group = \"quadrature\" ) ! ---------------------------- ! Test: gauss_legendre_3D ! ---------------------------- call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 , 1 ], Xksi = Xksi , Wksi = Wksi ) call ut % test ( 33 )% check ( & name = \"gauss_legendre_3D_size\" , & res = size ( Xksi , 1 ), & expected = 8 , & msg = \"Number of Gauss points (3D)\" , & group = \"quadrature\" ) ! ---------------------------- ! Test: export_vtk_legacy ! ---------------------------- call export_vtk_legacy ( filename = vtk_file , points = reshape ([ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 0.0_rk , 0.0_rk ], [ 2 , 3 ]), & elemConn = reshape ([ 1 , 2 ], [ 1 , 2 ]), vtkCellType = 3 , encoding = \"binary\" ) call ut % test ( 34 )% check ( & name = \"export_vtk_legacy\" , & res = . true ., & expected = . true ., & msg = \"Export to VTK (not crashing)\" , & group = \"export\" ) call export_vtk_legacy ( filename = vtk_file , points = reshape ([ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 0.0_rk , 0.0_rk ], [ 2 , 3 ]), & elemConn = reshape ([ 1 , 2 ], [ 1 , 2 ]), vtkCellType = 3 , encoding = \"ascii\" ) call ut % test ( 35 )% check ( & name = \"export_vtk_legacy\" , & res = . true ., & expected = . true ., & msg = \"Export to VTK (not crashing)\" , & group = \"export\" ) ! ---------------------------- ! Test: linspace ! ---------------------------- call ut % test ( 36 )% check ( & name = \"linspace_uniform\" , & res = linspace ( 0.0_rk , 1.0_rk , 5 ), & expected = [ 0.0_rk , 0.25_rk , 0.5_rk , 0.75_rk , 1.0_rk ], & msg = \"Uniform linspace from 0 to 1\" , & group = \"linspace\" ) ! ---------------------------- ! Test: kron3 ! ---------------------------- K1 = [ 1.0_rk , 2.0_rk ] K2 = [ 3.0_rk ] K3 = [ 4.0_rk , 5.0_rk ] out = kron ( K1 , K2 , K3 ) call ut % test ( 37 )% check ( & name = \"kron3_product\" , & res = out , & expected = [ 1 2.0_rk , 1 5.0_rk , 2 4.0_rk , 3 0.0_rk ], & msg = \"kron3 result values\" , & group = \"kron\" ) ! ---------------------------- ! Test: elemConn_C0 ! ---------------------------- conn1D = elemConn_C0 ( 5 , 2 ) call ut % test ( 38 )% check ( & name = \"elemConn_C0_L\" , & res = conn1D , & expected = reshape ([ 1 , 3 , 2 , 4 , 3 , 5 ], [ 2 , 3 ]), & msg = \"Linear C0 connectivity\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_Cn (L) ! ---------------------------- call elemConn_Cn ( 5 , 2 , [ 0.0_rk , 0.5_rk , 1.0_rk ], [ 3 , 1 , 3 ], conn1D ) call ut % test ( 39 )% check ( & name = \"elemConn_Cn_L\" , & res = conn1D , & expected = reshape ([ 1 , 2 , 2 , 3 , 3 , 4 ], [ 2 , 3 ]), & msg = \"Linear Cn connectivity\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_C0 (2D) ! ---------------------------- conn2D = elemConn_C0 ( 5 , 5 , 2 , 2 ) call ut % test ( 40 )% check ( & name = \"elemConn_C0_S\" , & res = shape ( conn2D ), & expected = [ 4 , 9 ], & msg = \"Surface C0 connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_Cn (2D) ! ---------------------------- call elemConn_Cn ( 5 , 5 , 2 , 2 , [ 0.0_rk , 0.5_rk , 1.0_rk ], [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 3 , 1 , 3 ], [ 3 , 1 , 3 ], conn2D ) call ut % test ( 41 )% check ( & name = \"elemConn_Cn_S\" , & res = shape ( conn2D ), & expected = [ 4 , 9 ], & msg = \"Surface Cn connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_C0 (3D) ! ---------------------------- conn3D = elemConn_C0 ( 5 , 5 , 5 , 2 , 2 , 2 ) call ut % test ( 42 )% check ( & name = \"elemConn_C0_V\" , & res = shape ( conn3D ), & expected = [ 8 , 27 ], & msg = \"Volume C0 connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: elemConn_Cn (3D) ! ---------------------------- call elemConn_Cn ( 5 , 5 , 5 , 2 , 2 , 2 , & [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 0.0_rk , 0.5_rk , 1.0_rk ], & [ 3 , 1 , 3 ], [ 3 , 1 , 3 ], [ 3 , 1 , 3 ], conn3D ) call ut % test ( 43 )% check ( & name = \"elemConn_Cn_V\" , & res = shape ( conn3D ), & expected = [ 8 , 27 ], & msg = \"Volume Cn connectivity shape\" , & group = \"connectivity\" ) ! ---------------------------- ! Test: inv (3x3 matrix) ! ---------------------------- allocate ( A2 ( 3 , 3 )) A2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , & 0.0_rk , 1.0_rk , 4.0_rk , & 5.0_rk , 6.0_rk , 0.0_rk ], [ 3 , 3 ]) A_inv = inv ( A2 ) call ut % test ( 44 )% check ( & name = \"inv_3x3\" , & res = matmul ( A2 , A_inv ), & expected = eye ( 3 ), & msg = \"A . inv(A) = I for 3x3\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv (rectangular 3x2 matrix) ! ---------------------------- deallocate ( A2 , A_inv ) allocate ( A2 ( 3 , 2 )) A2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk , 5.0_rk , 6.0_rk ], [ 3 , 2 ]) A_inv = inv ( A2 ) call ut % test ( 45 )% check ( & name = \"inv_rectangular_3x2\" , & res = matmul ( A_inv , A2 ), & expected = eye ( 2 ), & msg = \"inv(A) . A = I for 3x2\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv (rectangular 2x3 matrix) ! ---------------------------- deallocate ( A2 , A_inv ) allocate ( A2 ( 2 , 3 )) A2 = reshape ([ 1.0_rk , 4.0_rk , 2.0_rk , 5.0_rk , 3.0_rk , 6.0_rk ], [ 2 , 3 ]) A_inv = inv ( A2 ) call ut % test ( 46 )% check ( & name = \"inv_rectangular_2x3\" , & res = matmul ( A2 , A_inv ), & expected = eye ( 2 ), & msg = \"A . inv(A) = I for 2x3\" , & group = \"matrix\" ) ! ---------------------------- ! Test: inv (identity matrix) ! ---------------------------- deallocate ( A2 , A_inv ) allocate ( A2 ( 4 , 4 )) A2 = eye ( 4 ) A_inv = inv ( A2 ) call ut % test ( 47 )% check ( & name = \"inv_identity\" , & res = A_inv , & expected = A2 , & msg = \"inv(I) = I\" , & group = \"matrix\" ) call ut % test ( 48 )% check ( & name = \"inv_rectangular_2x3_proj\" , & res = matmul ( A_inv , A2 ), & expected = transpose ( matmul ( A_inv , A2 )), & msg = \"inv(A) . A is symmetric projection (2x3)\" , & group = \"matrix\" ) ! ---------------------------- ! Test: kron_eye ! ---------------------------- if ( allocated ( A2 )) deallocate ( A2 ) allocate ( A2 ( 2 , 2 )) A2 = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ],[ 2 , 2 ]) R = kron_eye ( A2 , 2 ) call ut % test ( 49 )% check ( & name = \"kron_eye_block_diag\" , & res = R , & expected = reshape ([ & 1.0_rk , 0.0_rk , 2.0_rk , 0.0_rk , & 0.0_rk , 1.0_rk , 0.0_rk , 2.0_rk , & 3.0_rk , 0.0_rk , 4.0_rk , 0.0_rk , & 0.0_rk , 3.0_rk , 0.0_rk , 4.0_rk ], [ 4 , 4 ]), & msg = \"Kronecker with identity blocks\" , & group = \"kron\" ) ! ---------------------------- ! Test: kron_t1_t1 (vector .kron. vector) ! ---------------------------- ! different sizes + negatives/zeros u2 = [ - 1.0_rk , 0.0_rk , 2.0_rk ] v2 = [ 5.0_rk , - 3.0_rk ] w2 = kron ( u2 , v2 ) call ut % test ( 50 )% check ( & name = \"kron_t1_t1_values\" , & res = w2 , & expected = [ - 5.0_rk , 3.0_rk , 0.0_rk , 0.0_rk , 1 0.0_rk , - 6.0_rk ], & msg = \"kron(u,v) concatenates u(i)*v blocks\" , & group = \"kron\" ) ! length matches size(u)*size(v) call ut % test ( 51 )% check ( & name = \"kron_t1_t1_size\" , & res = size ( w2 ), & expected = size ( u2 ) * size ( v2 ), & msg = \"Length of kron(u,v)\" , & group = \"kron\" ) ! non-commutativity (order matters) call ut % test ( 52 )% check ( & name = \"kron_t1_t1_noncommutative\" , & res = all ( w2 == kron ( v2 , u2 )), & expected = . false ., & msg = \"kron(u,v) /= kron(v,u) for vectors\" , & group = \"kron\" ) ! ---------------------------- ! Test: kron3(u, v, w) ! ---------------------------- ! values with zeros/negatives and |v|=2, |w|=1 u2 = [ - 1.0_rk , 2.0_rk ] v2 = [ 0.0_rk , 3.0_rk ] K3 = [ - 2.0_rk ] out = kron ( u2 , v2 , K3 ) ! kron3 call ut % test ( 53 )% check ( & name = \"kron3_values_mixed\" , & res = out , & expected = [ 0.0_rk , 6.0_rk , 0.0_rk , - 1 2.0_rk ], & msg = \"ordering: (u1*v1*w1, u1*v2*w1, u2*v1*w1, u2*v2*w1)\" , & group = \"kron\" ) ! size = |u|*|v|*|w| call ut % test ( 54 )% check ( & name = \"kron3_size\" , & res = size ( out ), & expected = size ( u2 ) * size ( v2 ) * size ( K3 ), & msg = \"length of kron3 output\" , & group = \"kron\" ) ! associativity check: kron3(u,v,w) == kron(u, kron(v,w)) u2 = [ 1.0_rk , 2.0_rk ] v2 = [ 3.0_rk , 4.0_rk ] K3 = [ 5.0_rk ] out = kron ( u2 , v2 , K3 ) w2 = kron ( v2 , K3 ) A = kron ( u2 , w2 ) call ut % test ( 55 )% check ( & name = \"kron3_associativity_vec\" , & res = all ( abs ( out - A ) <= epsilon ( 0.0_rk )), & expected = . true ., & msg = \"kron3 equals kron(u, kron(v,w))\" , & group = \"kron\" ) ! another ordering/values case (|u|=2, |v|=1, |w|=3) u2 = [ 2.0_rk , - 1.0_rk ] v2 = [ 7.0_rk ] K3 = [ 1.0_rk , 0.0_rk , - 2.0_rk ] out = kron ( u2 , v2 , K3 ) call ut % test ( 56 )% check ( & name = \"kron3_values_ordering\" , & res = out , & expected = [ 1 4.0_rk , 0.0_rk , - 2 8.0_rk , - 7.0_rk , 0.0_rk , 1 4.0_rk ], & msg = \"iterate i (u), then j (v), then k (w)\" , & group = \"kron\" ) ! non-commutativity across arguments u2 = [ 1.0_rk , 2.0_rk ] v2 = [ 3.0_rk , 4.0_rk ] K3 = [ 5.0_rk ] ! length-1 w is fine; non-commutativity comes from u vs v call ut % test ( 57 )% check ( & name = \"kron3_noncommutative\" , & res = all ( kron ( u2 , v2 , K3 ) == kron ( v2 , u2 , K3 )), & expected = . false ., & msg = \"kron3(u,v,w) /= kron3(v,u,w)\" , & group = \"kron\" ) ! summary of tests call ut % summary ( & required_score = 10 0.0 , & verbose = 3 , & stop_fail = . false .) end program test_forcad_utils","tags":"","url":"sourcefile/test_utils.f90.html"},{"title":"shape_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_circle.f90~~EfferentGraph sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS circle !----------------------------------------------------------------------------- !> Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_circle ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_circle_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating circle !----------------------------------------------------------------------------- !> Generate the NURBS circle with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_circle_Xc.vtk' , 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_circle.f90.html"},{"title":"nearest_point_2d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d.f90~~EfferentGraph sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ) :: nearest_Xg ( 3 ) !! Coordinates of the nearest point on the surface real ( rk ) :: nearest_Xt ( 2 ) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 4 , 3 ) !! Control points real ( rk ) :: Wc ( 4 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a surface with 4 control points Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 0.7_rk , 1.0_rk ] call shape % set ( knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the surface (Approximation) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the surface (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) call shape % nearest_point2 ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","url":"sourcefile/nearest_point_2d.f90.html"},{"title":"shape_C_1d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_1d.f90~~EfferentGraph sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.F90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_interface.f90 forcad_interface.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_utils.f90 forcad_utils.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_interface.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_interface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_1d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_1d_Xc.vtk' , 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_c_1d.f90.html"}]}