var tipuesearch = {"pages":[{"title":" ForCAD ","text":"ForCAD ForCAD : A parallel Fortran library for geometric modeling using NURBS (Non-Uniform Rational B-Splines). ForCAD supports B-Spline , NURBS , Bezier , and Rational Bezier curves, surfaces, and volumes. Main Features Parallelized using OpenMP and do concurrent . Create NURBS objects by specifying control points, weights and knots. Refine NURBS objects by inserting or removing knots and elevating degree. Compute basis functions and derivatives of NURBS objects. Obtain IGA elements connectivity. Obtain visualized elements connectivity and coordinates for geometry and control geometry. Mesh insertion into a NURBS object. Export NURBS objects to VTK files for visualization. Export of NURBS curves and surfaces to IGES format (volumes currently not supported). Includes predefined NURBS shapes: Circle, Half Circle, Tetragon, Hexahedron, 2D Ring, Half 2D Ring, 3D Ring, Half 3D Ring, C-shapes. Rotate and translate NURBS objects. Visualization using provided python PyVista scripts. Examples Installation Requirements A Fortran compiler, such as GNU Fortran ( gfortran ), Intel Fortran Compiler ( ifx ) or NVIDIA HPC SDK Fortran compiler ( nvfortran ). The Fortran Package Manager fpm . Optional: PyVista (Recommended) or ParaView for visualization. Clone the repository Clone the ForCAD repository from GitHub: git clone https://github.com/gha3mi/forcad.git cd forcad Install PyVista (Optional) To install PyVista, run the following command: pip install pyvista Running Examples with fpm fpm run --example <file name excluding the .f90 extension> After executing the examples, .vtk files will be generated in the vtk directory. To visualize these files, a show() method is provided which utilizes PyVista. Alternatively, other visualization tools like ParaView can also be used. Using ForCAD as a fpm Dependency If you want to use ForCAD as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forcad = { git = \"https://github.com/gha3mi/forcad.git\" } Precision Configuration The library uses double precision ( real64 ) by default for all real-valued computations. To change the precision, you can define one of the following preprocessor flags during compilation: Preprocessor Flag Fortran Kind Description REAL32 selected_real_kind(6) Single precision REAL64 (default) selected_real_kind(15) Double precision REALXDP selected_real_kind(18) Extended double precision REAL128 selected_real_kind(33) Quadruple precision Note : The examples example_ppm1.f90 , example_ppm2.f90 , and example_ppm3.f90 use the ForColormap library, which only supports REAL64 precision. Example: Building with double precision fpm build --profile release --flag \"-DREAL64\" API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForCAD using ford run the following\ncommand: ford README.md Roadmap For a detailed roadmap outlining upcoming features and enhancements, please refer to ROADMAP.md . Contributing To contribute to ForCAD, please review the CONTRIBUTING.md . Citation If you use ForCAD in your research, please cite it as follows: @software { seyed_ali_ghasemi_2024_10904447 , author = {Ghasemi, S. A.} , title = {gha3mi/ForCAD} , year = 2024 , publisher = {Zenodo} , doi = {10.5281/zenodo.10904447} , url = {https://doi.org/10.5281/zenodo.10904447} } References Piegl, L., & Tiller, W. (1995). The NURBS Book. In Monographs in Visual Communications. Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-642-97385-7 An Introduction to NURBS. (2001). Elsevier. https://doi.org/10.1016/b978-1-55860-669-2.x5000-3 Sullivan et al., (2019). PyVista: 3D plotting and mesh analysis through a streamlined interface for the Visualization Toolkit (VTK). Journal of Open Source Software, 4(37), 1450, https://doi.org/10.21105/joss.01450 Ahrens, James, Geveci, Berk, Law, Charles, ParaView: An End-User Tool for Large Data Visualization, Visualization Handbook, Elsevier, 2005, ISBN-13: 9780123875822 Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"nurbs_volume – ForCAD ","text":"type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1) ng(2) ng(3), dim] real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dV private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dV) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dV generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS volume private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_degree Compute degree of the NURBS volume private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_degreeFace Compute degrees of the faces private pure function cmp_degreeFace (this, face) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elemFace Compute faces of the IGA elements private pure function cmp_elemFace (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elemFace_Xc_vis Compute faces of the control points private pure function cmp_elemFace_Xc_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elemFace_Xg_vis Compute faces of the geometry points private pure function cmp_elemFace_Xg_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_volume Compute the volume of the NURBS volume private pure subroutine cmp_volume (this, volume) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(out) :: volume procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS volume private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS volume private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate the degree of the NURBS volume private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth Export parameter space to VTK file private impure subroutine export_Xth (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: finalize Finalize the NURBS volume object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the NURBS volume private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knots private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS volume is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS volume (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS volume (Minimization - Newton's method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) procedure, public :: put_to_nurbs Put a shape to a NURBS volume private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 , set4 Set NURBS volume private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vectors, control points and weights for the NURBS volume object private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier volume using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set4 Set NURBS volume using degree, number of control points, control points and weights private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_ring Set a half ring private pure subroutine set_half_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: set_hexahedron Set a hexahedron private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_ring Set a ring private pure subroutine set_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS volume private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS volume private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS volume private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS volume private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS volume private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) procedure, private :: derivative_vector Compute the derivative of the NURBS volume private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_degree_all Get degree of the NURBS volume in all directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) procedure, private :: get_nc_all Get number of control points in all directions private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, private :: get_nc_dir Get number of control points in a specific direction private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer","tags":"","url":"type/nurbs_volume.html"},{"title":"nurbs_curve – ForCAD ","text":"type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dL private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dL) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dL generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS curve private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_degree Compute degree of the NURBS curve private pure subroutine cmp_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_length Compute the length of the NURBS curve private pure subroutine cmp_length (this, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(out) :: length procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: create Generate geometry points private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS curve private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS curve private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate the degree of the curve private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth Export parameter space to VTK file private impure subroutine export_Xth (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_iges Export the NURBS curve to an IGES file private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS curve object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the curve private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_degree Get degree of the NURBS curve private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knots private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS curve is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS curve (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS curve (Minimization - Newton's method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set1a , set2 , set3 , set4 Set NURBS curve private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set1a (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vector, control points and weights for the NURBS curve object private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1a private pure subroutine set1a (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier curve using control points and weights private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set4 Set NURBS curve using degree, number of control points, control points and weights private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: set_circle Set a circle private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_circle Set a half circle private pure subroutine set_half_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS curve private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS curve private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS curve private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS curve private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS curve private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) procedure, private :: derivative_vector Compute the derivative of the NURBS curve private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk)","tags":"","url":"type/nurbs_curve.html"},{"title":"nurbs_surface – ForCAD ","text":"type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dA private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dA) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dA generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS surface private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_area Compute the area of the NURBS surface private pure subroutine cmp_area (this, area) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(out) :: area procedure, public :: cmp_degree Compute degree of the NURBS surface private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS surface private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS surface private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate degree private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_Xth Export parameter space to VTK file private impure subroutine export_Xth (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding procedure, public :: export_iges Export the NURBS surface to IGES format private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS surface object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the NURBS surface private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knot vector private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS surface is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS surface (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS surface (Minimization - Newton's method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 , set4 Set NURBS surface private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vectors, control points and weights for the NURBS surface object private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier surface using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set4 Set NURBS surface using degree, number of control points, control points and weights private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_ring Set a half ring private pure subroutine set_half_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_ring Set a ring private pure subroutine set_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_tetragon Set a tetragon private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS surface private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS surface private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS surface private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS surface private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS surface private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) procedure, private :: derivative_vector Compute the derivative of the NURBS surface private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_degree_all Get degree of the NURBS surface in both directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) procedure, private :: get_nc_all Get number of control points in all directions private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, private :: get_nc_dir Get number of control points in a specific direction private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer","tags":"","url":"type/nurbs_surface.html"},{"title":"cmp_Tgc_3d – ForCAD","text":"private pure function cmp_Tgc_3d(Xti, knot1, knot2, knot3, nc, degree, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: nc (3) integer, intent(in) :: degree (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)*nc(3)) Calls proc~~cmp_tgc_3d~~CallsGraph proc~cmp_tgc_3d cmp_Tgc_3d proc~basis_bspline basis_bspline proc~cmp_tgc_3d->proc~basis_bspline proc~kron kron proc~cmp_tgc_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_tgc_3d~~CalledByGraph proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_nurbs_3d proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_volume%create proc~create->interface~compute_xg proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_tgc_3d.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~~CallsGraph proc~cmp_xg nurbs_volume%cmp_Xg interface~compute_xg compute_Xg proc~cmp_xg->interface~compute_xg proc~is_rational nurbs_volume%is_rational proc~cmp_xg->proc~is_rational proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~~CalledByGraph proc~cmp_xg nurbs_volume%cmp_Xg proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_xg.html"},{"title":"cmp_degreeFace – ForCAD","text":"private pure function cmp_degreeFace(this, face) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) Called by proc~~cmp_degreeface~~CalledByGraph proc~cmp_degreeface nurbs_volume%cmp_degreeFace program~example3_volume example3_volume program~example3_volume->proc~cmp_degreeface Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degreeface.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~~CallsGraph proc~cmp_elem nurbs_volume%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn interface~unique unique proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem~~CalledByGraph proc~cmp_elem nurbs_volume%cmp_elem proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth nurbs_volume%export_Xth proc~export_xth->proc~cmp_elem program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem.html"},{"title":"cmp_elemFace – ForCAD","text":"private pure function cmp_elemFace(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) Called by proc~~cmp_elemface~~CalledByGraph proc~cmp_elemface nurbs_volume%cmp_elemFace program~example3_volume example3_volume program~example3_volume->proc~cmp_elemface Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemface.html"},{"title":"cmp_elemFace_Xc_vis – ForCAD","text":"private pure function cmp_elemFace_Xc_vis(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:)","tags":"","url":"proc/cmp_elemface_xc_vis.html"},{"title":"cmp_elemFace_Xg_vis – ForCAD","text":"private pure function cmp_elemFace_Xg_vis(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:)","tags":"","url":"proc/cmp_elemface_xg_vis.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~~CallsGraph proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~~CalledByGraph proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc nurbs_volume%export_Xc proc~export_xc->proc~cmp_elem_xc_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis program~test_nurbs_volume->proc~export_xc program~example3_volume example3_volume program~example3_volume->proc~export_xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xc_vis.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~~CallsGraph proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~~CalledByGraph proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg nurbs_volume%export_Xg proc~export_xg->proc~cmp_elem_xg_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xg_vis program~test_nurbs_volume->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xg program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xg_vis.html"},{"title":"compute_Tgc_bspline_3d_scalar – ForCAD","text":"private pure function compute_Tgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_3d_scalar~~CallsGraph proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_3d_scalar~~CalledByGraph proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_3d_scalar proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_3d_scalar.html"},{"title":"compute_Tgc_bspline_3d_vector – ForCAD","text":"private pure function compute_Tgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_3d_vector~~CallsGraph proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_3d_vector~~CalledByGraph proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_3d_vector proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_3d_vector.html"},{"title":"compute_Tgc_nurbs_3d_scalar – ForCAD","text":"private pure function compute_Tgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_3d_scalar~~CallsGraph proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_3d_scalar~~CalledByGraph proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_nurbs_3d_scalar proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_3d_scalar.html"},{"title":"compute_Tgc_nurbs_3d_vector – ForCAD","text":"private pure function compute_Tgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_3d_vector~~CallsGraph proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_3d_vector~~CalledByGraph proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_nurbs_3d_vector proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_3d_vector.html"},{"title":"compute_Xg_bspline_3d – ForCAD","text":"private pure function compute_Xg_bspline_3d(Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_3d~~CallsGraph proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_3d~~CalledByGraph proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_3d proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_volume%create proc~create->interface~compute_xg proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_3d.html"},{"title":"compute_Xg_bspline_3d_1point – ForCAD","text":"private pure function compute_Xg_bspline_3d_1point(Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_bspline_3d_1point~~CallsGraph proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_3d_1point~~CalledByGraph proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_volume%create proc~create->interface~compute_xg proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_3d_1point.html"},{"title":"compute_Xg_nurbs_3d – ForCAD","text":"private pure function compute_Xg_nurbs_3d(Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_3d~~CallsGraph proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~basis_bspline basis_bspline proc~cmp_tgc_3d->proc~basis_bspline proc~kron kron proc~cmp_tgc_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_3d~~CalledByGraph proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_nurbs_3d proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_volume%create proc~create->interface~compute_xg proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_3d.html"},{"title":"compute_Xg_nurbs_3d_1point – ForCAD","text":"private pure function compute_Xg_nurbs_3d_1point(Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_nurbs_3d_1point~~CallsGraph proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~basis_bspline basis_bspline proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_nurbs_3d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_3d_1point~~CalledByGraph proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_volume%create proc~create->interface~compute_xg proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_3d_1point.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~~CalledByGraph proc~get_wc_all nurbs_volume%get_Wc_all none~get_wc nurbs_volume%get_Wc none~get_wc->proc~get_wc_all proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~get_wc proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~get_wc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_wc program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wc_all.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~~CalledByGraph proc~get_wci nurbs_volume%get_Wci none~get_wc nurbs_volume%get_Wc none~get_wc->proc~get_wci proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~get_wc proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~get_wc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_wc program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wci.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~~CalledByGraph proc~get_xc_all nurbs_volume%get_Xc_all none~get_xc nurbs_volume%get_Xc none~get_xc->proc~get_xc_all proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~get_xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xc program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xc_all.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~~CalledByGraph proc~get_xci nurbs_volume%get_Xci none~get_xc nurbs_volume%get_Xc none~get_xc->proc~get_xci proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~get_xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xc program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xci.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~~CalledByGraph proc~get_xcid nurbs_volume%get_Xcid none~get_xc nurbs_volume%get_Xc none~get_xc->proc~get_xcid proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~get_xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xc program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xcid.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xg_all~~CalledByGraph proc~get_xg_all nurbs_volume%get_Xg_all none~get_xg nurbs_volume%get_Xg none~get_xg->proc~get_xg_all program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xg_all.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xgi~~CalledByGraph proc~get_xgi nurbs_volume%get_Xgi none~get_xg nurbs_volume%get_Xg none~get_xg->proc~get_xgi program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgi.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xgid~~CalledByGraph proc~get_xgid nurbs_volume%get_Xgid none~get_xg nurbs_volume%get_Xg none~get_xg->proc~get_xgid program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgid.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xt~~CalledByGraph proc~get_xt nurbs_volume%get_Xt program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_xt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xt.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~~CallsGraph proc~get_continuity nurbs_volume%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_continuity~~CalledByGraph proc~get_continuity nurbs_volume%get_continuity program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_continuity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_continuity.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Called by proc~~get_degree_all~~CalledByGraph proc~get_degree_all nurbs_volume%get_degree_all none~get_degree nurbs_volume%get_degree none~get_degree->proc~get_degree_all program~example3_volume example3_volume program~example3_volume->none~get_degree program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_all.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Called by proc~~get_degree_dir~~CalledByGraph proc~get_degree_dir nurbs_volume%get_degree_dir none~get_degree nurbs_volume%get_degree none~get_degree->proc~get_degree_dir program~example3_volume example3_volume program~example3_volume->none~get_degree program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_dir.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem~~CalledByGraph proc~get_elem nurbs_volume%get_elem program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_elem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xc_vis~~CalledByGraph proc~get_elem_xc_vis nurbs_volume%get_elem_Xc_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_elem_xc_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xc_vis.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xg_vis~~CalledByGraph proc~get_elem_xg_vis nurbs_volume%get_elem_Xg_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_elem_xg_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xg_vis.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~~CalledByGraph proc~get_knot_all nurbs_volume%get_knot_all none~get_knot nurbs_volume%get_knot none~get_knot->proc~get_knot_all proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~get_knot proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~get_knot proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~get_knot proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~get_knot proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~get_knot program~example3_volume example3_volume program~example3_volume->none~get_knot program~example3_volume->proc~elevate_degree program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_knot program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knot_all.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~~CalledByGraph proc~get_knoti nurbs_volume%get_knoti none~get_knot nurbs_volume%get_knot none~get_knot->proc~get_knoti proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~get_knot proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~get_knot proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~get_knot proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~get_knot proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~get_knot program~example3_volume example3_volume program~example3_volume->none~get_knot program~example3_volume->proc~elevate_degree program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_knot program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knoti.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~~CallsGraph proc~get_multiplicity nurbs_volume%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~~CalledByGraph proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree nurbs_volume%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->proc~get_multiplicity program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~get_multiplicity program~test_nurbs_volume->proc~cmp_elem proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~export_xth nurbs_volume%export_Xth program~test_nurbs_volume->proc~export_xth none~set nurbs_volume%set program~test_nurbs_volume->none~set proc~elevate_degree nurbs_volume%elevate_degree program~test_nurbs_volume->proc~elevate_degree proc~insert_knots nurbs_volume%insert_knots program~test_nurbs_volume->proc~insert_knots proc~modify_wc nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc proc~modify_xc nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc proc~remove_knots nurbs_volume%remove_knots program~test_nurbs_volume->proc~remove_knots proc~set_c nurbs_volume%set_C program~test_nurbs_volume->proc~set_c proc~set_half_ring nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth->proc~cmp_elem proc~export_xth->none~set proc~set1 nurbs_volume%set1 proc~set1->proc~cmp_degree proc~set3 nurbs_volume%set3 proc~set3->proc~cmp_degree program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots none~set->proc~set1 none~set->proc~set3 program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~compute_volume->none~set proc~elevate_degree->none~set proc~insert_knots->none~set proc~modify_wc->none~set proc~modify_xc->none~set proc~remove_knots->none~set proc~set_c->none~set proc~set_half_ring->none~set proc~set_hexahedron->none~set proc~set_ring->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_multiplicity.html"},{"title":"get_nc_all – ForCAD","text":"private pure function get_nc_all(this) result(nc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Called by proc~~get_nc_all~~CalledByGraph proc~get_nc_all nurbs_volume%get_nc_all none~get_nc nurbs_volume%get_nc none~get_nc->proc~get_nc_all program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_nc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_all.html"},{"title":"get_nc_dir – ForCAD","text":"private pure function get_nc_dir(this, dir) result(nc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc_dir~~CallsGraph proc~get_nc_dir nurbs_volume%get_nc_dir interface~compute_multiplicity compute_multiplicity proc~get_nc_dir->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc_dir~~CalledByGraph proc~get_nc_dir nurbs_volume%get_nc_dir none~get_nc nurbs_volume%get_nc none~get_nc->proc~get_nc_dir program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~get_nc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_dir.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3)","tags":"","url":"proc/get_ng.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical Called by proc~~is_rational~~CalledByGraph proc~is_rational nurbs_volume%is_rational proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->proc~is_rational proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->proc~is_rational proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->proc~is_rational proc~create nurbs_volume%create proc~create->proc~is_rational proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->proc~is_rational proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->proc~is_rational proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->proc~is_rational proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->proc~is_rational none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~fdm_test_volume->none~derivative2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->none~basis program~test_nurbs_volume->none~derivative program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_rational.html"},{"title":"nearest_point_help_3d – ForCAD","text":"private pure function nearest_point_help_3d(ng, Xg, point_Xg) result(distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:) Called by proc~~nearest_point_help_3d~~CalledByGraph proc~nearest_point_help_3d nearest_point_help_3d proc~nearest_point nurbs_volume%nearest_point proc~nearest_point->proc~nearest_point_help_3d proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~nearest_point program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point program~nearest_point_3d->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point_help_3d.html"},{"title":"ansatz – ForCAD","text":"private pure subroutine ansatz(this, ie, ig, Tgc, dTgc_dXg, dV) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dV Calls proc~~ansatz~~CallsGraph proc~ansatz nurbs_volume%ansatz interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz->interface~ndgrid interface~unique unique proc~ansatz->interface~unique none~derivative nurbs_volume%derivative proc~ansatz->none~derivative none~set nurbs_volume%set proc~ansatz->none~set proc~cmp_elem nurbs_volume%cmp_elem proc~ansatz->proc~cmp_elem proc~det det proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar nurbs_volume%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_volume%derivative_vector none~derivative->proc~derivative_vector proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_elem->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_volume%is_rational proc~derivative_scalar->proc~is_rational proc~derivative_vector->interface~ndgrid proc~derivative_vector->interface~compute_dtgc proc~derivative_vector->proc~is_rational proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~kron proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ansatz~~CalledByGraph proc~ansatz nurbs_volume%ansatz proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ansatz.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~~CallsGraph proc~basis_scalar nurbs_volume%basis_scalar interface~compute_tgc compute_Tgc proc~basis_scalar->interface~compute_tgc proc~is_rational nurbs_volume%is_rational proc~basis_scalar->proc~is_rational proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc->proc~compute_tgc_nurbs_3d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_3d_scalar->proc~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->proc~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->proc~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_scalar~~CalledByGraph proc~basis_scalar nurbs_volume%basis_scalar none~basis nurbs_volume%basis none~basis->proc~basis_scalar program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_scalar.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~~CallsGraph proc~basis_vector nurbs_volume%basis_vector interface~compute_tgc compute_Tgc proc~basis_vector->interface~compute_tgc interface~ndgrid ndgrid proc~basis_vector->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~basis_vector->proc~is_rational proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc->proc~compute_tgc_nurbs_3d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_3d_scalar->proc~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->proc~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->proc~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_vector~~CalledByGraph proc~basis_vector nurbs_volume%basis_vector none~basis nurbs_volume%basis none~basis->proc~basis_vector program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_vector.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_degree~~CallsGraph proc~cmp_degree nurbs_volume%cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~~CalledByGraph proc~cmp_degree nurbs_volume%cmp_degree proc~set1 nurbs_volume%set1 proc~set1->proc~cmp_degree proc~set3 nurbs_volume%set3 proc~set3->proc~cmp_degree none~set nurbs_volume%set none~set->proc~set1 none~set->proc~set3 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~set proc~export_xth nurbs_volume%export_Xth proc~export_xth->none~set proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~set proc~set_c nurbs_volume%set_C proc~set_c->none~set proc~set_half_ring nurbs_volume%set_half_ring proc~set_half_ring->none~set proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set proc~set_ring nurbs_volume%set_ring proc~set_ring->none~set program~compute_volume compute_volume program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->proc~set_c program~test_nurbs_volume->proc~set_half_ring program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degree.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_nc~~CallsGraph proc~cmp_nc nurbs_volume%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~~CalledByGraph proc~cmp_nc nurbs_volume%cmp_nc proc~set1 nurbs_volume%set1 proc~set1->proc~cmp_nc proc~set2 nurbs_volume%set2 proc~set2->proc~cmp_nc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc none~set nurbs_volume%set program~test_nurbs_volume->none~set proc~elevate_degree nurbs_volume%elevate_degree program~test_nurbs_volume->proc~elevate_degree proc~export_xth nurbs_volume%export_Xth program~test_nurbs_volume->proc~export_xth proc~insert_knots nurbs_volume%insert_knots program~test_nurbs_volume->proc~insert_knots proc~modify_wc nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc proc~modify_xc nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc proc~remove_knots nurbs_volume%remove_knots program~test_nurbs_volume->proc~remove_knots proc~set_c nurbs_volume%set_C program~test_nurbs_volume->proc~set_c proc~set_half_ring nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume none~set->proc~set1 none~set->proc~set2 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~elevate_degree->none~set proc~export_xth->none~set proc~insert_knots->none~set proc~modify_wc->none~set proc~modify_xc->none~set proc~remove_knots->none~set proc~set_c->none~set proc~set_half_ring->none~set proc~set_hexahedron->none~set proc~set_ring->none~set program~compute_volume compute_volume program~compute_volume->none~set program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set proc~cmp_volume->proc~ansatz program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_nc.html"},{"title":"cmp_volume – ForCAD","text":"private pure subroutine cmp_volume(this, volume) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(out) :: volume Calls proc~~cmp_volume~~CallsGraph proc~cmp_volume nurbs_volume%cmp_volume proc~ansatz nurbs_volume%ansatz proc~cmp_volume->proc~ansatz proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_volume->proc~cmp_elem proc~ansatz->proc~cmp_elem interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz->interface~ndgrid interface~unique unique proc~ansatz->interface~unique none~derivative nurbs_volume%derivative proc~ansatz->none~derivative none~set nurbs_volume%set proc~ansatz->none~set proc~det det proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar nurbs_volume%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_volume%derivative_vector none~derivative->proc~derivative_vector proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_volume%is_rational proc~derivative_scalar->proc~is_rational proc~derivative_vector->interface~ndgrid proc~derivative_vector->interface~compute_dtgc proc~derivative_vector->proc~is_rational proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~kron proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_volume~~CalledByGraph proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_volume.html"},{"title":"compute_d2Tgc_bspline_3d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_3d_scalar~~CallsGraph proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_3d_scalar~~CalledByGraph proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_3d_scalar.html"},{"title":"compute_d2Tgc_bspline_3d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_3d_vector~~CallsGraph proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_3d_vector~~CalledByGraph proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_3d_vector.html"},{"title":"compute_d2Tgc_nurbs_3d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_3d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_3d_scalar~~CalledByGraph proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_3d_scalar.html"},{"title":"compute_d2Tgc_nurbs_3d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_3d_vector~~CallsGraph proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_3d_vector~~CalledByGraph proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_3d_vector.html"},{"title":"compute_dTgc_bspline_3d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~compute_dtgc_bspline_3d_scalar~~CallsGraph proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_3d_scalar~~CalledByGraph proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_3d_scalar.html"},{"title":"compute_dTgc_bspline_3d_vector – ForCAD","text":"private pure subroutine compute_dTgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_3d_vector~~CallsGraph proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_3d_vector~~CalledByGraph proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_3d_vector.html"},{"title":"compute_dTgc_nurbs_3d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~compute_dtgc_nurbs_3d_scalar~~CallsGraph proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_3d_scalar~~CalledByGraph proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_3d_scalar.html"},{"title":"compute_dTgc_nurbs_3d_vector – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_3d_vector~~CallsGraph proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_3d_vector~~CalledByGraph proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_3d_vector.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~~CallsGraph proc~create nurbs_volume%create interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~~CalledByGraph proc~create nurbs_volume%create proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~create program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/create.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~~CallsGraph proc~derivative2_scalar nurbs_volume%derivative2_scalar interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~is_rational nurbs_volume%is_rational proc~derivative2_scalar->proc~is_rational proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~~CalledByGraph proc~derivative2_scalar nurbs_volume%derivative2_scalar none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_scalar.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~~CallsGraph proc~derivative2_vector nurbs_volume%derivative2_vector interface~compute_d2tgc compute_d2Tgc proc~derivative2_vector->interface~compute_d2tgc interface~ndgrid ndgrid proc~derivative2_vector->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~derivative2_vector->proc~is_rational proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~~CalledByGraph proc~derivative2_vector nurbs_volume%derivative2_vector none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_vector.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc, elem) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~derivative_scalar~~CallsGraph proc~derivative_scalar nurbs_volume%derivative_scalar interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_volume%is_rational proc~derivative_scalar->proc~is_rational proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_scalar~~CalledByGraph proc~derivative_scalar nurbs_volume%derivative_scalar none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_scalar.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~~CallsGraph proc~derivative_vector nurbs_volume%derivative_vector interface~compute_dtgc compute_dTgc proc~derivative_vector->interface~compute_dtgc interface~ndgrid ndgrid proc~derivative_vector->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~derivative_vector->proc~is_rational proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_vector~~CalledByGraph proc~derivative_vector nurbs_volume%derivative_vector none~derivative nurbs_volume%derivative none~derivative->proc~derivative_vector proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_vector.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t Calls proc~~elevate_degree~~CallsGraph proc~elevate_degree nurbs_volume%elevate_degree none~get_knot nurbs_volume%get_knot proc~elevate_degree->none~get_knot none~set nurbs_volume%set proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~get_knot_all nurbs_volume%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_volume%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~~CalledByGraph proc~elevate_degree nurbs_volume%elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename, encoding) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xc~~CallsGraph proc~export_xc nurbs_volume%export_Xc proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~~CalledByGraph proc~export_xc nurbs_volume%export_Xc program~example3_volume example3_volume program~example3_volume->proc~export_xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xc.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename, encoding) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xg~~CallsGraph proc~export_xg nurbs_volume%export_Xg proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xg->proc~export_vtk_legacy interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~~CalledByGraph proc~export_xg nurbs_volume%export_Xg program~example3_volume example3_volume program~example3_volume->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xg program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xg program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xg.html"},{"title":"export_Xth – ForCAD","text":"private impure subroutine export_Xth(this, filename, encoding) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xth~~CallsGraph proc~export_xth nurbs_volume%export_Xth interface~ndgrid ndgrid proc~export_xth->interface~ndgrid interface~unique unique proc~export_xth->interface~unique none~set nurbs_volume%set proc~export_xth->none~set proc~cmp_elem nurbs_volume%cmp_elem proc~export_xth->proc~cmp_elem proc~export_vtk_legacy export_vtk_legacy proc~export_xth->proc~export_vtk_legacy proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_elem->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth~~CalledByGraph proc~export_xth nurbs_volume%export_Xth program~example3_volume example3_volume program~example3_volume->proc~export_xth program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xth Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this Called by proc~~finalize~~CalledByGraph proc~finalize nurbs_volume%finalize proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~finalize program~example3_volume example3_volume program~example3_volume->proc~finalize program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~finalize program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~finalize program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~finalize program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~finalize program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~finalize program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~finalize program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~finalize program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~finalize program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~finalize program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/finalize.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~~CallsGraph proc~insert_knots nurbs_volume%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity none~get_knot nurbs_volume%get_knot proc~insert_knots->none~get_knot none~set nurbs_volume%set proc~insert_knots->none~set proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all nurbs_volume%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_volume%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~~CalledByGraph proc~insert_knots nurbs_volume%insert_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~insert_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knots.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~~CallsGraph proc~modify_wc nurbs_volume%modify_Wc none~get_knot nurbs_volume%get_knot proc~modify_wc->none~get_knot none~get_wc nurbs_volume%get_Wc proc~modify_wc->none~get_wc none~get_xc nurbs_volume%get_Xc proc~modify_wc->none~get_xc none~set nurbs_volume%set proc~modify_wc->none~set proc~get_knot_all nurbs_volume%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_volume%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_volume%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_volume%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_volume%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_volume%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_volume%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_wc~~CalledByGraph proc~modify_wc nurbs_volume%modify_Wc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~modify_wc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_wc.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~~CallsGraph proc~modify_xc nurbs_volume%modify_Xc none~get_knot nurbs_volume%get_knot proc~modify_xc->none~get_knot none~get_wc nurbs_volume%get_Wc proc~modify_xc->none~get_wc none~get_xc nurbs_volume%get_Xc proc~modify_xc->none~get_xc none~set nurbs_volume%set proc~modify_xc->none~set proc~get_knot_all nurbs_volume%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_volume%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_volume%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_volume%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_volume%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_volume%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_volume%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_xc~~CalledByGraph proc~modify_xc nurbs_volume%modify_Xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_xc.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id Calls proc~~nearest_point~~CallsGraph proc~nearest_point nurbs_volume%nearest_point proc~nearest_point_help_3d nearest_point_help_3d proc~nearest_point->proc~nearest_point_help_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point~~CalledByGraph proc~nearest_point nurbs_volume%nearest_point proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~nearest_point program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point program~nearest_point_3d->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) Calls proc~~nearest_point2~~CallsGraph proc~nearest_point2 nurbs_volume%nearest_point2 none~derivative2 nurbs_volume%derivative2 proc~nearest_point2->none~derivative2 proc~cmp_xg nurbs_volume%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~create nurbs_volume%create proc~nearest_point2->proc~create proc~finalize nurbs_volume%finalize proc~nearest_point2->proc~finalize proc~inv inv proc~nearest_point2->proc~inv proc~nearest_point nurbs_volume%nearest_point proc~nearest_point2->proc~nearest_point proc~derivative2_scalar nurbs_volume%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_volume%derivative2_vector none~derivative2->proc~derivative2_vector interface~compute_xg compute_Xg proc~cmp_xg->interface~compute_xg proc~is_rational nurbs_volume%is_rational proc~cmp_xg->proc~is_rational proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~create->proc~is_rational proc~inv->proc~inv proc~det det proc~inv->proc~det proc~nearest_point_help_3d nearest_point_help_3d proc~nearest_point->proc~nearest_point_help_3d proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~~CalledByGraph proc~nearest_point2 nurbs_volume%nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point2.html"},{"title":"put_to_nurbs – ForCAD","text":"private pure subroutine put_to_nurbs(this, X, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) Calls proc~~put_to_nurbs~~CallsGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~basis_bspline basis_bspline proc~put_to_nurbs->proc~basis_bspline proc~kron kron proc~put_to_nurbs->proc~kron proc~set_elem_xg_vis nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~put_to_nurbs~~CalledByGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/put_to_nurbs.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~~CallsGraph proc~remove_knots nurbs_volume%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots->interface~compute_multiplicity none~get_knot nurbs_volume%get_knot proc~remove_knots->none~get_knot none~set nurbs_volume%set proc~remove_knots->none~set proc~findspan findspan proc~remove_knots->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all nurbs_volume%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_volume%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~~CalledByGraph proc~remove_knots nurbs_volume%remove_knots program~example3_volume example3_volume program~example3_volume->proc~remove_knots program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~~CallsGraph proc~rotate_xc nurbs_volume%rotate_Xc proc~rotation rotation proc~rotate_xc->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~~CalledByGraph proc~rotate_xc nurbs_volume%rotate_Xc program~example3_volume example3_volume program~example3_volume->proc~rotate_xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~rotate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xc.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~~CallsGraph proc~rotate_xg nurbs_volume%rotate_Xg proc~rotation rotation proc~rotate_xg->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~~CalledByGraph proc~rotate_xg nurbs_volume%rotate_Xg program~example3_volume example3_volume program~example3_volume->proc~rotate_xg program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~rotate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xg.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, knot3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~~CallsGraph proc~set1 nurbs_volume%set1 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~~CalledByGraph proc~set1 nurbs_volume%set1 none~set nurbs_volume%set none~set->proc~set1 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~set proc~export_xth nurbs_volume%export_Xth proc~export_xth->none~set proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~set proc~set_c nurbs_volume%set_C proc~set_c->none~set proc~set_half_ring nurbs_volume%set_half_ring proc~set_half_ring->none~set proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set proc~set_ring nurbs_volume%set_ring proc~set_ring->none~set program~compute_volume compute_volume program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->proc~set_c program~test_nurbs_volume->proc~set_half_ring program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~~CallsGraph proc~set2 nurbs_volume%set2 proc~cmp_nc nurbs_volume%cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~~CalledByGraph proc~set2 nurbs_volume%set2 none~set nurbs_volume%set none~set->proc~set2 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~set proc~export_xth nurbs_volume%export_Xth proc~export_xth->none~set proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~set proc~set_c nurbs_volume%set_C proc~set_c->none~set proc~set_half_ring nurbs_volume%set_half_ring proc~set_half_ring->none~set proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set proc~set_ring nurbs_volume%set_ring proc~set_ring->none~set program~compute_volume compute_volume program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->proc~set_c program~test_nurbs_volume->proc~set_half_ring program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier volume using control points and weights. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~~CallsGraph proc~set3 nurbs_volume%set3 proc~cmp_degree nurbs_volume%cmp_degree proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~~CalledByGraph proc~set3 nurbs_volume%set3 none~set nurbs_volume%set none~set->proc~set3 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~set proc~export_xth nurbs_volume%export_Xth proc~export_xth->none~set proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~set proc~set_c nurbs_volume%set_C proc~set_c->none~set proc~set_half_ring nurbs_volume%set_half_ring proc~set_half_ring->none~set proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set proc~set_ring nurbs_volume%set_ring proc~set_ring->none~set program~compute_volume compute_volume program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->proc~set_c program~test_nurbs_volume->proc~set_half_ring program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set3.html"},{"title":"set4 – ForCAD","text":"private pure subroutine set4(this, degree, nc, Xc, Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Called by proc~~set4~~CalledByGraph proc~set4 nurbs_volume%set4 none~set nurbs_volume%set none~set->proc~set4 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~set proc~export_xth nurbs_volume%export_Xth proc~export_xth->none~set proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~set proc~set_c nurbs_volume%set_C proc~set_c->none~set proc~set_half_ring nurbs_volume%set_half_ring proc~set_half_ring->none~set proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set proc~set_ring nurbs_volume%set_ring proc~set_ring->none~set program~compute_volume compute_volume program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->proc~set_c program~test_nurbs_volume->proc~set_half_ring program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set4.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_c~~CallsGraph proc~set_c nurbs_volume%set_C none~set nurbs_volume%set proc~set_c->none~set proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~~CalledByGraph proc~set_c nurbs_volume%set_C program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_c.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem~~CalledByGraph proc~set_elem nurbs_volume%set_elem program~example3_volume example3_volume program~example3_volume->proc~set_elem program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_elem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xc_vis~~CalledByGraph proc~set_elem_xc_vis nurbs_volume%set_elem_Xc_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_elem_xc_vis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xc_vis.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~~CalledByGraph proc~set_elem_xg_vis nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~set_elem_xg_vis program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_elem_xg_vis program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xg_vis.html"},{"title":"set_half_ring – ForCAD","text":"private pure subroutine set_half_ring(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_half_ring~~CallsGraph proc~set_half_ring nurbs_volume%set_half_ring none~set nurbs_volume%set proc~set_half_ring->none~set proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_ring~~CalledByGraph proc~set_half_ring nurbs_volume%set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_half_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_half_ring.html"},{"title":"set_hexahedron – ForCAD","text":"private pure subroutine set_hexahedron(this, L, nc, Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_hexahedron~~CallsGraph proc~set_hexahedron nurbs_volume%set_hexahedron none~set nurbs_volume%set proc~set_hexahedron->none~set proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_hexahedron~~CalledByGraph proc~set_hexahedron nurbs_volume%set_hexahedron program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_hexahedron.html"},{"title":"set_ring – ForCAD","text":"private pure subroutine set_ring(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_ring~~CallsGraph proc~set_ring nurbs_volume%set_ring none~set nurbs_volume%set proc~set_ring->none~set proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_ring~~CalledByGraph proc~set_ring nurbs_volume%set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_ring.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg Called by proc~~show~~CalledByGraph proc~show nurbs_volume%show program~example3_volume example3_volume program~example3_volume->proc~show program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~show program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~show program~shape_c_3d shape_C_3d program~shape_c_3d->proc~show program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~show program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~show program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/show.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~~CalledByGraph proc~translate_xc nurbs_volume%translate_Xc program~example3_volume example3_volume program~example3_volume->proc~translate_xc program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~translate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xc.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~~CalledByGraph proc~translate_xg nurbs_volume%translate_Xg program~example3_volume example3_volume program~example3_volume->proc~translate_xg program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~translate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xg.html"},{"title":"compute_Tgc – ForCAD","text":"private interface compute_Tgc Calls interface~~compute_tgc~~CallsGraph interface~compute_tgc compute_Tgc proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc->proc~compute_tgc_nurbs_3d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_3d_scalar->proc~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->proc~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->proc~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_tgc~~CalledByGraph interface~compute_tgc compute_Tgc proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~compute_tgc none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_tgc.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Calls interface~~compute_xg~~CallsGraph interface~compute_xg compute_Xg proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_xg~~CalledByGraph interface~compute_xg compute_Xg proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_volume%create proc~create->interface~compute_xg proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Xg_nurbs_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_bspline_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_xg.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Calls interface~~compute_d2tgc~~CallsGraph interface~compute_d2tgc compute_d2Tgc proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_d2tgc~~CalledByGraph interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_d2Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:)","tags":"","url":"interface/compute_d2tgc.html"},{"title":"compute_dTgc – ForCAD","text":"private interface compute_dTgc Calls interface~~compute_dtgc~~CallsGraph interface~compute_dtgc compute_dTgc proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_dtgc~~CalledByGraph interface~compute_dtgc compute_dTgc proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~compute_dtgc none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_volume->proc~ansatz program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_dTgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:)","tags":"","url":"interface/compute_dtgc.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~~CalledByGraph proc~generate_xc generate_Xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~generate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc.html"},{"title":"cmp_Tgc_1d – ForCAD","text":"private pure function cmp_Tgc_1d(Xti, knot, nc, degree, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xti real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc) Calls proc~~cmp_tgc_1d~~CallsGraph proc~cmp_tgc_1d cmp_Tgc_1d proc~basis_bspline basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_tgc_1d~~CalledByGraph proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_tgc_1d.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~2~~CallsGraph proc~cmp_xg~2 nurbs_curve%cmp_Xg interface~compute_xg~2 compute_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~cmp_xg~2->proc~is_rational~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~2~~CalledByGraph proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_xg~2.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~2~~CallsGraph proc~cmp_elem~2 nurbs_curve%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn interface~unique unique proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem~2~~CalledByGraph proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem~2.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~2~~CallsGraph proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~2~~CalledByGraph proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xc_vis~2.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~2~~CallsGraph proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~2~~CalledByGraph proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xg~2 program~example1_curve example1_curve program~example1_curve->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xg_vis~2.html"},{"title":"compute_Tgc_bspline_1d_scalar – ForCAD","text":"private pure function compute_Tgc_bspline_1d_scalar(Xt, knot, degree, nc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_1d_scalar~~CallsGraph proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_1d_scalar~~CalledByGraph proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_1d_scalar.html"},{"title":"compute_Tgc_bspline_1d_vector – ForCAD","text":"private pure function compute_Tgc_bspline_1d_vector(Xt, knot, degree, nc, ng) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_1d_vector~~CallsGraph proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_1d_vector~~CalledByGraph proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_1d_vector.html"},{"title":"compute_Tgc_nurbs_1d_scalar – ForCAD","text":"private pure function compute_Tgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_1d_scalar~~CallsGraph proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_1d_scalar~~CalledByGraph proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_1d_scalar.html"},{"title":"compute_Tgc_nurbs_1d_vector – ForCAD","text":"private pure function compute_Tgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_1d_vector~~CallsGraph proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_1d_vector~~CalledByGraph proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_1d_vector.html"},{"title":"compute_Xg_bspline_1d – ForCAD","text":"private pure function compute_Xg_bspline_1d(Xt, knot, degree, nc, ng, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_1d~~CallsGraph proc~compute_xg_bspline_1d compute_Xg_bspline_1d proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_1d~~CalledByGraph proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_bspline_1d proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_1d.html"},{"title":"compute_Xg_bspline_1d_1point – ForCAD","text":"private pure function compute_Xg_bspline_1d_1point(Xt, knot, degree, nc, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_bspline_1d_1point~~CallsGraph proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_1d_1point~~CalledByGraph proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_1d_1point.html"},{"title":"compute_Xg_nurbs_1d – ForCAD","text":"private pure function compute_Xg_nurbs_1d(Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_1d~~CallsGraph proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~basis_bspline basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_1d~~CalledByGraph proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_1d.html"},{"title":"compute_Xg_nurbs_1d_1point – ForCAD","text":"private pure function compute_Xg_nurbs_1d_1point(Xt, knot, degree, nc, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_nurbs_1d_1point~~CallsGraph proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_nurbs_1d_1point->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_1d_1point~~CalledByGraph proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_1d_1point.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~2~~CalledByGraph proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2 nurbs_curve%get_Wc none~get_wc~2->proc~get_wc_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_wc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_wc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wc_all~2.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~2~~CalledByGraph proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2 nurbs_curve%get_Wc none~get_wc~2->proc~get_wci~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_wc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_wc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wci~2.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~2~~CalledByGraph proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xc_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xc_all~2.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~2~~CalledByGraph proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xci~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xci~2.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~2~~CalledByGraph proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xcid~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xc~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xcid~2.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xg_all~2~~CalledByGraph proc~get_xg_all~2 nurbs_curve%get_Xg_all none~get_xg~2 nurbs_curve%get_Xg none~get_xg~2->proc~get_xg_all~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xg_all~2.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xgi~2~~CalledByGraph proc~get_xgi~2 nurbs_curve%get_Xgi none~get_xg~2 nurbs_curve%get_Xg none~get_xg~2->proc~get_xgi~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgi~2.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xgid~2~~CalledByGraph proc~get_xgid~2 nurbs_curve%get_Xgid none~get_xg~2 nurbs_curve%get_Xg none~get_xg~2->proc~get_xgid~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgid~2.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this) result(Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xt~2~~CalledByGraph proc~get_xt~2 nurbs_curve%get_Xt program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_xt~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xt~2.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this) result(c) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_continuity~2~~CallsGraph proc~get_continuity~2 nurbs_curve%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_continuity~2~~CalledByGraph proc~get_continuity~2 nurbs_curve%get_continuity program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_continuity~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_continuity~2.html"},{"title":"get_degree – ForCAD","text":"private pure function get_degree(this) result(degree) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Called by proc~~get_degree~~CalledByGraph proc~get_degree nurbs_curve%get_degree program~example1_curve example1_curve program~example1_curve->proc~get_degree program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem~2~~CalledByGraph proc~get_elem~2 nurbs_curve%get_elem program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_elem~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem~2.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xc_vis~2~~CalledByGraph proc~get_elem_xc_vis~2 nurbs_curve%get_elem_Xc_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_elem_xc_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xc_vis~2.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xg_vis~2~~CalledByGraph proc~get_elem_xg_vis~2 nurbs_curve%get_elem_Xg_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_elem_xg_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xg_vis~2.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~2~~CalledByGraph proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2 nurbs_curve%get_knot none~get_knot~2->proc~get_knot_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_knot~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_knot~2 program~example1_curve example1_curve program~example1_curve->none~get_knot~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_knot~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knot_all~2.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, i) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~2~~CalledByGraph proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2 nurbs_curve%get_knot none~get_knot~2->proc~get_knoti~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_knot~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_knot~2 program~example1_curve example1_curve program~example1_curve->none~get_knot~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~get_knot~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knoti~2.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this) result(m) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~2~~CallsGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~2~~CalledByGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~cmp_elem~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~export_xth~2 nurbs_curve%export_Xth program~test_nurbs_curve->proc~export_xth~2 none~set~2 nurbs_curve%set program~test_nurbs_curve->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~test_nurbs_curve->proc~elevate_degree~2 proc~insert_knots~2 nurbs_curve%insert_knots program~test_nurbs_curve->proc~insert_knots~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~remove_knots~2 nurbs_curve%remove_knots program~test_nurbs_curve->proc~remove_knots~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_c~2 nurbs_curve%set_C program~test_nurbs_curve->proc~set_c~2 proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~2->none~set~2 proc~set1a nurbs_curve%set1a proc~set1a->proc~cmp_degree~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 none~set~2->proc~set1a none~set~2->proc~set1~2 none~set~2->proc~set3~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_length->none~set~2 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 proc~elevate_degree~2->none~set~2 proc~insert_knots~2->none~set~2 proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~set~2 proc~remove_knots~2->none~set~2 proc~set_circle->none~set~2 proc~set_c~2->none~set~2 proc~set_half_circle->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_multiplicity~2.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Called by proc~~get_nc~~CalledByGraph proc~get_nc nurbs_curve%get_nc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_nc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Called by proc~~get_ng~2~~CalledByGraph proc~get_ng~2 nurbs_curve%get_ng program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~get_ng~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_ng~2.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical Called by proc~~is_rational~2~~CalledByGraph proc~is_rational~2 nurbs_curve%is_rational proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->proc~is_rational~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->proc~is_rational~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->proc~is_rational~2 proc~create~2 nurbs_curve%create proc~create~2->proc~is_rational~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->proc~is_rational~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->proc~is_rational~2 proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->proc~is_rational~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~is_rational~2 proc~export_iges nurbs_curve%export_iges proc~export_iges->proc~is_rational~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~is_rational~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~is_rational~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->none~derivative2~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_iges program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~fdm_test_curve->none~derivative2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_iges program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->none~basis~2 program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->none~derivative~2 program~test_nurbs_curve->proc~nearest_point2~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_rational~2.html"},{"title":"nearest_point_help_1d – ForCAD","text":"private pure function nearest_point_help_1d(ng, Xg, point_Xg) result(distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:) Called by proc~~nearest_point_help_1d~~CalledByGraph proc~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point~2->proc~nearest_point_help_1d proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~nearest_point~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point~2 program~nearest_point_1d->proc~nearest_point2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point_help_1d.html"},{"title":"ansatz – ForCAD","text":"private pure subroutine ansatz(this, ie, ig, Tgc, dTgc_dXg, dL) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dL Calls proc~~ansatz~2~~CallsGraph proc~ansatz~2 nurbs_curve%ansatz interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg interface~unique unique proc~ansatz~2->interface~unique none~derivative~2 nurbs_curve%derivative proc~ansatz~2->none~derivative~2 none~set~2 nurbs_curve%set proc~ansatz~2->none~set~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_elem~2->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ansatz~2~~CalledByGraph proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ansatz~2.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~2~~CallsGraph proc~basis_scalar~2 nurbs_curve%basis_scalar interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2->interface~compute_tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~basis_scalar~2->proc~is_rational~2 proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_scalar~2~~CalledByGraph proc~basis_scalar~2 nurbs_curve%basis_scalar none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_scalar~2.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~2~~CallsGraph proc~basis_vector~2 nurbs_curve%basis_vector interface~compute_tgc~2 compute_Tgc proc~basis_vector~2->interface~compute_tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~basis_vector~2->proc~is_rational~2 proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_vector~2~~CalledByGraph proc~basis_vector~2 nurbs_curve%basis_vector none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_vector~2.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Calls proc~~cmp_degree~2~~CallsGraph proc~cmp_degree~2 nurbs_curve%cmp_degree proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~2~~CalledByGraph proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a nurbs_curve%set1a proc~set1a->proc~cmp_degree~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 none~set~2 nurbs_curve%set none~set~2->proc~set1a none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degree~2.html"},{"title":"cmp_length – ForCAD","text":"private pure subroutine cmp_length(this, length) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(out) :: length Calls proc~~cmp_length~~CallsGraph proc~cmp_length nurbs_curve%cmp_length proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_length->proc~cmp_elem~2 proc~ansatz~2->proc~cmp_elem~2 interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg interface~unique unique proc~ansatz~2->interface~unique none~derivative~2 nurbs_curve%derivative proc~ansatz~2->none~derivative~2 none~set~2 nurbs_curve%set proc~ansatz~2->none~set~2 interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_length~~CalledByGraph proc~cmp_length nurbs_curve%cmp_length program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_length.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Calls proc~~cmp_nc~2~~CallsGraph proc~cmp_nc~2 nurbs_curve%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~2~~CalledByGraph proc~cmp_nc~2 nurbs_curve%cmp_nc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_nc~2.html"},{"title":"compute_d2Tgc_bspline_1d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_1d_scalar(Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_1d_scalar~~CallsGraph proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_1d_scalar~~CalledByGraph proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_1d_scalar.html"},{"title":"compute_d2Tgc_bspline_1d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_1d_vector(Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_1d_vector~~CallsGraph proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_1d_vector~~CalledByGraph proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_1d_vector.html"},{"title":"compute_d2Tgc_nurbs_1d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_1d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_1d_scalar~~CalledByGraph proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_1d_scalar.html"},{"title":"compute_d2Tgc_nurbs_1d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_1d_vector~~CallsGraph proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_1d_vector~~CalledByGraph proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_1d_vector.html"},{"title":"compute_dTgc_bspline_1d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_bspline_1d_scalar(Xt, knot, degree, nc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~compute_dtgc_bspline_1d_scalar~~CallsGraph proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_1d_scalar~~CalledByGraph proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_1d_scalar.html"},{"title":"compute_dTgc_bspline_1d_vector – ForCAD","text":"private pure subroutine compute_dTgc_bspline_1d_vector(Xt, knot, degree, nc, ng, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_1d_vector~~CallsGraph proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_1d_vector~~CalledByGraph proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_1d_vector.html"},{"title":"compute_dTgc_nurbs_1d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~compute_dtgc_nurbs_1d_scalar~~CallsGraph proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_1d_scalar~~CalledByGraph proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_1d_scalar.html"},{"title":"compute_dTgc_nurbs_1d_vector – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_1d_vector~~CallsGraph proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_1d_vector~~CalledByGraph proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_1d_vector.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res, Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) Calls proc~~create~2~~CallsGraph proc~create~2 nurbs_curve%create interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~2~~CalledByGraph proc~create~2 nurbs_curve%create proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/create~2.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~2~~CallsGraph proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative2_scalar~2->proc~is_rational~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~2~~CalledByGraph proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_scalar~2.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~2~~CallsGraph proc~derivative2_vector~2 nurbs_curve%derivative2_vector interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative2_vector~2->proc~is_rational~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~2~~CalledByGraph proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_vector~2.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc, elem) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~derivative_scalar~2~~CallsGraph proc~derivative_scalar~2 nurbs_curve%derivative_scalar interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_scalar~2~~CalledByGraph proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_scalar~2.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res, Xt, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~2~~CallsGraph proc~derivative_vector~2 nurbs_curve%derivative_vector interface~compute_dtgc~2 compute_dTgc proc~derivative_vector~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_vector~2->proc~is_rational~2 proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_vector~2~~CalledByGraph proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_vector~2.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, t) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t Calls proc~~elevate_degree~2~~CallsGraph proc~elevate_degree~2 nurbs_curve%elevate_degree none~set~2 nurbs_curve%set proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~is_rational~2 nurbs_curve%is_rational proc~elevate_degree~2->proc~is_rational~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~2~~CalledByGraph proc~elevate_degree~2 nurbs_curve%elevate_degree program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree~2.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename, encoding) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xc~2~~CallsGraph proc~export_xc~2 nurbs_curve%export_Xc proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~2~~CalledByGraph proc~export_xc~2 nurbs_curve%export_Xc program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xc~2.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename, encoding) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xg~2~~CallsGraph proc~export_xg~2 nurbs_curve%export_Xg proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xg~2->proc~export_vtk_legacy interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~2~~CalledByGraph proc~export_xg~2 nurbs_curve%export_Xg program~example1_curve example1_curve program~example1_curve->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xg~2.html"},{"title":"export_Xth – ForCAD","text":"private impure subroutine export_Xth(this, filename, encoding) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xth~2~~CallsGraph proc~export_xth~2 nurbs_curve%export_Xth interface~ndgrid ndgrid proc~export_xth~2->interface~ndgrid interface~unique unique proc~export_xth~2->interface~unique none~set~2 nurbs_curve%set proc~export_xth~2->none~set~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~export_xth~2->proc~cmp_elem~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xth~2->proc~export_vtk_legacy proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_elem~2->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth~2~~CalledByGraph proc~export_xth~2 nurbs_curve%export_Xth program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth~2.html"},{"title":"export_iges – ForCAD","text":"private impure subroutine export_iges(this, filename) Uses forIGES proc~~export_iges~~UsesGraph proc~export_iges nurbs_curve%export_iges forIGES forIGES proc~export_iges->forIGES Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename Calls proc~~export_iges~~CallsGraph proc~export_iges nurbs_curve%export_iges append append proc~export_iges->append delete delete proc~export_iges->delete init init proc~export_iges->init makedpsections makedpsections proc~export_iges->makedpsections makegsection makegsection proc~export_iges->makegsection makessection makessection proc~export_iges->makessection proc~is_rational~2 nurbs_curve%is_rational proc~export_iges->proc~is_rational~2 writeigesfile writeigesfile proc~export_iges->writeigesfile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_iges~~CalledByGraph proc~export_iges nurbs_curve%export_iges program~example1_curve example1_curve program~example1_curve->proc~export_iges program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_iges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_iges.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Called by proc~~finalize~2~~CalledByGraph proc~finalize~2 nurbs_curve%finalize proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~finalize~2 program~example1_curve example1_curve program~example1_curve->proc~finalize~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~finalize~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~finalize~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~finalize~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~finalize~2 program~shape_circle shape_circle program~shape_circle->proc~finalize~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~finalize~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~finalize~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/finalize~2.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, Xth, r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~2~~CallsGraph proc~insert_knots~2 nurbs_curve%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~is_rational~2 nurbs_curve%is_rational proc~insert_knots~2->proc~is_rational~2 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~2~~CalledByGraph proc~insert_knots~2 nurbs_curve%insert_knots program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~insert_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knots~2.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~2~~CallsGraph proc~modify_wc~2 nurbs_curve%modify_Wc none~get_knot~2 nurbs_curve%get_knot proc~modify_wc~2->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc proc~modify_wc~2->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc proc~modify_wc~2->none~get_xc~2 none~set~2 nurbs_curve%set proc~modify_wc~2->none~set~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_wc~2~~CalledByGraph proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~modify_wc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_wc~2.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~2~~CallsGraph proc~modify_xc~2 nurbs_curve%modify_Xc none~get_knot~2 nurbs_curve%get_knot proc~modify_xc~2->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc proc~modify_xc~2->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc proc~modify_xc~2->none~get_xc~2 none~set~2 nurbs_curve%set proc~modify_xc~2->none~set~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_xc~2~~CalledByGraph proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~modify_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_xc~2.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id Calls proc~~nearest_point~2~~CallsGraph proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2->proc~nearest_point_help_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point~2~~CalledByGraph proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~nearest_point~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point~2 program~nearest_point_1d->proc~nearest_point2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point~2.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) Calls proc~~nearest_point2~2~~CallsGraph proc~nearest_point2~2 nurbs_curve%nearest_point2 none~derivative2~2 nurbs_curve%derivative2 proc~nearest_point2~2->none~derivative2~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 proc~create~2 nurbs_curve%create proc~nearest_point2~2->proc~create~2 proc~finalize~2 nurbs_curve%finalize proc~nearest_point2~2->proc~finalize~2 proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point2~2->proc~nearest_point~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 interface~compute_xg~2 compute_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~cmp_xg~2->proc~is_rational~2 proc~create~2->interface~compute_xg~2 proc~create~2->proc~is_rational~2 proc~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2->proc~nearest_point_help_1d proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~2~~CalledByGraph proc~nearest_point2~2 nurbs_curve%nearest_point2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point2~2.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, Xth, r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~2~~CallsGraph proc~remove_knots~2 nurbs_curve%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~remove_knots~2->none~set~2 proc~findspan findspan proc~remove_knots~2->proc~findspan proc~is_rational~2 nurbs_curve%is_rational proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~2~~CalledByGraph proc~remove_knots~2 nurbs_curve%remove_knots program~example1_curve example1_curve program~example1_curve->proc~remove_knots~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~remove_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots~2.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~2~~CallsGraph proc~rotate_xc~2 nurbs_curve%rotate_Xc proc~rotation rotation proc~rotate_xc~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~2~~CalledByGraph proc~rotate_xc~2 nurbs_curve%rotate_Xc program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~rotate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xc~2.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~2~~CallsGraph proc~rotate_xg~2 nurbs_curve%rotate_Xg proc~rotation rotation proc~rotate_xg~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~2~~CalledByGraph proc~rotate_xg~2 nurbs_curve%rotate_Xg program~example1_curve example1_curve program~example1_curve->proc~rotate_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~rotate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xg~2.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot, Xc, Wc) Set knot vector, control points and weights for the NURBS curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~2~~CallsGraph proc~set1~2 nurbs_curve%set1 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~2~~CalledByGraph proc~set1~2 nurbs_curve%set1 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1~2.html"},{"title":"set1a – ForCAD","text":"private pure subroutine set1a(this, knot, Xc, Wc) Set knot vector, control points and weights for the NURBS curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1a~~CallsGraph proc~set1a nurbs_curve%set1a proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1a~~CalledByGraph proc~set1a nurbs_curve%set1a none~set~2 nurbs_curve%set none~set~2->proc~set1a proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1a.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir, degree, continuity, Xc, Wc) Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~2~~CallsGraph proc~set2~2 nurbs_curve%set2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~2~~CalledByGraph proc~set2~2 nurbs_curve%set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set2~2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, Xc, Wc) Set Bezier or Rational Bezier curve using control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~2~~CallsGraph proc~set3~2 nurbs_curve%set3 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~2~~CalledByGraph proc~set3~2 nurbs_curve%set3 none~set~2 nurbs_curve%set none~set~2->proc~set3~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set3~2.html"},{"title":"set4 – ForCAD","text":"private pure subroutine set4(this, degree, nc, Xc, Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Called by proc~~set4~2~~CalledByGraph proc~set4~2 nurbs_curve%set4 none~set~2 nurbs_curve%set none~set~2->proc~set4~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set4~2.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_c~2~~CallsGraph proc~set_c~2 nurbs_curve%set_C none~set~2 nurbs_curve%set proc~set_c~2->none~set~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~2~~CalledByGraph proc~set_c~2 nurbs_curve%set_C program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_c~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_c~2.html"},{"title":"set_circle – ForCAD","text":"private pure subroutine set_circle(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_circle~~CallsGraph proc~set_circle nurbs_curve%set_circle none~set~2 nurbs_curve%set proc~set_circle->none~set~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_circle~~CalledByGraph proc~set_circle nurbs_curve%set_circle program~shape_circle shape_circle program~shape_circle->proc~set_circle program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_circle.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem~2~~CalledByGraph proc~set_elem~2 nurbs_curve%set_elem program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_elem~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem~2.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xc_vis~2~~CalledByGraph proc~set_elem_xc_vis~2 nurbs_curve%set_elem_Xc_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_elem_xc_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xc_vis~2.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~2~~CalledByGraph proc~set_elem_xg_vis~2 nurbs_curve%set_elem_Xg_vis program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_elem_xg_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xg_vis~2.html"},{"title":"set_half_circle – ForCAD","text":"private pure subroutine set_half_circle(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_half_circle~~CallsGraph proc~set_half_circle nurbs_curve%set_half_circle none~set~2 nurbs_curve%set proc~set_half_circle->none~set~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_circle~~CalledByGraph proc~set_half_circle nurbs_curve%set_half_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_half_circle.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg Called by proc~~show~2~~CalledByGraph proc~show~2 nurbs_curve%show program~example1_curve example1_curve program~example1_curve->proc~show~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~show~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~show~2 program~shape_circle shape_circle program~shape_circle->proc~show~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~show~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/show~2.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~2~~CalledByGraph proc~translate_xc~2 nurbs_curve%translate_Xc program~example1_curve example1_curve program~example1_curve->proc~translate_xc~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~translate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xc~2.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~2~~CalledByGraph proc~translate_xg~2 nurbs_curve%translate_Xg program~example1_curve example1_curve program~example1_curve->proc~translate_xg~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~translate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xg~2.html"},{"title":"compute_Tgc – ForCAD","text":"private interface compute_Tgc Calls interface~~compute_tgc~2~~CallsGraph interface~compute_tgc~2 compute_Tgc proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_tgc~2~~CalledByGraph interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~basis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_scalar (Xt, knot, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_tgc~2.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Calls interface~~compute_xg~2~~CallsGraph interface~compute_xg~2 compute_Xg proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_xg~2~~CalledByGraph interface~compute_xg~2 compute_Xg proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Xg_nurbs_1d (Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d (Xt, knot, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point (Xt, knot, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_bspline_1d_1point (Xt, knot, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_xg~2.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Calls interface~~compute_d2tgc~2~~CallsGraph interface~compute_d2tgc~2 compute_d2Tgc proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_d2tgc~2~~CalledByGraph interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_d2Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_scalar (Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:)","tags":"","url":"interface/compute_d2tgc~2.html"},{"title":"compute_dTgc – ForCAD","text":"private interface compute_dTgc Calls interface~~compute_dtgc~2~~CallsGraph interface~compute_dtgc~2 compute_dTgc proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_dtgc~2~~CalledByGraph interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_dTgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_1d_vector (Xt, knot, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_1d_scalar (Xt, knot, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:)","tags":"","url":"interface/compute_dtgc~2.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~2~~CalledByGraph proc~generate_xc~2 generate_Xc program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~generate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~2.html"},{"title":"cmp_Tgc_2d – ForCAD","text":"private pure function cmp_Tgc_2d(Xti, knot1, knot2, nc, degree, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: nc (2) integer, intent(in) :: degree (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)) Calls proc~~cmp_tgc_2d~~CallsGraph proc~cmp_tgc_2d cmp_Tgc_2d proc~basis_bspline basis_bspline proc~cmp_tgc_2d->proc~basis_bspline proc~kron kron proc~cmp_tgc_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_tgc_2d~~CalledByGraph proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_tgc_2d.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~3~~CallsGraph proc~cmp_xg~3 nurbs_surface%cmp_Xg interface~compute_xg~3 compute_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~is_rational~3 nurbs_surface%is_rational proc~cmp_xg~3->proc~is_rational~3 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~3~~CalledByGraph proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_xg~3.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~3~~CallsGraph proc~cmp_elem~3 nurbs_surface%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem~3~~CalledByGraph proc~cmp_elem~3 nurbs_surface%cmp_elem proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->proc~cmp_elem~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem~3.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~3~~CallsGraph proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~3~~CalledByGraph proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3 nurbs_surface%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis~3 program~test_nurbs_surface->proc~export_xc~3 program~example3_surface example3_surface program~example3_surface->proc~export_xc~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xc_vis~3.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~3~~CallsGraph proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~3~~CalledByGraph proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3 nurbs_surface%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xg_vis~3 program~test_nurbs_surface->proc~export_xg~3 program~example3_surface example3_surface program~example3_surface->proc~export_xg~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xg~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elem_xg_vis~3.html"},{"title":"compute_Tgc_bspline_2d_scalar – ForCAD","text":"private pure function compute_Tgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_2d_scalar~~CallsGraph proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_2d_scalar~~CalledByGraph proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_2d_scalar proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_2d_scalar.html"},{"title":"compute_Tgc_bspline_2d_vector – ForCAD","text":"private pure function compute_Tgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_2d_vector~~CallsGraph proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_bspline_2d_vector~~CalledByGraph proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_2d_vector proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_bspline_2d_vector.html"},{"title":"compute_Tgc_nurbs_2d_scalar – ForCAD","text":"private pure function compute_Tgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_2d_scalar~~CallsGraph proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_2d_scalar~~CalledByGraph proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_scalar proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_2d_scalar.html"},{"title":"compute_Tgc_nurbs_2d_vector – ForCAD","text":"private pure function compute_Tgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_2d_vector~~CallsGraph proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_tgc_nurbs_2d_vector~~CalledByGraph proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_vector proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_tgc_nurbs_2d_vector.html"},{"title":"compute_Xg_bspline_2d – ForCAD","text":"private pure function compute_Xg_bspline_2d(Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_2d~~CallsGraph proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_2d~~CalledByGraph proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_2d proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_2d.html"},{"title":"compute_Xg_bspline_2d_1point – ForCAD","text":"private pure function compute_Xg_bspline_2d_1point(Xt, knot1, knot2, degree, nc, Xc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_bspline_2d_1point~~CallsGraph proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_bspline_2d_1point~~CalledByGraph proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_bspline_2d_1point.html"},{"title":"compute_Xg_nurbs_2d – ForCAD","text":"private pure function compute_Xg_nurbs_2d(Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_2d~~CallsGraph proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~basis_bspline basis_bspline proc~cmp_tgc_2d->proc~basis_bspline proc~kron kron proc~cmp_tgc_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_2d~~CalledByGraph proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_2d.html"},{"title":"compute_Xg_nurbs_2d_1point – ForCAD","text":"private pure function compute_Xg_nurbs_2d_1point(Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_nurbs_2d_1point~~CallsGraph proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~basis_bspline basis_bspline proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_nurbs_2d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_xg_nurbs_2d_1point~~CalledByGraph proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_xg_nurbs_2d_1point.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~3~~CalledByGraph proc~get_wc_all~3 nurbs_surface%get_Wc_all none~get_wc~3 nurbs_surface%get_Wc none~get_wc~3->proc~get_wc_all~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~get_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~get_wc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_wc~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wc_all~3.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~3~~CalledByGraph proc~get_wci~3 nurbs_surface%get_Wci none~get_wc~3 nurbs_surface%get_Wc none~get_wc~3->proc~get_wci~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~get_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~get_wc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_wc~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_wci~3.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~3~~CalledByGraph proc~get_xc_all~3 nurbs_surface%get_Xc_all none~get_xc~3 nurbs_surface%get_Xc none~get_xc~3->proc~get_xc_all~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~get_xc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xc~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xc_all~3.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~3~~CalledByGraph proc~get_xci~3 nurbs_surface%get_Xci none~get_xc~3 nurbs_surface%get_Xc none~get_xc~3->proc~get_xci~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~get_xc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xc~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xci~3.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~3~~CalledByGraph proc~get_xcid~3 nurbs_surface%get_Xcid none~get_xc~3 nurbs_surface%get_Xc none~get_xc~3->proc~get_xcid~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~get_xc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xc~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xcid~3.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xg_all~3~~CalledByGraph proc~get_xg_all~3 nurbs_surface%get_Xg_all none~get_xg~3 nurbs_surface%get_Xg none~get_xg~3->proc~get_xg_all~3 program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg~3 program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg~3 program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xg_all~3.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xgi~3~~CalledByGraph proc~get_xgi~3 nurbs_surface%get_Xgi none~get_xg~3 nurbs_surface%get_Xg none~get_xg~3->proc~get_xgi~3 program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg~3 program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg~3 program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgi~3.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xgid~3~~CalledByGraph proc~get_xgid~3 nurbs_surface%get_Xgid none~get_xg~3 nurbs_surface%get_Xg none~get_xg~3->proc~get_xgid~3 program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg~3 program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg~3 program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xgid~3.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xt~3~~CalledByGraph proc~get_xt~3 nurbs_surface%get_Xt program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_xt~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_xt~3.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~3~~CallsGraph proc~get_continuity~3 nurbs_surface%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_continuity~3~~CalledByGraph proc~get_continuity~3 nurbs_surface%get_continuity program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_continuity~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_continuity~3.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_degree_all~2~~CalledByGraph proc~get_degree_all~2 nurbs_surface%get_degree_all none~get_degree~3 nurbs_surface%get_degree none~get_degree~3->proc~get_degree_all~2 program~example3_surface example3_surface program~example3_surface->none~get_degree~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_all~2.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Called by proc~~get_degree_dir~2~~CalledByGraph proc~get_degree_dir~2 nurbs_surface%get_degree_dir none~get_degree~3 nurbs_surface%get_degree none~get_degree~3->proc~get_degree_dir~2 program~example3_surface example3_surface program~example3_surface->none~get_degree~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_degree_dir~2.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem~3~~CalledByGraph proc~get_elem~3 nurbs_surface%get_elem program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem~3.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xc_vis~3~~CalledByGraph proc~get_elem_xc_vis~3 nurbs_surface%get_elem_Xc_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_elem_xc_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xc_vis~3.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Called by proc~~get_elem_xg_vis~3~~CalledByGraph proc~get_elem_xg_vis~3 nurbs_surface%get_elem_Xg_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_elem_xg_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_elem_xg_vis~3.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~3~~CalledByGraph proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3 nurbs_surface%get_knot none~get_knot~3->proc~get_knot_all~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~get_knot~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~get_knot~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~get_knot~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~get_knot~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~get_knot~3 program~example3_surface example3_surface program~example3_surface->none~get_knot~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_knot~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knot_all~3.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~3~~CalledByGraph proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3 nurbs_surface%get_knot none~get_knot~3->proc~get_knoti~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~get_knot~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~get_knot~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~get_knot~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~get_knot~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~get_knot~3 program~example3_surface example3_surface program~example3_surface->none~get_knot~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_knot~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_knoti~3.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~3~~CallsGraph proc~get_multiplicity~3 nurbs_surface%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~3~~CalledByGraph proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3 nurbs_surface%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~get_multiplicity~3 program~test_nurbs_surface->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~export_xth~3 nurbs_surface%export_Xth program~test_nurbs_surface->proc~export_xth~3 none~set~3 nurbs_surface%set program~test_nurbs_surface->none~set~3 proc~elevate_degree~3 nurbs_surface%elevate_degree program~test_nurbs_surface->proc~elevate_degree~3 proc~insert_knots~3 nurbs_surface%insert_knots program~test_nurbs_surface->proc~insert_knots~3 proc~modify_wc~3 nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc~3 proc~remove_knots~3 nurbs_surface%remove_knots program~test_nurbs_surface->proc~remove_knots~3 proc~set_c~3 nurbs_surface%set_C program~test_nurbs_surface->proc~set_c~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring~2 proc~set_ring~2 nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~export_xth~3->proc~cmp_elem~3 proc~export_xth~3->none~set~3 proc~set1~3 nurbs_surface%set1 proc~set1~3->proc~cmp_degree~3 proc~set3~3 nurbs_surface%set3 proc~set3~3->proc~cmp_degree~3 none~set~3->proc~set1~3 none~set~3->proc~set3~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_area->none~set~3 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 proc~elevate_degree~3->none~set~3 proc~insert_knots~3->none~set~3 proc~modify_wc~3->none~set~3 proc~modify_xc~3->none~set~3 proc~remove_knots~3->none~set~3 proc~set_c~3->none~set~3 proc~set_half_ring~2->none~set~3 proc~set_ring~2->none~set~3 proc~set_tetragon->none~set~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_multiplicity~3.html"},{"title":"get_nc_all – ForCAD","text":"private pure function get_nc_all(this) result(nc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_nc_all~2~~CalledByGraph proc~get_nc_all~2 nurbs_surface%get_nc_all none~get_nc~3 nurbs_surface%get_nc none~get_nc~3->proc~get_nc_all~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_nc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_all~2.html"},{"title":"get_nc_dir – ForCAD","text":"private pure function get_nc_dir(this, dir) result(nc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc_dir~2~~CallsGraph proc~get_nc_dir~2 nurbs_surface%get_nc_dir interface~compute_multiplicity compute_multiplicity proc~get_nc_dir~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc_dir~2~~CalledByGraph proc~get_nc_dir~2 nurbs_surface%get_nc_dir none~get_nc~3 nurbs_surface%get_nc none~get_nc~3->proc~get_nc_dir~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~get_nc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_nc_dir~2.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_ng~3~~CalledByGraph proc~get_ng~3 nurbs_surface%get_ng program~example_ppm1 example_ppm1 program~example_ppm1->proc~get_ng~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~get_ng~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~get_ng~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/get_ng~3.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical Called by proc~~is_rational~3~~CalledByGraph proc~is_rational~3 nurbs_surface%is_rational proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->proc~is_rational~3 proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->proc~is_rational~3 proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->proc~is_rational~3 proc~create~3 nurbs_surface%create proc~create~3->proc~is_rational~3 proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->proc~is_rational~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->proc~is_rational~3 proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->proc~is_rational~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->proc~is_rational~3 proc~export_iges~2 nurbs_surface%export_iges proc~export_iges~2->proc~is_rational~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->proc~is_rational~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->proc~is_rational~3 none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_iges~2 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~fdm_test_surface->none~derivative2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_iges~2 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->none~basis~3 program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->none~derivative~3 program~test_nurbs_surface->proc~nearest_point2~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/is_rational~3.html"},{"title":"nearest_point_help_2d – ForCAD","text":"private pure function nearest_point_help_2d(ng, Xg, point_Xg) result(distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:) Called by proc~~nearest_point_help_2d~~CalledByGraph proc~nearest_point_help_2d nearest_point_help_2d proc~nearest_point~3 nurbs_surface%nearest_point proc~nearest_point~3->proc~nearest_point_help_2d proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~nearest_point~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~nearest_point~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point_help_2d.html"},{"title":"ansatz – ForCAD","text":"private pure subroutine ansatz(this, ie, ig, Tgc, dTgc_dXg, dA) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dA Calls proc~~ansatz~3~~CallsGraph proc~ansatz~3 nurbs_surface%ansatz interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz~3->interface~ndgrid interface~unique unique proc~ansatz~3->interface~unique none~derivative~3 nurbs_surface%derivative proc~ansatz~3->none~derivative~3 none~set~3 nurbs_surface%set proc~ansatz~3->none~set~3 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~det det proc~ansatz~3->proc~det proc~inv inv proc~ansatz~3->proc~inv proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~3 nurbs_surface%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_surface%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_elem~3->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~inv->proc~det proc~inv->proc~inv proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_surface%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->interface~compute_dtgc~3 proc~derivative_vector~3->proc~is_rational~3 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~kron proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ansatz~3~~CalledByGraph proc~ansatz~3 nurbs_surface%ansatz proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ansatz~3.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~3~~CallsGraph proc~basis_scalar~3 nurbs_surface%basis_scalar interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3->interface~compute_tgc~3 proc~is_rational~3 nurbs_surface%is_rational proc~basis_scalar~3->proc~is_rational~3 proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_2d_scalar->proc~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->proc~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->proc~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_scalar~3~~CalledByGraph proc~basis_scalar~3 nurbs_surface%basis_scalar none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_scalar~3.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res1, res2, Xt1, Xt2, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~3~~CallsGraph proc~basis_vector~3 nurbs_surface%basis_vector interface~compute_tgc~3 compute_Tgc proc~basis_vector~3->interface~compute_tgc~3 interface~ndgrid ndgrid proc~basis_vector~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~basis_vector~3->proc~is_rational~3 proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_2d_scalar->proc~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->proc~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->proc~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_vector~3~~CalledByGraph proc~basis_vector~3 nurbs_surface%basis_vector none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_vector~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_vector~3.html"},{"title":"cmp_area – ForCAD","text":"private pure subroutine cmp_area(this, area) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(out) :: area Calls proc~~cmp_area~~CallsGraph proc~cmp_area nurbs_surface%cmp_area proc~ansatz~3 nurbs_surface%ansatz proc~cmp_area->proc~ansatz~3 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_area->proc~cmp_elem~3 proc~ansatz~3->proc~cmp_elem~3 interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz~3->interface~ndgrid interface~unique unique proc~ansatz~3->interface~unique none~derivative~3 nurbs_surface%derivative proc~ansatz~3->none~derivative~3 none~set~3 nurbs_surface%set proc~ansatz~3->none~set~3 proc~det det proc~ansatz~3->proc~det proc~inv inv proc~ansatz~3->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~3 nurbs_surface%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_surface%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_surface%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->interface~compute_dtgc~3 proc~derivative_vector~3->proc~is_rational~3 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~kron proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_area~~CalledByGraph proc~cmp_area nurbs_surface%cmp_area program~compute_area compute_area program~compute_area->proc~cmp_area program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_area.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_degree~3~~CallsGraph proc~cmp_degree~3 nurbs_surface%cmp_degree proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~3~~CalledByGraph proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3 nurbs_surface%set1 proc~set1~3->proc~cmp_degree~3 proc~set3~3 nurbs_surface%set3 proc~set3~3->proc~cmp_degree~3 none~set~3 nurbs_surface%set none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->none~set~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_surface%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_surface%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_ring~2 nurbs_surface%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->proc~set_c~3 program~test_nurbs_surface->proc~set_half_ring~2 program~test_nurbs_surface->proc~set_ring~2 program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_degree~3.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_nc~3~~CallsGraph proc~cmp_nc~3 nurbs_surface%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~3~~CalledByGraph proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3 nurbs_surface%set1 proc~set1~3->proc~cmp_nc~3 proc~set2~3 nurbs_surface%set2 proc~set2~3->proc~cmp_nc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc~3 none~set~3 nurbs_surface%set program~test_nurbs_surface->none~set~3 proc~elevate_degree~3 nurbs_surface%elevate_degree program~test_nurbs_surface->proc~elevate_degree~3 proc~export_xth~3 nurbs_surface%export_Xth program~test_nurbs_surface->proc~export_xth~3 proc~insert_knots~3 nurbs_surface%insert_knots program~test_nurbs_surface->proc~insert_knots~3 proc~modify_wc~3 nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc~3 proc~remove_knots~3 nurbs_surface%remove_knots program~test_nurbs_surface->proc~remove_knots~3 proc~set_c~3 nurbs_surface%set_C program~test_nurbs_surface->proc~set_c~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring~2 proc~set_ring~2 nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree~3->none~set~3 proc~export_xth~3->none~set~3 proc~insert_knots~3->none~set~3 proc~modify_wc~3->none~set~3 proc~modify_xc~3->none~set~3 proc~remove_knots~3->none~set~3 proc~set_c~3->none~set~3 proc~set_half_ring~2->none~set~3 proc~set_ring~2->none~set~3 proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 proc~cmp_area->proc~ansatz~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_nc~3.html"},{"title":"compute_d2Tgc_bspline_2d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_2d_scalar~~CallsGraph proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_2d_scalar~~CalledByGraph proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_2d_scalar.html"},{"title":"compute_d2Tgc_bspline_2d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_2d_vector~~CallsGraph proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_bspline_2d_vector~~CalledByGraph proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_bspline_2d_vector.html"},{"title":"compute_d2Tgc_nurbs_2d_scalar – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_2d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_2d_scalar~~CalledByGraph proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_2d_scalar.html"},{"title":"compute_d2Tgc_nurbs_2d_vector – ForCAD","text":"private pure subroutine compute_d2Tgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_2d_vector~~CallsGraph proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_d2tgc_nurbs_2d_vector~~CalledByGraph proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_d2tgc_nurbs_2d_vector.html"},{"title":"compute_dTgc_bspline_2d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~compute_dtgc_bspline_2d_scalar~~CallsGraph proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_2d_scalar~~CalledByGraph proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_2d_scalar.html"},{"title":"compute_dTgc_bspline_2d_vector – ForCAD","text":"private pure subroutine compute_dTgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_2d_vector~~CallsGraph proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_bspline_2d_vector~~CalledByGraph proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_bspline_2d_vector.html"},{"title":"compute_dTgc_nurbs_2d_scalar – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~compute_dtgc_nurbs_2d_scalar~~CallsGraph proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_2d_scalar~~CalledByGraph proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_2d_scalar.html"},{"title":"compute_dTgc_nurbs_2d_vector – ForCAD","text":"private pure subroutine compute_dTgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_2d_vector~~CallsGraph proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_dtgc_nurbs_2d_vector~~CalledByGraph proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_dtgc_nurbs_2d_vector.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, Xt1, Xt2, Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~3~~CallsGraph proc~create~3 nurbs_surface%create interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~3~~CalledByGraph proc~create~3 nurbs_surface%create proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/create~3.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~3~~CallsGraph proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~is_rational~3 nurbs_surface%is_rational proc~derivative2_scalar~3->proc~is_rational~3 proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~3~~CalledByGraph proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_scalar~3.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~3~~CallsGraph proc~derivative2_vector~3 nurbs_surface%derivative2_vector interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_vector~3->interface~compute_d2tgc~3 interface~ndgrid ndgrid proc~derivative2_vector~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~derivative2_vector~3->proc~is_rational~3 proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~3~~CalledByGraph proc~derivative2_vector~3 nurbs_surface%derivative2_vector none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative2_vector~3.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc, elem) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Calls proc~~derivative_scalar~3~~CallsGraph proc~derivative_scalar~3 nurbs_surface%derivative_scalar interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_surface%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_scalar~3~~CalledByGraph proc~derivative_scalar~3 nurbs_surface%derivative_scalar none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_scalar~3.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res1, res2, Xt1, Xt2, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~3~~CallsGraph proc~derivative_vector~3 nurbs_surface%derivative_vector interface~compute_dtgc~3 compute_dTgc proc~derivative_vector~3->interface~compute_dtgc~3 interface~ndgrid ndgrid proc~derivative_vector~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~derivative_vector~3->proc~is_rational~3 proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative_vector~3~~CalledByGraph proc~derivative_vector~3 nurbs_surface%derivative_vector none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/derivative_vector~3.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t Calls proc~~elevate_degree~3~~CallsGraph proc~elevate_degree~3 nurbs_surface%elevate_degree none~get_knot~3 nurbs_surface%get_knot proc~elevate_degree~3->none~get_knot~3 none~set~3 nurbs_surface%set proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~is_rational~3 nurbs_surface%is_rational proc~elevate_degree~3->proc~is_rational~3 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~3~~CalledByGraph proc~elevate_degree~3 nurbs_surface%elevate_degree program~example3_surface example3_surface program~example3_surface->proc~elevate_degree~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree~3.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename, encoding) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xc~3~~CallsGraph proc~export_xc~3 nurbs_surface%export_Xc proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~3~~CalledByGraph proc~export_xc~3 nurbs_surface%export_Xc program~example3_surface example3_surface program~example3_surface->proc~export_xc~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xc~3.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename, encoding) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xg~3~~CallsGraph proc~export_xg~3 nurbs_surface%export_Xg proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xg~3->proc~export_vtk_legacy interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~3~~CalledByGraph proc~export_xg~3 nurbs_surface%export_Xg program~example3_surface example3_surface program~example3_surface->proc~export_xg~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xg~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xg~3.html"},{"title":"export_Xth – ForCAD","text":"private impure subroutine export_Xth(this, filename, encoding) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding Calls proc~~export_xth~3~~CallsGraph proc~export_xth~3 nurbs_surface%export_Xth interface~ndgrid ndgrid proc~export_xth~3->interface~ndgrid interface~unique unique proc~export_xth~3->interface~unique none~set~3 nurbs_surface%set proc~export_xth~3->none~set~3 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~export_xth~3->proc~cmp_elem~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xth~3->proc~export_vtk_legacy proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_elem~3->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xth~3~~CalledByGraph proc~export_xth~3 nurbs_surface%export_Xth program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_xth~3.html"},{"title":"export_iges – ForCAD","text":"private impure subroutine export_iges(this, filename) Uses forIGES proc~~export_iges~2~~UsesGraph proc~export_iges~2 nurbs_surface%export_iges forIGES forIGES proc~export_iges~2->forIGES Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename Calls proc~~export_iges~2~~CallsGraph proc~export_iges~2 nurbs_surface%export_iges append append proc~export_iges~2->append delete delete proc~export_iges~2->delete init init proc~export_iges~2->init makedpsections makedpsections proc~export_iges~2->makedpsections makegsection makegsection proc~export_iges~2->makegsection makessection makessection proc~export_iges~2->makessection proc~is_rational~3 nurbs_surface%is_rational proc~export_iges~2->proc~is_rational~3 writeigesfile writeigesfile proc~export_iges~2->writeigesfile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_iges~2~~CalledByGraph proc~export_iges~2 nurbs_surface%export_iges program~example3_surface example3_surface program~example3_surface->proc~export_iges~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_iges~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_iges~2.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this Called by proc~~finalize~3~~CalledByGraph proc~finalize~3 nurbs_surface%finalize proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~finalize~3 program~example3_surface example3_surface program~example3_surface->proc~finalize~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~finalize~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~finalize~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~finalize~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~finalize~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~finalize~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~finalize~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~finalize~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~finalize~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~finalize~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~finalize~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~finalize~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~finalize~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/finalize~3.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~3~~CallsGraph proc~insert_knots~3 nurbs_surface%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity none~get_knot~3 nurbs_surface%get_knot proc~insert_knots~3->none~get_knot~3 none~set~3 nurbs_surface%set proc~insert_knots~3->none~set~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~is_rational~3 nurbs_surface%is_rational proc~insert_knots~3->proc~is_rational~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~3~~CalledByGraph proc~insert_knots~3 nurbs_surface%insert_knots program~example3_surface example3_surface program~example3_surface->proc~insert_knots~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knots~3.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~3~~CallsGraph proc~modify_wc~3 nurbs_surface%modify_Wc none~get_knot~3 nurbs_surface%get_knot proc~modify_wc~3->none~get_knot~3 none~get_wc~3 nurbs_surface%get_Wc proc~modify_wc~3->none~get_wc~3 none~get_xc~3 nurbs_surface%get_Xc proc~modify_wc~3->none~get_xc~3 none~set~3 nurbs_surface%set proc~modify_wc~3->none~set~3 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_surface%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_surface%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_surface%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_surface%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_surface%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_wc~3~~CalledByGraph proc~modify_wc~3 nurbs_surface%modify_Wc program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~modify_wc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_wc~3.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~3~~CallsGraph proc~modify_xc~3 nurbs_surface%modify_Xc none~get_knot~3 nurbs_surface%get_knot proc~modify_xc~3->none~get_knot~3 none~get_wc~3 nurbs_surface%get_Wc proc~modify_xc~3->none~get_wc~3 none~get_xc~3 nurbs_surface%get_Xc proc~modify_xc~3->none~get_xc~3 none~set~3 nurbs_surface%set proc~modify_xc~3->none~set~3 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_surface%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_surface%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_surface%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_surface%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_surface%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_xc~3~~CalledByGraph proc~modify_xc~3 nurbs_surface%modify_Xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~modify_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/modify_xc~3.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id Calls proc~~nearest_point~3~~CallsGraph proc~nearest_point~3 nurbs_surface%nearest_point proc~nearest_point_help_2d nearest_point_help_2d proc~nearest_point~3->proc~nearest_point_help_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point~3~~CalledByGraph proc~nearest_point~3 nurbs_surface%nearest_point proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~nearest_point~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~nearest_point~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point~3.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) Calls proc~~nearest_point2~3~~CallsGraph proc~nearest_point2~3 nurbs_surface%nearest_point2 none~derivative2~3 nurbs_surface%derivative2 proc~nearest_point2~3->none~derivative2~3 proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 proc~create~3 nurbs_surface%create proc~nearest_point2~3->proc~create~3 proc~finalize~3 nurbs_surface%finalize proc~nearest_point2~3->proc~finalize~3 proc~inv inv proc~nearest_point2~3->proc~inv proc~nearest_point~3 nurbs_surface%nearest_point proc~nearest_point2~3->proc~nearest_point~3 proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 interface~compute_xg~3 compute_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~is_rational~3 nurbs_surface%is_rational proc~cmp_xg~3->proc~is_rational~3 proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~create~3->proc~is_rational~3 proc~inv->proc~inv proc~det det proc~inv->proc~det proc~nearest_point_help_2d nearest_point_help_2d proc~nearest_point~3->proc~nearest_point_help_2d proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~3~~CalledByGraph proc~nearest_point2~3 nurbs_surface%nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/nearest_point2~3.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~3~~CallsGraph proc~remove_knots~3 nurbs_surface%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~3->interface~compute_multiplicity none~get_knot~3 nurbs_surface%get_knot proc~remove_knots~3->none~get_knot~3 none~set~3 nurbs_surface%set proc~remove_knots~3->none~set~3 proc~findspan findspan proc~remove_knots~3->proc~findspan proc~is_rational~3 nurbs_surface%is_rational proc~remove_knots~3->proc~is_rational~3 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~3~~CalledByGraph proc~remove_knots~3 nurbs_surface%remove_knots program~example3_surface example3_surface program~example3_surface->proc~remove_knots~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots~3.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~3~~CallsGraph proc~rotate_xc~3 nurbs_surface%rotate_Xc proc~rotation rotation proc~rotate_xc~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~3~~CalledByGraph proc~rotate_xc~3 nurbs_surface%rotate_Xc program~example3_surface example3_surface program~example3_surface->proc~rotate_xc~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~rotate_xc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~rotate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xc~3.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~3~~CallsGraph proc~rotate_xg~3 nurbs_surface%rotate_Xg proc~rotation rotation proc~rotate_xg~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~3~~CalledByGraph proc~rotate_xg~3 nurbs_surface%rotate_Xg program~example3_surface example3_surface program~example3_surface->proc~rotate_xg~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~rotate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotate_xg~3.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, Xc, Wc) Set knot vectors, control points and weights for the NURBS surface object. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~3~~CallsGraph proc~set1~3 nurbs_surface%set1 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~3~~CalledByGraph proc~set1~3 nurbs_surface%set1 none~set~3 nurbs_surface%set none~set~3->proc~set1~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->none~set~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_surface%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_surface%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_ring~2 nurbs_surface%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->proc~set_c~3 program~test_nurbs_surface->proc~set_half_ring~2 program~test_nurbs_surface->proc~set_ring~2 program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set1~3.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~3~~CallsGraph proc~set2~3 nurbs_surface%set2 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~3~~CalledByGraph proc~set2~3 nurbs_surface%set2 none~set~3 nurbs_surface%set none~set~3->proc~set2~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->none~set~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_surface%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_surface%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_ring~2 nurbs_surface%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->proc~set_c~3 program~test_nurbs_surface->proc~set_half_ring~2 program~test_nurbs_surface->proc~set_ring~2 program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set2~3.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier surface using control points and weights. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~3~~CallsGraph proc~set3~3 nurbs_surface%set3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~3~~CalledByGraph proc~set3~3 nurbs_surface%set3 none~set~3 nurbs_surface%set none~set~3->proc~set3~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->none~set~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_surface%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_surface%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_ring~2 nurbs_surface%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->proc~set_c~3 program~test_nurbs_surface->proc~set_half_ring~2 program~test_nurbs_surface->proc~set_ring~2 program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set3~3.html"},{"title":"set4 – ForCAD","text":"private pure subroutine set4(this, degree, nc, Xc, Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Called by proc~~set4~3~~CalledByGraph proc~set4~3 nurbs_surface%set4 none~set~3 nurbs_surface%set none~set~3->proc~set4~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->none~set~3 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_surface%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_surface%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_ring~2 nurbs_surface%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->proc~set_c~3 program~test_nurbs_surface->proc~set_half_ring~2 program~test_nurbs_surface->proc~set_ring~2 program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set4~3.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_c~3~~CallsGraph proc~set_c~3 nurbs_surface%set_C none~set~3 nurbs_surface%set proc~set_c~3->none~set~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~3~~CalledByGraph proc~set_c~3 nurbs_surface%set_C program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_c~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_c~3.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem~3~~CalledByGraph proc~set_elem~3 nurbs_surface%set_elem program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem~3.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xc_vis~3~~CalledByGraph proc~set_elem_xc_vis~3 nurbs_surface%set_elem_Xc_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_elem_xc_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xc_vis~3.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~3~~CalledByGraph proc~set_elem_xg_vis~3 nurbs_surface%set_elem_Xg_vis program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_elem_xg_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_elem_xg_vis~3.html"},{"title":"set_half_ring – ForCAD","text":"private pure subroutine set_half_ring(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_half_ring~2~~CallsGraph proc~set_half_ring~2 nurbs_surface%set_half_ring none~set~3 nurbs_surface%set proc~set_half_ring~2->none~set~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_ring~2~~CalledByGraph proc~set_half_ring~2 nurbs_surface%set_half_ring program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_half_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_half_ring~2.html"},{"title":"set_ring – ForCAD","text":"private pure subroutine set_ring(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_ring~2~~CallsGraph proc~set_ring~2 nurbs_surface%set_ring none~set~3 nurbs_surface%set proc~set_ring~2->none~set~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_ring~2~~CalledByGraph proc~set_ring~2 nurbs_surface%set_ring program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_ring~2.html"},{"title":"set_tetragon – ForCAD","text":"private pure subroutine set_tetragon(this, L, nc, Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_tetragon~~CallsGraph proc~set_tetragon nurbs_surface%set_tetragon none~set~3 nurbs_surface%set proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_tetragon~~CalledByGraph proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/set_tetragon.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg Called by proc~~show~3~~CalledByGraph proc~show~3 nurbs_surface%show program~example3_surface example3_surface program~example3_surface->proc~show~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~show~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~show~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~show~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~show~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~show~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/show~3.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~3~~CalledByGraph proc~translate_xc~3 nurbs_surface%translate_Xc program~example3_surface example3_surface program~example3_surface->proc~translate_xc~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~translate_xc~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~translate_xc~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~translate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xc~3.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~3~~CalledByGraph proc~translate_xg~3 nurbs_surface%translate_Xg program~example3_surface example3_surface program~example3_surface->proc~translate_xg~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~translate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/translate_xg~3.html"},{"title":"compute_Tgc – ForCAD","text":"private interface compute_Tgc Calls interface~~compute_tgc~3~~CallsGraph interface~compute_tgc~3 compute_Tgc proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_2d_scalar->proc~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->proc~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->proc~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_tgc~3~~CalledByGraph interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~compute_tgc~3 none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~basis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_tgc~3.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Calls interface~~compute_xg~3~~CallsGraph interface~compute_xg~3 compute_Xg proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_xg~3~~CalledByGraph interface~compute_xg~3 compute_Xg proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_Xg_nurbs_2d (Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d (Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point (Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_bspline_2d_1point (Xt, knot1, knot2, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:)","tags":"","url":"interface/compute_xg~3.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Calls interface~~compute_d2tgc~3~~CallsGraph interface~compute_d2tgc~3 compute_d2Tgc proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_d2tgc~3~~CalledByGraph interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_d2Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:)","tags":"","url":"interface/compute_d2tgc~3.html"},{"title":"compute_dTgc – ForCAD","text":"private interface compute_dTgc Calls interface~~compute_dtgc~3~~CallsGraph interface~compute_dtgc~3 compute_dTgc proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_dtgc~3~~CalledByGraph interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_area->proc~ansatz~3 program~compute_area compute_area program~compute_area->proc~cmp_area Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine compute_dTgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:)","tags":"","url":"interface/compute_dtgc~3.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~3~~CalledByGraph proc~generate_xc~3 generate_Xc program~example3_surface example3_surface program~example3_surface->proc~generate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~3.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~4~~CalledByGraph proc~generate_xc~4 generate_Xc program~example3_volume example3_volume program~example3_volume->proc~generate_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~4.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~5~~CalledByGraph proc~generate_xc~5 generate_Xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~generate_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/generate_xc~5.html"},{"title":"basis_bernstein – ForCAD","text":"public pure function basis_bernstein(Xt, nc) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:)","tags":"","url":"proc/basis_bernstein.html"},{"title":"basis_bspline – ForCAD","text":"public pure function basis_bspline(Xt, knot, nc, degree) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), (nc) Called by proc~~basis_bspline~~CalledByGraph proc~basis_bspline basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~cmp_tgc_1d->proc~basis_bspline proc~cmp_tgc_2d cmp_Tgc_2d proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_3d cmp_Tgc_3d proc~cmp_tgc_3d->proc~basis_bspline proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_xg_bspline_1d compute_Xg_bspline_1d proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~basis_bspline interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_3d_scalar interface~compute_tgc->proc~compute_tgc_bspline_3d_vector interface~compute_tgc->proc~compute_tgc_nurbs_3d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_3d_vector interface~compute_tgc~2 compute_Tgc interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_2d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_2d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_vector interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d interface~compute_xg~2 compute_Xg interface~compute_xg~2->proc~compute_xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~compute_tgc proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create nurbs_volume%create proc~create->interface~compute_xg proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~basis~2 nurbs_curve%basis none~basis~2->proc~basis_scalar~2 none~basis~2->proc~basis_vector~2 none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->proc~create~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~create~2 program~test_nurbs_curve->none~basis~2 program~test_nurbs_curve->proc~nearest_point2~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->none~basis~3 program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->none~basis program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline.html"},{"title":"compute_knot_vector – ForCAD","text":"public pure function compute_knot_vector(Xth_dir, degree, continuity) result(knot) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_knot_vector~~CallsGraph proc~compute_knot_vector compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_knot_vector~~CalledByGraph proc~compute_knot_vector compute_knot_vector proc~set2 nurbs_volume%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_surface%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_volume%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~3 nurbs_surface%set none~set~3->proc~set2~3 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~set~3 proc~export_xth nurbs_volume%export_Xth proc~export_xth->none~set proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->none~set~3 proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~set~3 proc~set_c nurbs_volume%set_C proc~set_c->none~set proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3 nurbs_surface%set_C proc~set_c~3->none~set~3 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 proc~set_half_ring nurbs_volume%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_surface%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set proc~set_ring nurbs_volume%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_surface%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->proc~set_c~3 program~test_nurbs_surface->proc~set_half_ring~2 program~test_nurbs_surface->proc~set_ring~2 program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->proc~set_c program~test_nurbs_volume->proc~set_half_ring program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz~3 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_knot_vector.html"},{"title":"det – ForCAD","text":"public pure function det(A) result(detA) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk) Called by proc~~det~~CalledByGraph proc~det det proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~det proc~ansatz~3->proc~inv proc~inv->proc~det proc~inv->proc~inv proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~inv proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~inv program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/det.html"},{"title":"findspan – ForCAD","text":"public pure function findspan(n, degree, Xth, knot) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer Called by proc~~findspan~~CalledByGraph proc~findspan findspan proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->proc~findspan proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~findspan proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->proc~findspan proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->proc~findspan proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~findspan proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->proc~findspan program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example3_volume example3_volume program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/findspan.html"},{"title":"hexahedron_Xc – ForCAD","text":"public pure function hexahedron_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~hexahedron_xc~~CalledByGraph proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->proc~hexahedron_xc program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~hexahedron_xc program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/hexahedron_xc.html"},{"title":"inv – ForCAD","text":"public pure recursive function inv(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~inv~~CallsGraph proc~inv inv proc~inv->proc~inv proc~det det proc~inv->proc~det Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~inv~~CalledByGraph proc~inv inv proc~inv->proc~inv proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~inv proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~inv proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~inv proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~inv proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~nearest_point2 program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/inv.html"},{"title":"kron – ForCAD","text":"public pure function kron(u, v) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) Called by proc~~kron~~CalledByGraph proc~kron kron proc~cmp_tgc_2d cmp_Tgc_2d proc~cmp_tgc_2d->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~cmp_tgc_3d->proc~kron proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->proc~kron proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->proc~kron proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->proc~kron proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->proc~kron proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->proc~kron proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->proc~kron proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->proc~kron proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->proc~kron proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->proc~kron proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->proc~kron proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->proc~kron proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->proc~kron proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->proc~kron proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->proc~kron proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->proc~kron proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->proc~kron proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~kron interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector interface~compute_tgc compute_Tgc interface~compute_tgc->proc~compute_tgc_bspline_3d_scalar interface~compute_tgc->proc~compute_tgc_bspline_3d_vector interface~compute_tgc->proc~compute_tgc_nurbs_3d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_3d_vector interface~compute_tgc~3 compute_Tgc interface~compute_tgc~3->proc~compute_tgc_bspline_2d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_2d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_vector interface~compute_xg compute_Xg interface~compute_xg->proc~compute_xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d interface~compute_xg~3 compute_Xg interface~compute_xg~3->proc~compute_xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~gauss_leg none~derivative nurbs_volume%derivative proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~gauss_leg none~derivative~3 nurbs_surface%derivative proc~ansatz~3->none~derivative~3 proc~basis_scalar nurbs_volume%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_scalar~3 nurbs_surface%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~compute_tgc proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg nurbs_volume%cmp_Xg proc~cmp_xg->interface~compute_xg proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create nurbs_volume%create proc~create->interface~compute_xg proc~create~3 nurbs_surface%create proc~create~3->interface~compute_xg~3 proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~basis nurbs_volume%basis none~basis->proc~basis_scalar none~basis->proc~basis_vector none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_scalar~3 none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~fdm_test_surface->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~fdm_test_volume->none~derivative2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->none~basis~3 program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->none~derivative~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->none~basis program~test_nurbs_volume->none~derivative program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~nearest_point2 program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/kron.html"},{"title":"rotation – ForCAD","text":"public pure function rotation(alpha, beta, theta) result(R) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) Calls proc~~rotation~~CallsGraph proc~rotation rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation~~CalledByGraph proc~rotation rotation proc~rotate_xc nurbs_volume%rotate_Xc proc~rotate_xc->proc~rotation proc~rotate_xc~2 nurbs_curve%rotate_Xc proc~rotate_xc~2->proc~rotation proc~rotate_xc~3 nurbs_surface%rotate_Xc proc~rotate_xc~3->proc~rotation proc~rotate_xg nurbs_volume%rotate_Xg proc~rotate_xg->proc~rotation proc~rotate_xg~2 nurbs_curve%rotate_Xg proc~rotate_xg~2->proc~rotation proc~rotate_xg~3 nurbs_surface%rotate_Xg proc~rotate_xg~3->proc~rotation program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~2 program~example1_curve->proc~rotate_xg~2 program~example3_surface example3_surface program~example3_surface->proc~rotate_xc~3 program~example3_surface->proc~rotate_xg~3 program~example3_volume example3_volume program~example3_volume->proc~rotate_xc program~example3_volume->proc~rotate_xg program~example_ppm2 example_ppm2 program~example_ppm2->proc~rotate_xc~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~rotate_xc~2 program~test_nurbs_curve->proc~rotate_xg~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~rotate_xc~3 program~test_nurbs_surface->proc~rotate_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~rotate_xc program~test_nurbs_volume->proc~rotate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/rotation.html"},{"title":"tetragon_Xc – ForCAD","text":"public pure function tetragon_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~tetragon_xc~~CalledByGraph proc~tetragon_xc tetragon_Xc proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->proc~tetragon_xc program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/tetragon_xc.html"},{"title":"bincoeff – ForCAD","text":"private pure function bincoeff(n, k) result(b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) Calls proc~~bincoeff~~CallsGraph proc~bincoeff bincoeff proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bincoeff~~CalledByGraph proc~bincoeff bincoeff proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree~3 program~example3_volume example3_volume program~example3_volume->proc~elevate_degree program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/bincoeff.html"},{"title":"cmp_elemConn_C0_L – ForCAD","text":"private pure function cmp_elemConn_C0_L(nnode, p) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_l~~CalledByGraph proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_volume%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_surface%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_volume%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_surface%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis~3 program~test_nurbs_surface->proc~cmp_elem_xg_vis~3 program~test_nurbs_surface->proc~export_xc~3 program~test_nurbs_surface->proc~export_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis program~test_nurbs_volume->proc~cmp_elem_xg_vis program~test_nurbs_volume->proc~export_xc program~test_nurbs_volume->proc~export_xg program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc~3 program~example3_surface->proc~export_xg~3 program~example3_volume example3_volume program~example3_volume->proc~export_xc program~example3_volume->proc~export_xg program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc~3 program~example_nurbs_surface->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc program~example_nurbs_volume->proc~export_xg program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc program~example_put_to_nurbs->proc~export_xg program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc~3 program~shape_c_2d->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc program~shape_c_3d->proc~export_xg program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc~3 program~shape_half_ring_2d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc program~shape_half_ring_3d->proc~export_xg program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc program~shape_hexahedron->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc~3 program~shape_ring_2d->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc program~shape_ring_3d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc~3 program~shape_tetragon->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_c0_l.html"},{"title":"cmp_elemConn_C0_S – ForCAD","text":"private pure function cmp_elemConn_C0_S(nnode1, nnode2, p1, p2) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_s~~CalledByGraph proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_volume%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_surface%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_volume%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_surface%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis~3 program~test_nurbs_surface->proc~cmp_elem_xg_vis~3 program~test_nurbs_surface->proc~export_xc~3 program~test_nurbs_surface->proc~export_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis program~test_nurbs_volume->proc~cmp_elem_xg_vis program~test_nurbs_volume->proc~export_xc program~test_nurbs_volume->proc~export_xg program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc~3 program~example3_surface->proc~export_xg~3 program~example3_volume example3_volume program~example3_volume->proc~export_xc program~example3_volume->proc~export_xg program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc~3 program~example_nurbs_surface->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc program~example_nurbs_volume->proc~export_xg program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc program~example_put_to_nurbs->proc~export_xg program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc~3 program~shape_c_2d->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc program~shape_c_3d->proc~export_xg program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc~3 program~shape_half_ring_2d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc program~shape_half_ring_3d->proc~export_xg program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc program~shape_hexahedron->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc~3 program~shape_ring_2d->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc program~shape_ring_3d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc~3 program~shape_tetragon->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_c0_s.html"},{"title":"cmp_elemConn_C0_V – ForCAD","text":"private pure function cmp_elemConn_C0_V(nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_v~~CalledByGraph proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_volume%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_surface%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_volume%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_surface%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis~3 program~test_nurbs_surface->proc~cmp_elem_xg_vis~3 program~test_nurbs_surface->proc~export_xc~3 program~test_nurbs_surface->proc~export_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis program~test_nurbs_volume->proc~cmp_elem_xg_vis program~test_nurbs_volume->proc~export_xc program~test_nurbs_volume->proc~export_xg program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc~3 program~example3_surface->proc~export_xg~3 program~example3_volume example3_volume program~example3_volume->proc~export_xc program~example3_volume->proc~export_xg program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc~3 program~example_nurbs_surface->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc program~example_nurbs_volume->proc~export_xg program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc program~example_put_to_nurbs->proc~export_xg program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc~3 program~shape_c_2d->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc program~shape_c_3d->proc~export_xg program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc~3 program~shape_half_ring_2d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc program~shape_half_ring_3d->proc~export_xg program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc program~shape_hexahedron->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc~3 program~shape_ring_2d->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc program~shape_ring_3d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc~3 program~shape_tetragon->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_c0_v.html"},{"title":"compute_multiplicity1 – ForCAD","text":"private pure function compute_multiplicity1(knot) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) Called by proc~~compute_multiplicity1~~CalledByGraph proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity1 proc~cmp_nc nurbs_volume%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_surface%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_volume%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_surface%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_volume%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc_dir nurbs_volume%get_nc_dir proc~get_nc_dir->interface~compute_multiplicity proc~get_nc_dir~2 nurbs_surface%get_nc_dir proc~get_nc_dir~2->interface~compute_multiplicity proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_volume%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_surface%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 none~get_nc nurbs_volume%get_nc none~get_nc->proc~get_nc_dir none~get_nc~3 nurbs_surface%get_nc none~get_nc~3->proc~get_nc_dir~2 proc~cmp_degree nurbs_volume%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_volume%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_surface%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_volume%set2 proc~set2->proc~cmp_nc proc~set2~3 nurbs_surface%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 proc~export_xth~2 nurbs_curve%export_Xth program~example1_curve->proc~export_xth~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example3_volume->proc~cmp_elem program~example3_volume->proc~elevate_degree program~example3_volume->none~set proc~export_xth nurbs_volume%export_Xth program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 program~test_nurbs_curve->proc~get_continuity~2 program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~elevate_degree~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_c~2 nurbs_curve%set_C program~test_nurbs_curve->proc~set_c~2 proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc~3 program~test_nurbs_surface->proc~get_continuity~3 program~test_nurbs_surface->proc~get_multiplicity~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->none~get_nc~3 program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 proc~modify_wc~3 nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc~3 proc~set_c~3 nurbs_surface%set_C program~test_nurbs_surface->proc~set_c~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring~2 proc~set_ring~2 nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc program~test_nurbs_volume->proc~get_continuity program~test_nurbs_volume->proc~get_multiplicity program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->none~get_nc program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth proc~modify_wc nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc proc~modify_xc nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc proc~set_c nurbs_volume%set_C program~test_nurbs_volume->proc~set_c proc~set_half_ring nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth->proc~cmp_elem proc~export_xth->none~set proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~2->none~set~2 proc~export_xth~3->proc~cmp_elem~3 proc~export_xth~3->none~set~3 proc~set1a nurbs_curve%set1a proc~set1a->proc~cmp_degree~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 none~set~2->proc~set1a none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~modify_wc->none~set proc~modify_wc~3->none~set~3 proc~modify_xc->none~set proc~modify_xc~3->none~set~3 proc~set_c->none~set proc~set_c~3->none~set~3 proc~set_half_ring->none~set proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set proc~set_ring->none~set proc~set_ring~2->none~set~3 proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_length->none~set~2 program~compute_volume compute_volume program~compute_volume->none~set program~compute_volume->proc~cmp_volume program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~set~2 proc~set_circle->none~set~2 proc~set_c~2->none~set~2 proc~set_half_circle->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_multiplicity1.html"},{"title":"compute_multiplicity2 – ForCAD","text":"private pure function compute_multiplicity2(knot, Xth) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer Called by proc~~compute_multiplicity2~~CalledByGraph proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_nc nurbs_volume%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_surface%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_volume%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_surface%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_volume%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc_dir nurbs_volume%get_nc_dir proc~get_nc_dir->interface~compute_multiplicity proc~get_nc_dir~2 nurbs_surface%get_nc_dir proc~get_nc_dir~2->interface~compute_multiplicity proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_volume%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_surface%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 none~get_nc nurbs_volume%get_nc none~get_nc->proc~get_nc_dir none~get_nc~3 nurbs_surface%get_nc none~get_nc~3->proc~get_nc_dir~2 proc~cmp_degree nurbs_volume%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_volume%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_surface%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_volume%set2 proc~set2->proc~cmp_nc proc~set2~3 nurbs_surface%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 proc~export_xth~2 nurbs_curve%export_Xth program~example1_curve->proc~export_xth~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example3_volume->proc~cmp_elem program~example3_volume->proc~elevate_degree program~example3_volume->none~set proc~export_xth nurbs_volume%export_Xth program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 program~test_nurbs_curve->proc~get_continuity~2 program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~elevate_degree~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_c~2 nurbs_curve%set_C program~test_nurbs_curve->proc~set_c~2 proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc~3 program~test_nurbs_surface->proc~get_continuity~3 program~test_nurbs_surface->proc~get_multiplicity~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->none~get_nc~3 program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 proc~modify_wc~3 nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc~3 proc~set_c~3 nurbs_surface%set_C program~test_nurbs_surface->proc~set_c~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring~2 proc~set_ring~2 nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc program~test_nurbs_volume->proc~get_continuity program~test_nurbs_volume->proc~get_multiplicity program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->none~get_nc program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth proc~modify_wc nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc proc~modify_xc nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc proc~set_c nurbs_volume%set_C program~test_nurbs_volume->proc~set_c proc~set_half_ring nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth->proc~cmp_elem proc~export_xth->none~set proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~2->none~set~2 proc~export_xth~3->proc~cmp_elem~3 proc~export_xth~3->none~set~3 proc~set1a nurbs_curve%set1a proc~set1a->proc~cmp_degree~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 none~set~2->proc~set1a none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~modify_wc->none~set proc~modify_wc~3->none~set~3 proc~modify_xc->none~set proc~modify_xc~3->none~set~3 proc~set_c->none~set proc~set_c~3->none~set~3 proc~set_half_ring->none~set proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set proc~set_ring->none~set proc~set_ring~2->none~set~3 proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_length->none~set~2 program~compute_volume compute_volume program~compute_volume->none~set program~compute_volume->proc~cmp_volume program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~set~2 proc~set_circle->none~set~2 proc~set_c~2->none~set~2 proc~set_half_circle->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/compute_multiplicity2.html"},{"title":"dyad_t1_t1 – ForCAD","text":"private pure function dyad_t1_t1(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~dyad_t1_t1~~CalledByGraph proc~dyad_t1_t1 dyad_t1_t1 interface~dyad dyad interface~dyad->proc~dyad_t1_t1 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~dyad proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/dyad_t1_t1.html"},{"title":"factln – ForCAD","text":"private pure function factln(n) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~factln~~CalledByGraph proc~factln factln proc~bincoeff bincoeff proc~bincoeff->proc~factln proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree~3 program~example3_volume example3_volume program~example3_volume->proc~elevate_degree program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/factln.html"},{"title":"repelem – ForCAD","text":"private pure function repelem(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) Called by proc~~repelem~~CalledByGraph proc~repelem repelem proc~compute_knot_vector compute_knot_vector proc~compute_knot_vector->proc~repelem proc~set2 nurbs_volume%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_surface%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_volume%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~3 nurbs_surface%set none~set~3->proc~set2~3 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~set~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~set~3 proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->none~set~3 proc~export_xth nurbs_volume%export_Xth proc~export_xth->none~set proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->none~set~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->none~set~3 proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc nurbs_volume%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_surface%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_volume%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_surface%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->none~set~3 proc~set_c nurbs_volume%set_C proc~set_c->none~set proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3 nurbs_surface%set_C proc~set_c~3->none~set~3 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 proc~set_half_ring nurbs_volume%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_surface%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set proc~set_ring nurbs_volume%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_surface%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~export_xth~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->none~set~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->proc~export_xth~3 program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example3_volume example3_volume program~example3_volume->none~set program~example3_volume->proc~elevate_degree program~example3_volume->proc~export_xth program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~set~2 program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~modify_wc~2 program~test_nurbs_curve->proc~modify_xc~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~set_circle program~test_nurbs_curve->proc~set_c~2 program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~set~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~modify_wc~3 program~test_nurbs_surface->proc~modify_xc~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->proc~set_c~3 program~test_nurbs_surface->proc~set_half_ring~2 program~test_nurbs_surface->proc~set_ring~2 program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~set program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~modify_wc program~test_nurbs_volume->proc~modify_xc program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->proc~set_c program~test_nurbs_volume->proc~set_half_ring program~test_nurbs_volume->proc~set_hexahedron program~test_nurbs_volume->proc~set_ring program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz~3 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/repelem.html"},{"title":"unique_integer – ForCAD","text":"private pure function unique_integer(vec) result(output) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable Called by proc~~unique_integer~~CalledByGraph proc~unique_integer unique_integer interface~unique unique interface~unique->proc~unique_integer proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~unique proc~cmp_elem nurbs_volume%cmp_elem proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~unique proc~cmp_elem~3 nurbs_surface%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~cmp_elem->interface~unique proc~cmp_elem~2->interface~unique proc~cmp_elem~3->interface~unique proc~export_xth nurbs_volume%export_Xth proc~export_xth->interface~unique proc~export_xth->proc~cmp_elem proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~unique proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->interface~unique proc~export_xth~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_area->proc~cmp_elem~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~cmp_volume->proc~cmp_elem program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/unique_integer.html"},{"title":"unique_real – ForCAD","text":"private pure function unique_real(vec) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Called by proc~~unique_real~~CalledByGraph proc~unique_real unique_real interface~unique unique interface~unique->proc~unique_real proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~unique proc~cmp_elem nurbs_volume%cmp_elem proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~unique proc~cmp_elem~3 nurbs_surface%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~cmp_elem->interface~unique proc~cmp_elem~2->interface~unique proc~cmp_elem~3->interface~unique proc~export_xth nurbs_volume%export_Xth proc~export_xth->interface~unique proc~export_xth->proc~cmp_elem proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~unique proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->interface~unique proc~export_xth~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_area->proc~cmp_elem~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~cmp_volume->proc~cmp_elem program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/unique_real.html"},{"title":"basis_bspline_2der – ForCAD","text":"public pure subroutine basis_bspline_2der(Xt, knot, nc, degree, d2B, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out), optional :: dB (nc) real(kind=rk), intent(out), optional :: B (nc) Called by proc~~basis_bspline_2der~~CalledByGraph proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der interface~compute_d2tgc compute_d2Tgc interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector interface~compute_d2tgc~2 compute_d2Tgc interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector interface~compute_d2tgc~3 compute_d2Tgc interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~derivative2_scalar nurbs_volume%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->none~derivative2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~derivative2~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->none~derivative2 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative2~2 program~test_nurbs_curve->proc~nearest_point2~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~nearest_point2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline_2der.html"},{"title":"basis_bspline_der – ForCAD","text":"public pure subroutine basis_bspline_der(Xt, knot, nc, degree, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out), optional :: B (nc) Called by proc~~basis_bspline_der~~CalledByGraph proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der interface~compute_dtgc compute_dTgc interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector interface~compute_dtgc~2 compute_dTgc interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector interface~compute_dtgc~3 compute_dTgc interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~derivative_scalar nurbs_volume%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_scalar~3 nurbs_surface%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~compute_dtgc proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 none~derivative nurbs_volume%derivative none~derivative->proc~derivative_scalar none~derivative->proc~derivative_vector none~derivative~2 nurbs_curve%derivative none~derivative~2->proc~derivative_scalar~2 none~derivative~2->proc~derivative_vector~2 none~derivative~3 nurbs_surface%derivative none~derivative~3->proc~derivative_scalar~3 none~derivative~3->proc~derivative_vector~3 proc~ansatz nurbs_volume%ansatz proc~ansatz->none~derivative proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->none~derivative~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->none~derivative~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->none~derivative~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->none~derivative~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->none~derivative proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~cmp_area->proc~ansatz~3 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/basis_bspline_der.html"},{"title":"elevate_degree_A_5_9 – ForCAD","text":"public pure subroutine elevate_degree_A_5_9(t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) Calls proc~~elevate_degree_a_5_9~~CallsGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree_a_5_9~~CalledByGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree~3 program~example3_volume example3_volume program~example3_volume->proc~elevate_degree program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~elevate_degree~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/elevate_degree_a_5_9.html"},{"title":"export_vtk_legacy – ForCAD","text":"public impure subroutine export_vtk_legacy(filename, points, elemConn, vtkCellType, encoding) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rk), intent(in) :: points (:,:) integer, intent(in) :: elemConn (:,:) integer, intent(in) :: vtkCellType character(len=*), intent(in), optional :: encoding Called by proc~~export_vtk_legacy~~CalledByGraph proc~export_vtk_legacy export_vtk_legacy proc~export_xc nurbs_volume%export_Xc proc~export_xc->proc~export_vtk_legacy proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~export_vtk_legacy proc~export_xc~3 nurbs_surface%export_Xc proc~export_xc~3->proc~export_vtk_legacy proc~export_xg nurbs_volume%export_Xg proc~export_xg->proc~export_vtk_legacy proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~export_vtk_legacy proc~export_xg~3 nurbs_surface%export_Xg proc~export_xg~3->proc~export_vtk_legacy proc~export_xth nurbs_volume%export_Xth proc~export_xth->proc~export_vtk_legacy proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~export_vtk_legacy proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->proc~export_vtk_legacy program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc~3 program~example3_surface->proc~export_xg~3 program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~export_xc program~example3_volume->proc~export_xg program~example3_volume->proc~export_xth program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc~3 program~example_nurbs_surface->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc program~example_nurbs_volume->proc~export_xg program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc program~example_put_to_nurbs->proc~export_xg program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc~3 program~shape_c_2d->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc program~shape_c_3d->proc~export_xg program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc~3 program~shape_half_ring_2d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc program~shape_half_ring_3d->proc~export_xg program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc program~shape_hexahedron->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc~3 program~shape_ring_2d->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc program~shape_ring_3d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc~3 program~shape_tetragon->proc~export_xg~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~export_xc~3 program~test_nurbs_surface->proc~export_xg~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~export_xc program~test_nurbs_volume->proc~export_xg program~test_nurbs_volume->proc~export_xth Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/export_vtk_legacy.html"},{"title":"insert_knot_A_5_1 – ForCAD","text":"public pure subroutine insert_knot_A_5_1(p, UP, Pw, u, k, s, r, nq, UQ, Qw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) Called by proc~~insert_knot_a_5_1~~CalledByGraph proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->proc~insert_knot_a_5_1 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots~3 program~example3_volume example3_volume program~example3_volume->proc~insert_knots program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~insert_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/insert_knot_a_5_1.html"},{"title":"remove_knots_A_5_8 – ForCAD","text":"public pure subroutine remove_knots_A_5_8(p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) Called by proc~~remove_knots_a_5_8~~CalledByGraph proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->proc~remove_knots_a_5_8 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~remove_knots_a_5_8 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->proc~remove_knots_a_5_8 program~example1_curve example1_curve program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->proc~remove_knots~3 program~example3_volume example3_volume program~example3_volume->proc~remove_knots program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/remove_knots_a_5_8.html"},{"title":"cmp_elemConn_Cn_L – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_L(nnode, p, Xth, vecKnot_mul, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_l~~CalledByGraph proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->interface~elemconn_cn proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth nurbs_volume%export_Xth proc~export_xth->proc~cmp_elem proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->proc~cmp_elem~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_cn_l.html"},{"title":"cmp_elemConn_Cn_S – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_S(nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_s~~CalledByGraph proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->interface~elemconn_cn proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth nurbs_volume%export_Xth proc~export_xth->proc~cmp_elem proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->proc~cmp_elem~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_cn_s.html"},{"title":"cmp_elemConn_Cn_V – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_V(nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_v~~CalledByGraph proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->interface~elemconn_cn proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth nurbs_volume%export_Xth proc~export_xth->proc~cmp_elem proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->proc~cmp_elem~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/cmp_elemconn_cn_v.html"},{"title":"gauss_legendre – ForCAD","text":"private pure subroutine gauss_legendre(x, w, interval) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: x (:) real(kind=rk), intent(out) :: w (:) real(kind=rk), intent(in) :: interval (2) Called by proc~~gauss_legendre~~CalledByGraph proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d gauss_legendre_1D proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->proc~gauss_legendre interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_1d interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre.html"},{"title":"gauss_legendre_1D – ForCAD","text":"private pure subroutine gauss_legendre_1D(interval, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_1d~~CallsGraph proc~gauss_legendre_1d gauss_legendre_1D proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_1d~~CalledByGraph proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_1d proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre_1d.html"},{"title":"gauss_legendre_2D – ForCAD","text":"private pure subroutine gauss_legendre_2D(interval1, interval2, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_2d~~CallsGraph proc~gauss_legendre_2d gauss_legendre_2D interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre gauss_legendre proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_2d~~CalledByGraph proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre_2d.html"},{"title":"gauss_legendre_3D – ForCAD","text":"private pure subroutine gauss_legendre_3D(interval1, interval2, interval3, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_3d~~CallsGraph proc~gauss_legendre_3d gauss_legendre_3D interface~ndgrid ndgrid proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre gauss_legendre proc~gauss_legendre_3d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_3d->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_3d~~CalledByGraph proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_3d proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/gauss_legendre_3d.html"},{"title":"ndgrid2 – ForCAD","text":"private pure subroutine ndgrid2(X_dir1, X_dir2, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid2~~CalledByGraph proc~ndgrid2 ndgrid2 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid2 proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~ndgrid interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg none~derivative nurbs_volume%derivative proc~ansatz->none~derivative proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~ndgrid proc~ansatz~3->interface~gauss_leg none~derivative~3 nurbs_surface%derivative proc~ansatz~3->none~derivative~3 proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_volume%create proc~create->interface~ndgrid proc~create~3 nurbs_surface%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~ndgrid proc~export_xth nurbs_volume%export_Xth proc~export_xth->interface~ndgrid proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~ndgrid proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->interface~ndgrid proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d none~basis nurbs_volume%basis none~basis->proc~basis_vector none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_vector none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_vector none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~create program~example3_volume->proc~export_xth program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~fdm_test_surface->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~fdm_test_volume->none~derivative2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->none~basis~3 program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->none~derivative~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->none~basis program~test_nurbs_volume->none~derivative program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~nearest_point2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ndgrid2.html"},{"title":"ndgrid3 – ForCAD","text":"private pure subroutine ndgrid3(X_dir1, X_dir2, X_dir3, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid3~~CalledByGraph proc~ndgrid3 ndgrid3 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid3 proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~ndgrid interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg none~derivative nurbs_volume%derivative proc~ansatz->none~derivative proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~ndgrid proc~ansatz~3->interface~gauss_leg none~derivative~3 nurbs_surface%derivative proc~ansatz~3->none~derivative~3 proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_volume%create proc~create->interface~ndgrid proc~create~3 nurbs_surface%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~ndgrid proc~export_xth nurbs_volume%export_Xth proc~export_xth->interface~ndgrid proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~ndgrid proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->interface~ndgrid proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d none~basis nurbs_volume%basis none~basis->proc~basis_vector none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_vector none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_vector none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~create program~example3_volume->proc~export_xth program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~fdm_test_surface->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~fdm_test_volume->none~derivative2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->none~basis~3 program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->none~derivative~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->none~basis program~test_nurbs_volume->none~derivative program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~nearest_point2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ndgrid3.html"},{"title":"compute_multiplicity – ForCAD","text":"public interface compute_multiplicity Calls interface~~compute_multiplicity~~CallsGraph interface~compute_multiplicity compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_multiplicity~~CalledByGraph interface~compute_multiplicity compute_multiplicity proc~cmp_nc nurbs_volume%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_surface%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_volume%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_surface%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_volume%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc_dir nurbs_volume%get_nc_dir proc~get_nc_dir->interface~compute_multiplicity proc~get_nc_dir~2 nurbs_surface%get_nc_dir proc~get_nc_dir~2->interface~compute_multiplicity proc~insert_knots nurbs_volume%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_volume%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_surface%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_surface%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_volume%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_surface%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 none~get_nc nurbs_volume%get_nc none~get_nc->proc~get_nc_dir none~get_nc~3 nurbs_surface%get_nc none~get_nc~3->proc~get_nc_dir~2 proc~cmp_degree nurbs_volume%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_volume%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_surface%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_volume%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_surface%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_volume%set2 proc~set2->proc~cmp_nc proc~set2~3 nurbs_surface%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 proc~export_xth~2 nurbs_curve%export_Xth program~example1_curve->proc~export_xth~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots~3 program~example3_surface->proc~remove_knots~3 program~example3_surface->proc~elevate_degree~3 program~example3_surface->none~set~3 proc~export_xth~3 nurbs_surface%export_Xth program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~insert_knots program~example3_volume->proc~remove_knots program~example3_volume->proc~cmp_elem program~example3_volume->proc~elevate_degree program~example3_volume->none~set proc~export_xth nurbs_volume%export_Xth program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_nc~2 program~test_nurbs_curve->proc~get_continuity~2 program~test_nurbs_curve->proc~get_multiplicity~2 program~test_nurbs_curve->proc~insert_knots~2 program~test_nurbs_curve->proc~remove_knots~2 program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~elevate_degree~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_c~2 nurbs_curve%set_C program~test_nurbs_curve->proc~set_c~2 proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_nc~3 program~test_nurbs_surface->proc~get_continuity~3 program~test_nurbs_surface->proc~get_multiplicity~3 program~test_nurbs_surface->proc~insert_knots~3 program~test_nurbs_surface->proc~remove_knots~3 program~test_nurbs_surface->none~get_nc~3 program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~elevate_degree~3 program~test_nurbs_surface->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 proc~modify_wc~3 nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc~3 proc~set_c~3 nurbs_surface%set_C program~test_nurbs_surface->proc~set_c~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring~2 proc~set_ring~2 nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_nc program~test_nurbs_volume->proc~get_continuity program~test_nurbs_volume->proc~get_multiplicity program~test_nurbs_volume->proc~insert_knots program~test_nurbs_volume->proc~remove_knots program~test_nurbs_volume->none~get_nc program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~elevate_degree program~test_nurbs_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth proc~modify_wc nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc proc~modify_xc nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc proc~set_c nurbs_volume%set_C program~test_nurbs_volume->proc~set_c proc~set_half_ring nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz->none~set proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth->proc~cmp_elem proc~export_xth->none~set proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~2->none~set~2 proc~export_xth~3->proc~cmp_elem~3 proc~export_xth~3->none~set~3 proc~set1a nurbs_curve%set1a proc~set1a->proc~cmp_degree~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 none~set~2->proc~set1a none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~modify_wc->none~set proc~modify_wc~3->none~set~3 proc~modify_xc->none~set proc~modify_xc~3->none~set~3 proc~set_c->none~set proc~set_c~3->none~set~3 proc~set_half_ring->none~set proc~set_half_ring~2->none~set~3 proc~set_hexahedron->none~set proc~set_ring->none~set proc~set_ring~2->none~set~3 proc~set_tetragon->none~set~3 program~compute_area compute_area program~compute_area->none~set~3 program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_length->none~set~2 program~compute_volume compute_volume program~compute_volume->none~set program~compute_volume->proc~cmp_volume program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~set~2 proc~set_circle->none~set~2 proc~set_c~2->none~set~2 proc~set_half_circle->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring~2 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring~2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc~3 program~example_ppm3->proc~set_tetragon program~fdm_test_curve fdm_test_curve program~fdm_test_curve->none~set~2 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~set_tetragon program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~set_hexahedron program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring~2 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring~2 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer","tags":"","url":"interface/compute_multiplicity.html"},{"title":"dyad – ForCAD","text":"public interface dyad Calls interface~~dyad~~CallsGraph interface~dyad dyad proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dyad~~CalledByGraph interface~dyad dyad proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~dyad proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:)","tags":"","url":"interface/dyad.html"},{"title":"elemConn_C0 – ForCAD","text":"public interface elemConn_C0 Calls interface~~elemconn_c0~~CallsGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_c0~~CalledByGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_volume%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_surface%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_volume%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_surface%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 program~test_nurbs_curve->proc~export_xc~2 program~test_nurbs_curve->proc~export_xg~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem_xc_vis~3 program~test_nurbs_surface->proc~cmp_elem_xg_vis~3 program~test_nurbs_surface->proc~export_xc~3 program~test_nurbs_surface->proc~export_xg~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem_xc_vis program~test_nurbs_volume->proc~cmp_elem_xg_vis program~test_nurbs_volume->proc~export_xc program~test_nurbs_volume->proc~export_xg program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc~3 program~example3_surface->proc~export_xg~3 program~example3_volume example3_volume program~example3_volume->proc~export_xc program~example3_volume->proc~export_xg program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc~3 program~example_nurbs_surface->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc program~example_nurbs_volume->proc~export_xg program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc program~example_put_to_nurbs->proc~export_xg program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc~3 program~shape_c_2d->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc program~shape_c_3d->proc~export_xg program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc~3 program~shape_half_ring_2d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc program~shape_half_ring_3d->proc~export_xg program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc program~shape_hexahedron->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc~3 program~shape_ring_2d->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc program~shape_ring_3d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc~3 program~shape_tetragon->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:)","tags":"","url":"interface/elemconn_c0.html"},{"title":"elemConn_Cn – ForCAD","text":"public interface elemConn_Cn Calls interface~~elemconn_cn~~CallsGraph interface~elemconn_cn elemConn_Cn proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_cn~~CalledByGraph interface~elemconn_cn elemConn_Cn proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_elem~3->interface~elemconn_cn proc~ansatz nurbs_volume%ansatz proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~cmp_elem~3 proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~cmp_elem~2 proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~cmp_elem proc~cmp_volume->proc~ansatz proc~export_xth nurbs_volume%export_Xth proc~export_xth->proc~cmp_elem proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->proc~cmp_elem~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~export_xth program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:)","tags":"","url":"interface/elemconn_cn.html"},{"title":"gauss_leg – ForCAD","text":"public interface gauss_leg Calls interface~~gauss_leg~~CallsGraph interface~gauss_leg gauss_leg proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~gauss_leg~~CalledByGraph interface~gauss_leg gauss_leg proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~gauss_leg proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~gauss_leg proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:)","tags":"","url":"interface/gauss_leg.html"},{"title":"ndgrid – ForCAD","text":"public interface ndgrid Calls interface~~ndgrid~~CallsGraph interface~ndgrid ndgrid proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~ndgrid~~CalledByGraph interface~ndgrid ndgrid proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~ndgrid interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg none~derivative nurbs_volume%derivative proc~ansatz->none~derivative proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~ndgrid proc~ansatz~3->interface~gauss_leg none~derivative~3 nurbs_surface%derivative proc~ansatz~3->none~derivative~3 proc~basis_vector nurbs_volume%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_surface%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_volume%create proc~create->interface~ndgrid proc~create~3 nurbs_surface%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_volume%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_surface%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_volume%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_surface%derivative_vector proc~derivative_vector~3->interface~ndgrid proc~export_xth nurbs_volume%export_Xth proc~export_xth->interface~ndgrid proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~ndgrid proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->interface~ndgrid proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d none~basis nurbs_volume%basis none~basis->proc~basis_vector none~basis~3 nurbs_surface%basis none~basis~3->proc~basis_vector~3 none~derivative->proc~derivative_vector none~derivative2 nurbs_volume%derivative2 none~derivative2->proc~derivative2_vector none~derivative2~3 nurbs_surface%derivative2 none~derivative2~3->proc~derivative2_vector~3 none~derivative~3->proc~derivative_vector~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~nearest_point2 nurbs_volume%nearest_point2 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3 nurbs_surface%nearest_point2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~create~3 program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~create program~example3_volume->proc~export_xth program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~create~3 program~example_ppm3 example_ppm3 program~example_ppm3->proc~create~3 program~fdm_test_surface fdm_test_surface program~fdm_test_surface->proc~create~3 program~fdm_test_surface->none~derivative2~3 program~fdm_test_volume fdm_test_volume program~fdm_test_volume->proc~create program~fdm_test_volume->none~derivative2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create~3 program~nearest_point_2d->proc~nearest_point2~3 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create program~nearest_point_3d->proc~nearest_point2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create~3 program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~export_xth~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~create~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->none~basis~3 program~test_nurbs_surface->none~derivative2~3 program~test_nurbs_surface->none~derivative~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_surface->proc~nearest_point2~3 program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~create program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->none~basis program~test_nurbs_volume->none~derivative program~test_nurbs_volume->none~derivative2 program~test_nurbs_volume->proc~cmp_volume program~test_nurbs_volume->proc~nearest_point2 proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~gauss_leg program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_volume compute_volume program~compute_volume->proc~cmp_volume proc~cmp_length->proc~ansatz~2 program~compute_length compute_length program~compute_length->proc~cmp_length Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","url":"interface/ndgrid.html"},{"title":"unique – ForCAD","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique unique proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~unique~~CalledByGraph interface~unique unique proc~ansatz nurbs_volume%ansatz proc~ansatz->interface~unique proc~cmp_elem nurbs_volume%cmp_elem proc~ansatz->proc~cmp_elem proc~ansatz~2 nurbs_curve%ansatz proc~ansatz~2->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~3 nurbs_surface%ansatz proc~ansatz~3->interface~unique proc~cmp_elem~3 nurbs_surface%cmp_elem proc~ansatz~3->proc~cmp_elem~3 proc~cmp_elem->interface~unique proc~cmp_elem~2->interface~unique proc~cmp_elem~3->interface~unique proc~export_xth nurbs_volume%export_Xth proc~export_xth->interface~unique proc~export_xth->proc~cmp_elem proc~export_xth~2 nurbs_curve%export_Xth proc~export_xth~2->interface~unique proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~3 nurbs_surface%export_Xth proc~export_xth~3->interface~unique proc~export_xth~3->proc~cmp_elem~3 proc~cmp_area nurbs_surface%cmp_area proc~cmp_area->proc~ansatz~3 proc~cmp_area->proc~cmp_elem~3 proc~cmp_length nurbs_curve%cmp_length proc~cmp_length->proc~ansatz~2 proc~cmp_length->proc~cmp_elem~2 proc~cmp_volume nurbs_volume%cmp_volume proc~cmp_volume->proc~ansatz proc~cmp_volume->proc~cmp_elem program~example1_curve example1_curve program~example1_curve->proc~export_xth~2 program~example3_surface example3_surface program~example3_surface->proc~export_xth~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem program~example3_volume->proc~export_xth program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->proc~cmp_elem~2 program~test_nurbs_curve->proc~export_xth~2 program~test_nurbs_curve->proc~cmp_length program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->proc~cmp_elem~3 program~test_nurbs_surface->proc~export_xth~3 program~test_nurbs_surface->proc~cmp_area program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->proc~cmp_elem program~test_nurbs_volume->proc~export_xth program~test_nurbs_volume->proc~cmp_volume program~compute_area compute_area program~compute_area->proc~cmp_area program~compute_length compute_length program~compute_length->proc~cmp_length program~compute_volume compute_volume program~compute_volume->proc~cmp_volume Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable","tags":"","url":"interface/unique.html"},{"title":"forcad_nurbs_volume – ForCAD","text":"This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. Uses forcad_kinds forcad_utils module~~forcad_nurbs_volume~~UsesGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad_kinds forcad_kinds module~forcad_nurbs_volume->module~forcad_kinds module~forcad_utils forcad_utils module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_volume~~UsedByGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad forcad module~forcad->module~forcad_nurbs_volume program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces private        interface compute_Tgc private pure function compute_Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:) private        interface compute_Xg private pure function compute_Xg_nurbs_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_bspline_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private        interface compute_dTgc private pure subroutine compute_dTgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Derived Types type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1) ng(2) ng(3), dim] real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dV Read more… generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS volume Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_degree Compute degree of the NURBS volume Read more… procedure, public :: cmp_degreeFace Compute degrees of the faces Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elemFace Compute faces of the IGA elements Read more… procedure, public :: cmp_elemFace_Xc_vis Compute faces of the control points Read more… procedure, public :: cmp_elemFace_Xg_vis Compute faces of the geometry points Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: cmp_volume Compute the volume of the NURBS volume Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS volume Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS volume Read more… procedure, public :: elevate_degree Elevate the degree of the NURBS volume Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: export_Xth Export parameter space to VTK file Read more… procedure, public :: finalize Finalize the NURBS volume object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the NURBS volume Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knots Read more… generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS volume is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS volume (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS volume (Minimization - Newton's method) Read more… procedure, public :: put_to_nurbs Put a shape to a NURBS volume Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 , set4 Set NURBS volume Read more… procedure, public :: set1 Set knot vectors, control points and weights for the NURBS volume object Read more… procedure, public :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier volume using control points and weights Read more… procedure, public :: set4 Set NURBS volume using degree, number of control points, control points and weights Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_ring Set a half ring Read more… procedure, public :: set_hexahedron Set a hexahedron Read more… procedure, public :: set_ring Set a ring Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS volume Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS volume Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS volume Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS volume Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS volume Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS volume Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_degree_all Get degree of the NURBS volume in all directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… procedure, private :: get_nc_all Get number of control points in all directions Read more… procedure, private :: get_nc_dir Get number of control points in a specific direction Read more… Functions private pure function cmp_Tgc_3d (Xti, knot1, knot2, knot3, nc, degree, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: nc (3) integer, intent(in) :: degree (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)*nc(3)) private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) private pure function cmp_degreeFace (this, face) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elemFace (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elemFace_Xc_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elemFace_Xg_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function compute_Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_3d (Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point (Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical private pure function nearest_point_help_3d (ng, Xg, point_Xg) result(distances) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:) Subroutines private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dV) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dV private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_volume (this, volume) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(out) :: volume private pure subroutine compute_d2Tgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar (Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_nurbs_3d_vector (Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t private impure subroutine export_Xc (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_Xg (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","url":"module/forcad_nurbs_volume.html"},{"title":"forcad – ForCAD","text":"Uses forcad_kinds forcad_nurbs_surface forcad_utils forcad_nurbs_curve forcad_nurbs_volume module~~forcad~~UsesGraph module~forcad forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad~~UsedByGraph module~forcad forcad program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/forcad.html"},{"title":"forcad_nurbs_curve – ForCAD","text":"This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. Uses forcad_kinds forcad_utils module~~forcad_nurbs_curve~~UsesGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad_kinds forcad_kinds module~forcad_nurbs_curve->module~forcad_kinds module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_curve~~UsedByGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad forcad module~forcad->module~forcad_nurbs_curve program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces private        interface compute_Tgc private pure function compute_Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_scalar (Xt, knot, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) private        interface compute_Xg private pure function compute_Xg_nurbs_1d (Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d (Xt, knot, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point (Xt, knot, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_bspline_1d_1point (Xt, knot, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_scalar (Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private        interface compute_dTgc private pure subroutine compute_dTgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_1d_vector (Xt, knot, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_1d_scalar (Xt, knot, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Derived Types type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dL Read more… generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS curve Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_degree Compute degree of the NURBS curve Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_length Compute the length of the NURBS curve Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS curve Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS curve Read more… procedure, public :: elevate_degree Elevate the degree of the curve Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: export_Xth Export parameter space to VTK file Read more… procedure, public :: export_iges Export the NURBS curve to an IGES file Read more… procedure, public :: finalize Finalize the NURBS curve object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the curve Read more… procedure, public :: get_degree Get degree of the NURBS curve Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knots Read more… procedure, public :: get_nc Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS curve is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS curve (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS curve (Minimization - Newton's method) Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set1a , set2 , set3 , set4 Set NURBS curve Read more… procedure, public :: set1 Set knot vector, control points and weights for the NURBS curve object Read more… procedure, public :: set1a procedure, public :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier curve using control points and weights Read more… procedure, public :: set4 Set NURBS curve using degree, number of control points, control points and weights Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_circle Set a circle Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_circle Set a half circle Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS curve Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS curve Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS curve Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS curve Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS curve Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS curve Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… Functions private pure function cmp_Tgc_1d (Xti, knot, nc, degree, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xti real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc) private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function compute_Tgc_bspline_1d_scalar (Xt, knot, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d (Xt, knot, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d_1point (Xt, knot, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_1d (Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point (Xt, knot, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical private pure function nearest_point_help_1d (ng, Xg, point_Xg) result(distances) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:) Subroutines private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dL) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dL private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine cmp_length (this, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(out) :: length private pure subroutine cmp_nc (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine compute_d2Tgc_bspline_1d_scalar (Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_vector (Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_1d_scalar (Xt, knot, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_1d_vector (Xt, knot, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar (Xt, knot, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_nurbs_1d_vector (Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t private impure subroutine export_Xc (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_Xg (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine insert_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set1a (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","url":"module/forcad_nurbs_curve.html"},{"title":"forcad_nurbs_surface – ForCAD","text":"This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. Uses forcad_kinds forcad_utils module~~forcad_nurbs_surface~~UsesGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad_kinds forcad_kinds module~forcad_nurbs_surface->module~forcad_kinds module~forcad_utils forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_surface~~UsedByGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad forcad module~forcad->module~forcad_nurbs_surface program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces private        interface compute_Tgc private pure function compute_Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:) private        interface compute_Xg private pure function compute_Xg_nurbs_2d (Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d (Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point (Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_bspline_2d_1point (Xt, knot1, knot2, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private        interface compute_dTgc private pure subroutine compute_dTgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) Derived Types type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures procedure, public :: ansatz Compute the shape functions, derivative of shape functions and dA Read more… generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS surface Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_area Compute the area of the NURBS surface Read more… procedure, public :: cmp_degree Compute degree of the NURBS surface Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS surface Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS surface Read more… procedure, public :: elevate_degree Elevate degree Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: export_Xth Export parameter space to VTK file Read more… procedure, public :: export_iges Export the NURBS surface to IGES format Read more… procedure, public :: finalize Finalize the NURBS surface object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the NURBS surface Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knot vector Read more… generic, public :: get_nc => get_nc_all , get_nc_dir Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS surface is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS surface (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS surface (Minimization - Newton's method) Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 , set4 Set NURBS surface Read more… procedure, public :: set1 Set knot vectors, control points and weights for the NURBS surface object Read more… procedure, public :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier surface using control points and weights Read more… procedure, public :: set4 Set NURBS surface using degree, number of control points, control points and weights Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_ring Set a half ring Read more… procedure, public :: set_ring Set a ring Read more… procedure, public :: set_tetragon Set a tetragon Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS surface Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS surface Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS surface Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS surface Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS surface Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS surface Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_degree_all Get degree of the NURBS surface in both directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… procedure, private :: get_nc_all Get number of control points in all directions Read more… procedure, private :: get_nc_dir Get number of control points in a specific direction Read more… Functions private pure function cmp_Tgc_2d (Xti, knot1, knot2, nc, degree, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xti (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: nc (2) integer, intent(in) :: degree (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), (nc(1)*nc(2)) private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function compute_Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d (Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d_1point (Xt, knot1, knot2, degree, nc, Xc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_2d (Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point (Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc_all (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_nc_dir (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical private pure function nearest_point_help_2d (ng, Xg, point_Xg) result(distances) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:) Subroutines private pure subroutine ansatz (this, ie, ig, Tgc, dTgc_dXg, dA) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: ie integer, intent(in) :: ig real(kind=rk), intent(out), allocatable :: Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc_dXg (:,:) real(kind=rk), intent(out) :: dA private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_area (this, area) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(out) :: area private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine compute_d2Tgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine compute_d2Tgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_bspline_2d_scalar (Xt, knot1, knot2, degree, nc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_bspline_2d_vector (Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar (Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine compute_dTgc_nurbs_2d_vector (Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc, elem) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) integer, intent(in), optional :: elem (:) private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t private impure subroutine export_Xc (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_Xg (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_Xth (this, filename, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: encoding private impure subroutine export_iges (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set4 (this, degree, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","url":"module/forcad_nurbs_surface.html"},{"title":"forcad_kinds – ForCAD","text":"Used by module~~forcad_kinds~~UsedByGraph module~forcad_kinds forcad_kinds module~forcad forcad module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~example_put_to_nurbs->module~forcad_utils program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = selected_real_kind(15)","tags":"","url":"module/forcad_kinds.html"},{"title":"forcad_utils – ForCAD","text":"This module contains parameters, functions and subroutines that are used in the library. Uses forcad_kinds module~~forcad_utils~~UsesGraph module~forcad_utils forcad_utils module~forcad_kinds forcad_kinds module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_utils~~UsedByGraph module~forcad_utils forcad_utils module~forcad forcad module~forcad->module~forcad_utils module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad_utils program~example_put_to_nurbs->module~forcad program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~fdm_test_curve fdm_test_curve program~fdm_test_curve->module~forcad program~fdm_test_surface fdm_test_surface program~fdm_test_surface->module~forcad program~fdm_test_volume fdm_test_volume program~fdm_test_volume->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad program~test_nurbs_curve test_nurbs_curve program~test_nurbs_curve->module~forcad program~test_nurbs_surface test_nurbs_surface program~test_nurbs_surface->module~forcad program~test_nurbs_volume test_nurbs_volume program~test_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface compute_multiplicity private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer public        interface dyad private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) public        interface elemConn_C0 private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) public        interface elemConn_Cn private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) public        interface gauss_leg private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) public        interface ndgrid private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) public        interface unique private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Functions public pure function basis_bernstein (Xt, nc) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline (Xt, knot, nc, degree) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), (nc) public pure function compute_knot_vector (Xth_dir, degree, continuity) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) public pure function det (A) result(detA) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk) public pure function findspan (n, degree, Xth, knot) result(s) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer public pure function hexahedron_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) public pure recursive function inv (A) result(A_inv) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk), allocatable, (:,:) public pure function kron (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) public pure function rotation (alpha, beta, theta) result(R) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) public pure function tetragon_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:) private pure function bincoeff (n, k) result(b) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) private pure function factln (n) result(f) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) private pure function repelem (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Subroutines public pure subroutine basis_bspline_2der (Xt, knot, nc, degree, d2B, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: d2B (nc) real(kind=rk), intent(out), optional :: dB (nc) real(kind=rk), intent(out), optional :: B (nc) public pure subroutine basis_bspline_der (Xt, knot, nc, degree, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out) :: dB (nc) real(kind=rk), intent(out), optional :: B (nc) public pure subroutine elevate_degree_A_5_9 (t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) public impure subroutine export_vtk_legacy (filename, points, elemConn, vtkCellType, encoding) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rk), intent(in) :: points (:,:) integer, intent(in) :: elemConn (:,:) integer, intent(in) :: vtkCellType character(len=*), intent(in), optional :: encoding public pure subroutine insert_knot_A_5_1 (p, UP, Pw, u, k, s, r, nq, UQ, Qw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) public pure subroutine remove_knots_A_5_8 (p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine gauss_legendre (x, w, interval) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: x (:) real(kind=rk), intent(out) :: w (:) real(kind=rk), intent(in) :: interval (2) private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","url":"module/forcad_utils.html"},{"title":"nearest_point_3d – ForCAD","text":"Uses forcad program~~nearest_point_3d~~UsesGraph program~nearest_point_3d nearest_point_3d module~forcad forcad program~nearest_point_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. The weights of the control points (Wc) are optional. Generate the NURBS volume with resolutions of 20, 20, 20 Find the nearest point on the volume to a given point\nFind the nearest point on the volume to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS volume object Calls program~~nearest_point_3d~~CallsGraph program~nearest_point_3d nearest_point_3d none~set nurbs_volume%set program~nearest_point_3d->none~set proc~create nurbs_volume%create program~nearest_point_3d->proc~create proc~finalize nurbs_volume%finalize program~nearest_point_3d->proc~finalize proc~nearest_point nurbs_volume%nearest_point program~nearest_point_3d->proc~nearest_point proc~nearest_point2 nurbs_volume%nearest_point2 program~nearest_point_3d->proc~nearest_point2 proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~nearest_point_help_3d nearest_point_help_3d proc~nearest_point->proc~nearest_point_help_3d proc~nearest_point2->proc~create proc~nearest_point2->proc~finalize proc~nearest_point2->proc~nearest_point none~derivative2 nurbs_volume%derivative2 proc~nearest_point2->none~derivative2 proc~cmp_xg nurbs_volume%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~inv inv proc~nearest_point2->proc~inv proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar nurbs_volume%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_volume%derivative2_vector none~derivative2->proc~derivative2_vector proc~cmp_xg->interface~compute_xg proc~cmp_xg->proc~is_rational proc~inv->proc~inv proc~det det proc~inv->proc~det proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~get_multiplicity->interface~compute_multiplicity proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (8) Weights of the control points real(kind=rk) :: Xc (8,3) Control points integer :: id id of the nearest point real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the volume real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point type( nurbs_volume ) :: shape Declare a NURBS volume object","tags":"","url":"program/nearest_point_3d.html"},{"title":"compute_volume – ForCAD","text":"Uses forcad program~~compute_volume~~UsesGraph program~compute_volume compute_volume module~forcad forcad program~compute_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_volume~~CallsGraph program~compute_volume compute_volume none~set nurbs_volume%set program~compute_volume->none~set proc~cmp_volume nurbs_volume%cmp_volume program~compute_volume->proc~cmp_volume proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~ansatz nurbs_volume%ansatz proc~cmp_volume->proc~ansatz proc~cmp_elem nurbs_volume%cmp_elem proc~cmp_volume->proc~cmp_elem proc~ansatz->none~set proc~ansatz->proc~cmp_elem interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz->interface~ndgrid interface~unique unique proc~ansatz->interface~unique none~derivative nurbs_volume%derivative proc~ansatz->none~derivative proc~det det proc~ansatz->proc~det proc~inv inv proc~ansatz->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar nurbs_volume%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_volume%derivative_vector none~derivative->proc~derivative_vector proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_volume%is_rational proc~derivative_scalar->proc~is_rational proc~derivative_vector->interface~ndgrid proc~derivative_vector->interface~compute_dtgc proc~derivative_vector->proc~is_rational proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~kron proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (8,3) type( nurbs_volume ) :: shape real(kind=rk) :: volume","tags":"","url":"program/compute_volume.html"},{"title":"test_nurbs_volume – ForCAD","text":"Uses forcad forunittest program~~test_nurbs_volume~~UsesGraph program~test_nurbs_volume test_nurbs_volume forunittest forunittest program~test_nurbs_volume->forunittest module~forcad forcad program~test_nurbs_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_nurbs_volume~~CallsGraph program~test_nurbs_volume test_nurbs_volume check check program~test_nurbs_volume->check none~basis nurbs_volume%basis program~test_nurbs_volume->none~basis none~derivative nurbs_volume%derivative program~test_nurbs_volume->none~derivative none~derivative2 nurbs_volume%derivative2 program~test_nurbs_volume->none~derivative2 none~get_degree nurbs_volume%get_degree program~test_nurbs_volume->none~get_degree none~get_knot nurbs_volume%get_knot program~test_nurbs_volume->none~get_knot none~get_nc nurbs_volume%get_nc program~test_nurbs_volume->none~get_nc none~get_wc nurbs_volume%get_Wc program~test_nurbs_volume->none~get_wc none~get_xc nurbs_volume%get_Xc program~test_nurbs_volume->none~get_xc none~get_xg nurbs_volume%get_Xg program~test_nurbs_volume->none~get_xg none~set nurbs_volume%set program~test_nurbs_volume->none~set proc~cmp_elem nurbs_volume%cmp_elem program~test_nurbs_volume->proc~cmp_elem proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis program~test_nurbs_volume->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis program~test_nurbs_volume->proc~cmp_elem_xg_vis proc~cmp_nc nurbs_volume%cmp_nc program~test_nurbs_volume->proc~cmp_nc proc~cmp_volume nurbs_volume%cmp_volume program~test_nurbs_volume->proc~cmp_volume proc~create nurbs_volume%create program~test_nurbs_volume->proc~create proc~elevate_degree nurbs_volume%elevate_degree program~test_nurbs_volume->proc~elevate_degree proc~export_xc nurbs_volume%export_Xc program~test_nurbs_volume->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~test_nurbs_volume->proc~export_xg proc~export_xth nurbs_volume%export_Xth program~test_nurbs_volume->proc~export_xth proc~finalize nurbs_volume%finalize program~test_nurbs_volume->proc~finalize proc~get_continuity nurbs_volume%get_continuity program~test_nurbs_volume->proc~get_continuity proc~get_elem nurbs_volume%get_elem program~test_nurbs_volume->proc~get_elem proc~get_elem_xc_vis nurbs_volume%get_elem_Xc_vis program~test_nurbs_volume->proc~get_elem_xc_vis proc~get_elem_xg_vis nurbs_volume%get_elem_Xg_vis program~test_nurbs_volume->proc~get_elem_xg_vis proc~get_multiplicity nurbs_volume%get_multiplicity program~test_nurbs_volume->proc~get_multiplicity proc~get_xt nurbs_volume%get_Xt program~test_nurbs_volume->proc~get_xt proc~insert_knots nurbs_volume%insert_knots program~test_nurbs_volume->proc~insert_knots proc~modify_wc nurbs_volume%modify_Wc program~test_nurbs_volume->proc~modify_wc proc~modify_xc nurbs_volume%modify_Xc program~test_nurbs_volume->proc~modify_xc proc~nearest_point nurbs_volume%nearest_point program~test_nurbs_volume->proc~nearest_point proc~nearest_point2 nurbs_volume%nearest_point2 program~test_nurbs_volume->proc~nearest_point2 proc~remove_knots nurbs_volume%remove_knots program~test_nurbs_volume->proc~remove_knots proc~rotate_xc nurbs_volume%rotate_Xc program~test_nurbs_volume->proc~rotate_xc proc~rotate_xg nurbs_volume%rotate_Xg program~test_nurbs_volume->proc~rotate_xg proc~set_c nurbs_volume%set_C program~test_nurbs_volume->proc~set_c proc~set_elem nurbs_volume%set_elem program~test_nurbs_volume->proc~set_elem proc~set_elem_xc_vis nurbs_volume%set_elem_Xc_vis program~test_nurbs_volume->proc~set_elem_xc_vis proc~set_elem_xg_vis nurbs_volume%set_elem_Xg_vis program~test_nurbs_volume->proc~set_elem_xg_vis proc~set_half_ring nurbs_volume%set_half_ring program~test_nurbs_volume->proc~set_half_ring proc~set_hexahedron nurbs_volume%set_hexahedron program~test_nurbs_volume->proc~set_hexahedron proc~set_ring nurbs_volume%set_ring program~test_nurbs_volume->proc~set_ring proc~translate_xc nurbs_volume%translate_Xc program~test_nurbs_volume->proc~translate_xc proc~translate_xg nurbs_volume%translate_Xg program~test_nurbs_volume->proc~translate_xg proc~basis_scalar nurbs_volume%basis_scalar none~basis->proc~basis_scalar proc~basis_vector nurbs_volume%basis_vector none~basis->proc~basis_vector proc~derivative_scalar nurbs_volume%derivative_scalar none~derivative->proc~derivative_scalar proc~derivative_vector nurbs_volume%derivative_vector none~derivative->proc~derivative_vector proc~derivative2_scalar nurbs_volume%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_volume%derivative2_vector none~derivative2->proc~derivative2_vector proc~get_degree_all nurbs_volume%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_volume%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_volume%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_volume%get_knoti none~get_knot->proc~get_knoti proc~get_nc_all nurbs_volume%get_nc_all none~get_nc->proc~get_nc_all proc~get_nc_dir nurbs_volume%get_nc_dir none~get_nc->proc~get_nc_dir proc~get_wc_all nurbs_volume%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_volume%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_volume%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_volume%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_volume%get_Xcid none~get_xc->proc~get_xcid proc~get_xg_all nurbs_volume%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_volume%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_volume%get_Xgid none~get_xg->proc~get_xgid proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_elem->proc~get_multiplicity interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn interface~unique unique proc~cmp_elem->interface~unique interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_volume->proc~cmp_elem proc~ansatz nurbs_volume%ansatz proc~cmp_volume->proc~ansatz interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~elevate_degree->none~get_knot proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xth->none~set proc~export_xth->proc~cmp_elem proc~export_xth->interface~ndgrid proc~export_xth->interface~unique proc~export_xth->proc~export_vtk_legacy proc~get_continuity->interface~compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~insert_knots->none~get_knot proc~insert_knots->none~set proc~insert_knots->interface~compute_multiplicity proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~modify_wc->none~get_knot proc~modify_wc->none~get_wc proc~modify_wc->none~get_xc proc~modify_wc->none~set proc~modify_xc->none~get_knot proc~modify_xc->none~get_wc proc~modify_xc->none~get_xc proc~modify_xc->none~set proc~nearest_point_help_3d nearest_point_help_3d proc~nearest_point->proc~nearest_point_help_3d proc~nearest_point2->none~derivative2 proc~nearest_point2->proc~create proc~nearest_point2->proc~finalize proc~nearest_point2->proc~nearest_point proc~cmp_xg nurbs_volume%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~inv inv proc~nearest_point2->proc~inv proc~remove_knots->none~get_knot proc~remove_knots->none~set proc~remove_knots->interface~compute_multiplicity proc~remove_knots->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc->proc~rotation proc~rotate_xg->proc~rotation proc~set_c->none~set proc~set_half_ring->none~set proc~set_hexahedron->none~set proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~set_ring->none~set proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~ansatz->none~derivative proc~ansatz->none~set proc~ansatz->proc~cmp_elem proc~ansatz->interface~ndgrid proc~ansatz->interface~unique proc~ansatz->proc~inv interface~gauss_leg gauss_leg proc~ansatz->interface~gauss_leg proc~det det proc~ansatz->proc~det proc~basis_scalar->proc~is_rational interface~compute_tgc compute_Tgc proc~basis_scalar->interface~compute_tgc proc~basis_vector->interface~ndgrid proc~basis_vector->proc~is_rational proc~basis_vector->interface~compute_tgc proc~cmp_xg->interface~compute_xg proc~cmp_xg->proc~is_rational proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~derivative_scalar->proc~is_rational interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector->interface~ndgrid proc~derivative_vector->proc~is_rational proc~derivative_vector->interface~compute_dtgc proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_nc_dir->interface~compute_multiplicity proc~inv->proc~inv proc~inv->proc~det cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1->proc~cmp_nc proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar interface~compute_dtgc->proc~compute_dtgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector interface~compute_dtgc->proc~compute_dtgc_bspline_3d_vector proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector interface~compute_dtgc->proc~compute_dtgc_nurbs_3d_vector proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar interface~compute_tgc->proc~compute_tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector interface~compute_tgc->proc~compute_tgc_bspline_3d_vector proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar interface~compute_tgc->proc~compute_tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector interface~compute_tgc->proc~compute_tgc_nurbs_3d_vector proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree->proc~get_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~kron proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~kron proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_bspline_3d_vector->proc~kron proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar->proc~kron proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector->proc~kron proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~kron proc~gauss_legendre_3d->proc~gauss_legendre Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Tgc (:,:) real(kind=rk), allocatable :: Tgc1 (:) real(kind=rk), allocatable :: Tgc1b (:) real(kind=rk), allocatable :: Tgcb (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xg (:,:) real(kind=rk), allocatable :: Xgb (:,:) type( nurbs_volume ) :: bsp real(kind=rk), allocatable :: d2Tgc (:,:,:) real(kind=rk), allocatable :: d2Tgc1 (:,:) real(kind=rk), allocatable :: d2Tgc1b (:,:) real(kind=rk), allocatable :: d2Tgcb (:,:,:) real(kind=rk), allocatable :: dTgc (:,:,:) real(kind=rk), allocatable :: dTgc1 (:,:) real(kind=rk), allocatable :: dTgc1b (:,:) real(kind=rk), allocatable :: dTgcb (:,:,:) integer, allocatable :: elemConn (:,:) integer :: i integer :: id real(kind=rk) :: knot1 (4) real(kind=rk) :: knot2 (4) real(kind=rk) :: knot3 (4) real(kind=rk), allocatable :: nearest_Xg (:) real(kind=rk), allocatable :: nearest_Xt (:) type( nurbs_volume ) :: nurbs type(unit_test) :: ut real(kind=rk) :: volume real(kind=rk) :: volumeb","tags":"","url":"program/test_nurbs_volume.html"},{"title":"compute_area – ForCAD","text":"Uses forcad program~~compute_area~~UsesGraph program~compute_area compute_area module~forcad forcad program~compute_area->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_area~~CallsGraph program~compute_area compute_area none~set~3 nurbs_surface%set program~compute_area->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~compute_area->proc~cmp_area proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~ansatz~3 nurbs_surface%ansatz proc~cmp_area->proc~ansatz~3 proc~cmp_elem~3 nurbs_surface%cmp_elem proc~cmp_area->proc~cmp_elem~3 proc~ansatz~3->none~set~3 proc~ansatz~3->proc~cmp_elem~3 interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg interface~ndgrid ndgrid proc~ansatz~3->interface~ndgrid interface~unique unique proc~ansatz~3->interface~unique none~derivative~3 nurbs_surface%derivative proc~ansatz~3->none~derivative~3 proc~det det proc~ansatz~3->proc~det proc~inv inv proc~ansatz~3->proc~inv interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~3 nurbs_surface%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_surface%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity proc~inv->proc~det proc~inv->proc~inv proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_surface%is_rational proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->interface~compute_dtgc~3 proc~derivative_vector~3->proc~is_rational~3 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~kron proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (4,3) real(kind=rk) :: area type( nurbs_surface ) :: shape","tags":"","url":"program/compute_area.html"},{"title":"example_nurbs_surface – ForCAD","text":"Uses forcad program~~example_nurbs_surface~~UsesGraph program~example_nurbs_surface example_nurbs_surface module~forcad forcad program~example_nurbs_surface->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface.\nIt sets up control points and weights, generates the surface, and exports the control points\nand the surface to VTK files at various stages. Define control points for the NURBS surface Define weights for the control points Set control points and weights for the NURBS surface object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS surface with a resolution of 30x30 Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~example_nurbs_surface~~CallsGraph program~example_nurbs_surface example_nurbs_surface none~set~3 nurbs_surface%set program~example_nurbs_surface->none~set~3 proc~create~3 nurbs_surface%create program~example_nurbs_surface->proc~create~3 proc~export_xc~3 nurbs_surface%export_Xc program~example_nurbs_surface->proc~export_xc~3 proc~export_xg~3 nurbs_surface%export_Xg program~example_nurbs_surface->proc~export_xg~3 proc~finalize~3 nurbs_surface%finalize program~example_nurbs_surface->proc~finalize~3 proc~generate_xc generate_Xc program~example_nurbs_surface->proc~generate_xc proc~show~3 nurbs_surface%show program~example_nurbs_surface->proc~show~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","url":"program/example_nurbs_surface.html"},{"title":"example_ppm3 – ForCAD","text":"Uses forcad forimage forcolormap fortime program~~example_ppm3~~UsesGraph program~example_ppm3 example_ppm3 forcolormap forcolormap program~example_ppm3->forcolormap forimage forimage program~example_ppm3->forimage fortime fortime program~example_ppm3->fortime module~forcad forcad program~example_ppm3->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon Calls program~~example_ppm3~~CallsGraph program~example_ppm3 example_ppm3 compute_rgb compute_rgb program~example_ppm3->compute_rgb export_pnm export_pnm program~example_ppm3->export_pnm get_b get_b program~example_ppm3->get_b get_g get_g program~example_ppm3->get_g get_r get_r program~example_ppm3->get_r none~get_xg~3 nurbs_surface%get_Xg program~example_ppm3->none~get_xg~3 proc~create~3 nurbs_surface%create program~example_ppm3->proc~create~3 proc~finalize~3 nurbs_surface%finalize program~example_ppm3->proc~finalize~3 proc~get_ng~3 nurbs_surface%get_ng program~example_ppm3->proc~get_ng~3 proc~modify_xc~3 nurbs_surface%modify_Xc program~example_ppm3->proc~modify_xc~3 proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm3->proc~set_tetragon proc~translate_xc~3 nurbs_surface%translate_Xc program~example_ppm3->proc~translate_xc~3 set set program~example_ppm3->set set_pnm set_pnm program~example_ppm3->set_pnm timer_start timer_start program~example_ppm3->timer_start timer_stop timer_stop program~example_ppm3->timer_stop proc~get_xg_all~3 nurbs_surface%get_Xg_all none~get_xg~3->proc~get_xg_all~3 proc~get_xgid~3 nurbs_surface%get_Xgid none~get_xg~3->proc~get_xgid~3 proc~get_xgi~3 nurbs_surface%get_Xgi none~get_xg~3->proc~get_xgi~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 none~get_knot~3 nurbs_surface%get_knot proc~modify_xc~3->none~get_knot~3 none~get_wc~3 nurbs_surface%get_Wc proc~modify_xc~3->none~get_wc~3 none~get_xc~3 nurbs_surface%get_Xc proc~modify_xc~3->none~get_xc~3 none~set~3 nurbs_surface%set proc~modify_xc~3->none~set~3 proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_surface%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_surface%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_surface%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_surface%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_surface%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image integer :: ng (2) integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","url":"program/example_ppm3.html"},{"title":"nearest_point_1d – ForCAD","text":"Uses forcad program~~nearest_point_1d~~UsesGraph program~nearest_point_1d nearest_point_1d module~forcad forcad program~nearest_point_1d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Find the nearest point on the curve to a given point\nFind the nearest point on the curve to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS curve object Calls program~~nearest_point_1d~~CallsGraph program~nearest_point_1d nearest_point_1d none~set~2 nurbs_curve%set program~nearest_point_1d->none~set~2 proc~create~2 nurbs_curve%create program~nearest_point_1d->proc~create~2 proc~finalize~2 nurbs_curve%finalize program~nearest_point_1d->proc~finalize~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 program~nearest_point_1d->proc~nearest_point2~2 proc~nearest_point~2 nurbs_curve%nearest_point program~nearest_point_1d->proc~nearest_point~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->proc~finalize~2 proc~nearest_point2~2->proc~nearest_point~2 none~derivative2~2 nurbs_curve%derivative2 proc~nearest_point2~2->none~derivative2~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2->proc~nearest_point_help_1d proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 proc~cmp_xg~2->interface~compute_xg~2 proc~cmp_xg~2->proc~is_rational~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~cmp_tgc_1d->proc~basis_bspline interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights integer :: id Variable for the id of the nearest point real(kind=rk) :: knot (6) Array for knot vector real(kind=rk), allocatable :: nearest_Xg (:) Array for the nearest point on the curve real(kind=rk) :: nearest_Xt Array for the parametric coordinates of the nearest point type( nurbs_curve ) :: shape Declare a NURBS curve object","tags":"","url":"program/nearest_point_1d.html"},{"title":"fdm_test_surface – ForCAD","text":"Uses forcad program~~fdm_test_surface~~UsesGraph program~fdm_test_surface fdm_test_surface module~forcad forcad program~fdm_test_surface->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate the NURBS surface with a resolution of 20 Finalize the NURBS surface object\nGenerate the NURBS surface with a resolution of 20 Finalize the NURBS surface object Calls program~~fdm_test_surface~~CallsGraph program~fdm_test_surface fdm_test_surface none~derivative2~3 nurbs_surface%derivative2 program~fdm_test_surface->none~derivative2~3 proc~create~3 nurbs_surface%create program~fdm_test_surface->proc~create~3 proc~finalize~3 nurbs_surface%finalize program~fdm_test_surface->proc~finalize~3 proc~set_tetragon nurbs_surface%set_tetragon program~fdm_test_surface->proc~set_tetragon proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 none~set~3 nurbs_surface%set proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: BFD (:,:) real(kind=rk), allocatable :: BFD2 (:,:) real(kind=rk), allocatable :: CFD (:,:) real(kind=rk), allocatable :: CFD2 (:,:) real(kind=rk), allocatable :: FFD (:,:) real(kind=rk), allocatable :: FFD2 (:,:) real(kind=rk), allocatable :: Tgc (:) real(kind=rk), allocatable :: Tgcm (:) real(kind=rk), allocatable :: Tgcp (:) real(kind=rk), allocatable :: Wc (:) Declare the control points weights real(kind=rk) :: Xt (2) real(kind=rk) :: Xtm (2) real(kind=rk) :: Xtp (2) real(kind=rk), allocatable :: d2Tgc (:,:) real(kind=rk), allocatable :: d2Tgcm (:,:) real(kind=rk), allocatable :: d2Tgcp (:,:) real(kind=rk), allocatable :: dTgc (:,:) real(kind=rk), allocatable :: dTgcm (:,:) real(kind=rk), allocatable :: dTgcp (:,:) integer :: i type( nurbs_surface ) :: surface Declare a NURBS surface object real(kind=rk) :: tol","tags":"","url":"program/fdm_test_surface.html"},{"title":"example_put_to_nurbs – ForCAD","text":"Uses forcad forcad_utils program~~example_put_to_nurbs~~UsesGraph program~example_put_to_nurbs example_put_to_nurbs module~forcad forcad program~example_put_to_nurbs->module~forcad module~forcad_utils forcad_utils program~example_put_to_nurbs->module~forcad_utils module~forcad->module~forcad_utils module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. You can create your shape or use a predefined one\nRead coordinates from file\nRead element connectivities from file\nSet a control shape that will be used to put the shape into\nThe contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points\nBy modifying the control shape you can modify the shape Map the shape into the shape Deallocate local variables Export the shape and the control shape to vtk files\nShow the control geometry and geometry using PyVista Finalize the control shape Calls program~~example_put_to_nurbs~~CallsGraph program~example_put_to_nurbs example_put_to_nurbs none~set nurbs_volume%set program~example_put_to_nurbs->none~set proc~export_xc nurbs_volume%export_Xc program~example_put_to_nurbs->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~example_put_to_nurbs->proc~export_xg proc~finalize nurbs_volume%finalize program~example_put_to_nurbs->proc~finalize proc~hexahedron_xc hexahedron_Xc program~example_put_to_nurbs->proc~hexahedron_xc proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs proc~show nurbs_volume%show program~example_put_to_nurbs->proc~show proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~basis_bspline basis_bspline proc~put_to_nurbs->proc~basis_bspline proc~kron kron proc~put_to_nurbs->proc~kron proc~set_elem_xg_vis nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: X (:,:) type( nurbs_volume ) :: control_shape integer, allocatable :: elem (:,:) integer :: i integer :: nunit","tags":"","url":"program/example_put_to_nurbs.html"},{"title":"shape_half_ring_2d – ForCAD","text":"Uses forcad program~~shape_half_ring_2d~~UsesGraph program~shape_half_ring_2d shape_half_ring_2d module~forcad forcad program~shape_half_ring_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_2d~~CallsGraph program~shape_half_ring_2d shape_half_ring_2d proc~create~3 nurbs_surface%create program~shape_half_ring_2d->proc~create~3 proc~export_xc~3 nurbs_surface%export_Xc program~shape_half_ring_2d->proc~export_xc~3 proc~export_xg~3 nurbs_surface%export_Xg program~shape_half_ring_2d->proc~export_xg~3 proc~finalize~3 nurbs_surface%finalize program~shape_half_ring_2d->proc~finalize~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~shape_half_ring_2d->proc~set_half_ring~2 proc~show~3 nurbs_surface%show program~shape_half_ring_2d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy none~set~3 nurbs_surface%set proc~set_half_ring~2->none~set~3 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","url":"program/shape_half_ring_2d.html"},{"title":"fdm_test_volume – ForCAD","text":"Uses forcad program~~fdm_test_volume~~UsesGraph program~fdm_test_volume fdm_test_volume module~forcad forcad program~fdm_test_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate the NURBS volume with a resolution of 20 Finalize the NURBS volume object\nGenerate the NURBS volume with a resolution of 20 Finalize the NURBS volume object Calls program~~fdm_test_volume~~CallsGraph program~fdm_test_volume fdm_test_volume none~derivative2 nurbs_volume%derivative2 program~fdm_test_volume->none~derivative2 proc~create nurbs_volume%create program~fdm_test_volume->proc~create proc~finalize nurbs_volume%finalize program~fdm_test_volume->proc~finalize proc~set_hexahedron nurbs_volume%set_hexahedron program~fdm_test_volume->proc~set_hexahedron proc~derivative2_scalar nurbs_volume%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_volume%derivative2_vector none~derivative2->proc~derivative2_vector interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational none~set nurbs_volume%set proc~set_hexahedron->none~set proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_bspline_3d_vector proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector interface~compute_d2tgc->proc~compute_d2tgc_nurbs_3d_vector proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: BFD (:,:) real(kind=rk), allocatable :: BFD2 (:,:) real(kind=rk), allocatable :: CFD (:,:) real(kind=rk), allocatable :: CFD2 (:,:) real(kind=rk), allocatable :: FFD (:,:) real(kind=rk), allocatable :: FFD2 (:,:) real(kind=rk), allocatable :: Tgc (:) real(kind=rk), allocatable :: Tgcm (:) real(kind=rk), allocatable :: Tgcp (:) real(kind=rk), allocatable :: Wc (:) Weights for the control points real(kind=rk) :: Xt (3) real(kind=rk) :: Xtm (3) real(kind=rk) :: Xtp (3) real(kind=rk), allocatable :: d2Tgc (:,:) real(kind=rk), allocatable :: d2Tgcm (:,:) real(kind=rk), allocatable :: d2Tgcp (:,:) real(kind=rk), allocatable :: dTgc (:,:) real(kind=rk), allocatable :: dTgcm (:,:) real(kind=rk), allocatable :: dTgcp (:,:) integer :: i real(kind=rk) :: tol type( nurbs_volume ) :: volume Declare a NURBS volume object","tags":"","url":"program/fdm_test_volume.html"},{"title":"nearest_point_2d – ForCAD","text":"Uses forcad program~~nearest_point_2d~~UsesGraph program~nearest_point_2d nearest_point_2d module~forcad forcad program~nearest_point_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a surface with 4 control points\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFind the nearest point on the surface to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS surface object Calls program~~nearest_point_2d~~CallsGraph program~nearest_point_2d nearest_point_2d none~set~3 nurbs_surface%set program~nearest_point_2d->none~set~3 proc~create~3 nurbs_surface%create program~nearest_point_2d->proc~create~3 proc~finalize~3 nurbs_surface%finalize program~nearest_point_2d->proc~finalize~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 program~nearest_point_2d->proc~nearest_point2~3 proc~nearest_point~3 nurbs_surface%nearest_point program~nearest_point_2d->proc~nearest_point~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->proc~finalize~3 proc~nearest_point2~3->proc~nearest_point~3 none~derivative2~3 nurbs_surface%derivative2 proc~nearest_point2~3->none~derivative2~3 proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 proc~inv inv proc~nearest_point2~3->proc~inv proc~nearest_point_help_2d nearest_point_help_2d proc~nearest_point~3->proc~nearest_point_help_2d proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 proc~cmp_xg~3->interface~compute_xg~3 proc~cmp_xg~3->proc~is_rational~3 proc~inv->proc~inv proc~det det proc~inv->proc~det proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (4) Weights of the control points real(kind=rk) :: Xc (4,3) Control points integer :: id id of the nearest point real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the surface real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point type( nurbs_surface ) :: shape Declare a NURBS surface object","tags":"","url":"program/nearest_point_2d.html"},{"title":"example_nurbs_curve – ForCAD","text":"Uses forcad program~~example_nurbs_curve~~UsesGraph program~example_nurbs_curve example_nurbs_curve module~forcad forcad program~example_nurbs_curve->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve.\nIt sets up control points and weights, generates the curve, and exports the control points\nand the curve to VTK files at various stages. Define control points for the NURBS curve Define weights for the control points Set control points and weights for the NURBS curve object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS curve with a resolution of 500 Export the generated curve to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example_nurbs_curve~~CallsGraph program~example_nurbs_curve example_nurbs_curve none~set~2 nurbs_curve%set program~example_nurbs_curve->none~set~2 proc~create~2 nurbs_curve%create program~example_nurbs_curve->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~example_nurbs_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~example_nurbs_curve->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~example_nurbs_curve->proc~finalize~2 proc~generate_xc~2 generate_Xc program~example_nurbs_curve->proc~generate_xc~2 proc~show~2 nurbs_curve%show program~example_nurbs_curve->proc~show~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_curve ) :: nurbs Declare a NURBS curve object Functions function generate_Xc (num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","url":"program/example_nurbs_curve.html"},{"title":"test_nurbs_curve – ForCAD","text":"Uses forcad forunittest program~~test_nurbs_curve~~UsesGraph program~test_nurbs_curve test_nurbs_curve forunittest forunittest program~test_nurbs_curve->forunittest module~forcad forcad program~test_nurbs_curve->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_nurbs_curve~~CallsGraph program~test_nurbs_curve test_nurbs_curve check check program~test_nurbs_curve->check none~basis~2 nurbs_curve%basis program~test_nurbs_curve->none~basis~2 none~derivative2~2 nurbs_curve%derivative2 program~test_nurbs_curve->none~derivative2~2 none~derivative~2 nurbs_curve%derivative program~test_nurbs_curve->none~derivative~2 none~get_knot~2 nurbs_curve%get_knot program~test_nurbs_curve->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc program~test_nurbs_curve->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc program~test_nurbs_curve->none~get_xc~2 none~get_xg~2 nurbs_curve%get_Xg program~test_nurbs_curve->none~get_xg~2 none~set~2 nurbs_curve%set program~test_nurbs_curve->none~set~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis program~test_nurbs_curve->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis program~test_nurbs_curve->proc~cmp_elem_xg_vis~2 proc~cmp_elem~2 nurbs_curve%cmp_elem program~test_nurbs_curve->proc~cmp_elem~2 proc~cmp_length nurbs_curve%cmp_length program~test_nurbs_curve->proc~cmp_length proc~cmp_nc~2 nurbs_curve%cmp_nc program~test_nurbs_curve->proc~cmp_nc~2 proc~create~2 nurbs_curve%create program~test_nurbs_curve->proc~create~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~test_nurbs_curve->proc~elevate_degree~2 proc~export_iges nurbs_curve%export_iges program~test_nurbs_curve->proc~export_iges proc~export_xc~2 nurbs_curve%export_Xc program~test_nurbs_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~test_nurbs_curve->proc~export_xg~2 proc~export_xth~2 nurbs_curve%export_Xth program~test_nurbs_curve->proc~export_xth~2 proc~finalize~2 nurbs_curve%finalize program~test_nurbs_curve->proc~finalize~2 proc~get_continuity~2 nurbs_curve%get_continuity program~test_nurbs_curve->proc~get_continuity~2 proc~get_degree nurbs_curve%get_degree program~test_nurbs_curve->proc~get_degree proc~get_elem_xc_vis~2 nurbs_curve%get_elem_Xc_vis program~test_nurbs_curve->proc~get_elem_xc_vis~2 proc~get_elem_xg_vis~2 nurbs_curve%get_elem_Xg_vis program~test_nurbs_curve->proc~get_elem_xg_vis~2 proc~get_elem~2 nurbs_curve%get_elem program~test_nurbs_curve->proc~get_elem~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity program~test_nurbs_curve->proc~get_multiplicity~2 proc~get_nc nurbs_curve%get_nc program~test_nurbs_curve->proc~get_nc proc~get_ng~2 nurbs_curve%get_ng program~test_nurbs_curve->proc~get_ng~2 proc~get_xt~2 nurbs_curve%get_Xt program~test_nurbs_curve->proc~get_xt~2 proc~insert_knots~2 nurbs_curve%insert_knots program~test_nurbs_curve->proc~insert_knots~2 proc~modify_wc~2 nurbs_curve%modify_Wc program~test_nurbs_curve->proc~modify_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc program~test_nurbs_curve->proc~modify_xc~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 program~test_nurbs_curve->proc~nearest_point2~2 proc~nearest_point~2 nurbs_curve%nearest_point program~test_nurbs_curve->proc~nearest_point~2 proc~remove_knots~2 nurbs_curve%remove_knots program~test_nurbs_curve->proc~remove_knots~2 proc~rotate_xc~2 nurbs_curve%rotate_Xc program~test_nurbs_curve->proc~rotate_xc~2 proc~rotate_xg~2 nurbs_curve%rotate_Xg program~test_nurbs_curve->proc~rotate_xg~2 proc~set_circle nurbs_curve%set_circle program~test_nurbs_curve->proc~set_circle proc~set_c~2 nurbs_curve%set_C program~test_nurbs_curve->proc~set_c~2 proc~set_elem_xc_vis~2 nurbs_curve%set_elem_Xc_vis program~test_nurbs_curve->proc~set_elem_xc_vis~2 proc~set_elem_xg_vis~2 nurbs_curve%set_elem_Xg_vis program~test_nurbs_curve->proc~set_elem_xg_vis~2 proc~set_elem~2 nurbs_curve%set_elem program~test_nurbs_curve->proc~set_elem~2 proc~set_half_circle nurbs_curve%set_half_circle program~test_nurbs_curve->proc~set_half_circle proc~translate_xc~2 nurbs_curve%translate_Xc program~test_nurbs_curve->proc~translate_xc~2 proc~translate_xg~2 nurbs_curve%translate_Xg program~test_nurbs_curve->proc~translate_xg~2 proc~basis_scalar~2 nurbs_curve%basis_scalar none~basis~2->proc~basis_scalar~2 proc~basis_vector~2 nurbs_curve%basis_vector none~basis~2->proc~basis_vector~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~get_xg_all~2 nurbs_curve%get_Xg_all none~get_xg~2->proc~get_xg_all~2 proc~get_xgid~2 nurbs_curve%get_Xgid none~get_xg~2->proc~get_xgid~2 proc~get_xgi~2 nurbs_curve%get_Xgi none~get_xg~2->proc~get_xgi~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem~2->proc~get_multiplicity~2 interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn interface~unique unique proc~cmp_elem~2->interface~unique proc~cmp_length->proc~cmp_elem~2 proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length->proc~ansatz~2 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->proc~is_rational~2 append append proc~export_iges->append delete delete proc~export_iges->delete init init proc~export_iges->init makedpsections makedpsections proc~export_iges->makedpsections makegsection makegsection proc~export_iges->makegsection makessection makessection proc~export_iges->makessection proc~export_iges->proc~is_rational~2 writeigesfile writeigesfile proc~export_iges->writeigesfile proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xth~2->none~set~2 proc~export_xth~2->proc~cmp_elem~2 interface~ndgrid ndgrid proc~export_xth~2->interface~ndgrid proc~export_xth~2->interface~unique proc~export_xth~2->proc~export_vtk_legacy proc~get_continuity~2->interface~compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~insert_knots~2->none~set~2 proc~insert_knots~2->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~2->proc~is_rational~2 proc~modify_wc~2->none~get_knot~2 proc~modify_wc~2->none~get_wc~2 proc~modify_wc~2->none~get_xc~2 proc~modify_wc~2->none~set~2 proc~modify_xc~2->none~get_knot~2 proc~modify_xc~2->none~get_wc~2 proc~modify_xc~2->none~get_xc~2 proc~modify_xc~2->none~set~2 proc~nearest_point2~2->none~derivative2~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->proc~finalize~2 proc~nearest_point2~2->proc~nearest_point~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2->proc~nearest_point_help_1d proc~remove_knots~2->none~set~2 proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->proc~findspan proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~2->proc~rotation proc~rotate_xg~2->proc~rotation proc~set_circle->none~set~2 proc~set_c~2->none~set~2 proc~set_half_circle->none~set~2 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~ansatz~2->none~derivative~2 proc~ansatz~2->none~set~2 proc~ansatz~2->proc~cmp_elem~2 proc~ansatz~2->interface~unique interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg proc~basis_scalar~2->proc~is_rational~2 interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2->proc~is_rational~2 proc~basis_vector~2->interface~compute_tgc~2 proc~cmp_xg~2->interface~compute_xg~2 proc~cmp_xg~2->proc~is_rational~2 proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~derivative_scalar~2->proc~is_rational~2 interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar interface~compute_tgc~2->proc~compute_tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector interface~compute_tgc~2->proc~compute_tgc_bspline_1d_vector proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector interface~compute_tgc~2->proc~compute_tgc_nurbs_1d_vector proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Tgc (:,:) real(kind=rk), allocatable :: Tgc1 (:) real(kind=rk), allocatable :: Tgc1b (:) real(kind=rk), allocatable :: Tgcb (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xg (:,:) real(kind=rk), allocatable :: Xgb (:,:) type( nurbs_curve ) :: bsp real(kind=rk), allocatable :: d2Tgc (:,:) real(kind=rk), allocatable :: d2Tgc1 (:) real(kind=rk), allocatable :: d2Tgc1b (:) real(kind=rk), allocatable :: d2Tgcb (:,:) real(kind=rk), allocatable :: dTgc (:,:) real(kind=rk), allocatable :: dTgc1 (:) real(kind=rk), allocatable :: dTgc1b (:) real(kind=rk), allocatable :: dTgcb (:,:) integer, allocatable :: elemConn (:,:) integer :: i integer :: id real(kind=rk) :: knot (6) real(kind=rk) :: length real(kind=rk) :: lengthb real(kind=rk), allocatable :: nearest_Xg (:) real(kind=rk) :: nearest_Xt type( nurbs_curve ) :: nurbs type(unit_test) :: ut","tags":"","url":"program/test_nurbs_curve.html"},{"title":"shape_C_3d – ForCAD","text":"Uses forcad program~~shape_c_3d~~UsesGraph program~shape_c_3d shape_C_3d module~forcad forcad program~shape_c_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_3d~~CallsGraph program~shape_c_3d shape_C_3d proc~create nurbs_volume%create program~shape_c_3d->proc~create proc~export_xc nurbs_volume%export_Xc program~shape_c_3d->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~shape_c_3d->proc~export_xg proc~finalize nurbs_volume%finalize program~shape_c_3d->proc~finalize proc~set_c nurbs_volume%set_C program~shape_c_3d->proc~set_c proc~show nurbs_volume%show program~shape_c_3d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy none~set nurbs_volume%set proc~set_c->none~set proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_c_3d.html"},{"title":"example_ppm1 – ForCAD","text":"Uses forcad forimage forcolormap fortime program~~example_ppm1~~UsesGraph program~example_ppm1 example_ppm1 forcolormap forcolormap program~example_ppm1->forcolormap forimage forimage program~example_ppm1->forimage fortime fortime program~example_ppm1->fortime module~forcad forcad program~example_ppm1->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm1~~CallsGraph program~example_ppm1 example_ppm1 compute_rgb compute_rgb program~example_ppm1->compute_rgb export_pnm export_pnm program~example_ppm1->export_pnm get_b get_b program~example_ppm1->get_b get_g get_g program~example_ppm1->get_g get_r get_r program~example_ppm1->get_r none~get_xg~3 nurbs_surface%get_Xg program~example_ppm1->none~get_xg~3 proc~create~3 nurbs_surface%create program~example_ppm1->proc~create~3 proc~finalize~3 nurbs_surface%finalize program~example_ppm1->proc~finalize~3 proc~get_ng~3 nurbs_surface%get_ng program~example_ppm1->proc~get_ng~3 proc~set_ring~2 nurbs_surface%set_ring program~example_ppm1->proc~set_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm1->proc~set_tetragon set set program~example_ppm1->set set_pnm set_pnm program~example_ppm1->set_pnm timer_start timer_start program~example_ppm1->timer_start timer_stop timer_stop program~example_ppm1->timer_stop proc~get_xg_all~3 nurbs_surface%get_Xg_all none~get_xg~3->proc~get_xg_all~3 proc~get_xgid~3 nurbs_surface%get_Xgid none~get_xg~3->proc~get_xgid~3 proc~get_xgi~3 nurbs_surface%get_Xgi none~get_xg~3->proc~get_xgi~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 none~set~3 nurbs_surface%set proc~set_ring~2->none~set~3 proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","url":"program/example_ppm1.html"},{"title":"example1_curve – ForCAD","text":"Uses forcad program~~example1_curve~~UsesGraph program~example1_curve example1_curve module~forcad forcad program~example1_curve->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Deallocate local arrays Export parameter space to a VTK file Export control points to a VTK file Generate the NURBS curve with a resolution of 20 Export the generated curve to a VTK file Export the NURBS curve to an IGES file Show the control geometry and geometry using PyVista Print size of the knot vector Insert knots 0.25, twice and 0.75, once Print size of the updated knot vector Print the degree of the curve Elevate the degree of the curve (2 times) Print the updated degree of the curve Print size of the knot vector Remove knots 0.25, twice and 0.75, once Print size of the updated knot vector Generate the refined curve with a resolution of 20 Export refined parameter space to a VTK file Export updated control points to a VTK file Export the refined generated curve to a VTK file Export the refined NURBS curve to an IGES file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export parameter space to a VTK file Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Export the transformed NURBS curve to an IGES file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example1_curve~~CallsGraph program~example1_curve example1_curve none~get_knot~2 nurbs_curve%get_knot program~example1_curve->none~get_knot~2 none~set~2 nurbs_curve%set program~example1_curve->none~set~2 proc~create~2 nurbs_curve%create program~example1_curve->proc~create~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~example1_curve->proc~elevate_degree~2 proc~export_iges nurbs_curve%export_iges program~example1_curve->proc~export_iges proc~export_xc~2 nurbs_curve%export_Xc program~example1_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~example1_curve->proc~export_xg~2 proc~export_xth~2 nurbs_curve%export_Xth program~example1_curve->proc~export_xth~2 proc~finalize~2 nurbs_curve%finalize program~example1_curve->proc~finalize~2 proc~get_degree nurbs_curve%get_degree program~example1_curve->proc~get_degree proc~insert_knots~2 nurbs_curve%insert_knots program~example1_curve->proc~insert_knots~2 proc~remove_knots~2 nurbs_curve%remove_knots program~example1_curve->proc~remove_knots~2 proc~rotate_xc~2 nurbs_curve%rotate_Xc program~example1_curve->proc~rotate_xc~2 proc~rotate_xg~2 nurbs_curve%rotate_Xg program~example1_curve->proc~rotate_xg~2 proc~show~2 nurbs_curve%show program~example1_curve->proc~show~2 proc~translate_xc~2 nurbs_curve%translate_Xc program~example1_curve->proc~translate_xc~2 proc~translate_xg~2 nurbs_curve%translate_Xg program~example1_curve->proc~translate_xg~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->proc~is_rational~2 append append proc~export_iges->append delete delete proc~export_iges->delete init init proc~export_iges->init makedpsections makedpsections proc~export_iges->makedpsections makegsection makegsection proc~export_iges->makegsection makessection makessection proc~export_iges->makessection proc~export_iges->proc~is_rational~2 writeigesfile writeigesfile proc~export_iges->writeigesfile proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy proc~export_xth~2->none~set~2 interface~ndgrid ndgrid proc~export_xth~2->interface~ndgrid interface~unique unique proc~export_xth~2->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~export_xth~2->proc~cmp_elem~2 proc~export_xth~2->proc~export_vtk_legacy proc~insert_knots~2->none~set~2 interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~2->proc~is_rational~2 proc~remove_knots~2->none~set~2 proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->proc~findspan proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~2->proc~rotation proc~rotate_xg~2->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem~2->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~get_multiplicity~2->interface~compute_multiplicity proc~cmp_tgc_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot (6) Array for knot vector type( nurbs_curve ) :: nurbs Declare a NURBS curve object Source Code program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth.vtk' ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !> Export the NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !> Export the refined NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !> Export the transformed NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","url":"program/example1_curve.html"},{"title":"compute_length – ForCAD","text":"Uses forcad program~~compute_length~~UsesGraph program~compute_length compute_length module~forcad forcad program~compute_length->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_length~~CallsGraph program~compute_length compute_length none~set~2 nurbs_curve%set program~compute_length->none~set~2 proc~cmp_length nurbs_curve%cmp_length program~compute_length->proc~cmp_length proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 proc~ansatz~2 nurbs_curve%ansatz proc~cmp_length->proc~ansatz~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_length->proc~cmp_elem~2 proc~ansatz~2->none~set~2 proc~ansatz~2->proc~cmp_elem~2 interface~dyad dyad proc~ansatz~2->interface~dyad interface~gauss_leg gauss_leg proc~ansatz~2->interface~gauss_leg interface~unique unique proc~ansatz~2->interface~unique none~derivative~2 nurbs_curve%derivative proc~ansatz~2->none~derivative~2 interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~derivative_scalar~2 nurbs_curve%derivative_scalar none~derivative~2->proc~derivative_scalar~2 proc~derivative_vector~2 nurbs_curve%derivative_vector none~derivative~2->proc~derivative_vector~2 proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2->interface~compute_dtgc~2 proc~derivative_vector~2->proc~is_rational~2 proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~gauss_legendre proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~gauss_legendre proc~gauss_legendre_3d->proc~kron proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_bspline_1d_vector proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector interface~compute_dtgc~2->proc~compute_dtgc_nurbs_1d_vector proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (2,3) real(kind=rk) :: length type( nurbs_curve ) :: shape","tags":"","url":"program/compute_length.html"},{"title":"shape_C_2d – ForCAD","text":"Uses forcad program~~shape_c_2d~~UsesGraph program~shape_c_2d shape_C_2d module~forcad forcad program~shape_c_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_2d~~CallsGraph program~shape_c_2d shape_C_2d proc~create~3 nurbs_surface%create program~shape_c_2d->proc~create~3 proc~export_xc~3 nurbs_surface%export_Xc program~shape_c_2d->proc~export_xc~3 proc~export_xg~3 nurbs_surface%export_Xg program~shape_c_2d->proc~export_xg~3 proc~finalize~3 nurbs_surface%finalize program~shape_c_2d->proc~finalize~3 proc~set_c~3 nurbs_surface%set_C program~shape_c_2d->proc~set_c~3 proc~show~3 nurbs_surface%show program~shape_c_2d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy none~set~3 nurbs_surface%set proc~set_c~3->none~set~3 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","url":"program/shape_c_2d.html"},{"title":"example_ppm2 – ForCAD","text":"Uses forcad forimage forcolormap fortime program~~example_ppm2~~UsesGraph program~example_ppm2 example_ppm2 forcolormap forcolormap program~example_ppm2->forcolormap forimage forimage program~example_ppm2->forimage fortime fortime program~example_ppm2->fortime module~forcad forcad program~example_ppm2->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm2~~CallsGraph program~example_ppm2 example_ppm2 compute_rgb compute_rgb program~example_ppm2->compute_rgb export_pnm export_pnm program~example_ppm2->export_pnm get_b get_b program~example_ppm2->get_b get_g get_g program~example_ppm2->get_g get_r get_r program~example_ppm2->get_r none~get_xg~3 nurbs_surface%get_Xg program~example_ppm2->none~get_xg~3 proc~create~3 nurbs_surface%create program~example_ppm2->proc~create~3 proc~finalize~3 nurbs_surface%finalize program~example_ppm2->proc~finalize~3 proc~get_ng~3 nurbs_surface%get_ng program~example_ppm2->proc~get_ng~3 proc~rotate_xc~3 nurbs_surface%rotate_Xc program~example_ppm2->proc~rotate_xc~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~example_ppm2->proc~set_half_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm2->proc~set_tetragon proc~translate_xc~3 nurbs_surface%translate_Xc program~example_ppm2->proc~translate_xc~3 set set program~example_ppm2->set set_pnm set_pnm program~example_ppm2->set_pnm timer_start timer_start program~example_ppm2->timer_start timer_stop timer_stop program~example_ppm2->timer_stop proc~get_xg_all~3 nurbs_surface%get_Xg_all none~get_xg~3->proc~get_xg_all~3 proc~get_xgid~3 nurbs_surface%get_Xgid none~get_xg~3->proc~get_xgid~3 proc~get_xgi~3 nurbs_surface%get_Xgi none~get_xg~3->proc~get_xgi~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~rotation rotation proc~rotate_xc~3->proc~rotation none~set~3 nurbs_surface%set proc~set_half_ring~2->none~set~3 proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","url":"program/example_ppm2.html"},{"title":"nearest_point_2d_bench – ForCAD","text":"Uses forcad fortime program~~nearest_point_2d_bench~~UsesGraph program~nearest_point_2d_bench nearest_point_2d_bench fortime fortime program~nearest_point_2d_bench->fortime module~forcad forcad program~nearest_point_2d_bench->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFinalize the NURBS surface object Calls program~~nearest_point_2d_bench~~CallsGraph program~nearest_point_2d_bench nearest_point_2d_bench proc~create~3 nurbs_surface%create program~nearest_point_2d_bench->proc~create~3 proc~finalize~3 nurbs_surface%finalize program~nearest_point_2d_bench->proc~finalize~3 proc~nearest_point~3 nurbs_surface%nearest_point program~nearest_point_2d_bench->proc~nearest_point~3 proc~set_tetragon nurbs_surface%set_tetragon program~nearest_point_2d_bench->proc~set_tetragon timer_start timer_start program~nearest_point_2d_bench->timer_start timer_stop timer_stop program~nearest_point_2d_bench->timer_stop interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~nearest_point_help_2d nearest_point_help_2d proc~nearest_point~3->proc~nearest_point_help_2d none~set~3 nurbs_surface%set proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: i integer :: id id of the nearest point integer :: j real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the surface real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point real(kind=rk), allocatable :: points (:,:) type( nurbs_surface ) :: shape Declare a NURBS surface object type(timer) :: t","tags":"","url":"program/nearest_point_2d_bench.html"},{"title":"shape_hexahedron – ForCAD","text":"Uses forcad program~~shape_hexahedron~~UsesGraph program~shape_hexahedron shape_hexahedron module~forcad forcad program~shape_hexahedron->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8].\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_hexahedron~~CallsGraph program~shape_hexahedron shape_hexahedron proc~create nurbs_volume%create program~shape_hexahedron->proc~create proc~export_xc nurbs_volume%export_Xc program~shape_hexahedron->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~shape_hexahedron->proc~export_xg proc~finalize nurbs_volume%finalize program~shape_hexahedron->proc~finalize proc~set_hexahedron nurbs_volume%set_hexahedron program~shape_hexahedron->proc~set_hexahedron proc~show nurbs_volume%show program~shape_hexahedron->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy none~set nurbs_volume%set proc~set_hexahedron->none~set proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_hexahedron.html"},{"title":"shape_circle – ForCAD","text":"Uses forcad program~~shape_circle~~UsesGraph program~shape_circle shape_circle module~forcad forcad program~shape_circle->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS circle with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_circle~~CallsGraph program~shape_circle shape_circle proc~create~2 nurbs_curve%create program~shape_circle->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_circle->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_circle->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_circle->proc~finalize~2 proc~set_circle nurbs_curve%set_circle program~shape_circle->proc~set_circle proc~show~2 nurbs_curve%show program~shape_circle->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy none~set~2 nurbs_curve%set proc~set_circle->none~set~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_tgc_1d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","url":"program/shape_circle.html"},{"title":"test_nurbs_surface – ForCAD","text":"Uses forcad forunittest program~~test_nurbs_surface~~UsesGraph program~test_nurbs_surface test_nurbs_surface forunittest forunittest program~test_nurbs_surface->forunittest module~forcad forcad program~test_nurbs_surface->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_nurbs_surface~~CallsGraph program~test_nurbs_surface test_nurbs_surface check check program~test_nurbs_surface->check none~basis~3 nurbs_surface%basis program~test_nurbs_surface->none~basis~3 none~derivative2~3 nurbs_surface%derivative2 program~test_nurbs_surface->none~derivative2~3 none~derivative~3 nurbs_surface%derivative program~test_nurbs_surface->none~derivative~3 none~get_degree~3 nurbs_surface%get_degree program~test_nurbs_surface->none~get_degree~3 none~get_knot~3 nurbs_surface%get_knot program~test_nurbs_surface->none~get_knot~3 none~get_nc~3 nurbs_surface%get_nc program~test_nurbs_surface->none~get_nc~3 none~get_wc~3 nurbs_surface%get_Wc program~test_nurbs_surface->none~get_wc~3 none~get_xc~3 nurbs_surface%get_Xc program~test_nurbs_surface->none~get_xc~3 none~get_xg~3 nurbs_surface%get_Xg program~test_nurbs_surface->none~get_xg~3 none~set~3 nurbs_surface%set program~test_nurbs_surface->none~set~3 proc~cmp_area nurbs_surface%cmp_area program~test_nurbs_surface->proc~cmp_area proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis program~test_nurbs_surface->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis program~test_nurbs_surface->proc~cmp_elem_xg_vis~3 proc~cmp_elem~3 nurbs_surface%cmp_elem program~test_nurbs_surface->proc~cmp_elem~3 proc~cmp_nc~3 nurbs_surface%cmp_nc program~test_nurbs_surface->proc~cmp_nc~3 proc~create~3 nurbs_surface%create program~test_nurbs_surface->proc~create~3 proc~elevate_degree~3 nurbs_surface%elevate_degree program~test_nurbs_surface->proc~elevate_degree~3 proc~export_iges~2 nurbs_surface%export_iges program~test_nurbs_surface->proc~export_iges~2 proc~export_xc~3 nurbs_surface%export_Xc program~test_nurbs_surface->proc~export_xc~3 proc~export_xg~3 nurbs_surface%export_Xg program~test_nurbs_surface->proc~export_xg~3 proc~export_xth~3 nurbs_surface%export_Xth program~test_nurbs_surface->proc~export_xth~3 proc~finalize~3 nurbs_surface%finalize program~test_nurbs_surface->proc~finalize~3 proc~get_continuity~3 nurbs_surface%get_continuity program~test_nurbs_surface->proc~get_continuity~3 proc~get_elem_xc_vis~3 nurbs_surface%get_elem_Xc_vis program~test_nurbs_surface->proc~get_elem_xc_vis~3 proc~get_elem_xg_vis~3 nurbs_surface%get_elem_Xg_vis program~test_nurbs_surface->proc~get_elem_xg_vis~3 proc~get_elem~3 nurbs_surface%get_elem program~test_nurbs_surface->proc~get_elem~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity program~test_nurbs_surface->proc~get_multiplicity~3 proc~get_xt~3 nurbs_surface%get_Xt program~test_nurbs_surface->proc~get_xt~3 proc~insert_knots~3 nurbs_surface%insert_knots program~test_nurbs_surface->proc~insert_knots~3 proc~modify_wc~3 nurbs_surface%modify_Wc program~test_nurbs_surface->proc~modify_wc~3 proc~modify_xc~3 nurbs_surface%modify_Xc program~test_nurbs_surface->proc~modify_xc~3 proc~nearest_point2~3 nurbs_surface%nearest_point2 program~test_nurbs_surface->proc~nearest_point2~3 proc~nearest_point~3 nurbs_surface%nearest_point program~test_nurbs_surface->proc~nearest_point~3 proc~remove_knots~3 nurbs_surface%remove_knots program~test_nurbs_surface->proc~remove_knots~3 proc~rotate_xc~3 nurbs_surface%rotate_Xc program~test_nurbs_surface->proc~rotate_xc~3 proc~rotate_xg~3 nurbs_surface%rotate_Xg program~test_nurbs_surface->proc~rotate_xg~3 proc~set_c~3 nurbs_surface%set_C program~test_nurbs_surface->proc~set_c~3 proc~set_elem_xc_vis~3 nurbs_surface%set_elem_Xc_vis program~test_nurbs_surface->proc~set_elem_xc_vis~3 proc~set_elem_xg_vis~3 nurbs_surface%set_elem_Xg_vis program~test_nurbs_surface->proc~set_elem_xg_vis~3 proc~set_elem~3 nurbs_surface%set_elem program~test_nurbs_surface->proc~set_elem~3 proc~set_half_ring~2 nurbs_surface%set_half_ring program~test_nurbs_surface->proc~set_half_ring~2 proc~set_ring~2 nurbs_surface%set_ring program~test_nurbs_surface->proc~set_ring~2 proc~set_tetragon nurbs_surface%set_tetragon program~test_nurbs_surface->proc~set_tetragon proc~translate_xc~3 nurbs_surface%translate_Xc program~test_nurbs_surface->proc~translate_xc~3 proc~translate_xg~3 nurbs_surface%translate_Xg program~test_nurbs_surface->proc~translate_xg~3 proc~basis_scalar~3 nurbs_surface%basis_scalar none~basis~3->proc~basis_scalar~3 proc~basis_vector~3 nurbs_surface%basis_vector none~basis~3->proc~basis_vector~3 proc~derivative2_scalar~3 nurbs_surface%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_surface%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 proc~derivative_scalar~3 nurbs_surface%derivative_scalar none~derivative~3->proc~derivative_scalar~3 proc~derivative_vector~3 nurbs_surface%derivative_vector none~derivative~3->proc~derivative_vector~3 proc~get_degree_all~2 nurbs_surface%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_surface%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_nc_all~2 nurbs_surface%get_nc_all none~get_nc~3->proc~get_nc_all~2 proc~get_nc_dir~2 nurbs_surface%get_nc_dir none~get_nc~3->proc~get_nc_dir~2 proc~get_wc_all~3 nurbs_surface%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_surface%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_surface%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_surface%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_surface%get_Xci none~get_xc~3->proc~get_xci~3 proc~get_xg_all~3 nurbs_surface%get_Xg_all none~get_xg~3->proc~get_xg_all~3 proc~get_xgid~3 nurbs_surface%get_Xgid none~get_xg~3->proc~get_xgid~3 proc~get_xgi~3 nurbs_surface%get_Xgi none~get_xg~3->proc~get_xgi~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 proc~cmp_area->proc~cmp_elem~3 proc~ansatz~3 nurbs_surface%ansatz proc~cmp_area->proc~ansatz~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem~3->proc~get_multiplicity~3 interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 append append proc~export_iges~2->append delete delete proc~export_iges~2->delete init init proc~export_iges~2->init makedpsections makedpsections proc~export_iges~2->makedpsections makegsection makegsection proc~export_iges~2->makegsection makessection makessection proc~export_iges~2->makessection proc~export_iges~2->proc~is_rational~3 writeigesfile writeigesfile proc~export_iges~2->writeigesfile proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xth~3->none~set~3 proc~export_xth~3->proc~cmp_elem~3 proc~export_xth~3->interface~ndgrid proc~export_xth~3->interface~unique proc~export_xth~3->proc~export_vtk_legacy proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~insert_knots~3->none~get_knot~3 proc~insert_knots~3->none~set~3 proc~insert_knots~3->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 proc~modify_wc~3->none~get_knot~3 proc~modify_wc~3->none~get_wc~3 proc~modify_wc~3->none~get_xc~3 proc~modify_wc~3->none~set~3 proc~modify_xc~3->none~get_knot~3 proc~modify_xc~3->none~get_wc~3 proc~modify_xc~3->none~get_xc~3 proc~modify_xc~3->none~set~3 proc~nearest_point2~3->none~derivative2~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->proc~finalize~3 proc~nearest_point2~3->proc~nearest_point~3 proc~cmp_xg~3 nurbs_surface%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 proc~inv inv proc~nearest_point2~3->proc~inv proc~nearest_point_help_2d nearest_point_help_2d proc~nearest_point~3->proc~nearest_point_help_2d proc~remove_knots~3->none~get_knot~3 proc~remove_knots~3->none~set~3 proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->proc~findspan proc~remove_knots~3->proc~is_rational~3 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~3->proc~rotation proc~rotate_xg~3->proc~rotation proc~set_c~3->none~set~3 proc~set_half_ring~2->none~set~3 proc~set_ring~2->none~set~3 proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real proc~ansatz~3->none~derivative~3 proc~ansatz~3->none~set~3 proc~ansatz~3->proc~cmp_elem~3 proc~ansatz~3->interface~ndgrid proc~ansatz~3->interface~unique proc~ansatz~3->proc~inv interface~gauss_leg gauss_leg proc~ansatz~3->interface~gauss_leg proc~det det proc~ansatz~3->proc~det proc~basis_scalar~3->proc~is_rational~3 interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3->interface~ndgrid proc~basis_vector~3->proc~is_rational~3 proc~basis_vector~3->interface~compute_tgc~3 proc~cmp_xg~3->interface~compute_xg~3 proc~cmp_xg~3->proc~is_rational~3 proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~derivative_scalar~3->proc~is_rational~3 interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3->interface~ndgrid proc~derivative_vector~3->proc~is_rational~3 proc~derivative_vector~3->interface~compute_dtgc~3 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_nc_dir~2->interface~compute_multiplicity proc~inv->proc~inv proc~inv->proc~det cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1~3->proc~cmp_nc~3 proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_bspline_2d_vector proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector interface~compute_d2tgc~3->proc~compute_d2tgc_nurbs_2d_vector proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_bspline_2d_vector proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector interface~compute_dtgc~3->proc~compute_dtgc_nurbs_2d_vector proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar interface~compute_tgc~3->proc~compute_tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector interface~compute_tgc~3->proc~compute_tgc_bspline_2d_vector proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector interface~compute_tgc~3->proc~compute_tgc_nurbs_2d_vector proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3->proc~get_multiplicity~3 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~kron proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~kron proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_bspline_2d_vector->proc~kron proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar->proc~kron proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector->proc~kron proc~gauss_legendre gauss_legendre proc~gauss_legendre_1d->proc~gauss_legendre proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_2d->proc~gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~kron proc~gauss_legendre_3d->proc~gauss_legendre Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Tgc (:,:) real(kind=rk), allocatable :: Tgc1 (:) real(kind=rk), allocatable :: Tgc1b (:) real(kind=rk), allocatable :: Tgcb (:,:) real(kind=rk), allocatable :: Wc (:) real(kind=rk), allocatable :: Xc (:,:) real(kind=rk), allocatable :: Xg (:,:) real(kind=rk), allocatable :: Xgb (:,:) real(kind=rk) :: area real(kind=rk) :: areab type( nurbs_surface ) :: bsp real(kind=rk), allocatable :: d2Tgc (:,:,:) real(kind=rk), allocatable :: d2Tgc1 (:,:) real(kind=rk), allocatable :: d2Tgc1b (:,:) real(kind=rk), allocatable :: d2Tgcb (:,:,:) real(kind=rk), allocatable :: dTgc (:,:,:) real(kind=rk), allocatable :: dTgc1 (:,:) real(kind=rk), allocatable :: dTgc1b (:,:) real(kind=rk), allocatable :: dTgcb (:,:,:) integer, allocatable :: elemConn (:,:) integer :: i integer :: id real(kind=rk) :: knot1 (4) real(kind=rk) :: knot2 (4) real(kind=rk), allocatable :: nearest_Xg (:) real(kind=rk), allocatable :: nearest_Xt (:) type( nurbs_surface ) :: nurbs type(unit_test) :: ut","tags":"","url":"program/test_nurbs_surface.html"},{"title":"shape_tetragon – ForCAD","text":"Uses forcad program~~shape_tetragon~~UsesGraph program~shape_tetragon shape_tetragon module~forcad forcad program~shape_tetragon->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~shape_tetragon~~CallsGraph program~shape_tetragon shape_tetragon proc~create~3 nurbs_surface%create program~shape_tetragon->proc~create~3 proc~export_xc~3 nurbs_surface%export_Xc program~shape_tetragon->proc~export_xc~3 proc~export_xg~3 nurbs_surface%export_Xg program~shape_tetragon->proc~export_xg~3 proc~finalize~3 nurbs_surface%finalize program~shape_tetragon->proc~finalize~3 proc~set_tetragon nurbs_surface%set_tetragon program~shape_tetragon->proc~set_tetragon proc~show~3 nurbs_surface%show program~shape_tetragon->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy none~set~3 nurbs_surface%set proc~set_tetragon->none~set~3 proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape Declare a NURBS surface object","tags":"","url":"program/shape_tetragon.html"},{"title":"shape_half_circle – ForCAD","text":"Uses forcad program~~shape_half_circle~~UsesGraph program~shape_half_circle shape_half_circle module~forcad forcad program~shape_half_circle->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half circle shape centered at the 0,0,0 with a radius of 1 Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_circle~~CallsGraph program~shape_half_circle shape_half_circle proc~create~2 nurbs_curve%create program~shape_half_circle->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_half_circle->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_half_circle->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_half_circle->proc~finalize~2 proc~set_half_circle nurbs_curve%set_half_circle program~shape_half_circle->proc~set_half_circle proc~show~2 nurbs_curve%show program~shape_half_circle->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy none~set~2 nurbs_curve%set proc~set_half_circle->none~set~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_tgc_1d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","url":"program/shape_half_circle.html"},{"title":"example3_surface – ForCAD","text":"Uses forcad program~~example3_surface~~UsesGraph program~example3_surface example3_surface module~forcad forcad program~example3_surface->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. Define control points for the NURBS surface Define weights for the control points\nDefine knot vectors for both dimensions\nSet knot vectors, control points, and weights for the NURBS surface object Deallocate local arrays Export parameter space to a VTK file Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Export the NURBS surface to an IGES file Show the control geometry and geometry using PyVista Print size of the knot vectors\nInsert knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after inserting knots\nPrint the degrees Elevate degree by 2 in both directions\nPrint the degrees after elevating Print size of the knot vectors\nRemove knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after removing knots\nGenerate the refined NURBS surface with resolutions of 30 in both dimensions Export refined parameter space to a VTK file Export updated control points to a VTK file Export the refined generated surface to a VTK file Export the NURBS surface to an IGES file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export parameter space to a VTK file Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Export the transformed NURBS surface to an IGES file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~example3_surface~~CallsGraph program~example3_surface example3_surface none~get_degree~3 nurbs_surface%get_degree program~example3_surface->none~get_degree~3 none~get_knot~3 nurbs_surface%get_knot program~example3_surface->none~get_knot~3 none~set~3 nurbs_surface%set program~example3_surface->none~set~3 proc~create~3 nurbs_surface%create program~example3_surface->proc~create~3 proc~elevate_degree~3 nurbs_surface%elevate_degree program~example3_surface->proc~elevate_degree~3 proc~export_iges~2 nurbs_surface%export_iges program~example3_surface->proc~export_iges~2 proc~export_xc~3 nurbs_surface%export_Xc program~example3_surface->proc~export_xc~3 proc~export_xg~3 nurbs_surface%export_Xg program~example3_surface->proc~export_xg~3 proc~export_xth~3 nurbs_surface%export_Xth program~example3_surface->proc~export_xth~3 proc~finalize~3 nurbs_surface%finalize program~example3_surface->proc~finalize~3 proc~generate_xc~3 generate_Xc program~example3_surface->proc~generate_xc~3 proc~insert_knots~3 nurbs_surface%insert_knots program~example3_surface->proc~insert_knots~3 proc~remove_knots~3 nurbs_surface%remove_knots program~example3_surface->proc~remove_knots~3 proc~rotate_xc~3 nurbs_surface%rotate_Xc program~example3_surface->proc~rotate_xc~3 proc~rotate_xg~3 nurbs_surface%rotate_Xg program~example3_surface->proc~rotate_xg~3 proc~show~3 nurbs_surface%show program~example3_surface->proc~show~3 proc~translate_xc~3 nurbs_surface%translate_Xc program~example3_surface->proc~translate_xc~3 proc~translate_xg~3 nurbs_surface%translate_Xg program~example3_surface->proc~translate_xg~3 proc~get_degree_all~2 nurbs_surface%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_surface%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_knot_all~3 nurbs_surface%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_surface%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 append append proc~export_iges~2->append delete delete proc~export_iges~2->delete init init proc~export_iges~2->init makedpsections makedpsections proc~export_iges~2->makedpsections makegsection makegsection proc~export_iges~2->makegsection makessection makessection proc~export_iges~2->makessection proc~export_iges~2->proc~is_rational~3 writeigesfile writeigesfile proc~export_iges~2->writeigesfile proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy proc~export_xth~3->none~set~3 proc~export_xth~3->interface~ndgrid interface~unique unique proc~export_xth~3->interface~unique proc~cmp_elem~3 nurbs_surface%cmp_elem proc~export_xth~3->proc~cmp_elem~3 proc~export_xth~3->proc~export_vtk_legacy proc~insert_knots~3->none~get_knot~3 proc~insert_knots~3->none~set~3 interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 proc~remove_knots~3->none~get_knot~3 proc~remove_knots~3->none~set~3 proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->proc~findspan proc~remove_knots~3->proc~is_rational~3 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~3->proc~rotation proc~rotate_xg~3->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elem~3->interface~unique interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~get_multiplicity~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (6) Arrays for knot vectors in both dimensions real(kind=rk) :: knot2 (6) Arrays for knot vectors in both dimensions type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !> Export the transformed NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","url":"program/example3_surface.html"},{"title":"example3_volume – ForCAD","text":"Uses forcad program~~example3_volume~~UsesGraph program~example3_volume example3_volume module~forcad forcad program~example3_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. Define the control points for the NURBS volume Define weights for the control points (optional)\nDefine knot vectors for all three dimensions\nSet knot vectors, control points, and weights for the NURBS volume object\nWc is optional. Deallocate local arrays Export parameter space to a VTK file Export the control points to a VTK file Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions Export the generated volume to a VTK file Export the NURBS volume to an IGES file\nNot supported for volumes.\nShow the control geometry and geometry using PyVista Print size of knot vectors\nInsert knots 0.25 and 0.75 in all three directions\nPrint size of knot vectors after inserting knots\nPrint degrees Elevate degree by 2 in all three directions\nPrint degrees after elevating Print size of knot vectors\nPrint size of knot vectors after removing knots\nGenerate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions Export refined parameter space to a VTK file Export updated control points to a VTK file Export the refined generated volume to a VTK file Export the NURBS volume to an IGES file\nNot supported for volumes.\nShow the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export parameter space to a VTK file Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Export the NURBS volume to an IGES file\nNot supported for volumes.\nShow the control geometry and geometry using PyVista first compute and set the connectivities of volume elements get the connectivity of the face1 of the first element\nget the degree of the faces\nFinalize the NURBS volume object Calls program~~example3_volume~~CallsGraph program~example3_volume example3_volume none~get_degree nurbs_volume%get_degree program~example3_volume->none~get_degree none~get_knot nurbs_volume%get_knot program~example3_volume->none~get_knot none~set nurbs_volume%set program~example3_volume->none~set proc~cmp_degreeface nurbs_volume%cmp_degreeFace program~example3_volume->proc~cmp_degreeface proc~cmp_elem nurbs_volume%cmp_elem program~example3_volume->proc~cmp_elem proc~cmp_elemface nurbs_volume%cmp_elemFace program~example3_volume->proc~cmp_elemface proc~create nurbs_volume%create program~example3_volume->proc~create proc~elevate_degree nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree proc~export_xc nurbs_volume%export_Xc program~example3_volume->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~example3_volume->proc~export_xg proc~export_xth nurbs_volume%export_Xth program~example3_volume->proc~export_xth proc~finalize nurbs_volume%finalize program~example3_volume->proc~finalize proc~generate_xc~4 generate_Xc program~example3_volume->proc~generate_xc~4 proc~insert_knots nurbs_volume%insert_knots program~example3_volume->proc~insert_knots proc~remove_knots nurbs_volume%remove_knots program~example3_volume->proc~remove_knots proc~rotate_xc nurbs_volume%rotate_Xc program~example3_volume->proc~rotate_xc proc~rotate_xg nurbs_volume%rotate_Xg program~example3_volume->proc~rotate_xg proc~set_elem nurbs_volume%set_elem program~example3_volume->proc~set_elem proc~show nurbs_volume%show program~example3_volume->proc~show proc~translate_xc nurbs_volume%translate_Xc program~example3_volume->proc~translate_xc proc~translate_xg nurbs_volume%translate_Xg program~example3_volume->proc~translate_xg proc~get_degree_all nurbs_volume%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_volume%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_volume%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_volume%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn interface~unique unique proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_elem->proc~get_multiplicity interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~elevate_degree->none~get_knot proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~export_xth->none~set proc~export_xth->proc~cmp_elem proc~export_xth->interface~ndgrid proc~export_xth->interface~unique proc~export_xth->proc~export_vtk_legacy proc~insert_knots->none~get_knot proc~insert_knots->none~set interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~remove_knots->none~get_knot proc~remove_knots->none~set proc~remove_knots->interface~compute_multiplicity proc~remove_knots->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc->proc~rotation proc~rotate_xg->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_multiplicity->interface~compute_multiplicity cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot2 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot3 (4) Arrays for knot vectors in all three dimensions type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","url":"program/example3_volume.html"},{"title":"example_nurbs_volume – ForCAD","text":"Uses forcad program~~example_nurbs_volume~~UsesGraph program~example_nurbs_volume example_nurbs_volume module~forcad forcad program~example_nurbs_volume->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume.\nIt sets up control points and weights, generates the volume, and exports the control points\nand the volume to VTK files at various stages. Define control points for the NURBS volume Define weights for the control points Set control points and weights for the NURBS volume object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS volume with a resolution of 15X15X15 Export the generated volume to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS volume object Calls program~~example_nurbs_volume~~CallsGraph program~example_nurbs_volume example_nurbs_volume none~set nurbs_volume%set program~example_nurbs_volume->none~set proc~create nurbs_volume%create program~example_nurbs_volume->proc~create proc~export_xc nurbs_volume%export_Xc program~example_nurbs_volume->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~example_nurbs_volume->proc~export_xg proc~finalize nurbs_volume%finalize program~example_nurbs_volume->proc~finalize proc~generate_xc~5 generate_Xc program~example_nurbs_volume->proc~generate_xc~5 proc~show nurbs_volume%show program~example_nurbs_volume->proc~show proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","url":"program/example_nurbs_volume.html"},{"title":"shape_C_1d – ForCAD","text":"Uses forcad program~~shape_c_1d~~UsesGraph program~shape_c_1d shape_C_1d module~forcad forcad program~shape_c_1d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_1d~~CallsGraph program~shape_c_1d shape_C_1d proc~create~2 nurbs_curve%create program~shape_c_1d->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_c_1d->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_c_1d->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_c_1d->proc~finalize~2 proc~set_c~2 nurbs_curve%set_C program~shape_c_1d->proc~set_c~2 proc~show~2 nurbs_curve%show program~shape_c_1d->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~2->proc~export_vtk_legacy proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~2->proc~export_vtk_legacy none~set~2 nurbs_curve%set proc~set_c~2->none~set~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_tgc_1d->proc~basis_bspline proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","url":"program/shape_c_1d.html"},{"title":"shape_half_ring_3d – ForCAD","text":"Uses forcad program~~shape_half_ring_3d~~UsesGraph program~shape_half_ring_3d shape_half_ring_3d module~forcad forcad program~shape_half_ring_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_3d~~CallsGraph program~shape_half_ring_3d shape_half_ring_3d proc~create nurbs_volume%create program~shape_half_ring_3d->proc~create proc~export_xc nurbs_volume%export_Xc program~shape_half_ring_3d->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~shape_half_ring_3d->proc~export_xg proc~finalize nurbs_volume%finalize program~shape_half_ring_3d->proc~finalize proc~set_half_ring nurbs_volume%set_half_ring program~shape_half_ring_3d->proc~set_half_ring proc~show nurbs_volume%show program~shape_half_ring_3d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy none~set nurbs_volume%set proc~set_half_ring->none~set proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_half_ring_3d.html"},{"title":"shape_ring_2d – ForCAD","text":"Uses forcad program~~shape_ring_2d~~UsesGraph program~shape_ring_2d shape_ring_2d module~forcad forcad program~shape_ring_2d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape with inner radius 1.0 and outer radius 2.0. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_2d~~CallsGraph program~shape_ring_2d shape_ring_2d proc~create~3 nurbs_surface%create program~shape_ring_2d->proc~create~3 proc~export_xc~3 nurbs_surface%export_Xc program~shape_ring_2d->proc~export_xc~3 proc~export_xg~3 nurbs_surface%export_Xg program~shape_ring_2d->proc~export_xg~3 proc~finalize~3 nurbs_surface%finalize program~shape_ring_2d->proc~finalize~3 proc~set_ring~2 nurbs_surface%set_ring program~shape_ring_2d->proc~set_ring~2 proc~show~3 nurbs_surface%show program~shape_ring_2d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_surface%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_surface%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_vtk_legacy export_vtk_legacy proc~export_xc~3->proc~export_vtk_legacy proc~cmp_elem_xg_vis~3 nurbs_surface%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~export_xg~3->proc~export_vtk_legacy none~set~3 nurbs_surface%set proc~set_ring~2->none~set~3 proc~compute_xg_bspline_2d compute_Xg_bspline_2d interface~compute_xg~3->proc~compute_xg_bspline_2d proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point interface~compute_xg~3->proc~compute_xg_bspline_2d_1point proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d interface~compute_xg~3->proc~compute_xg_nurbs_2d proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point interface~compute_xg~3->proc~compute_xg_nurbs_2d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_surface%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_surface%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_surface%set3 none~set~3->proc~set3~3 proc~set4~3 nurbs_surface%set4 none~set~3->proc~set4~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_2d_1point->proc~kron proc~cmp_tgc_2d cmp_Tgc_2d proc~compute_xg_nurbs_2d->proc~cmp_tgc_2d proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d_1point->proc~kron proc~cmp_degree~3 nurbs_surface%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_surface%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_surface%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~cmp_tgc_2d->proc~basis_bspline proc~cmp_tgc_2d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","url":"program/shape_ring_2d.html"},{"title":"shape_ring_3d – ForCAD","text":"Uses forcad program~~shape_ring_3d~~UsesGraph program~shape_ring_3d shape_ring_3d module~forcad forcad program~shape_ring_3d->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_3d~~CallsGraph program~shape_ring_3d shape_ring_3d proc~create nurbs_volume%create program~shape_ring_3d->proc~create proc~export_xc nurbs_volume%export_Xc program~shape_ring_3d->proc~export_xc proc~export_xg nurbs_volume%export_Xg program~shape_ring_3d->proc~export_xg proc~finalize nurbs_volume%finalize program~shape_ring_3d->proc~finalize proc~set_ring nurbs_volume%set_ring program~shape_ring_3d->proc~set_ring proc~show nurbs_volume%show program~shape_ring_3d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_volume%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_volume%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~export_vtk_legacy export_vtk_legacy proc~export_xc->proc~export_vtk_legacy proc~cmp_elem_xg_vis nurbs_volume%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg->proc~export_vtk_legacy none~set nurbs_volume%set proc~set_ring->none~set proc~compute_xg_bspline_3d compute_Xg_bspline_3d interface~compute_xg->proc~compute_xg_bspline_3d proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point interface~compute_xg->proc~compute_xg_bspline_3d_1point proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d interface~compute_xg->proc~compute_xg_nurbs_3d proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point interface~compute_xg->proc~compute_xg_nurbs_3d_1point proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_volume%set1 none~set->proc~set1 proc~set2 nurbs_volume%set2 none~set->proc~set2 proc~set3 nurbs_volume%set3 none~set->proc~set3 proc~set4 nurbs_volume%set4 none~set->proc~set4 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_bspline_3d_1point->proc~kron proc~cmp_tgc_3d cmp_Tgc_3d proc~compute_xg_nurbs_3d->proc~cmp_tgc_3d proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d_1point->proc~kron proc~cmp_degree nurbs_volume%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_volume%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_volume%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~cmp_tgc_3d->proc~basis_bspline proc~cmp_tgc_3d->proc~kron proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","url":"program/shape_ring_3d.html"},{"title":"fdm_test_curve – ForCAD","text":"Uses forcad program~~fdm_test_curve~~UsesGraph program~fdm_test_curve fdm_test_curve module~forcad forcad program~fdm_test_curve->module~forcad module~forcad_kinds forcad_kinds module~forcad->module~forcad_kinds module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_kinds module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_kinds module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_kinds module~forcad_nurbs_volume->module~forcad_utils module~forcad_utils->module~forcad_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Finalize the NURBS curve object\nDefine control points for the NURBS curve\nDefine knot vector Set knot vector, control points for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Finalize the NURBS curve object Calls program~~fdm_test_curve~~CallsGraph program~fdm_test_curve fdm_test_curve none~derivative2~2 nurbs_curve%derivative2 program~fdm_test_curve->none~derivative2~2 none~set~2 nurbs_curve%set program~fdm_test_curve->none~set~2 proc~create~2 nurbs_curve%create program~fdm_test_curve->proc~create~2 proc~finalize~2 nurbs_curve%finalize program~fdm_test_curve->proc~finalize~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 proc~set1a nurbs_curve%set1a none~set~2->proc~set1a proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~set4~2 nurbs_curve%set4 none~set~2->proc~set4~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~compute_xg_bspline_1d compute_Xg_bspline_1d interface~compute_xg~2->proc~compute_xg_bspline_1d proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point interface~compute_xg~2->proc~compute_xg_bspline_1d_1point proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d interface~compute_xg~2->proc~compute_xg_nurbs_1d proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point interface~compute_xg~2->proc~compute_xg_nurbs_1d_1point proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1a->proc~cmp_degree~2 proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_bspline_1d_vector proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector interface~compute_d2tgc~2->proc~compute_d2tgc_nurbs_1d_vector proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~cmp_tgc_1d cmp_Tgc_1d proc~compute_xg_nurbs_1d->proc~cmp_tgc_1d proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~cmp_tgc_1d->proc~basis_bspline proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Tgc (:) real(kind=rk), allocatable :: Tgcm (:) real(kind=rk), allocatable :: Tgcp (:) real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: Xt real(kind=rk) :: Xtm real(kind=rk) :: Xtp type( nurbs_curve ) :: curve Declare a NURBS curve object real(kind=rk), allocatable :: d2Tgc (:) real(kind=rk), allocatable :: d2Tgcm (:) real(kind=rk), allocatable :: d2Tgcp (:) real(kind=rk), allocatable :: dTgc (:) real(kind=rk), allocatable :: dTgcm (:) real(kind=rk), allocatable :: dTgcp (:) real(kind=rk) :: knot (6) Array for knot vector real(kind=rk) :: tol","tags":"","url":"program/fdm_test_curve.html"},{"title":"forcad_nurbs_volume.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_volume.f90~~EfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_volume.f90~~AfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. module forcad_nurbs_volume use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , det , inv , gauss_leg , export_vtk_legacy , basis_bspline_2der implicit none private public nurbs_volume !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_volume real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2)*nc(3), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2)*ng(3), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for the control points (1D array: [nc(1)*nc(2)*nc(3)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: Xt3 (:) !! Evaluation parameter values in the third direction (1D array: [ng(3)]) real ( rk ), allocatable , private :: Xt (:,:) !! Evaluation parameter values (2D array: [ng(1)*ng(2)*ng(3), dim] real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) real ( rk ), allocatable , private :: knot3 (:) !! Knot vector in the third direction (1D array) integer , private :: degree ( 3 ) !! Degree (order) of the volume integer , private :: nc ( 3 ) !! Number of control points in each direction integer , private :: ng ( 3 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vectors, control points and weights for the NURBS volume object procedure :: set2 !!> Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier volume using control points and weights procedure :: set4 !!> Set NURBS volume using degree, number of control points, control points and weights generic :: set => set1 , set2 , set3 , set4 !!> Set NURBS volume procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure , private :: get_nc_dir !!> Get number of control points in a specific direction procedure , private :: get_nc_all !!> Get number of control points in all directions generic :: get_nc => get_nc_all , get_nc_dir !!> Get number of control points procedure :: cmp_degree !!> Compute degree of the NURBS volume procedure , private :: get_degree_all !!> Get degree of the NURBS volume in all directions procedure , private :: get_degree_dir !!> Get degree of the NURBS volume in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS volume procedure :: finalize !!> Finalize the NURBS volume object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: export_Xth !!> Export parameter space to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knots procedure :: get_continuity !!> Compute and return the continuity of the NURBS volume procedure :: cmp_nc !!> Compute number of required control points procedure , private :: basis_vector !!> Compute the basis functions of the NURBS volume procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS volume generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS volume procedure , private :: derivative_vector !!> Compute the derivative of the NURBS volume procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS volume generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS volume procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS volume procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS volume generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS volume procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the NURBS volume procedure :: is_rational !!> Check if the NURBS volume is rational procedure :: put_to_nurbs !!> Put a shape to a NURBS volume procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS volume (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS volume (Minimization - Newton's method) procedure :: ansatz !!> Compute the shape functions, derivative of shape functions and dV procedure :: cmp_volume !!> Compute the volume of the NURBS volume ! Faces procedure :: cmp_elemFace_Xc_vis !!> Compute faces of the control points procedure :: cmp_elemFace_Xg_vis !!> Compute faces of the geometry points procedure :: cmp_elemFace !!> Compute faces of the IGA elements procedure :: cmp_degreeFace !!> Compute degrees of the faces ! Shapes procedure :: set_hexahedron !!> Set a hexahedron procedure :: set_ring !!> Set a ring procedure :: set_half_ring !!> Set a half ring procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg module procedure compute_Xg_nurbs_3d module procedure compute_Xg_bspline_3d module procedure compute_Xg_nurbs_3d_1point module procedure compute_Xg_bspline_3d_1point end interface interface compute_Tgc module procedure compute_Tgc_nurbs_3d_vector module procedure compute_Tgc_bspline_3d_vector module procedure compute_Tgc_nurbs_3d_scalar module procedure compute_Tgc_bspline_3d_scalar end interface interface compute_dTgc module procedure compute_dTgc_nurbs_3d_vector module procedure compute_dTgc_bspline_3d_vector module procedure compute_dTgc_nurbs_3d_scalar module procedure compute_dTgc_bspline_3d_scalar end interface interface compute_d2Tgc module procedure compute_d2Tgc_nurbs_3d_vector module procedure compute_d2Tgc_bspline_3d_vector module procedure compute_d2Tgc_nurbs_3d_scalar module procedure compute_d2Tgc_bspline_3d_scalar end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set1 ( this , knot1 , knot2 , knot3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot1 = knot1 this % knot2 = knot2 this % knot3 = knot3 call this % cmp_degree () call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , Xth_dir3 , degree , continuity1 , continuity2 , continuity3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:), Xth_dir3 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:), continuity3 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % knot3 = compute_knot_vector ( Xth_dir3 , degree ( 3 ), continuity3 ) this % degree ( 1 ) = degree ( 1 ) this % degree ( 2 ) = degree ( 2 ) this % degree ( 3 ) = degree ( 3 ) call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier volume using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) allocate ( this % knot1 ( 2 * this % nc ( 1 ))) this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) allocate ( this % knot2 ( 2 * this % nc ( 2 ))) this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) allocate ( this % knot3 ( 2 * this % nc ( 3 ))) this % knot3 ( 1 : this % nc ( 3 )) = 0.0_rk this % knot3 ( this % nc ( 3 ) + 1 : 2 * this % nc ( 3 )) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set4 ( this , degree , nc , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) integer :: m ( 3 ), i if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc this % degree = degree ! Size of knot vectors m = nc + degree + 1 if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) allocate ( this % knot1 ( m ( 1 ))) this % knot1 ( 1 : degree ( 1 ) + 1 ) = 0.0_rk this % knot1 ( degree ( 1 ) + 2 : m ( 1 ) - degree ( 1 ) - 1 ) = [( real ( i , rk ) / ( m ( 1 ) - 2 * degree ( 1 ) - 1 ), i = 1 , m ( 1 ) - 2 * degree ( 1 ) - 2 )] this % knot1 ( m ( 1 ) - degree ( 1 ): m ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) allocate ( this % knot2 ( m ( 2 ))) this % knot2 ( 1 : degree ( 2 ) + 1 ) = 0.0_rk this % knot2 ( degree ( 2 ) + 2 : m ( 2 ) - degree ( 2 ) - 1 ) = [( real ( i , rk ) / ( m ( 2 ) - 2 * degree ( 2 ) - 1 ), i = 1 , m ( 2 ) - 2 * degree ( 2 ) - 2 )] this % knot2 ( m ( 2 ) - degree ( 2 ): m ( 2 )) = 1.0_rk if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) allocate ( this % knot3 ( m ( 3 ))) this % knot3 ( 1 : degree ( 3 ) + 1 ) = 0.0_rk this % knot3 ( degree ( 3 ) + 2 : m ( 3 ) - degree ( 3 ) - 1 ) = [( real ( i , rk ) / ( m ( 3 ) - 2 * degree ( 3 ) - 1 ), i = 1 , m ( 3 ) - 2 * degree ( 3 ) - 2 )] this % knot3 ( m ( 3 ) - degree ( 3 ): m ( 3 )) = 1.0_rk if ( present ( Wc )) then if ( size ( Wc ) /= nc ( 1 ) * nc ( 2 ) * nc ( 3 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Xt ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), intent ( in ), contiguous , optional :: Xt (:,:) integer :: i ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 ) . or . . not . allocated ( this % knot3 )) then error stop 'Knot vector(s) is/are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if if ( present ( Xt )) then this % Xt = Xt else ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , this % Xt ) end if if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), size ( this % Xc , 2 ))) if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable :: Xg (:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 ) . or . . not . allocated ( this % knot3 )) then error stop 'Knot vector(s) is/are not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid direction for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid direction for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS volume is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS volume is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % Xt3 )) then Xt = this % Xt3 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_volume ), intent ( in ) :: this integer :: ng ( 3 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this , dir ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: dir integer , allocatable :: m1 (:), m2 (:), m3 (:) if ( present ( dir )) then if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 else if ( dir == 3 ) then m3 = this % get_multiplicity ( 3 ) this % degree ( 3 ) = m3 ( 1 ) - 1 else error stop 'Invalid direction for degree.' end if else m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 m3 = this % get_multiplicity ( 3 ) this % degree ( 3 ) = m3 ( 1 ) - 1 end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer :: degree ( 3 ) degree ( 1 ) = this % degree ( 1 ) degree ( 2 ) = this % degree ( 2 ) degree ( 3 ) = this % degree ( 3 ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree if ( dir == 1 ) then degree = this % degree ( 1 ) else if ( dir == 2 ) then degree = this % degree ( 2 ) else if ( dir == 3 ) then degree = this % degree ( 3 ) else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then knot = this % knot3 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then if ( i < 1 . or . i > size ( this % knot3 )) then error stop 'Invalid index for knot vector.' else knot = this % knot3 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_volume ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename , encoding ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if call export_vtk_legacy ( filename , this % Xc , elemConn , 12 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename , encoding ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if call export_vtk_legacy ( filename , this % Xg , elemConn , 12 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth ( this , filename , encoding ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Xth (:,:), Xth1 (:), Xth2 (:), Xth3 (:) type ( nurbs_volume ) :: th Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) Xth3 = unique ( this % knot3 ) call ndgrid ( Xth1 , Xth2 , Xth3 , Xth ) call th % set (& [ this % knot1 ( 1 ), Xth1 , this % knot1 ( size ( this % knot1 ))],& [ this % knot2 ( 1 ), Xth2 , this % knot2 ( size ( this % knot2 ))],& [ this % knot3 ( 1 ), Xth3 , this % knot3 ( size ( this % knot3 ))], Xth ) elemConn = th % cmp_elem () call export_vtk_legacy ( filename , Xth , elemConn , 12 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc ()) end if else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot1 ) . and . allocated ( this % knot2 ) . and . allocated ( this % knot3 )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( nc = this % nc , Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else error stop 'The NURBS volume is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else c = this % degree ( 3 ) - compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this , dir ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: dir if ( present ( dir )) then if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else this % nc ( 3 ) = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if else error stop 'Invalid direction.' end if else ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else this % nc ( 3 ) = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_all ( this ) result ( nc ) class ( nurbs_volume ), intent ( in ) :: this integer :: nc ( 3 ) nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_dir ( this , dir ) result ( nc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc , elem ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc , dTgc , Tgc , elem ) else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , dTgc , Tgc , elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , d2Tgc , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( this % knot3 ( 1 ) + ( this % knot3 ( size ( this % knot3 )) - this % knot3 ( 1 )) * real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc ) else Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc ) else Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( d + 1 )]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xcw_new = reshape ( Xcw_new ,[( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), d + 1 ]) allocate ( Xc_new ( 1 :( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 :( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , ( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * d ]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc_new = reshape ( Xc_new ,[( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), d ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end do end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( d + 1 )]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc4 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * d ]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc4 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end do end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( d + 1 )]) call insert_knot_A_5_1 (& this % degree ( 3 ),& this % knot3 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc4 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ))) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * d ]) call insert_knot_A_5_1 (& this % degree ( 3 ),& this % knot3 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc4 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , d ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new ) end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) integer :: nc_new , d , j real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( d + 1 )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , nc_new , knot_new , Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ nc_new * this % nc ( 2 ) * this % nc ( 3 ), d + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : nc_new * this % nc ( 2 ) * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 : nc_new * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , nc_new * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * d ], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , nc_new , knot_new , Xc_new ) Xc_new = reshape ( Xc_new ,[ nc_new * this % nc ( 2 ) * this % nc ( 3 ), d ], order = [ 1 , 2 ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( d + 1 )]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , nc_new , knot_new , Xcw_new ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * nc_new * this % nc ( 3 ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * nc_new * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * nc_new * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * nc_new * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * d ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , nc_new , knot_new , Xc_new ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * nc_new * this % nc ( 3 ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( d + 1 )]) call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xcw , nc_new , knot_new , Xcw_new ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * nc_new , d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * nc_new , 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * nc_new )) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * nc_new Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * d ]) call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xc , nc_new , knot_new , Xc_new ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , d ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * nc_new , d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new ) end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_volume ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_hexahedron ( this , L , nc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: L (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( present ( Wc )) then call this % set ( nc , hexahedron_Xc ( L , nc ), Wc ) else call this % set ( nc , hexahedron_Xc ( L , nc )) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine put_to_nurbs ( this , X , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: X (:,:) integer , intent ( in ), contiguous :: elemConn (:,:) integer :: i real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:), Tgc3 (:), Tgc (:) real ( rk ), allocatable :: Xt (:,:) real ( rk ) :: min_X1 , max_X1 , min_X2 , max_X2 , min_X3 , max_X3 ! Assuming knot vectors are in the range [0,1] ! Normalize the X coordinates to the range [0,1] allocate ( Xt ( size ( X , 1 ), size ( X , 2 ))) min_X1 = minval ( X (:, 1 )) max_X1 = maxval ( X (:, 1 )) min_X2 = minval ( X (:, 2 )) max_X2 = maxval ( X (:, 2 )) min_X3 = minval ( X (:, 3 )) max_X3 = maxval ( X (:, 3 )) Xt (:, 1 ) = ( X (:, 1 ) - min_X1 ) / ( max_X1 - min_X1 ) Xt (:, 2 ) = ( X (:, 2 ) - min_X2 ) / ( max_X2 - min_X2 ) Xt (:, 3 ) = ( X (:, 3 ) - min_X3 ) / ( max_X3 - min_X3 ) allocate ( this % Xg ( size ( Xt , 1 ), size ( this % Xc , 2 ))) allocate ( Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) this % Xg ( i ,:) = matmul ( Tgc , this % Xc ) end do else ! B-Spline volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) this % Xg ( i ,:) = matmul ( Tgc , this % Xc ) end do end if call this % set_elem_Xg_vis ( elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( d + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), d + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , ( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc_new = reshape ( Xc_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), d ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( d + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), d + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), d ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if end do end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( d + 1 )]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), d + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , d + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), d ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , d ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new ) end if end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ),& this % degree ( 1 ), this % degree ( 2 ), this % degree ( 3 ),& unique ( this % knot1 ), unique ( this % knot2 ), unique ( this % knot3 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ), this % get_multiplicity ( 3 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg ) class ( nurbs_volume ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len = 3000 ) :: pyvista_script pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=7,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels(\" // achar ( 10 ) // & \"        [point_coords],\" // achar ( 10 ) // & \"        [label],\" // achar ( 10 ) // & \"        font_size=14,\" // achar ( 10 ) // & \"        text_color='black',\" // achar ( 10 ) // & \"        show_points=False,\" // achar ( 10 ) // & \"        fill_shape=False,\" // achar ( 10 ) // & \"        shape=None,\" // achar ( 10 ) // & \"    )\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xg.SetVisibility(flag)\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcp_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='red',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 1 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcw_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='yellow',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 2 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xg_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='cyan',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 3 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Points)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 1 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Control geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 2 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xg (Geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 3 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'https://github.com/gha3mi/forcad',\" // achar ( 10 ) // & \"    position=(0.0, 0.0),\" // achar ( 10 ) // & \"    font_size=7,\" // achar ( 10 ) // & \"    color='blue',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" // achar ( 10 ) // & \"p.deep_clean()\" // achar ( 10 ) // & \"del p\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_ring ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i ! Define control points for ring allocate ( Xc ( 28 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 7 , 1 : 2 ) = Xc ( 1 : 7 , 1 : 2 ) * radius1 Xc ( 8 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 11 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 12 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 13 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 14 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 8 : 14 , 1 : 2 ) = Xc ( 8 : 14 , 1 : 2 ) * radius2 Xc ( 15 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 16 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 17 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 18 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 19 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 20 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), length ] Xc ( 21 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 15 : 21 , 1 : 2 ) = Xc ( 15 : 21 , 1 : 2 ) * radius1 Xc ( 22 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 23 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 24 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 25 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 26 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 27 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), length ] Xc ( 28 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 22 : 28 , 1 : 2 ) = Xc ( 22 : 28 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i ! Define control points for C-shape allocate ( Xc ( 20 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 8 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 Xc ( 11 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 12 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 13 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 14 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 15 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 11 : 15 , 1 : 2 ) = Xc ( 11 : 15 , 1 : 2 ) * radius1 Xc ( 16 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 17 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 18 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 19 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 20 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 16 : 20 , 1 : 2 ) = Xc ( 16 : 20 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_ring ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i ! Define control points for half ring allocate ( Xc ( 20 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 8 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 Xc ( 11 ,:) = [ 0.5_rk , 0.0_rk , length ] Xc ( 12 ,:) = [ 0.5_rk , 0.5_rk , length ] Xc ( 13 ,:) = [ 0.0_rk , 0.5_rk , length ] Xc ( 14 ,:) = [ - 0.5_rk , 0.5_rk , length ] Xc ( 15 ,:) = [ - 0.5_rk , 0.0_rk , length ] Xc ( 11 : 15 , 1 : 2 ) = Xc ( 11 : 15 , 1 : 2 ) * radius1 Xc ( 16 ,:) = [ 0.5_rk , 0.0_rk , length ] Xc ( 17 ,:) = [ 0.5_rk , 0.5_rk , length ] Xc ( 18 ,:) = [ 0.0_rk , 0.5_rk , length ] Xc ( 19 ,:) = [ - 0.5_rk , 0.5_rk , length ] Xc ( 20 ,:) = [ - 0.5_rk , 0.0_rk , length ] Xc ( 16 : 20 , 1 : 2 ) = Xc ( 16 : 20 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xt (:) integer , intent ( out ), optional :: id integer :: id_ real ( rk ), allocatable :: distances (:) allocate ( distances ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ))) distances = nearest_point_help_3d ( this % ng , this % Xg , point_Xg ) id_ = minloc ( distances , dim = 1 ) if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt ( 3 ) real ( rk ), allocatable , intent ( out ), optional :: nearest_Xg (:) real ( rk ) :: obj , grad ( 3 ), hess ( 3 , 3 ), dk ( 3 ), alphak , tau , beta , lower_bounds ( 3 ), upper_bounds ( 3 ) real ( rk ), allocatable :: Xg (:), xk (:), xkn (:), Tgc (:), dTgc (:,:), d2Tgc (:,:) integer :: k , l logical :: convergenz type ( nurbs_volume ) :: copy_this alphak = 0.0_rk dk = 0.0_rk k = 0 ! lower and upper bounds lower_bounds = [ minval ( this % knot1 ), minval ( this % knot2 ), minval ( this % knot3 )] upper_bounds = [ maxval ( this % knot1 ), maxval ( this % knot2 ), maxval ( this % knot3 )] ! guess initial point copy_this = this call copy_this % create ( 50 , 50 , 50 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! Check if xk is within the knot vector range if ( xk ( 1 ) < minval ( this % knot1 )) then xk ( 1 ) = minval ( this % knot1 ) else if ( xk ( 1 ) > maxval ( this % knot1 )) then xk ( 1 ) = maxval ( this % knot1 ) end if if ( xk ( 2 ) < minval ( this % knot2 )) then xk ( 2 ) = minval ( this % knot2 ) else if ( xk ( 2 ) > maxval ( this % knot2 )) then xk ( 2 ) = maxval ( this % knot2 ) end if if ( xk ( 3 ) < minval ( this % knot3 )) then xk ( 3 ) = minval ( this % knot3 ) else if ( xk ( 3 ) > maxval ( this % knot3 )) then xk ( 3 ) = maxval ( this % knot3 ) end if xkn = xk convergenz = . false . allocate ( Xg ( size ( this % Xc , 2 ))) ! allocate(dTgc(size(this%Xc,1), 2)) ! allocate(d2Tgc(size(this%Xc,1), 2)) do while (. not . convergenz . and . k < maxit ) ! objection, gradient and hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc is not needed obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! add a small number to avoid division by zero grad ( 1 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 1 ), this % Xc )) grad ( 2 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 2 ), this % Xc )) grad ( 3 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 3 ), this % Xc )) hess ( 1 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 2 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 3 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 1 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 2 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 3 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 1 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 hess ( 2 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 hess ( 3 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 ! debug print '(i3,1x,3e20.10,1x,e20.10)' , k , xk , norm2 ( grad ) if ( norm2 ( grad ) <= tol . or . ( k > 0 . and . norm2 ( xk - xkn ) <= tol )) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else dk = - matmul ( inv ( hess ), grad ) ! Backtracking-Armijo Line Search alphak = 1.0_rk tau = 0.5_rk ! 0 < tau  < 1 beta = 1.0e-4_rk ! 0 < beta < 1 l = 0 do while (. not . norm2 ( this % cmp_Xg ( xk + alphak * dk ) - point_Xg ) <= obj + alphak * beta * dot_product ( grad , dk ) . and . l < 50 ) alphak = tau * alphak l = l + 1 end do xkn = xk xk = xk + alphak * dk ! Check if xk is within the knot vector range xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k !> number of nodes in each direction n = this % degree + 1 select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace_Xc_vis ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k !> number of nodes in each direction n = [ 2 , 2 , 2 ] select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xc_vis ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace_Xg_vis ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k !> number of nodes in each direction n = [ 2 , 2 , 2 ] select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xg_vis ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_degreeFace ( this , face ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: face integer :: degree ( 3 ) select case ( face ) case ( 1 ) degree = [ this % degree ( 1 ), this % degree ( 2 ), 0 ] case ( 2 ) degree = [ this % degree ( 1 ), this % degree ( 2 ), 0 ] case ( 3 ) degree = [ this % degree ( 1 ), 0 , this % degree ( 3 )] case ( 4 ) degree = [ this % degree ( 1 ), 0 , this % degree ( 3 )] case ( 5 ) degree = [ 0 , this % degree ( 2 ), this % degree ( 3 )] case ( 6 ) degree = [ 0 , this % degree ( 2 ), this % degree ( 3 )] case default error stop 'Invalid face number' end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ansatz ( this , ie , ig , Tgc , dTgc_dXg , dV ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: ie , ig real ( rk ), intent ( out ) :: dV real ( rk ), allocatable , intent ( out ) :: Tgc (:), dTgc_dXg (:,:) real ( rk ), allocatable :: Xth (:,:), Xth_e (:,:), Xth_eT (:,:), Xc_eT (:,:), Xth1 (:), Xth2 (:), Xth3 (:), Xksi (:,:), Wksi (:) integer , allocatable :: elem_th (:,:), elem_c (:,:), elem_ce (:) type ( nurbs_volume ) :: th , th_e real ( rk ), allocatable :: dTtth_dXksi (:,:), Ttth (:), dTgc_dXt (:,:), Xt (:), dXt_dXksi (:,:), dXg_dXt (:,:) real ( rk ), allocatable :: dXg_dXksi (:,:) !! Jacobian matrix real ( rk ) :: det_dXg_dXksi !! Determinant of the Jacobian matrix call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], this % degree , Xksi , Wksi ) Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) Xth3 = unique ( this % knot3 ) call ndgrid ( Xth1 , Xth2 , Xth3 , Xth ) call th % set ([ 0.0_rk , Xth1 , 1.0_rk ], [ 0.0_rk , Xth2 , 1.0_rk ], [ 0.0_rk , Xth3 , 1.0_rk ], Xth ) elem_th = th % cmp_elem () elem_c = this % cmp_elem () Xth_e = Xth ( elem_th ( ie ,:),:) call th_e % set ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xth_e ) Xth_eT = transpose ( Xth_e ) elem_ce = elem_c ( ie ,:) Xc_eT = transpose ( this % Xc ( elem_ce ,:)) call th_e % derivative ( Xksi ( ig ,:), dTtth_dXksi , Ttth ) Xt = matmul ( Xth_eT , Ttth ) dXt_dXksi = matmul ( Xth_eT , dTtth_dXksi ) call this % derivative ( Xt , dTgc_dXt , Tgc , elem_ce ) dXg_dXt = matmul ( Xc_eT , dTgc_dXt ) dTgc_dXg = matmul ( dTgc_dXt , inv ( dXg_dXt )) dXg_dXksi = matmul ( dXg_dXt , dXt_dXksi ) det_dXg_dXksi = det ( dXg_dXksi ) dV = det_dXg_dXksi * Wksi ( ig ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_volume ( this , volume ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( out ) :: volume real ( rk ), allocatable :: Tgc (:), dTgc_dXg (:,:) integer :: ie , ig real ( rk ) :: dV , dV_ig volume = 0.0_rk do ie = 1 , size ( this % cmp_elem (), 1 ) dV = 0.0_rk do ig = 1 , size ( this % cmp_elem (), 2 ) call this % ansatz ( ie , ig , Tgc , dTgc_dXg , dV_ig ) dV = dV + dV_ig end do volume = volume + dV end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Tgc_3d ( Xti , knot1 , knot2 , knot3 , nc , degree , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xti (:) real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) real ( rk ), intent ( in ), contiguous :: knot3 (:) integer , intent ( in ) :: degree ( 3 ), nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )) real ( rk ) :: tmp integer :: i Tgc = kron ( basis_bspline ( Xti ( 3 ), knot3 , nc ( 3 ), degree ( 3 )),& kron (& basis_bspline ( Xti ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xti ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) tmp = dot_product ( Tgc , Wc ) do concurrent ( i = 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 )) Tgc ( i ) = ( Tgc ( i ) * Wc ( i )) / tmp end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_3d ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), size ( Xc , 2 ))) do concurrent ( i = 1 : ng ( 1 ) * ng ( 2 ) * ng ( 3 )) Xg ( i ,:) = matmul ( cmp_Tgc_3d ( Xt ( i ,:), knot1 , knot2 , knot3 , nc , degree , Wc ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_3d_1point ( Xt , knot1 , knot2 , knot3 , degree , nc , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:) real ( rk ), allocatable :: Tgc (:) allocate ( Xg ( size ( Xc , 2 ))) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )),& kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_3d ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), size ( Xc , 2 ))) do concurrent ( i = 1 : ng ( 1 ) * ng ( 2 ) * ng ( 3 )) Xg ( i ,:) = matmul ( kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))),& Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_3d_1point ( Xt , knot1 , knot2 , knot3 , degree , nc , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:) allocate ( Xg ( size ( Xc , 2 ))) Xg = matmul ( kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))),& Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ), allocatable :: dBi (:,:), Bi (:) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ), allocatable :: dBi (:,:), Bi (:) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) else allocate ( dTgc ( size ( elem ), 3 )) allocate ( Tgc ( size ( elem ))) allocate ( dBi ( size ( elem ), 3 ), Bi ( size ( elem ))) associate ( Biall => kron ( B3 , kron ( B2 , B1 ))) Bi = Biall ( elem ) Tgc = Bi * ( Wc ( elem ) / ( dot_product ( Bi , Wc ( elem )))) end associate associate ( dB1all => kron ( kron ( B3 , B2 ), dB1 ), dB2all => kron ( kron ( B3 , dB2 ), B1 ), dB3all => kron ( kron ( dB3 , B2 ), B1 )) dBi (:, 1 ) = dB1all ( elem ) dBi (:, 2 ) = dB2all ( elem ) dBi (:, 3 ) = dB3all ( elem ) end associate dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc ( elem ) - Tgc * dot_product ( dBi (:, 1 ), Wc ( elem )) ) / dot_product ( Bi , Wc ( elem )) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc ( elem ) - Tgc * dot_product ( dBi (:, 2 ), Wc ( elem )) ) / dot_product ( Bi , Wc ( elem )) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc ( elem ) - Tgc * dot_product ( dBi (:, 3 ), Wc ( elem )) ) / dot_product ( Bi , Wc ( elem )) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Tgc ( i ,:) = kron ( B3 , kron ( B2 , B1 )) dTgc ( i ,:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc ( i ,:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc ( i ,:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( B3 , kron ( B2 , B1 )) dTgc (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) else allocate ( dTgc ( size ( elem ), 3 )) allocate ( Tgc ( size ( elem ))) associate ( B => kron ( B3 , kron ( B2 , B1 ))) Tgc = B ( elem ) end associate associate ( dB1 => kron ( kron ( B3 , B2 ), dB1 ), dB2 => kron ( kron ( B3 , dB2 ), B1 ), dB3 => kron ( kron ( dB3 , B2 ), B1 )) dTgc (:, 1 ) = dB1 ( elem ) dTgc (:, 2 ) = dB2 ( elem ) dTgc (:, 3 ) = dB3 ( elem ) end associate end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ), allocatable :: Tgci (:), dTgci (:) real ( rk ), allocatable :: d2Bi (:,:), dBi (:,:), Bi (:) integer :: i allocate ( Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), d2Bi ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dTgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - 2.0_rk * dTgc ( i , :, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - 2.0_rk * dTgc ( i , :, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - 2.0_rk * dTgc ( i , :, 3 ) * dot_product ( dBi (:, 3 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) real ( rk ), allocatable :: d2Bi (:,:), dBi (:,:), Bi (:) allocate ( Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), d2Bi ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( d2Tgc ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - 2.0_rk * dTgc (:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - 2.0_rk * dTgc (:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc (:, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc (:, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - 2.0_rk * dTgc (:, 3 ) * dot_product ( dBi (:, 3 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Tgc ( i ,:) = kron ( B3 , kron ( B2 , B1 )) dTgc ( i ,:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc ( i ,:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc ( i ,:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 )) allocate ( d2Tgc ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Tgc = kron ( B3 , kron ( B2 , B1 )) dTgc (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( Tgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) do concurrent ( i = 1 : size ( Xt , 1 )) Tgci = kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), allocatable :: Tgc (:,:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) do concurrent ( i = 1 : size ( Xt , 1 )) Tgc ( i ,:) = kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function nearest_point_help_3d ( ng , Xg , point_Xg ) result ( distances ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xg (:,:) real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), allocatable :: distances (:) integer :: i allocate ( distances ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ))) do concurrent ( i = 1 : ng ( 1 ) * ng ( 2 ) * ng ( 3 )) distances ( i ) = norm2 ( Xg ( i ,:) - point_Xg ) end do end function !=============================================================================== end module forcad_nurbs_volume","tags":"","url":"sourcefile/forcad_nurbs_volume.f90.html"},{"title":"nearest_point_3d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_3d.f90~~EfferentGraph sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !! Declare a NURBS volume object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the volume real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 8 , 3 ) !! Control points real ( rk ) :: Wc ( 8 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS hexahedron !----------------------------------------------------------------------------- Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 4.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 4.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 2.0_rk ] Xc ( 6 ,:) = [ 2.0_rk , 0.0_rk , 2.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 4.0_rk , 2.0_rk ] Xc ( 8 ,:) = [ 2.0_rk , 4.0_rk , 2.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 1.11_rk , 1.0_rk , 0.5_rk , 0.5_rk , 1.2_rk , 1.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, 20 call shape % create ( 30 , 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the volume !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.5_rk , 3.5_rk , 1.1_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the volume (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) call shape % nearest_point2 ([ 1.5_rk , 3.5_rk , 1.1_rk ], 1.0e-11_rk , 500 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","url":"sourcefile/nearest_point_3d.f90.html"},{"title":"forcad.f90 – ForCAD","text":"This file depends on sourcefile~~forcad.f90~~EfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad.f90~~AfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forcad use forcad_kinds use forcad_utils use forcad_nurbs_curve use forcad_nurbs_surface use forcad_nurbs_volume implicit none private public rk , nurbs_curve , nurbs_surface , nurbs_volume end module forcad","tags":"","url":"sourcefile/forcad.f90.html"},{"title":"cmp_volume.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_volume.f90~~EfferentGraph sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_volume use forcad implicit none type ( nurbs_volume ) :: shape real ( rk ) :: volume real ( rk ) :: Xc ( 8 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 2.0_rk ] Xc ( 6 ,:) = [ 2.0_rk , 0.0_rk , 2.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 2.0_rk , 2.0_rk ] Xc ( 8 ,:) = [ 2.0_rk , 2.0_rk , 2.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_volume ( volume ) print * , volume end program","tags":"","url":"sourcefile/cmp_volume.f90.html"},{"title":"test_nurbs_volume.f90 – ForCAD","text":"This file depends on sourcefile~~test_nurbs_volume.f90~~EfferentGraph sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_nurbs_volume use forcad , only : rk , nurbs_volume use forunittest , only : unit_test implicit none type ( nurbs_volume ) :: nurbs , bsp real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xg (:,:), Xgb (:,:) integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Tgc (:,:), dTgc (:,:,:), Tgcb (:,:), dTgcb (:,:,:), d2Tgc (:,:,:), d2Tgcb (:,:,:) real ( rk ), allocatable :: Tgc1 (:), dTgc1 (:,:), Tgc1b (:), dTgc1b (:,:), d2Tgc1 (:,:), d2Tgc1b (:,:) real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ), volume , volumeb integer :: i , id real ( rk ), allocatable :: nearest_Xg (:), nearest_Xt (:) type ( unit_test ) :: ut allocate ( Xc ( 8 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 5.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 5.0_rk ] Xc ( 6 ,:) = [ 5.0_rk , 0.0_rk , 5.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 5.0_rk , 5.0_rk ] Xc ( 8 ,:) = [ 5.0_rk , 5.0_rk , 5.0_rk ] allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 0.9_rk knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) call bsp % set ( knot1 , knot2 , knot3 , Xc ) call nurbs % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc (), Wc = nurbs % get_Wc ()) call bsp % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc ()) call nurbs % create ( 20 , 20 , 20 ) call bsp % create ( 20 , 20 , 20 ) call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call nurbs % cmp_volume ( volume ) call bsp % cmp_volume ( volumeb ) call ut % check ( res = volume , expected = 12 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_volume: 01\" ) call ut % check ( res = volumeb , expected = 12 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_volume: 02\" ) call nurbs % nearest_point ([ 0.0_rk , 0.0_rk , - 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 03\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 04\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_volume: 05\" ) call bsp % nearest_point ([ 0.0_rk , 0.0_rk , - 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 06\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 07\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_volume: 08\" ) call nurbs % nearest_point2 ([ 0.0_rk , 0.0_rk , - 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 09\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 10\" ) call bsp % nearest_point2 ([ 0.0_rk , 0.0_rk , - 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 11\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_volume: 12\" ) Xg = nurbs % get_Xg () Xgb = bsp % get_Xg () call nurbs % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc , Wc ) call bsp % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 13\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 14\" ) call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) call bsp % set ([ 2 , 2 , 2 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 15\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 16\" ) call nurbs % create ( Xt1 = nurbs % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call bsp % create ( Xt1 = bsp % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 17\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 18\" ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 19\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 20\" ) call ut % check ( res = nurbs % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 21\" ) call ut % check ( res = bsp % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 22\" ) call ut % check ( res = nurbs % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 23\" ) call ut % check ( res = bsp % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 24\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 25\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 26\" ) call ut % check ( res = nurbs % get_Xg ( 1 ), expected = Xg ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 27\" ) call ut % check ( res = bsp % get_Xg ( 1 ), expected = Xgb ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_volume: 28\" ) call ut % check ( res = nurbs % get_Xg ( 1 , 1 ), expected = Xg ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 29\" ) call ut % check ( res = bsp % get_Xg ( 1 , 1 ), expected = Xgb ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 30\" ) call ut % check ( res = nurbs % get_Wc (), expected = Wc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 31\" ) call ut % check ( res = nurbs % get_Wc ( 1 ), expected = Wc ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 32\" ) call ut % check ( res = nurbs % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_volume: 33\" ) call ut % check ( res = bsp % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_volume: 34\" ) call ut % check ( res = nurbs % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 35\" ) call ut % check ( res = bsp % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_volume: 36\" ) ! call ut%check(res=nurbs%get_ng(), expected=size(Xg,1), msg=\"test_nurbs_volume: 37\") ! call ut%check(res=bsp%get_ng(), expected=size(Xgb,1), msg=\"test_nurbs_volume: 38\") call ut % check ( res = nurbs % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_volume: 39\" ) call ut % check ( res = bsp % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_volume: 40\" ) call ut % check ( res = nurbs % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_volume: 41\" ) call ut % check ( res = bsp % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_volume: 42\" ) call ut % check ( res = nurbs % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_volume: 43\" ) call ut % check ( res = bsp % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_volume: 44\" ) ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 45\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 46\") call nurbs % cmp_nc () call bsp % cmp_nc () ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 47\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_volume: 48\") elemConn = nurbs % cmp_elem_Xc_vis ([ 1 , 1 , 1 ]) call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 49\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xc_vis () call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 50\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis ([ 1 , 1 , 1 ]) call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 51\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis () call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_volume: 52\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis ([ 1 , 1 , 1 ]) call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 53\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis () call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 54\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis ([ 1 , 1 , 1 ]) call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 55\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis () call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_volume: 56\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem () call nurbs % set_elem ( elemConn ) call ut % check ( res = nurbs % get_elem (), expected = elemConn , msg = \"test_nurbs_volume: 57\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem () call bsp % set_elem ( elemConn ) call ut % check ( res = bsp % get_elem (), expected = elemConn , msg = \"test_nurbs_volume: 58\" ) deallocate ( elemConn ) call nurbs % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call bsp % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call nurbs % modify_Wc ( Wc ( 1 ), 1 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 59\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 60\" ) call nurbs % basis ( res1 = 20 , res2 = 20 , res3 = 20 , Tgc = Tgc ) call bsp % basis ( res1 = 20 , res2 = 20 , res3 = 20 , Tgc = Tgc ) call nurbs % basis ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], Tgc = Tgc1 ) call bsp % basis ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], Tgc = Tgc1b ) call nurbs % basis (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Tgc = Tgc ) call bsp % basis (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], Tgc = Tgc ) call nurbs % derivative ( res1 = 20 , res2 = 20 , res3 = 20 , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( res1 = 20 , res2 = 20 , res3 = 20 , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], dTgc = dTgc , Tgc = Tgc ) call bsp % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )], dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 , elem = [ 1 , 2 , 3 ]) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b , elem = [ 1 , 2 , 3 ]) call nurbs % derivative2 ( res1 = 20 , res2 = 20 , res3 = 20 , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( res1 = 20 , res2 = 20 , res3 = 20 , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt2 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& Xt3 = [( real ( i - 1 , rk ) / real ( 20 - 1 , rk ), i = 1 , 20 )],& d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1b , Tgc = Tgc1b ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1b , Tgc = Tgc1b ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 61\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 62\" ) call nurbs % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 63\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 64\" ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 65\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 66\" ) call nurbs % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 67\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 68\" ) call nurbs % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 69\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 70\" ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 71\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 72\" ) call nurbs % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 73\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_volume: 74\" ) call nurbs % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 75\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 76\" ) call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 77\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 78\" ) call nurbs % elevate_degree ( 1 , 2 ) call nurbs % elevate_degree ( 2 , 2 ) call nurbs % elevate_degree ( 3 , 2 ) call bsp % elevate_degree ( 1 , 2 ) call bsp % elevate_degree ( 2 , 2 ) call bsp % elevate_degree ( 3 , 2 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 79\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 80\" ) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! call bsp%remove_knots(1, [0.25_rk, 0.75_rk], [2,1]) ! call bsp%remove_knots(2, [0.25_rk, 0.75_rk], [2,1]) ! call bsp%remove_knots(3, [0.25_rk, 0.75_rk], [2,1]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_volume_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_volume_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_volume_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_volume_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_volume_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_volume_Xth.vtk\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_volume: 81\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_volume: 82\" ) call nurbs % set_hexahedron ([ 2.0_rk , 2.0_rk , 2.0_rk ], [ 2 , 2 , 2 ]) call bsp % set_hexahedron ([ 2.0_rk , 2.0_rk , 2.0_rk ], [ 2 , 2 , 2 ], [ 1.0_rk , 1.0_rk , 0.9_rk , 0.9_rk , 1.0_rk , 1.0_rk , 1.0_rk , 0.9_rk ]) call nurbs % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 2.0_rk ) call nurbs % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 2.0_rk ) call nurbs % set_C ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 2.0_rk ) call nurbs % finalize () call bsp % finalize () deallocate ( Xc , Wc , Xg , Xgb ) end program","tags":"","url":"sourcefile/test_nurbs_volume.f90.html"},{"title":"cmp_area.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_area.f90~~EfferentGraph sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_area use forcad implicit none type ( nurbs_surface ) :: shape real ( rk ) :: area real ( rk ) :: Xc ( 4 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_area ( area ) print * , area end program","tags":"","url":"sourcefile/cmp_area.f90.html"},{"title":"demo_surface.f90 – ForCAD","text":"This file depends on sourcefile~~demo_surface.f90~~EfferentGraph sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface. !> It sets up control points and weights, generates the surface, and exports the control points !> and the surface to VTK files at various stages. program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","url":"sourcefile/demo_surface.f90.html"},{"title":"example_ppm3.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm3.f90~~EfferentGraph sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm3 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap , wp use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 2 ]) call shape % translate_Xc ([ 0.01_rk , 0.01_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , real ( 0.0_rk , kind = wp ), real ( 2.2_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 2 ]) call shape % translate_Xc ([ 0.51_rk , 0.01_rk , 0.0_rk ]) call shape % modify_Xc ( 0.24_rk , 2 , 2 ) call shape % modify_Xc ( 0.26_rk , 5 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 3 ]) call shape % translate_Xc ([ 0.01_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.26_rk , 3 , 1 ) call shape % modify_Xc ( 0.24_rk , 4 , 1 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 3 ]) call shape % translate_Xc ([ 0.51_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.7_rk , 1 , 2 ) call shape % modify_Xc ( 0.7_rk , 3 , 2 ) call shape % modify_Xc ( 0.8_rk , 7 , 2 ) call shape % modify_Xc ( 0.8_rk , 9 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm3' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","url":"sourcefile/example_ppm3.f90.html"},{"title":"nearest_point_1d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_1d.f90~~EfferentGraph sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector real ( rk ), allocatable :: nearest_Xg (:) !! Array for the nearest point on the curve real ( rk ) :: nearest_Xt !! Array for the parametric coordinates of the nearest point integer :: id !! Variable for the id of the nearest point !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 1.1_rk , 1.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call shape % set ( knot , Xc , Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call shape % create ( 20 ) !----------------------------------------------------------------------------- ! Nearest point on the curve !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 4.5_rk , 4.5_rk , 5.0_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the curve (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) call shape % nearest_point2 ([ 4.5_rk , 4.5_rk , 5.0_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () deallocate ( nearest_Xg , Xc , Wc ) end program","tags":"","url":"sourcefile/nearest_point_1d.f90.html"},{"title":"fdm_surface.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_surface.f90~~EfferentGraph sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_test_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: surface !! Declare a NURBS surface object real ( rk ), allocatable :: Wc (:) !! Declare the control points weights real ( rk ) :: Xtp ( 2 ), tol , Xt ( 2 ), Xtm ( 2 ) real ( rk ), allocatable :: Tgc (:), dTgc (:,:), Tgcp (:), dTgcp (:,:), Tgcm (:), dTgcm (:,:), d2Tgc (:,:), d2Tgcp (:,:), d2Tgcm (:,:) real ( rk ), allocatable :: CFD (:,:), BFD (:,:), FFD (:,:), CFD2 (:,:), BFD2 (:,:), FFD2 (:,:) integer :: i !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.2_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 0.2_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.2_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.2_rk ] call surface % set_tetragon ( L = [ 5.0_rk , 8.0_rk ], nc = [ 4 , 4 ], Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 20 call surface % create ( 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 16 , 2 ), BFD ( 16 , 2 ), FFD ( 16 , 2 )) allocate ( CFD2 ( 2 * 16 , 2 ), BFD2 ( 2 * 16 , 2 ), FFD2 ( 2 * 16 , 2 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk call surface % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 2 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call surface % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call surface % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 2 * 16 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 2 * 16 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 2 * 16 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS surface object call surface % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- call surface % set_tetragon ( L = [ 5.0_rk , 8.0_rk ], nc = [ 4 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 20 call surface % create ( 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 16 , 2 ), BFD ( 16 , 2 ), FFD ( 16 , 2 )) allocate ( CFD2 ( 2 * 16 , 2 ), BFD2 ( 2 * 16 , 2 ), FFD2 ( 2 * 16 , 2 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk call surface % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 2 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call surface % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call surface % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 2 * 16 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 2 * 16 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 2 * 16 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS surface object call surface % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) end program","tags":"","url":"sourcefile/fdm_surface.f90.html"},{"title":"put_to_nurbs.f90 – ForCAD","text":"This file depends on sourcefile~~put_to_nurbs.f90~~EfferentGraph sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_put_to_nurbs use forcad use forcad_utils , only : hexahedron_Xc implicit none type ( nurbs_volume ) :: control_shape real ( rk ), allocatable :: X (:,:) integer , allocatable :: elem (:,:) integer :: i , nunit !> You can create your shape or use a predefined one !> Read coordinates from file allocate ( X ( 23200 , 3 )) open ( newunit = nunit , file = 'example/put_to_nurbs_X.txt' ) do i = 1 , 23200 read ( nunit , * ) X ( i , 1 ), X ( i , 2 ), X ( i , 3 ) end do close ( nunit ) !> Read element connectivities from file allocate ( elem ( 20577 , 8 )) open ( newunit = nunit , file = 'example/put_to_nurbs_elem.txt' ) do i = 1 , 20577 read ( nunit , * ) elem ( i , 1 ), elem ( i , 2 ), elem ( i , 4 ), elem ( i , 3 ), elem ( i , 5 ), elem ( i , 6 ), elem ( i , 8 ), elem ( i , 7 ) end do close ( nunit ) !> Set a control shape that will be used to put the shape into !> The contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points !> By modifying the control shape you can modify the shape call control_shape % set ( nc = [ 10 , 5 , 3 ], Xc = hexahedron_Xc ( L = [ 10 0.0_rk , 4 0.0_rk , 1 0.0_rk ], nc = [ 10 , 5 , 3 ])) !> Map the shape into the shape call control_shape % put_to_nurbs ( X , elem ) !> Deallocate local variables deallocate ( X , elem ) !> Export the shape and the control shape to vtk files call control_shape % export_Xc ( 'vtk/control_shape.vtk' ) call control_shape % export_Xg ( 'vtk/shape.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call control_shape % show ( 'vtk/control_shape.vtk' , 'vtk/shape.vtk' ) !> Finalize the control shape call control_shape % finalize () end program","tags":"","url":"sourcefile/put_to_nurbs.f90.html"},{"title":"shape_half_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_2d.f90~~EfferentGraph sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_2d_Xc.vtk' , 'vtk/shape_half_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_half_ring_2d.f90.html"},{"title":"forcad_nurbs_curve.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_curve.f90~~EfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_curve.f90~~AfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. module forcad_nurbs_curve use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , elemConn_C0 , ndgrid , compute_multiplicity , compute_knot_vector , basis_bspline_der ,& insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , dyad , gauss_leg , export_vtk_legacy , basis_bspline_2der implicit none private public nurbs_curve !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_curve real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc, dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng, dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc]) real ( rk ), allocatable , private :: Xt (:) !! Evaluation points (1D array: [ng]) real ( rk ), allocatable , private :: knot (:) !! Knot vector (1D array) integer , private :: degree !! Degree (order) of the curve integer , private :: nc !! Number of control points integer , private :: ng !! Number of geometry points integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vector, control points and weights for the NURBS curve object procedure :: set1a procedure :: set2 !!> Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier curve using control points and weights procedure :: set4 !!> Set NURBS curve using degree, number of control points, control points and weights generic :: set => set1 , set1a , set2 , set3 , set4 !!> Set NURBS curve procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: cmp_degree !!> Compute degree of the NURBS curve procedure :: get_degree !!> Get degree of the NURBS curve procedure :: finalize !!> Finalize the NURBS curve object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: export_Xth !!> Export parameter space to VTK file procedure :: export_iges !!> Export the NURBS curve to an IGES file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knots procedure :: get_continuity !!> Compute and return the continuity of the curve procedure :: cmp_nc !!> Compute number of required control points procedure :: get_nc !!> Get number of control points procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the curve procedure , private :: basis_vector !!> Compute the basis functions of the NURBS curve procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS curve generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS curve procedure , private :: derivative_vector !!> Compute the derivative of the NURBS curve procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS curve generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS curve procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS curve procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS curve generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS curve procedure :: is_rational !!> Check if the NURBS curve is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS curve (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS curve (Minimization - Newton's method) procedure :: ansatz !!> Compute the shape functions, derivative of shape functions and dL procedure :: cmp_length !!> Compute the length of the NURBS curve ! Shapes procedure :: set_circle !!> Set a circle procedure :: set_half_circle !!> Set a half circle procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg module procedure compute_Xg_nurbs_1d module procedure compute_Xg_bspline_1d module procedure compute_Xg_nurbs_1d_1point module procedure compute_Xg_bspline_1d_1point end interface interface compute_Tgc module procedure compute_Tgc_nurbs_1d_vector module procedure compute_Tgc_bspline_1d_vector module procedure compute_Tgc_nurbs_1d_scalar module procedure compute_Tgc_bspline_1d_scalar end interface interface compute_dTgc module procedure compute_dTgc_nurbs_1d_vector module procedure compute_dTgc_bspline_1d_vector module procedure compute_dTgc_nurbs_1d_scalar module procedure compute_dTgc_bspline_1d_scalar end interface interface compute_d2Tgc module procedure compute_d2Tgc_nurbs_1d_vector module procedure compute_d2Tgc_bspline_1d_vector module procedure compute_d2Tgc_nurbs_1d_scalar module procedure compute_d2Tgc_bspline_1d_scalar end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vector, control points and weights for the NURBS curve object. pure subroutine set1 ( this , knot , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot = knot call this % cmp_degree () this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vector, control points and weights for the NURBS curve object. pure subroutine set1a ( this , knot , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Xc (:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot = knot call this % cmp_degree () allocate ( this % Xc ( size ( Xc ), 3 ), source = 0.0_rk ) this % Xc (:, 1 ) = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. pure subroutine set2 ( this , Xth_dir , degree , continuity , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot = compute_knot_vector ( Xth_dir , degree , continuity ) this % degree = degree this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier curve using control points and weights. pure subroutine set3 ( this , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( allocated ( this % knot )) deallocate ( this % knot ) allocate ( this % knot ( 2 * this % nc )) this % knot ( 1 : this % nc ) = 0.0_rk this % knot ( this % nc + 1 : 2 * this % nc ) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set4 ( this , degree , nc , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) integer :: m , i if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc this % degree = degree ! Size of knot vectors m = nc + degree + 1 if ( allocated ( this % knot )) deallocate ( this % knot ) allocate ( this % knot ( m )) this % knot ( 1 : degree + 1 ) = 0.0_rk this % knot ( degree + 2 : m - degree - 1 ) = [( real ( i , rk ) / ( m - 2 * degree - 1 ), i = 1 , m - 2 * degree - 2 )] this % knot ( m - degree : m ) = 1.0_rk if ( present ( Wc )) then if ( size ( Wc ) /= nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res , Xt ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) integer :: i ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' end if ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt ) ! Allocate memory for geometry points if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable :: Xg (:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS curve is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS curve is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this ) result ( Xt ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xt (:) if ( allocated ( this % Xt )) then Xt = this % Xt else error stop 'Parameter values are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_curve ), intent ( in ) :: this integer :: ng ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this ) class ( nurbs_curve ), intent ( inout ) :: this integer , allocatable :: m (:) m = this % get_multiplicity () this % degree = m ( 1 ) - 1 end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree ( this ) result ( degree ) class ( nurbs_curve ), intent ( in ) :: this integer :: degree degree = this % degree end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: knot (:) if ( allocated ( this % knot )) then knot = this % knot else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , i ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: i real ( rk ) :: knot if ( allocated ( this % knot )) then if ( i < 1 . or . i > size ( this % knot )) then error stop 'Invalid index for knot vector.' else knot = this % knot ( i ) end if else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_curve ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % nc , p ) else elemConn = elemConn_C0 ( this % nc , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % ng , p ) else elemConn = elemConn_C0 ( this % ng , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename , encoding ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if call export_vtk_legacy ( filename , this % Xc , elemConn , 3 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename , encoding ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if call export_vtk_legacy ( filename , this % Xg , elemConn , 3 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth ( this , filename , encoding ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Xth (:,:), Xth1 (:), Xth2 (:), Xth3 (:) type ( nurbs_curve ) :: th Xth1 = unique ( this % knot ) Xth2 = [ 0.0_rk ] Xth3 = [ 0.0_rk ] call ndgrid ( Xth1 , Xth2 , Xth3 , Xth ) call th % set ([ this % knot ( 1 ), Xth1 , this % knot ( size ( this % knot ))], Xth ) elemConn = th % cmp_elem () call export_vtk_legacy ( filename , Xth , elemConn , 3 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_iges ( this , filename ) use forIGES , only : Gsection_t , Dentry_t , entity126_t , DElist_t , PElist_t ,& makeSsection , makeGsection , makeDPsections , writeIGESfile , wp class ( nurbs_curve ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename type ( Gsection_t ) :: G type ( Dentry_t ) :: D type ( entity126_t ) :: curve126 type ( DElist_t ) :: Dlist type ( PElist_t ) :: Plist character ( 80 ), allocatable :: Ssection (:), Gsection (:), Dsection (:), Psection (:), Ssec_out (:) real ( rk ), allocatable :: W (:), X (:), Y (:), Z (:), T (:) integer :: i , M , K , N , prop3 ! Parameters for IGES knot vector K = this % degree M = this % degree N = 1 + K - M ! Allocate IGES arrays explicitly with correct indexing allocate ( T ( - M : N + K ), X ( 0 : K ), Y ( 0 : K ), Z ( 0 : K ), W ( 0 : K )) ! Copy your knot vector to IGES indexing do i = - M , N + K T ( i ) = this % knot ( i + M + 1 ) end do ! Copy control points if ( this % is_rational ()) then do i = 0 , K X ( i ) = this % Xc ( i + 1 , 1 ) Y ( i ) = this % Xc ( i + 1 , 2 ) Z ( i ) = this % Xc ( i + 1 , 3 ) W ( i ) = this % Wc ( i + 1 ) end do prop3 = 1 else do i = 0 , K X ( i ) = this % Xc ( i + 1 , 1 ) Y ( i ) = this % Xc ( i + 1 , 2 ) Z ( i ) = this % Xc ( i + 1 , 3 ) W ( i ) = 1.0_rk end do prop3 = 0 end if ! Initialize IGES entity126 (Rational B-spline Curve) call curve126 % init (& DEP = 1 ,& form = 0 ,& K = K ,& M = M ,& PROP1 = 0 ,& PROP2 = 0 ,& PROP3 = prop3 ,& PROP4 = 0 ,& T = real ( T , kind = wp ),& W = real ( W , kind = wp ),& X = real ( X , kind = wp ),& Y = real ( Y , kind = wp ),& Z = real ( Z , kind = wp ),& V = real ([ minval ( this % knot ), maxval ( this % knot )], kind = wp ),& XNORM = real ( 0.0_rk , kind = wp ),& YNORM = real ( 0.0_rk , kind = wp ),& ZNORM = real ( 0.0_rk , kind = wp )) ! Directory entry call D % init ( entity_type = 126 , param_data = 1 , transformation_matrix = 0 , form_number = 0 ) ! Entity and directory lists call Dlist % init () call Plist % init () call Dlist % append ( D ) call Plist % append ( curve126 ) ! Global section call G % init ( filename = filename ) ! S-section description allocate ( Ssection ( 1 )) Ssection ( 1 ) = 'ForCAD' ! Create IGES sections call makeSsection ( Ssection , Ssec_out ) call makeGsection ( G , Gsection ) call makeDPsections ( Dlist , Plist , Dsection , Psection ) ! Write IGES file call writeIGESfile ( filename , Ssec_out , Gsection , Dsection , Psection ) ! Cleanup call Dlist % delete () call Plist % delete () end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot = this % get_knot (), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot = this % get_knot (), Xc = this % get_Xc ()) end if else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot )) then call this % set ( knot = this % get_knot (), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else error stop 'The NURBS curve is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this ) result ( m ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: m (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this ) result ( c ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: c (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else c = this % degree - compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this ) class ( nurbs_curve ), intent ( inout ) :: this this % nc = sum ( compute_multiplicity ( this % knot )) - this % degree - 1 end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( nurbs_curve ), intent ( in ) :: this integer :: nc nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , Xth , r ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , n_new real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) call insert_knot_A_5_1 (& this % degree ,& this % knot ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) allocate ( Xc_new ( 1 : n_new + 1 , 1 : d )) allocate ( Wc_new ( 1 : n_new + 1 )) do j = 1 , n_new + 1 Xc_new ( j , 1 : d ) = Xcw_new ( j - 1 , 1 : d ) / Xcw_new ( j - 1 , d + 1 ) Wc_new ( j ) = Xcw_new ( j - 1 , d + 1 ) end do call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if call insert_knot_A_5_1 (& this % degree ,& this % knot ,& this % Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) call this % set ( knot = knot_new , Xc = Xc_new ) end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , t ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) integer :: d , j , nc_new if ( this % is_rational ()) then ! NURBS d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) Xcw ( j , d + 1 ) = this % Wc ( j ) end do call elevate_degree_A_5_9 ( t , this % knot , this % degree , Xcw , nc_new , knot_new , Xcw_new ) allocate ( Xc_new ( 1 : nc_new , 1 : d )) allocate ( Wc_new ( 1 : nc_new )) do j = 1 , nc_new Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline d = size ( this % Xc , 2 ) call elevate_degree_A_5_9 ( t , this % knot , this % degree , this % Xc , nc_new , knot_new , Xc_new ) call this % set ( knot = knot_new , Xc = Xc_new ) deallocate ( Xc_new ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res , Xt , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc , elem ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot , this % degree , this % nc , this % Wc , dTgc , Tgc , elem ) else ! B-Spline call compute_dTgc ( Xt , this % knot , this % degree , this % nc , dTgc , Tgc , elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( this % knot ( 1 ) + ( this % knot ( size ( this % knot )) - this % knot ( 1 )) * real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: Tgc (:) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot , this % degree , this % nc , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_curve ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , Xth , r ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , nc_new , t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) call remove_knots_A_5_8 (& this % degree ,& this % knot ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) allocate ( Xc_new ( nc_new , d )) allocate ( Wc_new ( nc_new )) do j = 1 , nc_new Xc_new ( j ,:) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) if ( allocated ( Xcw_new )) deallocate ( Xcw_new ) if ( allocated ( Xc_new )) deallocate ( Xc_new ) if ( allocated ( Wc_new )) deallocate ( Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 call remove_knots_A_5_8 (& this % degree ,& this % knot ,& this % Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( t == 0 ) then ! no change else call this % set ( knot = knot_new , Xc = Xc_new ) end if end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_circle ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i ! Define control points for circle allocate ( Xc ( 7 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i ! Define control points for C-shape allocate ( Xc ( 5 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc , this % degree , unique ( this % knot ), this % get_multiplicity (),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg ) class ( nurbs_curve ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len = 3000 ) :: pyvista_script pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=7,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels(\" // achar ( 10 ) // & \"        [point_coords],\" // achar ( 10 ) // & \"        [label],\" // achar ( 10 ) // & \"        font_size=14,\" // achar ( 10 ) // & \"        text_color='black',\" // achar ( 10 ) // & \"        show_points=False,\" // achar ( 10 ) // & \"        fill_shape=False,\" // achar ( 10 ) // & \"        shape=None,\" // achar ( 10 ) // & \"    )\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xg.SetVisibility(flag)\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcp_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='red',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 1 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcw_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='yellow',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 2 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xg_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='cyan',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 3 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Points)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 1 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Control geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 2 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xg (Geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 3 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'https://github.com/gha3mi/forcad',\" // achar ( 10 ) // & \"    position=(0.0, 0.0),\" // achar ( 10 ) // & \"    font_size=7,\" // achar ( 10 ) // & \"    color='blue',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" // achar ( 10 ) // & \"p.deep_clean()\" // achar ( 10 ) // & \"del p\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_circle ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i ! Define control points for half circle allocate ( Xc ( 5 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xg (:) real ( rk ), intent ( out ), optional :: nearest_Xt integer , intent ( out ), optional :: id integer :: id_ real ( rk ), allocatable :: distances (:) allocate ( distances ( this % ng )) distances = nearest_point_help_1d ( this % ng , this % Xg , point_Xg ) id_ = minloc ( distances , dim = 1 ) if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt real ( rk ), allocatable , intent ( out ), optional :: nearest_Xg (:) real ( rk ) :: xk , xkn , obj , grad , hess , dk , alphak , tau , beta , lower_bounds , upper_bounds real ( rk ), allocatable :: Xg (:), Tgc (:), dTgc (:), d2Tgc (:) integer :: k , l logical :: convergenz type ( nurbs_curve ) :: copy_this k = 0 ! lower and upper bounds lower_bounds = minval ( this % knot ) upper_bounds = maxval ( this % knot ) ! guess initial point copy_this = this call copy_this % create ( 10 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! Check if xk is within the knot vector range if ( xk < minval ( this % knot )) then xk = minval ( this % knot ) else if ( xk > maxval ( this % knot )) then xk = maxval ( this % knot ) end if xkn = xk convergenz = . false . allocate ( Xg ( size ( this % Xc , 2 ))) ! allocate(dTgc(size(this%Xc,1))) ! allocate(d2Tgc(size(this%Xc,1))) do while (. not . convergenz . and . k < maxit ) ! objection, gradient and hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc is not needed obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! add a small number to avoid division by zero grad = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc , this % Xc )) hess = dot_product ( matmul ( dTgc , this % Xc ) - ( Xg - point_Xg ) / obj * grad , matmul ( dTgc , this % Xc )) / obj & + dot_product (( Xg - point_Xg ) / obj , matmul ( d2Tgc , this % Xc )) ! debug print '(i3,1x,e20.10,1x,e20.10)' , k , xk , abs ( grad ) if ( abs ( grad ) <= tol . or . ( k > 0 . and . abs ( xk - xkn ) <= tol )) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else dk = - grad / hess ! Backtracking-Armijo Line Search alphak = 1.0_rk tau = 0.5_rk ! 0 < tau  < 1 beta = 1.0e-4_rk ! 0 < beta < 1 l = 0 do while (. not . norm2 ( this % cmp_Xg ( xk + alphak * dk ) - point_Xg ) <= obj + alphak * beta * grad * dk . and . l < 50 ) alphak = tau * alphak l = l + 1 end do xkn = xk xk = xk + alphak * dk ! Check if xk is within the knot vector range xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ansatz ( this , ie , ig , Tgc , dTgc_dXg , dL ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: ie , ig real ( rk ), intent ( out ) :: dL real ( rk ), allocatable , intent ( out ) :: Tgc (:), dTgc_dXg (:,:) real ( rk ), allocatable :: Xth (:), Xth_e (:), Xc_eT (:,:), Xksi (:), Wksi (:) integer , allocatable :: elem_th (:,:), elem_c (:,:), elem_ce (:) type ( nurbs_curve ) :: th , th_e real ( rk ), allocatable :: dTtth_dXksi (:), Ttth (:), dTgc_dXt (:), dXg_dXt (:) real ( rk ) :: Xt , dXt_dXksi real ( rk ), allocatable :: dXg_dXksi (:) !! Jacobian matrix real ( rk ) :: det_dXg_dXksi !! Determinant of the Jacobian matrix call gauss_leg ([ 0.0_rk , 1.0_rk ], this % degree , Xksi , Wksi ) Xth = unique ( this % knot ) call th % set ([ 0.0_rk , Xth , 1.0_rk ], Xth ) elem_th = th % cmp_elem () elem_c = this % cmp_elem () Xth_e = Xth ( elem_th ( ie ,:)) call th_e % set ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xth_e ) elem_ce = elem_c ( ie ,:) Xc_eT = transpose ( this % Xc ( elem_ce ,:)) call th_e % derivative ( Xksi ( ig ), dTtth_dXksi , Ttth ) Xt = dot_product ( Xth_e , Ttth ) dXt_dXksi = dot_product ( Xth_e , dTtth_dXksi ) call this % derivative ( Xt , dTgc_dXt , Tgc , elem_ce ) dXg_dXt = matmul ( Xc_eT , dTgc_dXt ) dTgc_dXg = dyad ( dTgc_dXt , dXg_dXt ) / norm2 ( dXg_dXt ) dXg_dXksi = dXg_dXt * dXt_dXksi det_dXg_dXksi = norm2 ( dXg_dXksi ) dL = det_dXg_dXksi * Wksi ( ig ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_length ( this , length ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( out ) :: length real ( rk ), allocatable :: Tgc (:), dTgc_dXg (:,:) integer :: ie , ig real ( rk ) :: dL , dL_ig length = 0.0_rk do ie = 1 , size ( this % cmp_elem (), 1 ) dL = 0.0_rk do ig = 1 , size ( this % cmp_elem (), 2 ) call this % ansatz ( ie , ig , Tgc , dTgc_dXg , dL_ig ) dL = dL + dL_ig end do length = length + dL end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Tgc_1d ( Xti , knot , nc , degree , Wc ) result ( Tgc ) real ( rk ), intent ( in ) :: Xti real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree , nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Tgc ( nc ) real ( rk ) :: tmp integer :: i Tgc = basis_bspline ( Xti , knot , nc , degree ) tmp = dot_product ( Tgc , Wc ) do concurrent ( i = 1 : nc ) Tgc ( i ) = ( Tgc ( i ) * Wc ( i )) / tmp end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_1d ( Xt , knot , degree , nc , ng , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng , size ( Xc , 2 )), source = 0.0_rk ) do concurrent ( i = 1 : ng ) Xg ( i ,:) = matmul ( cmp_Tgc_1d ( Xt ( i ), knot , nc , degree , Wc ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_1d_1point ( Xt , knot , degree , nc , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:) real ( rk ), allocatable :: Tgc (:) allocate ( Xg ( size ( Xc ))) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_1d ( Xt , knot , degree , nc , ng , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng , size ( Xc , 2 ))) do concurrent ( i = 1 : ng ) Xg ( i ,:) = matmul ( basis_bspline ( Xt ( i ), knot , nc , degree ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_1d_1point ( Xt , knot , degree , nc , Xc ) result ( Xg ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:) allocate ( Xg ( size ( Xc ))) Xg = matmul ( basis_bspline ( Xt , knot , nc , degree ), Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: d2Bi (:), dBi (:), Tgci (:), dTgci (:), Bi (:) integer :: i allocate ( d2Tgc ( ng , nc ), dTgc ( ng , nc ), Tgc ( ng , nc ), d2Bi ( nc ), dTgci ( nc ), dBi ( nc ), Tgci ( nc ), Bi ( nc )) do concurrent ( i = 1 : size ( Xt )) call basis_bspline_2der ( Xt ( i ), knot , nc , degree , d2Bi , dBi , Bi ) Tgci = Bi * ( Wc / ( dot_product ( Bi , Wc ))) Tgc ( i ,:) = Tgci dTgci = ( dBi * Wc - Tgci * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:) = dTgci d2Tgc ( i ,:) = ( d2Bi * Wc - 2.0_rk * dTgci * dot_product ( dBi , Wc ) - Tgci * dot_product ( d2Bi , Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: d2Bi (:), dBi (:), Bi (:) allocate ( d2Tgc ( nc ), dTgc ( nc ), Tgc ( nc ), d2Bi ( nc ), dBi ( nc ), Bi ( nc )) call basis_bspline_2der ( Xt , knot , nc , degree , d2Bi , dBi , Bi ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc = ( dBi * Wc - Tgc * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) d2Tgc = ( d2Bi * Wc - 2.0_rk * dTgc * dot_product ( dBi , Wc ) - Tgc * dot_product ( d2Bi , Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_1d_vector ( Xt , knot , degree , nc , ng , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i allocate ( d2Tgc ( ng , nc ), dTgc ( ng , nc ), Tgc ( ng , nc )) do concurrent ( i = 1 : size ( Xt )) call basis_bspline_2der ( Xt ( i ), knot , nc , degree , d2Tgc ( i ,:) , dTgc ( i ,:), Tgc ( i ,:)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_1d_scalar ( Xt , knot , degree , nc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) allocate ( d2Tgc ( nc ), dTgc ( nc ), Tgc ( nc )) call basis_bspline_2der ( Xt , knot , nc , degree , d2Tgc , dTgc , Tgc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dBi ( nc ), Bi ( nc ) integer :: i allocate ( dTgc ( ng , nc ), Tgc ( ng , nc )) do concurrent ( i = 1 : size ( Xt )) call basis_bspline_der ( Xt ( i ), knot , nc , degree , dBi , Bi ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc ( i ,:) = ( dBi * Wc - Tgc ( i ,:) * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc , dTgc , Tgc , elem ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dBi ( nc ), Bi ( nc ) call basis_bspline_der ( Xt , knot , nc , degree , dBi , Bi ) if (. not . present ( elem )) then allocate ( dTgc ( nc ), Tgc ( nc )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc = ( dBi * Wc - Tgc * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) else allocate ( dTgc ( size ( elem )), Tgc ( size ( elem ))) Tgc = Bi ( elem ) * ( Wc ( elem ) / ( dot_product ( Bi ( elem ), Wc ( elem )))) dTgc = ( dBi ( elem ) * Wc ( elem ) - Tgc * dot_product ( dBi ( elem ), Wc ( elem )) ) / dot_product ( Bi ( elem ), Wc ( elem )) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_1d_vector ( Xt , knot , degree , nc , ng , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i allocate ( dTgc ( ng , nc ), Tgc ( ng , nc )) do concurrent ( i = 1 : size ( Xt )) call basis_bspline_der ( Xt ( i ), knot , nc , degree , dTgc ( i ,:), Tgc ( i ,:)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_1d_scalar ( Xt , knot , degree , nc , dTgc , Tgc , elem ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: dB (:), B (:) if (. not . present ( elem )) then allocate ( dTgc ( nc ), Tgc ( nc )) call basis_bspline_der ( Xt , knot , nc , degree , dTgc , Tgc ) else allocate ( dB ( size ( elem )), B ( size ( elem ))) call basis_bspline_der ( Xt , knot , nc , degree , dB , B ) Tgc = B ( elem ) dTgc = dB ( elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i allocate ( Tgc ( ng , nc ), Tgci ( nc )) do concurrent ( i = 1 : size ( Xt , 1 )) Tgci = basis_bspline ( Xt ( i ), knot , nc , degree ) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc ) result ( Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_1d_vector ( Xt , knot , degree , nc , ng ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), allocatable :: Tgc (:,:) integer :: i allocate ( Tgc ( ng , nc )) do concurrent ( i = 1 : size ( Xt , 1 )) Tgc ( i ,:) = basis_bspline ( Xt ( i ), knot , nc , degree ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_1d_scalar ( Xt , knot , degree , nc ) result ( Tgc ) real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function nearest_point_help_1d ( ng , Xg , point_Xg ) result ( distances ) integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Xg (:,:) real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), allocatable :: distances (:) integer :: i allocate ( distances ( ng )) do concurrent ( i = 1 : ng ) distances ( i ) = norm2 ( Xg ( i ,:) - point_Xg ) end do end function !=============================================================================== end module forcad_nurbs_curve","tags":"","url":"sourcefile/forcad_nurbs_curve.f90.html"},{"title":"fdm_volume.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_volume.f90~~EfferentGraph sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_test_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: volume !! Declare a NURBS volume object real ( rk ), allocatable :: Wc (:) !! Weights for the control points real ( rk ) :: Xt ( 3 ), tol , Xtm ( 3 ), Xtp ( 3 ) real ( rk ), allocatable :: Tgc (:), dTgc (:,:), Tgcp (:), dTgcp (:,:), Tgcm (:), dTgcm (:,:), d2Tgc (:,:), d2Tgcp (:,:), d2Tgcm (:,:) real ( rk ), allocatable :: CFD (:,:), BFD (:,:), FFD (:,:), CFD2 (:,:), BFD2 (:,:), FFD2 (:,:) integer :: i !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- allocate ( Wc ( 64 )) Wc = 1.0_rk Wc ( 10 ) = 0.5_rk call volume % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 4 , 4 ], Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 20 call volume % create ( 20 , 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 64 , 3 ), BFD ( 64 , 3 ), FFD ( 64 , 3 )) allocate ( CFD2 ( 3 * 64 , 3 ), BFD2 ( 3 * 64 , 3 ), FFD2 ( 3 * 64 , 3 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk Xt ( 3 ) = 0.7_rk call volume % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 3 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call volume % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call volume % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 3 * 64 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 3 * 64 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 3 * 64 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS volume object call volume % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) deallocate ( Wc ) !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- call volume % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 4 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 20 call volume % create ( 20 , 20 , 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- allocate ( CFD ( 64 , 3 ), BFD ( 64 , 3 ), FFD ( 64 , 3 )) allocate ( CFD2 ( 3 * 64 , 3 ), BFD2 ( 3 * 64 , 3 ), FFD2 ( 3 * 64 , 3 )) tol = 1.0e-6_rk Xt ( 1 ) = 0.5_rk Xt ( 2 ) = 0.3_rk Xt ( 3 ) = 0.7_rk call volume % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) do i = 1 , 3 Xtm = Xt Xtm ( i ) = Xt ( i ) - tol call volume % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt Xtp ( i ) = Xt ( i ) + tol call volume % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) BFD (:, i ) = ( Tgc - Tgcm ) / tol CFD (:, i ) = ( Tgcp - Tgcm ) / ( 2.0_rk * tol ) FFD (:, i ) = ( Tgcp - Tgc ) / tol BFD2 (:, i ) = reshape (( dTgc - dTgcm ) / tol , shape = [ 3 * 64 ]) CFD2 (:, i ) = reshape (( dTgcp - dTgcm ) / ( 2.0_rk * tol ), shape = [ 3 * 64 ]) FFD2 (:, i ) = reshape (( dTgcp - dTgc ) / tol , shape = [ 3 * 64 ]) end do print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 ( BFD - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 ( CFD - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 ( FFD - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 ( BFD2 - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 ( CFD2 - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 ( FFD2 - d2Tgc ) !> Finalize the NURBS volume object call volume % finalize () deallocate ( CFD , BFD , FFD , CFD2 , BFD2 , FFD2 ) end program","tags":"","url":"sourcefile/fdm_volume.f90.html"},{"title":"nearest_point_2d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d.f90~~EfferentGraph sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the surface real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 4 , 3 ) !! Control points real ( rk ) :: Wc ( 4 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a surface with 4 control points Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 0.7_rk , 1.0_rk ] call shape % set ( knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the surface (Approximation) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the surface (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) call shape % nearest_point2 ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","url":"sourcefile/nearest_point_2d.f90.html"},{"title":"demo_curve.f90 – ForCAD","text":"This file depends on sourcefile~~demo_curve.f90~~EfferentGraph sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve. !> It sets up control points and weights, generates the curve, and exports the control points !> and the curve to VTK files at various stages. program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","url":"sourcefile/demo_curve.f90.html"},{"title":"test_nurbs_curve.f90 – ForCAD","text":"This file depends on sourcefile~~test_nurbs_curve.f90~~EfferentGraph sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_nurbs_curve use forcad , only : rk , nurbs_curve use forunittest , only : unit_test implicit none type ( nurbs_curve ) :: nurbs , bsp real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xg (:,:), Xgb (:,:) real ( rk ) :: knot ( 6 ) integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Tgc (:,:), dTgc (:,:), Tgcb (:,:), dTgcb (:,:), d2Tgc (:,:), d2Tgcb (:,:) real ( rk ), allocatable :: Tgc1 (:), dTgc1 (:), Tgc1b (:), dTgc1b (:), d2Tgc1 (:), d2Tgc1b (:) integer :: i , id real ( rk ), allocatable :: nearest_Xg (:) real ( rk ) :: nearest_Xt , length , lengthb type ( unit_test ) :: ut allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 0.9_rk , 0.8_rk ] knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] call nurbs % set ( knot , Xc , Wc ) call bsp % set ( knot , Xc ) call nurbs % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc (), Wc = nurbs % get_Wc ()) call bsp % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc ()) call nurbs % create ( res = 23 ) call bsp % create ( res = 23 ) call nurbs % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_curve_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_curve_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_curve_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_curve_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_curve.iges' ) call bsp % export_iges ( 'iges/test_bsp_curve.iges' ) call nurbs % cmp_length ( length ) call bsp % cmp_length ( lengthb ) call ut % check ( res = length , expected = 2.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_curve: 01\" ) call ut % check ( res = lengthb , expected = 2.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_curve: 02\" ) call nurbs % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_curve: 03\" ) call ut % check ( res = nearest_Xt , expected = 0.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_curve: 04\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_curve: 05\" ) call bsp % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_curve: 06\" ) call ut % check ( res = nearest_Xt , expected = 0.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_curve: 07\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_curve: 08\" ) call nurbs % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_curve: 09\" ) call ut % check ( res = nearest_Xt , expected = 0.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_curve: 10\" ) call bsp % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_curve: 11\" ) call ut % check ( res = nearest_Xt , expected = 0.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_curve: 12\" ) Xg = nurbs % get_Xg () Xgb = bsp % get_Xg () call nurbs % set ([ 0.0_rk , 1.0_rk ], 2 , [ - 1 , - 1 ], Xc , Wc ) call bsp % set ([ 0.0_rk , 1.0_rk ], 2 , [ - 1 , - 1 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 13\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 14\" ) call nurbs % set ( Xc , Wc ) call bsp % set ( Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 15\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 16\" ) call nurbs % create ( Xt = nurbs % get_Xt ()) call bsp % create ( Xt = bsp % get_Xt ()) call nurbs % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_curve_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_curve_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_curve_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_curve_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_curve.iges' ) call bsp % export_iges ( 'iges/test_bsp_curve.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 17\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 18\" ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 19\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 20\" ) call ut % check ( res = nurbs % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_curve: 21\" ) call ut % check ( res = bsp % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_curve: 22\" ) call ut % check ( res = nurbs % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_curve: 23\" ) call ut % check ( res = bsp % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_curve: 24\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 25\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 26\" ) call ut % check ( res = nurbs % get_Xg ( 1 ), expected = Xg ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_curve: 27\" ) call ut % check ( res = bsp % get_Xg ( 1 ), expected = Xgb ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_curve: 28\" ) call ut % check ( res = nurbs % get_Xg ( 1 , 1 ), expected = Xg ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_curve: 29\" ) call ut % check ( res = bsp % get_Xg ( 1 , 1 ), expected = Xgb ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_curve: 30\" ) call ut % check ( res = nurbs % get_Wc (), expected = Wc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 31\" ) call ut % check ( res = nurbs % get_Wc ( 1 ), expected = Wc ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_curve: 32\" ) call ut % check ( res = nurbs % get_knot (), expected = knot , tol = 1e-5_rk , msg = \"test_nurbs_curve: 33\" ) call ut % check ( res = bsp % get_knot (), expected = knot , tol = 1e-5_rk , msg = \"test_nurbs_curve: 34\" ) call ut % check ( res = nurbs % get_knot ( 1 ), expected = knot ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_curve: 35\" ) call ut % check ( res = bsp % get_knot ( 1 ), expected = knot ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_curve: 36\" ) call ut % check ( res = nurbs % get_ng (), expected = size ( Xg , 1 ), msg = \"test_nurbs_curve: 37\" ) call ut % check ( res = bsp % get_ng (), expected = size ( Xgb , 1 ), msg = \"test_nurbs_curve: 38\" ) call ut % check ( res = nurbs % get_degree (), expected = 2 , msg = \"test_nurbs_curve: 39\" ) call ut % check ( res = bsp % get_degree (), expected = 2 , msg = \"test_nurbs_curve: 40\" ) call ut % check ( res = nurbs % get_multiplicity (), expected = [ 3 , 3 ], msg = \"test_nurbs_curve: 41\" ) call ut % check ( res = bsp % get_multiplicity (), expected = [ 3 , 3 ], msg = \"test_nurbs_curve: 42\" ) call ut % check ( res = nurbs % get_continuity (), expected = [ - 1 , - 1 ], msg = \"test_nurbs_curve: 43\" ) call ut % check ( res = bsp % get_continuity (), expected = [ - 1 , - 1 ], msg = \"test_nurbs_curve: 44\" ) call ut % check ( res = nurbs % get_nc (), expected = size ( Xc , 1 ), msg = \"test_nurbs_curve: 45\" ) call ut % check ( res = bsp % get_nc (), expected = size ( Xc , 1 ), msg = \"test_nurbs_curve: 46\" ) call nurbs % cmp_nc () call bsp % cmp_nc () call ut % check ( res = nurbs % get_nc (), expected = size ( Xc , 1 ), msg = \"test_nurbs_curve: 47\" ) call ut % check ( res = bsp % get_nc (), expected = size ( Xc , 1 ), msg = \"test_nurbs_curve: 48\" ) elemConn = nurbs % cmp_elem_Xc_vis ( 2 ) call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_curve: 49\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xc_vis () call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_curve: 50\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis ( 2 ) call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_curve: 51\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis () call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_curve: 52\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis ( 2 ) call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_curve: 53\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis () call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_curve: 54\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis ( 2 ) call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_curve: 55\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis () call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_curve: 56\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem () call nurbs % set_elem ( elemConn ) call ut % check ( res = nurbs % get_elem (), expected = elemConn , msg = \"test_nurbs_curve: 57\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem () call bsp % set_elem ( elemConn ) call ut % check ( res = bsp % get_elem (), expected = elemConn , msg = \"test_nurbs_curve: 58\" ) deallocate ( elemConn ) call nurbs % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call bsp % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call nurbs % modify_Wc ( Wc ( 1 ), 1 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_curve_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_curve_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_curve_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_curve_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_curve.iges' ) call bsp % export_iges ( 'iges/test_bsp_curve.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 59\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 60\" ) call nurbs % basis ( res = 23 , Tgc = Tgc ) call bsp % basis ( res = 23 , Tgc = Tgc ) call nurbs % basis ( Xt = 0.0_rk , Tgc = Tgc1 ) call bsp % basis ( Xt = 0.0_rk , Tgc = Tgc1b ) call nurbs % basis ( Xt = [( real ( i - 1 , rk ) / real ( 23 - 1 , rk ), i = 1 , 23 )], Tgc = Tgc ) call bsp % basis ( Xt = [( real ( i - 1 , rk ) / real ( 23 - 1 , rk ), i = 1 , 23 )], Tgc = Tgc ) call nurbs % derivative ( res = 23 , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( res = 23 , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative ( Xt = [( real ( i - 1 , rk ) / real ( 23 - 1 , rk ), i = 1 , 23 )], dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( Xt = [( real ( i - 1 , rk ) / real ( 23 - 1 , rk ), i = 1 , 23 )], dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative ( Xt = 0.0_rk , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative ( Xt = 0.0_rk , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative ( Xt = 0.0_rk , dTgc = dTgc1 , Tgc = Tgc1 , elem = [ 1 , 2 , 3 ]) call bsp % derivative ( Xt = 0.0_rk , dTgc = dTgc1b , Tgc = Tgc1b , elem = [ 1 , 2 , 3 ]) call nurbs % derivative2 ( res = 23 , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( res = 23 , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 ( Xt = [( real ( i - 1 , rk ) / real ( 23 - 1 , rk ), i = 1 , 23 )], d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( Xt = [( real ( i - 1 , rk ) / real ( 23 - 1 , rk ), i = 1 , 23 )], d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = 0.0_rk , d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 61\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 62\" ) call nurbs % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 63\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 64\" ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 65\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 66\" ) call nurbs % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 67\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 68\" ) call nurbs % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 69\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 70\" ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 71\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 72\" ) call nurbs % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 73\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_curve: 74\" ) call nurbs % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 75\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 76\" ) call nurbs % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call bsp % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_curve_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_curve_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_curve_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_curve_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_curve.iges' ) call bsp % export_iges ( 'iges/test_bsp_curve.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 77\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 78\" ) call nurbs % elevate_degree ( 2 ) call bsp % elevate_degree ( 2 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_curve_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_curve_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_curve_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_curve_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_curve.iges' ) call bsp % export_iges ( 'iges/test_bsp_curve.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 79\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 80\" ) call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_curve_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_curve_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_curve_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_curve_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_curve_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_curve_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_curve.iges' ) call bsp % export_iges ( 'iges/test_bsp_curve.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_curve: 81\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_curve: 82\" ) call nurbs % set_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) call nurbs % set_half_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) call nurbs % set_C ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) call nurbs % finalize () call bsp % finalize () deallocate ( Xc , Wc , Xg , Xgb ) call nurbs % set ( knot = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xc = [ 0.0_rk , 2.0_rk ], Wc = [ 1.0_rk , 0.9_rk ]) call bsp % set ( knot = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xc = [ 0.0_rk , 2.0_rk ]) call nurbs % finalize () call bsp % finalize () end program","tags":"","url":"sourcefile/test_nurbs_curve.f90.html"},{"title":"shape_C_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_3d.f90~~EfferentGraph sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk , length = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_3d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 , 10 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_3d_Xc.vtk' , 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_c_3d.f90.html"},{"title":"example_ppm1.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm1.f90~~EfferentGraph sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm1 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap , wp use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , real ( 0.0_rk , kind = wp ), real ( 2.2_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.08_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.01_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.22_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm1' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","url":"sourcefile/example_ppm1.f90.html"},{"title":"forcad_nurbs_surface.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_surface.f90~~EfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_surface.f90~~AfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. module forcad_nurbs_surface use forcad_kinds , only : rk use forcad_utils , only : basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , tetragon_Xc , & elemConn_Cn , unique , rotation , det , inv , gauss_leg , export_vtk_legacy , basis_bspline_2der implicit none private public nurbs_surface !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_surface real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc(1)*nc(2)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: Xt (:,:) !! Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) integer , private :: degree ( 2 ) !! Degree (order) of the surface integer , private :: nc ( 2 ) !! Number of control points in each direction integer , private :: ng ( 2 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vectors, control points and weights for the NURBS surface object procedure :: set2 !!> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier surface using control points and weights procedure :: set4 !!> Set NURBS surface using degree, number of control points, control points and weights generic :: set => set1 , set2 , set3 , set4 !!> Set NURBS surface procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure , private :: get_nc_dir !!> Get number of control points in a specific direction procedure , private :: get_nc_all !!> Get number of control points in all directions generic :: get_nc => get_nc_all , get_nc_dir !!> Get number of control points procedure :: cmp_degree !!> Compute degree of the NURBS surface procedure , private :: get_degree_all !!> Get degree of the NURBS surface in both directions procedure , private :: get_degree_dir !!> Get degree of the NURBS surface in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS surface procedure :: finalize !!> Finalize the NURBS surface object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: export_Xth !!> Export parameter space to VTK file procedure :: export_iges !!> Export the NURBS surface to IGES format procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knot vector procedure :: get_continuity !!> Compute and return the continuity of the NURBS surface procedure :: cmp_nc !!> Compute number of required control points procedure , private :: basis_vector !!> Compute the basis functions of the NURBS surface procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS surface generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS surface procedure , private :: derivative_vector !!> Compute the derivative of the NURBS surface procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS surface generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS surface procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS surface procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS surface generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS surface procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate degree procedure :: is_rational !!> Check if the NURBS surface is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS surface (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS surface (Minimization - Newton's method) procedure :: ansatz !!> Compute the shape functions, derivative of shape functions and dA procedure :: cmp_area !!> Compute the area of the NURBS surface ! Shapes procedure :: set_tetragon !!> Set a tetragon procedure :: set_ring !!> Set a ring procedure :: set_half_ring !!> Set a half ring procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg module procedure compute_Xg_nurbs_2d module procedure compute_Xg_bspline_2d module procedure compute_Xg_nurbs_2d_1point module procedure compute_Xg_bspline_2d_1point end interface interface compute_Tgc module procedure compute_Tgc_nurbs_2d_vector module procedure compute_Tgc_bspline_2d_vector module procedure compute_Tgc_nurbs_2d_scalar module procedure compute_Tgc_bspline_2d_scalar end interface interface compute_dTgc module procedure compute_dTgc_nurbs_2d_vector module procedure compute_dTgc_bspline_2d_vector module procedure compute_dTgc_nurbs_2d_scalar module procedure compute_dTgc_bspline_2d_scalar end interface interface compute_d2Tgc module procedure compute_d2Tgc_nurbs_2d_vector module procedure compute_d2Tgc_bspline_2d_vector module procedure compute_d2Tgc_nurbs_2d_scalar module procedure compute_d2Tgc_bspline_2d_scalar end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vectors, control points and weights for the NURBS surface object. pure subroutine set1 ( this , knot1 , knot2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot1 = knot1 this % knot2 = knot2 call this % cmp_degree () call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , degree , continuity1 , continuity2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % degree ( 1 ) = degree ( 1 ) this % degree ( 2 ) = degree ( 2 ) call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier surface using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) allocate ( this % knot1 ( 2 * this % nc ( 1 ))) this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) allocate ( this % knot2 ( 2 * this % nc ( 2 ))) this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set4 ( this , degree , nc , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) integer :: m ( 2 ), i if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc this % degree = degree ! Size of knot vectors m = nc + degree + 1 if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) allocate ( this % knot1 ( m ( 1 ))) this % knot1 ( 1 : degree ( 1 ) + 1 ) = 0.0_rk this % knot1 ( degree ( 1 ) + 2 : m ( 1 ) - degree ( 1 ) - 1 ) = [( real ( i , rk ) / ( m ( 1 ) - 2 * degree ( 1 ) - 1 ), i = 1 , m ( 1 ) - 2 * degree ( 1 ) - 2 )] this % knot1 ( m ( 1 ) - degree ( 1 ): m ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) allocate ( this % knot2 ( m ( 2 ))) this % knot2 ( 1 : degree ( 2 ) + 1 ) = 0.0_rk this % knot2 ( degree ( 2 ) + 2 : m ( 2 ) - degree ( 2 ) - 1 ) = [( real ( i , rk ) / ( m ( 2 ) - 2 * degree ( 2 ) - 1 ), i = 1 , m ( 2 ) - 2 * degree ( 2 ) - 2 )] this % knot2 ( m ( 2 ) - degree ( 2 ): m ( 2 )) = 1.0_rk if ( present ( Wc )) then if ( size ( Wc ) /= nc ( 1 ) * nc ( 2 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , Xt1 , Xt2 , Xt ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), contiguous , intent ( in ), optional :: Xt (:,:) integer :: i ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 )) then error stop 'Knot vector(s) is/are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if if ( present ( Xt )) then this % Xt = Xt else ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt ) end if if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), contiguous , intent ( in ) :: Xt (:) real ( rk ), allocatable :: Xg (:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 )) then error stop 'Knot vector(s) is/are not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid direction for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid direction for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS surface is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS surface is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_surface ), intent ( in ) :: this integer :: ng ( 2 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this , dir ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: dir integer , allocatable :: m1 (:), m2 (:) if ( present ( dir )) then if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 else error stop 'Invalid direction for degree.' end if else m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer :: degree ( 2 ) degree = this % degree end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree if ( dir == 1 ) then degree = this % degree ( 1 ) else if ( dir == 2 ) then degree = this % degree ( 2 ) else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_surface ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename , encoding ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if call export_vtk_legacy ( filename , this % Xc , elemConn , 9 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename , encoding ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if call export_vtk_legacy ( filename , this % Xg , elemConn , 9 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xth ( this , filename , encoding ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: encoding integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Xth (:,:), Xth1 (:), Xth2 (:) type ( nurbs_surface ) :: th Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) call ndgrid ( Xth1 , Xth2 , Xth ) call th % set (& [ this % knot1 ( 1 ), Xth1 , this % knot1 ( size ( this % knot1 ))],& [ this % knot2 ( 1 ), Xth2 , this % knot2 ( size ( this % knot2 ))], Xth ) elemConn = th % cmp_elem () call export_vtk_legacy ( filename , Xth , elemConn , 9 , encoding ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_iges ( this , filename ) use forIGES , only : Gsection_t , Dentry_t , entity128_t , DElist_t , PElist_t ,& makeSsection , makeGsection , makeDPsections , writeIGESfile , wp class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename type ( Gsection_t ) :: G type ( Dentry_t ) :: D type ( entity128_t ) :: surf128 type ( DElist_t ) :: Dlist type ( PElist_t ) :: Plist character ( 80 ), allocatable :: Ssection (:), Gsection (:), Dsection (:), Psection (:), Ssec_out (:) real ( rk ), allocatable :: W (:,:), X (:,:), Y (:,:), Z (:,:), S (:), T (:) integer :: i , j , idx integer :: K1 , K2 , M1 , M2 , N1 , N2 , prop3 ! Parameters consistent with the IGES definition K1 = this % degree ( 1 ) K2 = this % degree ( 2 ) M1 = this % degree ( 1 ) M2 = this % degree ( 2 ) ! Compute required N1 and N2 based on IGES standard N1 = 1 + K1 - M1 N2 = 1 + K2 - M2 ! Allocate exactly as expected by your IGES library allocate ( S ( - M1 : N1 + K1 ), T ( - M2 : N2 + K2 )) ! Copy knots explicitly, matching IGES indexing exactly do i = - M1 , N1 + K1 S ( i ) = this % knot1 ( i + M1 + 1 ) end do do i = - M2 , N2 + K2 T ( i ) = this % knot2 ( i + M2 + 1 ) end do ! Allocate and fill control point arrays allocate ( X ( 0 : K1 , 0 : K2 ), Y ( 0 : K1 , 0 : K2 ), Z ( 0 : K1 , 0 : K2 ), W ( 0 : K1 , 0 : K2 )) ! Correctly map control points and weights if ( this % is_rational ()) then do j = 0 , K2 do i = 0 , K1 idx = j * this % nc ( 1 ) + i + 1 X ( i , j ) = this % Xc ( idx , 1 ) Y ( i , j ) = this % Xc ( idx , 2 ) Z ( i , j ) = this % Xc ( idx , 3 ) W ( i , j ) = this % Wc ( idx ) end do end do prop3 = 1 ! Rational surface else do j = 0 , K2 do i = 0 , K1 idx = j * this % nc ( 1 ) + i + 1 X ( i , j ) = this % Xc ( idx , 1 ) Y ( i , j ) = this % Xc ( idx , 2 ) Z ( i , j ) = this % Xc ( idx , 3 ) W ( i , j ) = 1.0_rk end do end do prop3 = 0 ! b-Spline surface end if ! Initialize IGES entity 128 (Rational B-spline Surface) call surf128 % init (& DEP = 1 ,& form = 0 ,& K1 = K1 ,& K2 = K2 ,& M1 = M1 ,& M2 = M2 ,& PROP1 = 0 ,& PROP2 = 0 ,& PROP3 = prop3 ,& PROP4 = 0 ,& PROP5 = 0 ,& S = real ( S , kind = wp ),& T = real ( T , kind = wp ),& W = real ( W , kind = wp ),& X = real ( X , kind = wp ),& Y = real ( Y , kind = wp ),& Z = real ( Z , kind = wp ),& U = real ([ minval ( this % knot1 ), maxval ( this % knot1 )], kind = wp ),& V = real ([ minval ( this % knot2 ), maxval ( this % knot2 )], kind = wp )) ! Directory entry call D % init ( entity_type = 128 , param_data = 1 , transformation_matrix = 0 , form_number = 0 ) ! Create entity and directory lists call Dlist % init () call Plist % init () call Dlist % append ( D ) call Plist % append ( surf128 ) ! Global section initialization call G % init ( filename = filename ) ! S-section description allocate ( Ssection ( 1 )) Ssection ( 1 ) = 'ForCAD' ! Create IGES sections call makeSsection ( Ssection , Ssec_out ) call makeGsection ( G , Gsection ) call makeDPsections ( Dlist , Plist , Dsection , Psection ) ! Write IGES file call writeIGESfile ( filename , Ssec_out , Gsection , Dsection , Psection ) ! Cleanup call Dlist % delete () call Plist % delete () end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc ()) end if else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot1 ) . and . allocated ( this % knot2 )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( nc = this % nc , Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else error stop 'The NURBS surface is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this , dir ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: dir if ( present ( dir )) then if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if else error stop 'Invalid direction.' end if else ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_all ( this ) result ( nc ) class ( nurbs_surface ), intent ( in ) :: this integer :: nc ( 2 ) nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc_dir ( this , dir ) result ( nc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res1 , res2 , Xt1 , Xt2 , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc , elem ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc , dTgc , Tgc , elem ) else ! B-Spline call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , dTgc , Tgc , elem ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res1 , res2 , Xt1 , Xt2 , d2Tgc , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res1 , res2 , Xt1 , Xt2 , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( this % knot1 ( 1 ) + ( this % knot1 ( size ( this % knot1 )) - this % knot1 ( 1 )) * real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( this % knot2 ( 1 ) + ( this % knot2 ( size ( this % knot2 )) - this % knot2 ( 1 )) * real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( d + 1 )]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * ( n_new + 1 ), d + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * ( n_new + 1 ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * ( n_new + 1 ))) do j = 1 , this % nc ( 2 ) * ( n_new + 1 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * d ]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc_new = reshape ( Xc_new ,[( this % nc ( 2 )) * ( n_new + 1 ), d ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new ) end do end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * ( d + 1 )]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc3 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 1 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , d + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( n_new + 1 ), d + 1 ]) allocate ( Xc_new ( 1 :( n_new + 1 ) * this % nc ( 1 ), 1 : d )) allocate ( Wc_new ( 1 :( n_new + 1 ) * this % nc ( 1 ))) do j = 1 , ( n_new + 1 ) * this % nc ( 1 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if d = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * d ]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc3 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 1 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , d ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( n_new + 1 ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new ) end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) integer :: d , j , nc_new real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( d + 1 )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , nc_new , knot_new , Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * nc_new , d + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * nc_new , 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * nc_new )) do j = 1 , this % nc ( 2 ) * nc_new Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * ( d )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , nc_new , knot_new , Xc_new ) Xc_new = reshape ( Xc_new ,[ this % nc ( 2 ) * nc_new , d ], order = [ 1 , 2 ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new ) deallocate ( Xc , Xc_new ) end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * ( d + 1 )]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , nc_new , knot_new , Xcw_new ) Xc3 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , d + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * nc_new , d + 1 ]) allocate ( Xc_new ( 1 : nc_new * this % nc ( 1 ), 1 : d )) allocate ( Wc_new ( 1 : nc_new * this % nc ( 1 ))) do j = 1 , nc_new * this % nc ( 1 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline d = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * d ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , nc_new , knot_new , Xc_new ) Xc3 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , d ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * nc_new , d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new ) end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_surface ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , d , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( d + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * ( nc_new ), d + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * ( nc_new ), 1 : d )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * d ], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc_new = reshape ( Xc_new ,[( this % nc ( 2 )) * ( nc_new ), d ], order = [ 1 , 2 ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), d + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : d ) = this % Xc ( j , 1 : d ) * this % Wc ( j ) end do Xcw (:, d + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * ( d + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc3 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), d + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , d + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), d + 1 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 1 ), 1 : d )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 1 ))) do j = 1 , ( nc_new ) * this % nc ( 1 ) Xc_new ( j , 1 : d ) = Xcw_new ( j , 1 : d ) / Xcw_new ( j , d + 1 ) end do Wc_new (:) = Xcw_new (:, d + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 d = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), d ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * d ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc3 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), d ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , d ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), d ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new ) end if end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_tetragon ( this , L , nc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: L ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) call this % set ( nc = nc , Xc = tetragon_Xc ( L , nc ), Wc = Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ),& this % degree ( 1 ), this % degree ( 2 ),& unique ( this % knot1 ), unique ( this % knot2 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg ) class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len = 3000 ) :: pyvista_script pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=7,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels(\" // achar ( 10 ) // & \"        [point_coords],\" // achar ( 10 ) // & \"        [label],\" // achar ( 10 ) // & \"        font_size=14,\" // achar ( 10 ) // & \"        text_color='black',\" // achar ( 10 ) // & \"        show_points=False,\" // achar ( 10 ) // & \"        fill_shape=False,\" // achar ( 10 ) // & \"        shape=None,\" // achar ( 10 ) // & \"    )\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xg.SetVisibility(flag)\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcp_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='red',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 1 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcw_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='yellow',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 2 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xg_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='cyan',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 3 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Points)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 1 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Control geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 2 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xg (Geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 3 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'https://github.com/gha3mi/forcad',\" // achar ( 10 ) // & \"    position=(0.0, 0.0),\" // achar ( 10 ) // & \"    font_size=7,\" // achar ( 10 ) // & \"    color='blue',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" // achar ( 10 ) // & \"p.deep_clean()\" // achar ( 10 ) // & \"del p\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_ring ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i ! Define control points for ring allocate ( Xc ( 14 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 7 , 1 : 2 ) = Xc ( 1 : 7 , 1 : 2 ) * radius1 Xc ( 8 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 11 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 12 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 13 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 14 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 8 : 14 , 1 : 2 ) = Xc ( 8 : 14 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i ! Define control points for C-shape allocate ( Xc ( 10 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 8 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_ring ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i ! Define control points for half ring allocate ( Xc ( 10 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 8 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xt (:) integer , intent ( out ), optional :: id integer :: id_ real ( rk ), allocatable :: distances (:) allocate ( distances ( this % ng ( 1 ) * this % ng ( 2 ))) distances = nearest_point_help_2d ( this % ng , this % Xg , point_Xg ) id_ = minloc ( distances , dim = 1 ) if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt ( 2 ) real ( rk ), allocatable , intent ( out ), optional :: nearest_Xg (:) real ( rk ) :: obj , grad ( 2 ), hess ( 2 , 2 ), dk ( 2 ), alphak , tau , beta , lower_bounds ( 2 ), upper_bounds ( 2 ) real ( rk ), allocatable :: Xg (:), xk (:), xkn (:), Tgc (:), dTgc (:,:), d2Tgc (:,:) integer :: k , l logical :: convergenz type ( nurbs_surface ) :: copy_this k = 0 ! lower and upper bounds lower_bounds = [ minval ( this % knot1 ), minval ( this % knot2 )] upper_bounds = [ maxval ( this % knot1 ), maxval ( this % knot2 )] ! guess initial point copy_this = this call copy_this % create ( 10 , 10 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! Check if xk is within the knot vector range if ( xk ( 1 ) < minval ( this % knot1 )) then xk ( 1 ) = minval ( this % knot1 ) else if ( xk ( 1 ) > maxval ( this % knot1 )) then xk ( 1 ) = maxval ( this % knot1 ) end if if ( xk ( 2 ) < minval ( this % knot2 )) then xk ( 2 ) = minval ( this % knot2 ) else if ( xk ( 2 ) > maxval ( this % knot2 )) then xk ( 2 ) = maxval ( this % knot2 ) end if xkn = xk convergenz = . false . allocate ( Xg ( size ( this % Xc , 2 ))) ! allocate(dTgc(size(this%Xc,1), 2)) ! allocate(d2Tgc(size(this%Xc,1), 2)) do while (. not . convergenz . and . k < maxit ) ! objection, gradient and hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc is not needed obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! add a small number to avoid division by zero grad ( 1 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 1 ), this % Xc )) grad ( 2 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 2 ), this % Xc )) hess ( 1 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 2 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ), 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 1 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 2 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ), 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 ! debug print '(i3,1x,2e20.10,1x,e20.10)' , k , xk , norm2 ( grad ) if ( norm2 ( grad ) <= tol . or . ( k > 0 . and . norm2 ( xk - xkn ) <= tol )) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else dk = - matmul ( inv ( hess ), grad ) ! Backtracking-Armijo Line Search alphak = 1.0_rk tau = 0.5_rk ! 0 < tau  < 1 beta = 1.0e-4_rk ! 0 < beta < 1 l = 0 do while (. not . norm2 ( this % cmp_Xg ( xk + alphak * dk ) - point_Xg ) <= obj + alphak * beta * dot_product ( grad , dk ) . and . l < 50 ) alphak = tau * alphak l = l + 1 end do xkn = xk xk = xk + alphak * dk ! Check if xk is within the knot vector range xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ansatz ( this , ie , ig , Tgc , dTgc_dXg , dA ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: ie , ig real ( rk ), intent ( out ) :: dA real ( rk ), allocatable , intent ( out ) :: Tgc (:), dTgc_dXg (:,:) real ( rk ), allocatable :: Xth (:,:), Xth_e (:,:), Xth_eT (:,:), Xc_eT (:,:), Xth1 (:), Xth2 (:), Xksi (:,:), Wksi (:) integer , allocatable :: elem_th (:,:), elem_c (:,:), elem_ce (:) type ( nurbs_surface ) :: th , th_e real ( rk ), allocatable :: dTtth_dXksi (:,:), Ttth (:), dTgc_dXt (:,:), Xt (:), dXt_dXksi (:,:), dXg_dXt (:,:) real ( rk ), allocatable :: dXg_dXksi (:,:) !! Jacobian matrix real ( rk ) :: det_dXg_dXksi !! Determinant of the Jacobian matrix call gauss_leg ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], this % degree , Xksi , Wksi ) Xth1 = unique ( this % knot1 ) Xth2 = unique ( this % knot2 ) call ndgrid ( Xth1 , Xth2 , Xth ) call th % set ([ 0.0_rk , Xth1 , 1.0_rk ], [ 0.0_rk , Xth2 , 1.0_rk ], Xth ) elem_th = th % cmp_elem () elem_c = this % cmp_elem () Xth_e = Xth ( elem_th ( ie ,:),:) call th_e % set ([ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xth_e ) Xth_eT = transpose ( Xth_e ) elem_ce = elem_c ( ie ,:) Xc_eT = transpose ( this % Xc ( elem_ce ,:)) call th_e % derivative ( Xksi ( ig ,:), dTtth_dXksi , Ttth ) Xt = matmul ( Xth_eT , Ttth ) dXt_dXksi = matmul ( Xth_eT , dTtth_dXksi ) call this % derivative ( Xt , dTgc_dXt , Tgc , elem_ce ) dXg_dXt = matmul ( Xc_eT , dTgc_dXt ) dTgc_dXg = matmul ( dTgc_dXt , inv ( dXg_dXt )) dXg_dXksi = matmul ( dXg_dXt , dXt_dXksi ) det_dXg_dXksi = det ( dXg_dXksi ) dA = det_dXg_dXksi * Wksi ( ig ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_area ( this , area ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( out ) :: area real ( rk ), allocatable :: Tgc (:), dTgc_dXg (:,:) integer :: ie , ig real ( rk ) :: dA , dA_ig area = 0.0_rk do ie = 1 , size ( this % cmp_elem (), 1 ) dA = 0.0_rk do ig = 1 , size ( this % cmp_elem (), 2 ) call this % ansatz ( ie , ig , Tgc , dTgc_dXg , dA_ig ) dA = dA + dA_ig end do area = area + dA end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Tgc_2d ( Xti , knot1 , knot2 , nc , degree , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xti (:) real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) integer , intent ( in ) :: degree ( 2 ), nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ) :: Tgc ( nc ( 1 ) * nc ( 2 )) real ( rk ) :: tmp integer :: i Tgc = kron (& basis_bspline ( Xti ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xti ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) tmp = dot_product ( Tgc , Wc ) do concurrent ( i = 1 : nc ( 1 ) * nc ( 2 )) Tgc ( i ) = ( Tgc ( i ) * Wc ( i )) / tmp end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_2d ( Xt , knot1 , knot2 , degree , nc , ng , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ), size ( Xc , 2 ))) do concurrent ( i = 1 : ng ( 1 ) * ng ( 2 )) Xg ( i ,:) = matmul ( cmp_Tgc_2d ( Xt ( i ,:), knot1 , knot2 , nc , degree , Wc ), Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_nurbs_2d_1point ( Xt , knot1 , knot2 , degree , nc , Xc , Wc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:) real ( rk ), allocatable :: Tgc (:) allocate ( Xg ( size ( Xc , 2 ))) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_2d ( Xt , knot1 , knot2 , degree , nc , ng , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ), size ( Xc , 2 ))) do concurrent ( i = 1 : ng ( 1 ) * ng ( 2 )) Xg ( i ,:) = matmul ( kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))),& Xc ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Xg_bspline_2d_1point ( Xt , knot1 , knot2 , degree , nc , Xc ) result ( Xg ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:) allocate ( Xg ( size ( Xc , 2 ))) Xg = matmul ( kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))),& Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ), allocatable :: dBi (:,:), Bi (:) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 )), dBi ( nc ( 1 ) * nc ( 2 ), 2 )) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ), allocatable :: dBi (:,:), Bi (:) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( nc ( 1 ) * nc ( 2 ))) allocate ( dBi ( nc ( 1 ) * nc ( 2 ), 2 ), Bi ( nc ( 1 ) * nc ( 2 ))) Bi = kron ( B2 , B1 ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) else allocate ( dTgc ( size ( elem ), 2 ), Tgc ( size ( elem ))) allocate ( dBi ( size ( elem ), 2 ), Bi ( size ( elem ))) associate ( Biall => kron ( B2 , B1 )) Bi = Biall ( elem ) Tgc = Bi * ( Wc ( elem ) / ( dot_product ( Bi , Wc ( elem )))) end associate associate ( dB1all => kron ( B2 , dB1 ), dB2all => kron ( dB2 , B1 )) dBi (:, 1 ) = dB1all ( elem ) dBi (:, 2 ) = dB2all ( elem ) end associate dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc ( elem ) - Tgc * dot_product ( dBi (:, 1 ), Wc ( elem )) ) / dot_product ( Bi , Wc ( elem )) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc ( elem ) - Tgc * dot_product ( dBi (:, 2 ), Wc ( elem )) ) / dot_product ( Bi , Wc ( elem )) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) Tgc ( i ,:) = kron ( B2 , B1 ) dTgc ( i ,:, 1 ) = kron ( B2 , dB1 ) dTgc ( i ,:, 2 ) = kron ( dB2 , B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_dTgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc , dTgc , Tgc , elem ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ), optional :: elem (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: dTgc1 ( nc ( 1 )), dTgc2 ( nc ( 2 )) real ( rk ) :: Tgc1 ( nc ( 1 )), Tgc2 ( nc ( 2 )) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dTgc1 , Tgc1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dTgc2 , Tgc2 ) if (. not . present ( elem )) then allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 )) Tgc = kron ( Tgc2 , Tgc1 ) dTgc (:, 1 ) = kron ( Tgc2 , dTgc1 ) dTgc (:, 2 ) = kron ( dTgc2 , Tgc1 ) else allocate ( dTgc ( size ( elem ), 2 )) associate ( B => kron ( Tgc2 , Tgc1 )) Tgc = B ( elem ) end associate associate ( dB1 => kron ( Tgc2 , dTgc1 ), dB2 => kron ( dTgc2 , Tgc1 )) dTgc (:, 1 ) = dB1 ( elem ) dTgc (:, 2 ) = dB2 ( elem ) end associate end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ), allocatable :: Tgci (:), dTgci (:) real ( rk ), allocatable :: d2Bi (:,:), dBi (:,:), Bi (:) integer :: i allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ), 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Bi ( nc ( 1 ) * nc ( 2 )), dBi ( nc ( 1 ) * nc ( 2 ), 2 ), d2Bi ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgci ( nc ( 1 ) * nc ( 2 )), dTgci ( nc ( 1 ) * nc ( 2 ))) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 )), dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 )) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) * Wc - 2.0_rk * dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) * Wc & - dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) * Wc - dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) * Wc - 2.0_rk * dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ), Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) real ( rk ), allocatable :: d2Bi (:,:), dBi (:,:), Bi (:) allocate ( Bi ( nc ( 1 ) * nc ( 2 )), dBi ( nc ( 1 ) * nc ( 2 ), 2 ), d2Bi ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 )), dTgc ( nc ( 1 ) * nc ( 2 ), 2 ), d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) * Wc - 2.0_rk * dTgc (:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) * Wc - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) * Wc - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) * Wc - 2.0_rk * dTgc (:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ), Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) integer :: i allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ), 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) do concurrent ( i = 1 : size ( Xt , 1 )) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Tgc ( i ,:) = kron ( B2 , B1 ) dTgc ( i ,:, 1 ) = kron ( B2 , dB1 ) dTgc ( i ,:, 2 ) = kron ( dB2 , B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine compute_d2Tgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc , d2Tgc , dTgc , Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ) :: d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )) real ( rk ) :: dB1 ( nc ( 1 )), dB2 ( nc ( 2 )) real ( rk ) :: B1 ( nc ( 1 )), B2 ( nc ( 2 )) allocate ( d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Tgc = kron ( B2 , B1 ) dTgc (:, 1 ) = kron ( B2 , dB1 ) dTgc (:, 2 ) = kron ( dB2 , B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) allocate ( Tgci ( nc ( 1 ) * nc ( 2 ))) do concurrent ( i = 1 : size ( Xt , 1 )) Tgci = kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), allocatable :: Tgc (:,:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) do concurrent ( i = 1 : size ( Xt , 1 )) Tgc ( i ,:) = kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_Tgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc ) result ( Tgc ) real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function nearest_point_help_2d ( ng , Xg , point_Xg ) result ( distances ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Xg (:,:) real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), allocatable :: distances (:) integer :: i allocate ( distances ( ng ( 1 ) * ng ( 2 ))) do concurrent ( i = 1 : ng ( 1 ) * ng ( 2 )) distances ( i ) = norm2 ( Xg ( i ,:) - point_Xg ) end do end function !=============================================================================== end module forcad_nurbs_surface","tags":"","url":"sourcefile/forcad_nurbs_surface.f90.html"},{"title":"example_curve_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_curve_1.f90~~EfferentGraph sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth.vtk' ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !> Export the NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !> Export the refined NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_curve_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !> Export the transformed NURBS curve to an IGES file call nurbs % export_iges ( 'iges/nurbs_curve3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","url":"sourcefile/example_curve_1.f90.html"},{"title":"cmp_length.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_length.f90~~EfferentGraph sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_length use forcad implicit none type ( nurbs_curve ) :: shape real ( rk ) :: length real ( rk ) :: Xc ( 2 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] call shape % set (& knot = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_length ( length ) print * , length end program","tags":"","url":"sourcefile/cmp_length.f90.html"},{"title":"shape_C_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_2d.f90~~EfferentGraph sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_2d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_2d_Xc.vtk' , 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_c_2d.f90.html"},{"title":"example_ppm2.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm2.f90~~EfferentGraph sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm2 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap , wp use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.0_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , real ( 0.0_rk , kind = wp ), real ( 2.2_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.08_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.01_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 9 0.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , real ( 0.0_rk , kind = wp ), real ( 1.0_rk , kind = wp )) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( real ( z_values ( i ), kind = wp ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.22_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 0.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm2' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","url":"sourcefile/example_ppm2.f90.html"},{"title":"nearest_point_2d_bench.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d_bench.f90~~EfferentGraph sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d_bench use forcad , only : rk , nurbs_surface use fortime , only : timer implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the surface real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ), allocatable :: points (:,:) integer :: i , j type ( timer ) :: t !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 100 , 100 ) !----------------------------------------------------------------------------- ! Nearest point on the surface !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) do j = 1 , 40 allocate ( points ( j * 1000 , 3 )) print * , j * 1000 call random_number ( points ) call t % timer_start () do i = 1 , size ( points , 1 ) call shape % nearest_point ( points ( i ,:), nearest_Xg , nearest_Xt , id ) end do call t % timer_stop () deallocate ( points ) end do !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () deallocate ( nearest_Xg , nearest_Xt ) end program","tags":"","url":"sourcefile/nearest_point_2d_bench.f90.html"},{"title":"shape_hexahedron.f90 – ForCAD","text":"This file depends on sourcefile~~shape_hexahedron.f90~~EfferentGraph sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_hexahedron use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8]. !> The weights of the control points (Wc) are optional. call shape % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 6 , 8 ]) ! Additional modifications can be made to control points and weights, or the NURBS can be refined using knot insertion or degree elevation. ! call shape%insert_knots(...) ! call shape%elevate_degree(...) ! ... !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_hexahedron_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 8 , 16 , 32 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_hexahedron_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_hexahedron_Xc.vtk' , 'vtk/shape_hexahedron_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_hexahedron.f90.html"},{"title":"shape_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_circle.f90~~EfferentGraph sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS circle !----------------------------------------------------------------------------- !> Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_circle ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_circle_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating circle !----------------------------------------------------------------------------- !> Generate the NURBS circle with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_circle_Xc.vtk' , 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_circle.f90.html"},{"title":"test_nurbs_surface.f90 – ForCAD","text":"This file depends on sourcefile~~test_nurbs_surface.f90~~EfferentGraph sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_nurbs_surface use forcad , only : rk , nurbs_surface use forunittest , only : unit_test implicit none type ( nurbs_surface ) :: nurbs , bsp real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), area , areab real ( rk ), allocatable :: Xc (:,:), Wc (:) real ( rk ), allocatable :: Xg (:,:), Xgb (:,:) integer , allocatable :: elemConn (:,:) real ( rk ), allocatable :: Tgc (:,:), dTgc (:,:,:), Tgcb (:,:), dTgcb (:,:,:), d2Tgc (:,:,:), d2Tgcb (:,:,:) real ( rk ), allocatable :: Tgc1 (:), dTgc1 (:,:), Tgc1b (:), dTgc1b (:,:), d2Tgc1 (:,:), d2Tgc1b (:,:) integer :: i , id real ( rk ), allocatable :: nearest_Xg (:), nearest_Xt (:) type ( unit_test ) :: ut allocate ( Xc ( 4 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 5.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 0.9_rk knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] call nurbs % set ( knot1 , knot2 , Xc , Wc ) call bsp % set ( knot1 , knot2 , Xc ) call nurbs % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc (), Wc = nurbs % get_Wc ()) call bsp % set ( degree = nurbs % get_degree (), nc = nurbs % get_nc (), Xc = nurbs % get_Xc ()) call nurbs % create ( 30 , 30 ) call bsp % create ( 30 , 30 ) call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call nurbs % cmp_area ( area ) call bsp % cmp_area ( areab ) call ut % check ( res = area , expected = 2 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_surface: 01\" ) call ut % check ( res = areab , expected = 2 5.0_rk , tol = 1e-5_rk , msg = \"test_nurbs_surface: 02\" ) call nurbs % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 03\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 04\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_surface: 05\" ) call bsp % nearest_point ([ 0.0_rk , 0.0_rk , 0.5_rk ], nearest_Xg , nearest_Xt , id ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 06\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 07\" ) call ut % check ( res = id , expected = 1 , msg = \"test_nurbs_surface: 08\" ) call nurbs % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 09\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 10\" ) call bsp % nearest_point2 ([ 0.0_rk , 0.0_rk , 0.5_rk ], 1e-10_rk , 10 , nearest_Xt , nearest_Xg ) call ut % check ( res = nearest_Xg , expected = [ 0.0_rk , 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 11\" ) call ut % check ( res = nearest_Xt , expected = [ 0.0_rk , 0.0_rk ], tol = 1e-5_rk , msg = \"test_nurbs_surface: 12\" ) Xg = nurbs % get_Xg () Xgb = bsp % get_Xg () call nurbs % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc , Wc ) call bsp % set ([ 0.0_rk , 1.0_rk ], [ 0.0_rk , 1.0_rk ], [ 1 , 1 ], [ - 1 , - 1 ], [ - 1 , - 1 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 13\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 14\" ) call nurbs % set ([ 2 , 2 ], Xc , Wc ) call bsp % set ([ 2 , 2 ], Xc ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 15\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 16\" ) call nurbs % create ( Xt1 = nurbs % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call bsp % create ( Xt1 = bsp % get_Xt ( 1 ), Xt2 = nurbs % get_Xt ( 2 )) call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 17\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 18\" ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 19\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 20\" ) call ut % check ( res = nurbs % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 21\" ) call ut % check ( res = bsp % get_Xc ( 1 ), expected = Xc ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 22\" ) call ut % check ( res = nurbs % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 23\" ) call ut % check ( res = bsp % get_Xc ( 1 , 1 ), expected = Xc ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 24\" ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 25\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 26\" ) call ut % check ( res = nurbs % get_Xg ( 1 ), expected = Xg ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 27\" ) call ut % check ( res = bsp % get_Xg ( 1 ), expected = Xgb ( 1 ,:), tol = 1e-5_rk , msg = \"test_nurbs_surface: 28\" ) call ut % check ( res = nurbs % get_Xg ( 1 , 1 ), expected = Xg ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 29\" ) call ut % check ( res = bsp % get_Xg ( 1 , 1 ), expected = Xgb ( 1 , 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 30\" ) call ut % check ( res = nurbs % get_Wc (), expected = Wc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 31\" ) call ut % check ( res = nurbs % get_Wc ( 1 ), expected = Wc ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 32\" ) call ut % check ( res = nurbs % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_surface: 33\" ) call ut % check ( res = bsp % get_knot ( 1 ), expected = knot1 , tol = 1e-5_rk , msg = \"test_nurbs_surface: 34\" ) call ut % check ( res = nurbs % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 35\" ) call ut % check ( res = bsp % get_knot ( 1 , 1 ), expected = knot1 ( 1 ), tol = 1e-5_rk , msg = \"test_nurbs_surface: 36\" ) ! call ut%check(res=nurbs%get_ng(), expected=size(Xg,1), msg=\"test_nurbs_surface: 37\") ! call ut%check(res=bsp%get_ng(), expected=size(Xgb,1), msg=\"test_nurbs_surface: 38\") call ut % check ( res = nurbs % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_surface: 39\" ) call ut % check ( res = bsp % get_degree ( 1 ), expected = 1 , msg = \"test_nurbs_surface: 40\" ) call ut % check ( res = nurbs % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_surface: 41\" ) call ut % check ( res = bsp % get_multiplicity ( 1 ), expected = [ 2 , 2 ], msg = \"test_nurbs_surface: 42\" ) call ut % check ( res = nurbs % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_surface: 43\" ) call ut % check ( res = bsp % get_continuity ( 1 ), expected = [ - 1 , - 1 ], msg = \"test_nurbs_surface: 44\" ) ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 45\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 46\") call nurbs % cmp_nc () call bsp % cmp_nc () ! call ut%check(res=nurbs%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 47\") ! call ut%check(res=bsp%get_nc(), expected=size(Xc,1), msg=\"test_nurbs_surface: 48\") elemConn = nurbs % cmp_elem_Xc_vis ([ 1 , 1 ]) call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 49\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xc_vis () call nurbs % set_elem_Xc_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 50\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis ([ 1 , 1 ]) call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 51\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xc_vis () call bsp % set_elem_Xc_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xc_vis (), expected = elemConn , msg = \"test_nurbs_surface: 52\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis ([ 1 , 1 ]) call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 53\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem_Xg_vis () call nurbs % set_elem_Xg_vis ( elemConn ) call ut % check ( res = nurbs % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 54\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis ([ 1 , 1 ]) call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 55\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem_Xg_vis () call bsp % set_elem_Xg_vis ( elemConn ) call ut % check ( res = bsp % get_elem_Xg_vis (), expected = elemConn , msg = \"test_nurbs_surface: 56\" ) deallocate ( elemConn ) elemConn = nurbs % cmp_elem () call nurbs % set_elem ( elemConn ) call ut % check ( res = nurbs % get_elem (), expected = elemConn , msg = \"test_nurbs_surface: 57\" ) deallocate ( elemConn ) elemConn = bsp % cmp_elem () call bsp % set_elem ( elemConn ) call ut % check ( res = bsp % get_elem (), expected = elemConn , msg = \"test_nurbs_surface: 58\" ) deallocate ( elemConn ) call nurbs % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call bsp % modify_Xc ( Xc ( 1 , 1 ), 1 , 1 ) call nurbs % modify_Wc ( Wc ( 1 ), 1 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 59\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 60\" ) call nurbs % basis ( res1 = 30 , res2 = 30 , Tgc = Tgc ) call bsp % basis ( res1 = 30 , res2 = 30 , Tgc = Tgc ) call nurbs % basis ( Xt = [ 0.0_rk , 0.0_rk ], Tgc = Tgc1 ) call bsp % basis ( Xt = [ 0.0_rk , 0.0_rk ], Tgc = Tgc1b ) call nurbs % basis ( Xt1 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Xt2 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Tgc = Tgc ) call bsp % basis ( Xt1 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Xt2 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Tgc = Tgc ) call nurbs % derivative ( res1 = 30 , res2 = 30 , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative ( res1 = 30 , res2 = 30 , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Xt2 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], dTgc = dTgc , Tgc = Tgc ) call bsp % derivative (& Xt1 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Xt2 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1 , Tgc = Tgc1 , elem = [ 1 , 2 , 3 ]) call bsp % derivative ( Xt = [ 0.0_rk , 0.0_rk ], dTgc = dTgc1b , Tgc = Tgc1b , elem = [ 1 , 2 , 3 ]) call nurbs % derivative2 ( res1 = 30 , res2 = 30 , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 ( res1 = 30 , res2 = 30 , d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Xt2 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )],& d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) call bsp % derivative2 (& Xt1 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )], Xt2 = [( real ( i - 1 , rk ) / real ( 30 - 1 , rk ), i = 1 , 30 )],& d2Tgc = d2Tgcb , dTgc = dTgcb , Tgc = Tgcb ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1 , dTgc = dTgc1 , Tgc = Tgc1 ) call bsp % derivative2 ( Xt = [ 0.0_rk , 0.0_rk ], d2Tgc = d2Tgc1b , dTgc = dTgc1b , Tgc = Tgc1b ) call nurbs % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xc ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 61\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 62\" ) call nurbs % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xc ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 63\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 64\" ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 65\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 66\" ) call nurbs % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 4 5.0_rk , 0.0_rk , 0.0_rk ) call bsp % rotate_Xg ( - 4 5.0_rk , 0.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 67\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 68\" ) call nurbs % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 4 5.0_rk , 0.0_rk ) call bsp % rotate_Xg ( 0.0_rk , - 4 5.0_rk , 0.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 69\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 70\" ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call nurbs % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call bsp % rotate_Xg ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 71\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 72\" ) call nurbs % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xc ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xc ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 73\" ) call ut % check ( res = bsp % get_Xc (), expected = Xc , tol = 1e-5_rk , msg = \"test_nurbs_surface: 74\" ) call nurbs % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call nurbs % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call bsp % translate_Xg ([ 5.0_rk , 5.0_rk , 5.0_rk ]) call bsp % translate_Xg ([ - 5.0_rk , - 5.0_rk , - 5.0_rk ]) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 75\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 76\" ) call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call bsp % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 77\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 78\" ) call nurbs % elevate_degree ( 1 , 2 ) call nurbs % elevate_degree ( 2 , 2 ) call bsp % elevate_degree ( 1 , 2 ) call bsp % elevate_degree ( 2 , 2 ) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 79\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 80\" ) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call bsp % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) call nurbs % create () call bsp % create () call nurbs % export_Xc ( \"vtk/test_nurbs_surface_Xc.vtk\" ) call bsp % export_Xc ( \"vtk/test_bsp_surface_Xc.vtk\" ) call nurbs % export_Xg ( \"vtk/test_nurbs_surface_Xg.vtk\" ) call bsp % export_Xg ( \"vtk/test_bsp_surface_Xg.vtk\" ) call nurbs % export_Xth ( \"vtk/test_nurbs_surface_Xth.vtk\" ) call bsp % export_Xth ( \"vtk/test_bsp_surface_Xth.vtk\" ) call nurbs % export_iges ( 'iges/test_nurbs_surface.iges' ) call bsp % export_iges ( 'iges/test_bsp_surface.iges' ) call ut % check ( res = nurbs % get_Xg (), expected = Xg , tol = 1e-5_rk , msg = \"test_nurbs_surface: 81\" ) call ut % check ( res = bsp % get_Xg (), expected = Xgb , tol = 1e-5_rk , msg = \"test_nurbs_surface: 82\" ) call nurbs % set_tetragon ([ 2.0_rk , 2.0_rk ], [ 2 , 2 ]) call bsp % set_tetragon ([ 2.0_rk , 2.0_rk ], [ 2 , 2 ], [ 1.0_rk , 1.0_rk , 0.9_rk , 0.9_rk ]) call nurbs % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) call nurbs % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) call nurbs % set_C ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) call nurbs % finalize () call bsp % finalize () deallocate ( Xc , Wc , Xg , Xgb ) end program","tags":"","url":"sourcefile/test_nurbs_surface.f90.html"},{"title":"shape_tetragon.f90 – ForCAD","text":"This file depends on sourcefile~~shape_tetragon.f90~~EfferentGraph sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_tetragon use forcad implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !> Export the control points to a VTK file call shape % export_Xc ( 'vtk/shape_tetragon_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !> Export the generated surface to a VTK file call shape % export_Xg ( 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_tetragon_Xc.vtk' , 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () end program","tags":"","url":"sourcefile/shape_tetragon.f90.html"},{"title":"shape_half_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_circle.f90~~EfferentGraph sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !> Set up a half circle shape centered at the 0,0,0 with a radius of 1 call shape % set_half_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_circle_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_circle_Xc.vtk' , 'vtk/shape_half_circle_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_half_circle.f90.html"},{"title":"example_surface_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_surface_1.f90~~EfferentGraph sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !> Export the NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface2.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_surface_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !> Export the transformed NURBS surface to an IGES file call nurbs % export_iges ( 'iges/nurbs_surface3.iges' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","url":"sourcefile/example_surface_1.f90.html"},{"title":"forcad_kinds.F90 – ForCAD","text":"Files dependent on this one sourcefile~~forcad_kinds.f90~~AfferentGraph sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forcad_kinds implicit none private public rk #ifdef REAL32 integer , parameter :: rk = selected_real_kind ( 6 ) #elif REAL64 integer , parameter :: rk = selected_real_kind ( 15 ) #elif REALXDP integer , parameter :: rk = selected_real_kind ( 18 ) #elif REAL128 integer , parameter :: rk = selected_real_kind ( 33 ) #else integer , parameter :: rk = selected_real_kind ( 15 ) #endif end module","tags":"","url":"sourcefile/forcad_kinds.f90.html"},{"title":"example_volume_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_volume_1.f90~~EfferentGraph sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth.vtk' ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export refined parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth2.vtk' ) !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export parameter space to a VTK file call nurbs % export_Xth ( 'vtk/nurbs_volume_Xth3.vtk' ) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !> Export the NURBS volume to an IGES file !> Not supported for volumes. !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","url":"sourcefile/example_volume_1.f90.html"},{"title":"demo_volume.f90 – ForCAD","text":"This file depends on sourcefile~~demo_volume.f90~~EfferentGraph sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume. !> It sets up control points and weights, generates the volume, and exports the control points !> and the volume to VTK files at various stages. program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","url":"sourcefile/demo_volume.f90.html"},{"title":"shape_C_1d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_1d.f90~~EfferentGraph sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_1d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_1d_Xc.vtk' , 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","url":"sourcefile/shape_c_1d.f90.html"},{"title":"shape_half_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_3d.f90~~EfferentGraph sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_3d_Xc.vtk' , 'vtk/shape_half_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_half_ring_3d.f90.html"},{"title":"shape_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_2d.f90~~EfferentGraph sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a ring shape with inner radius 1.0 and outer radius 2.0. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_2d_Xc.vtk' , 'vtk/shape_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_ring_2d.f90.html"},{"title":"shape_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_3d.f90~~EfferentGraph sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_3d_Xc.vtk' , 'vtk/shape_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","url":"sourcefile/shape_ring_3d.f90.html"},{"title":"forcad_utils.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_utils.f90~~EfferentGraph sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_utils.f90~~AfferentGraph sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~fdm_surface.f90 fdm_surface.f90 sourcefile~fdm_surface.f90->sourcefile~forcad.f90 sourcefile~fdm_volume.f90 fdm_volume.f90 sourcefile~fdm_volume.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_curve.f90 test_nurbs_curve.f90 sourcefile~test_nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_surface.f90 test_nurbs_surface.f90 sourcefile~test_nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~test_nurbs_volume.f90 test_nurbs_volume.f90 sourcefile~test_nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module contains parameters, functions and subroutines that are used in the library. module forcad_utils use forcad_kinds , only : rk implicit none private public basis_bernstein , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , tetragon_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , basis_bspline_2der , det , inv , dyad , gauss_leg , export_vtk_legacy !=============================================================================== interface elemConn_C0 module procedure cmp_elemConn_C0_L module procedure cmp_elemConn_C0_S module procedure cmp_elemConn_C0_V end interface !=============================================================================== !=============================================================================== interface elemConn_Cn module procedure cmp_elemConn_Cn_L module procedure cmp_elemConn_Cn_S module procedure cmp_elemConn_Cn_V end interface !=============================================================================== !=============================================================================== interface ndgrid module procedure ndgrid2 module procedure ndgrid3 end interface !=============================================================================== !=============================================================================== interface compute_multiplicity module procedure compute_multiplicity1 module procedure compute_multiplicity2 end interface !=============================================================================== !=============================================================================== interface unique module procedure unique_integer module procedure unique_real end interface !=============================================================================== !=============================================================================== interface dyad module procedure dyad_t1_t1 end interface !=============================================================================== !=============================================================================== interface gauss_leg module procedure gauss_legendre_1D module procedure gauss_legendre_2D module procedure gauss_legendre_3D end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bspline ( Xt , knot , nc , degree ) result ( B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 real ( rk ) :: Nt ( nc , 0 : degree ) integer :: i , p real ( rk ) :: B ( nc ) temp = abs ( Xt - knot ( size ( knot ))) Nt = 0.0_rk do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xt >= Xth_i . and . Xt <= Xth_i1 ) Nt ( i , 0 ) = 1.0_rk if ( Xth_ip /= Xth_i ) Nt ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * Nt ( i , p - 1 ) if ( Xth_ip1 /= Xth_i1 ) Nt ( i , p ) = Nt ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * Nt ( i + 1 , p - 1 ) end do end do B = Nt (:, degree ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_der ( Xt , knot , nc , degree , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( out ) :: dB ( nc ) real ( rk ), intent ( out ), optional :: B ( nc ) real ( rk ), allocatable :: N (:,:), dN_dXt (:,:) real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 integer :: i , p temp = abs ( Xt - knot ( size ( knot ))) allocate ( N ( nc , 0 : degree ), source = 0.0_rk ) allocate ( dN_dXt ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xth_i <= Xt . and . Xt <= Xth_i1 ) then N ( i , 0 ) = 1.0_rk dN_dXt ( i , 0 ) = 0.0_rk end if if ( Xth_ip /= Xth_i ) then N ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * N ( i , p - 1 ) dN_dXt ( i , p ) = ( N ( i , p - 1 ) + ( Xt - Xth_i ) * dN_dXt ( i , p - 1 ) ) / ( Xth_ip - Xth_i ) end if if ( Xth_ip1 /= Xth_i1 ) then N ( i , p ) = N ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * N ( i + 1 , p - 1 ) dN_dXt ( i , p ) = dN_dXt ( i , p ) - ( N ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * dN_dXt ( i + 1 , p - 1 ) ) / ( Xth_ip1 - Xth_i1 ) end if end do end do dB = dN_dXt (:, degree ) if ( present ( B )) B = N (:, degree ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_2der ( Xt , knot , nc , degree , d2B , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( out ) :: d2B ( nc ) real ( rk ), intent ( out ), optional :: dB ( nc ) real ( rk ), intent ( out ), optional :: B ( nc ) real ( rk ), allocatable :: N (:,:), dN_dXt (:,:), d2N_dXt2 (:,:) real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 integer :: i , p temp = abs ( Xt - knot ( size ( knot ))) allocate ( N ( nc , 0 : degree ), source = 0.0_rk ) allocate ( dN_dXt ( nc , 0 : degree ), source = 0.0_rk ) allocate ( d2N_dXt2 ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xth_i <= Xt . and . Xt <= Xth_i1 ) then N ( i , 0 ) = 1.0_rk dN_dXt ( i , 0 ) = 0.0_rk d2N_dXt2 ( i , 0 ) = 0.0_rk end if if ( Xth_ip /= Xth_i ) then N ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * N ( i , p - 1 ) ! dN_dXt(i,p) = p*(N(i,p-1)/(Xth_ip - Xth_i)) dN_dXt ( i , p ) = ( N ( i , p - 1 ) + ( Xt - Xth_i ) * dN_dXt ( i , p - 1 ) ) / ( Xth_ip - Xth_i ) d2N_dXt2 ( i , p ) = ( 2 * dN_dXt ( i , p - 1 ) + ( Xt - Xth_i ) * d2N_dXt2 ( i , p - 1 )) / ( Xth_ip - Xth_i ) end if if ( Xth_ip1 /= Xth_i1 ) then N ( i , p ) = N ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * N ( i + 1 , p - 1 ) ! dN_dXt(i,p) = dN_dXt(i,p) - p*( N(i+1,p-1)/(Xth_ip1 - Xth_i1)) dN_dXt ( i , p ) = dN_dXt ( i , p ) - ( N ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * dN_dXt ( i + 1 , p - 1 ) ) / ( Xth_ip1 - Xth_i1 ) d2N_dXt2 ( i , p ) = d2N_dXt2 ( i , p ) - ( 2 * dN_dXt ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * d2N_dXt2 ( i + 1 , p - 1 )) / ( Xth_ip1 - Xth_i1 ) end if end do end do d2B = d2N_dXt2 (:, degree ) if ( present ( dB )) dB = dN_dXt (:, degree ) if ( present ( B )) B = N (:, degree ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bernstein ( Xt , nc ) result ( B ) real ( rk ), intent ( in ) :: Xt integer , intent ( in ) :: nc real ( rk ), allocatable :: B (:) integer :: p , degree degree = nc - 1 allocate ( B ( nc ), source = 0.0_rk ) do concurrent ( p = 0 : degree ) B ( p + 1 ) = gamma ( real ( nc , kind = rk )) / ( gamma ( real ( p + 1 , kind = rk )) * gamma ( real ( nc - p , kind = rk ))) if ( Xt == 0.0_rk . and . p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( 1.0_rk - Xt ) ** ( degree - p ) else if ( Xt == 0.0_rk . and . degree - p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) else B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) * ( 1.0_rk - Xt ) ** ( degree - p ) end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron ( u , v ) result ( w ) real ( rk ), intent ( in ), contiguous :: u (:), v (:) real ( rk ) :: w ( size ( u ) * size ( v )) integer :: i , j , n n = size ( v ) do concurrent ( i = 1 : size ( u ), j = 1 : n ) w (( i - 1 ) * n + j ) = u ( i ) * v ( j ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid2 ( X_dir1 , X_dir2 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , i , j s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) allocate ( Xt ( s1 * s2 , 2 )) do concurrent ( j = 1 : s2 , i = 1 : s1 ) Xt (( j - 1 ) * s1 + i , 1 ) = X_dir1 ( i ) Xt (( j - 1 ) * s1 + i , 2 ) = X_dir2 ( j ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid3 ( X_dir1 , X_dir2 , X_dir3 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:), X_dir3 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , s3 , i , j , k s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) s3 = size ( X_dir3 ) allocate ( Xt ( s1 * s2 * s3 , 3 )) do concurrent ( k = 1 : s3 , j = 1 : s2 , i = 1 : s1 ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 1 ) = X_dir1 ( i ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 2 ) = X_dir2 ( j ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 3 ) = X_dir3 ( k ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function repelem ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) integer , intent ( in ), contiguous :: b (:) real ( rk ) :: c ( sum ( b )) integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_L ( nnode , p ) result ( elemConn ) integer , intent ( in ) :: nnode integer , intent ( in ) :: p integer , allocatable :: elemConn (:,:) integer :: i , l integer , allocatable :: nodes (:) if ( mod ( nnode - 1 , p ) /= 0 ) error stop 'cmp_elemConn_C0_L: nnode-1 must be divisible by p' allocate ( elemConn ( ( nnode - 1 ) / p , p + 1 )) nodes = [( i , i = 1 , nnode )] l = 0 do i = 1 , nnode - p , p l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p ),[( p + 1 )]) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_S ( nnode1 , nnode2 , p1 , p2 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 integer , intent ( in ) :: p1 , p2 integer , allocatable :: elemConn (:,:) integer :: i , j , l integer , allocatable :: nodes (:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode2-1 must be divisible by p2' allocate ( elemConn ( (( nnode1 - 1 ) / p1 ) * (( nnode2 - 1 ) / p2 ), ( p1 + 1 ) * ( p2 + 1 ))) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 )], [ nnode1 , nnode2 ]) l = 0 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 ),[( p1 + 1 ) * ( p2 + 1 )]) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 , nnode3 integer , intent ( in ) :: p1 , p2 , p3 integer , allocatable :: elemConn (:,:) integer :: i , j , k , l integer , allocatable :: nodes (:,:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode2-1 must be divisible by p2' if ( mod ( nnode3 - 1 , p3 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode3-1 must be divisible by p3' allocate ( elemConn ( (( nnode1 - 1 ) / p1 ) * (( nnode2 - 1 ) / p2 ) * (( nnode3 - 1 ) / p3 ) ,( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 ))) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 * nnode3 )], [ nnode1 , nnode2 , nnode3 ]) l = 0 do k = 1 , nnode3 - p3 , p3 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 , k : k + p3 ),[( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 )]) end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_L ( nnode , p , Xth , vecKnot_mul , elemConn ) integer , intent ( in ) :: p , nnode integer , intent ( in ), contiguous :: vecKnot_mul (:) real ( rk ), intent ( in ), contiguous :: Xth (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:) integer :: i , nnel , m , nelem nnel = p + 1 nodes = [( i , i = 1 , nnode )] nelem = size ( Xth ) - 1 allocate ( elemConn ( nelem , nnel )) m = - p do i = 1 , nelem m = m + vecKnot_mul ( i ) elemConn ( i ,:) = nodes ( m : m + p ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_S ( nnode1 , nnode2 , p1 , p2 ,& Xth1 , Xth2 , vecKnot_mul1 , vecKnot_mul2 , elemConn ) integer , intent ( in ) :: p1 , p2 , nnode1 , nnode2 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:), nodes_vec (:) integer :: nnd_total , i , j , l , nnel1 , nnel2 , m , n , nelem1 , nelem2 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnd_total = nnode1 * nnode2 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem = nelem1 * nelem2 allocate ( elemConn ( nelem , nnel1 * nnel2 )) l = 0 n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 ), [ nnel1 * nnel2 ]) end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ,& Xth1 , Xth2 , Xth3 , vecKnot_mul1 , vecKnot_mul2 , vecKnot_mul3 , elemConn ) integer , intent ( in ) :: p1 , p2 , p3 , nnode1 , nnode2 , nnode3 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:), vecKnot_mul3 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:), Xth3 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:,:), nodes_vec (:) integer :: nnd_total , i , j , k , l , nnel1 , nnel2 , nnel3 , m , n , o , nelem1 , nelem2 , nelem3 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnel3 = p3 + 1 nnd_total = nnode1 * nnode2 * nnode3 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 , nnode3 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem3 = size ( Xth3 ) - 1 nelem = nelem1 * nelem2 * nelem3 allocate ( elemConn ( nelem , nnel1 * nnel2 * nnel3 )) l = 0 o = - p3 do k = 1 , nelem3 o = o + vecKnot_mul3 ( k ) n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 , o : o + p3 ), [ nnel1 * nnel2 * nnel3 ]) end do end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity1 ( knot ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) integer , allocatable :: multiplicity (:) integer :: i , count count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) count = count + 1 end do allocate ( multiplicity ( count )) multiplicity ( 1 ) = 1 count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) then count = count + 1 multiplicity ( count ) = 1 else multiplicity ( count ) = multiplicity ( count ) + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity2 ( knot , Xth ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ) :: Xth integer :: multiplicity integer :: i , count , size_knot size_knot = size ( knot ) multiplicity = 0 i = 1 do while ( i <= size_knot ) if ( knot ( i ) == Xth ) then count = 1 do while ( i + count <= size_knot . and . knot ( i + count ) == Xth ) count = count + 1 end do if ( count > multiplicity ) then multiplicity = count end if i = i + count else i = i + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_knot_vector ( Xth_dir , degree , continuity ) result ( knot ) real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), allocatable :: knot (:) knot = repelem ( Xth_dir , ( degree - continuity )) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knot_A_5_1 ( p , UP , Pw , u , k , s , r , nq , UQ , Qw ) integer , intent ( in ) :: p , k , s , r real ( rk ), intent ( in ), contiguous :: UP ( 0 :), Pw ( 0 :,:) real ( rk ), intent ( in ) :: u real ( rk ), allocatable , intent ( out ) :: UQ (:), Qw (:,:) integer , intent ( out ) :: nq integer :: i , j , L , mp , d , np real ( rk ), allocatable :: Rw (:,:) real ( rk ) :: alpha d = size ( Pw , 2 ) np = size ( Pw , 1 ) - 1 mp = np + p + 1 nq = np + r allocate ( UQ ( 0 : mp + r )) allocate ( Qw ( 0 : nq , 1 : d )) allocate ( Rw ( 0 : p , 1 : d )) UQ ( 0 : k ) = UP ( 0 : k ) UQ ( k + 1 : k + r ) = u UQ ( k + 1 + r : mp + r ) = UP ( k + 1 : mp ) Qw ( 0 : k - p ,:) = Pw ( 0 : k - p ,:) Qw ( k - s + r : np + r ,:) = Pw ( k - s : np ,:) Rw ( 0 : p - s ,:) = Pw ( k - p : k - s ,:) do j = 1 , r L = k - p + j do i = 0 , p - j - s alpha = ( u - UP ( L + i )) / ( UP ( i + k + 1 ) - UP ( L + i )) Rw ( i ,:) = alpha * Rw ( i + 1 ,:) + ( 1.0_rk - alpha ) * Rw ( i ,:) end do Qw ( L ,:) = Rw ( 0 ,:) Qw ( k + r - j - s ,:) = Rw ( p - j - s ,:) end do Qw ( L + 1 : k - s - 1 ,:) = Rw ( 1 : k - s - 1 - L ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function findspan ( n , degree , Xth , knot ) result ( s ) integer , intent ( in ) :: n , degree real ( rk ), intent ( in ) :: Xth real ( rk ), intent ( in ), contiguous :: knot (:) integer :: s integer :: low , high , mid if ( Xth == knot ( n + 2 )) then s = n return end if low = degree high = n + 1 mid = ( low + high ) / 2 do while ( Xth < knot ( mid + 1 ) . or . Xth >= knot ( mid + 2 )) if ( Xth < knot ( mid + 1 )) then high = mid else low = mid end if mid = ( low + high ) / 2 end do s = mid end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree_A_5_9 ( t , knot , degree , Xcw , nc_new , knot_new , Xcw_new ) integer , intent ( in ) :: t real ( rk ), intent ( in ), contiguous :: Xcw (:,:), knot (:) integer , intent ( in ) :: degree integer , intent ( out ) :: nc_new real ( rk ), allocatable , intent ( out ) :: Xcw_new (:,:), knot_new (:) real ( rk ), allocatable :: bezalfs (:,:), bpts (:,:), ebpts (:,:), Nextbpts (:,:), alfs (:) real ( rk ) :: iinv , alpha1 , alpha2 , Xth1 , Xth2 , numer , den integer :: n , lbz , rbz , sv , tr , kj , first , knoti , last , alpha3 , d , nc integer :: i , j , q , s , m , ph , ph2 , mpi , mh , r , a , b , Xcwi , oldr , mul integer , allocatable :: mlp (:) nc = size ( Xcw , 1 ) d = size ( Xcw , 2 ) mlp = compute_multiplicity ( knot ) mlp = mlp + t nc_new = sum ( mlp ) - ( mlp ( 1 ) - 1 ) - 1 allocate ( Xcw_new ( nc_new , d ), source = 0.0_rk ) allocate ( bezalfs ( degree + 1 , degree + t + 1 ), source = 0.0_rk ) allocate ( bpts ( degree + 1 , d ), source = 0.0_rk ) allocate ( ebpts ( degree + t + 1 , d ), source = 0.0_rk ) allocate ( Nextbpts ( degree + 1 , d ), source = 0.0_rk ) allocate ( alfs ( degree ), source = 0.0_rk ) n = nc - 1 m = n + degree + 1 ph = degree + t ph2 = ph / 2 bezalfs ( 1 , 1 ) = 1.0_rk bezalfs ( degree + 1 , ph + 1 ) = 1.0_rk do i = 1 , ph2 iinv = 1.0_rk / bincoeff ( ph , i ) mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = iinv * bincoeff ( degree , j ) * bincoeff ( t , i - j ) end do end do do i = ph2 + 1 , ph - 1 mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = bezalfs ( degree - j + 1 , ph - i + 1 ) end do end do mh = ph knoti = ph + 1 r = - 1 a = degree b = degree + 1 Xcwi = 1 Xth1 = knot ( 1 ) Xcw_new ( 1 ,:) = Xcw ( 1 ,:) allocate ( knot_new ( sum ( mlp )), source = 0.0_rk ) knot_new ( 1 : ph + 1 ) = Xth1 do i = 0 , degree bpts ( i + 1 ,:) = Xcw ( i + 1 ,:) end do do while ( b < m ) i = b do while ( b < m . and . knot ( b + 1 ) == knot ( b + 2 )) b = b + 1 if ( b + 2 > size ( knot )) then exit end if end do mul = b - i + 1 mh = mh + mul + t Xth2 = knot ( b + 1 ) oldr = r r = degree - mul if ( oldr > 0 ) then lbz = ( oldr + 2 ) / 2 else lbz = 1 end if if ( r > 0 ) then rbz = ph - ( r + 1 ) / 2 else rbz = ph end if if ( r > 0 ) then numer = Xth2 - Xth1 do q = degree , mul + 1 , - 1 alfs ( q - mul ) = numer / ( knot ( a + q + 1 ) - Xth1 ) end do do j = 1 , r sv = r - j s = mul + j do q = degree , s , - 1 bpts ( q + 1 ,:) = ( 1.0_rk - alfs ( q - s + 1 )) * bpts ( q ,:) + alfs ( q - s + 1 ) * bpts ( q + 1 ,:) end do Nextbpts ( sv + 1 ,:) = bpts ( degree + 1 ,:) end do end if do i = lbz , ph ebpts ( i + 1 ,:) = 0.0_rk mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi ebpts ( i + 1 ,:) = bezalfs ( j + 1 , i + 1 ) * bpts ( j + 1 ,:) + ebpts ( i + 1 ,:) end do end do if ( oldr > 1 ) then first = knoti - 2 last = knoti den = Xth2 - Xth1 alpha3 = floor (( Xth2 - knot ( knoti )) / den ) do tr = 1 , oldr - 1 i = first j = last kj = j - knoti + 1 do while ( j - i > tr ) if ( i < Xcwi ) then alpha1 = ( Xth2 - knot ( i + 1 )) / ( Xth1 - knot ( i + 1 )) Xcw_new ( i + 1 ,:) = ( 1 - alpha1 ) * Xcw_new ( i ,:) + alpha1 * Xcw_new ( i + 1 ,:) end if if ( j >= lbz ) then if ( j - tr <= knoti - ph + oldr ) then alpha2 = ( Xth2 - knot_new ( j - tr + 1 )) / den ebpts ( kj + 1 ,:) = alpha2 * ebpts ( kj + 1 ,:) + ( 1 - alpha2 ) * ebpts ( kj + 2 ,:) else ebpts ( kj + 1 ,:) = ( 1 - alpha3 ) * ebpts (:, kj + 2 ) + alpha3 * ebpts ( kj + 1 ,:) end if end if i = i + 1 j = j - 1 kj = kj - 1 end do first = first - 1 last = last + 1 end do end if if ( a /= degree ) then do i = 0 , ph - oldr - 1 knot_new ( knoti + 1 ) = Xth1 knoti = knoti + 1 end do end if do j = lbz , rbz Xcw_new ( Xcwi + 1 ,:) = ebpts ( j + 1 ,:) Xcwi = Xcwi + 1 end do if ( b < m ) then do j = 0 , r - 1 bpts ( j + 1 ,:) = Nextbpts ( j + 1 ,:) end do do j = r , degree bpts ( j + 1 ,:) = Xcw ( b - degree + j + 1 ,:) end do a = b b = b + 1 Xth1 = Xth2 else do i = 0 , ph knot_new ( knoti + i + 1 ) = Xth2 end do end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function bincoeff ( n , k ) result ( b ) integer , intent ( in ) :: n , k real ( rk ) :: b b = floor ( 0.5_rk + exp ( factln ( n ) - factln ( k ) - factln ( n - k ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function factln ( n ) result ( f ) integer , intent ( in ) :: n real ( rk ) :: f if ( n <= 1 ) then f = 0.0_rk return end if f = log ( gamma ( real ( n + 1 , rk ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function hexahedron_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy , dz integer :: i , j , k , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) dz = L ( 3 ) / real ( nc ( 3 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) nci = 1 do k = 0 , nc ( 3 ) - 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = real ( k , rk ) * dz nci = nci + 1 end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function tetragon_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy integer :: i , j , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ), 3 )) nci = 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = 0.0_rk nci = nci + 1 end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots_A_5_8 ( p , knot , Pw , u , r , s , num , t , knot_new , Pw_new ) real ( rk ), intent ( in ) :: u integer , intent ( in ) :: p , r , s , num real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Pw (:,:) real ( rk ), allocatable , intent ( out ) :: knot_new (:) real ( rk ), allocatable , intent ( out ) :: Pw_new (:,:) real ( rk ), allocatable :: Pw_copy (:,:), knot_copy (:) integer , intent ( out ) :: t real ( rk ) :: tol , alfi , alfj real ( rk ), allocatable :: temp (:,:) integer :: i , j , ii , jj , remflag , off , first , last , ord , fout , m , k , n , nc , d , tt d = size ( Pw , 2 ) nc = size ( Pw , 1 ) n = nc m = n + p + 1 ord = p + 1 fout = ( 2 * r - s - p ) / 2 last = r - s first = r - p Pw_copy = Pw knot_copy = knot ! TODO: tol = 1.0e-6_rk * minval ( Pw (:, d )) / ( 1.0_rk + maxval ( sqrt ( sum ( Pw ** 2 , 2 )))) allocate ( temp ( 2 * p + 1 , d ), source = 0.0_rk ) t = 0 do tt = 0 , num - 1 off = first - 1 temp ( 1 ,:) = Pw_copy ( off ,:) temp ( last + 1 - off + 1 ,:) = Pw_copy ( last + 1 ,:) i = first j = last ii = 1 jj = last - off remflag = 0 do while ( j - i > t ) alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) alfj = ( u - knot_copy ( j - t )) / ( knot_copy ( j + ord ) - knot_copy ( j - t )) temp ( ii + 1 ,:) = ( Pw_copy ( i ,:) - ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:)) / alfi temp ( jj + 1 ,:) = ( Pw_copy ( j ,:) - alfj * temp ( jj + 1 + 1 ,:)) / ( 1.0_rk - alfj ) i = i + 1 ii = ii + 1 j = j - 1 jj = jj - 1 end do if ( j - i <= t ) then if ( norm2 ( temp ( ii - 1 + 1 ,:) - temp ( jj + 1 + 1 ,:)) <= tol ) then remflag = 1 else alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) if ( norm2 ( Pw_copy ( i ,:) - ( alfi * temp ( ii + t + 1 + 1 ,:) + ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:))) <= tol ) then remflag = 1 end if end if end if if ( remflag == 0 ) then exit else i = first j = last do while ( j - i > t ) Pw_copy ( i ,:) = temp ( i - off + 1 ,:) Pw_copy ( j ,:) = temp ( j - off + 1 ,:) i = i + 1 j = j - 1 end do end if first = first - 1 last = last + 1 t = t + 1 end do if ( t == 0 ) then return end if do k = r + 1 , m knot_copy ( k - t ) = knot_copy ( k ) end do j = fout i = j do k = 1 , t - 1 if ( mod ( k , 2 ) == 1 ) then i = i + 1 else j = j - 1 end if end do do k = i + 1 , n Pw_copy ( j ,:) = Pw_copy ( k ,:) j = j + 1 end do knot_new = knot_copy ( 1 : size ( knot_copy ) - t ) Pw_new = Pw_copy ( 1 : size ( Pw_copy , 1 ) - t ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_integer ( vec ) result ( output ) integer , dimension (:), intent ( in ), contiguous :: vec integer , dimension (:), allocatable :: output integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) if ( vec ( i ) == output ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_real ( vec ) result ( output ) real ( rk ), dimension (:), intent ( in ), contiguous :: vec real ( rk ), dimension (:), allocatable :: output integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) if ( vec ( i ) == output ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function rotation ( alpha , beta , theta ) result ( R ) real ( rk ), intent ( in ) :: alpha , beta , theta real ( rk ), dimension ( 3 , 3 ) :: R R ( 1 , 1 ) = cosd ( beta ) * cosd ( theta ) R ( 2 , 1 ) = cosd ( beta ) * sind ( theta ) R ( 3 , 1 ) = - sind ( beta ) R ( 1 , 2 ) = sind ( alpha ) * sind ( beta ) * cosd ( theta ) - cosd ( alpha ) * sind ( theta ) R ( 2 , 2 ) = sind ( alpha ) * sind ( beta ) * sind ( theta ) + cosd ( alpha ) * cosd ( theta ) R ( 3 , 2 ) = sind ( alpha ) * cosd ( beta ) R ( 1 , 3 ) = cosd ( alpha ) * sind ( beta ) * cosd ( theta ) + sind ( alpha ) * sind ( theta ) R ( 2 , 3 ) = cosd ( alpha ) * sind ( beta ) * sind ( theta ) - sind ( alpha ) * cosd ( theta ) R ( 3 , 3 ) = cosd ( alpha ) * cosd ( beta ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function det ( A ) result ( detA ) real ( rk ), intent ( in ) :: A (:,:) real ( rk ) :: detA if ( size ( A , 1 ) == size ( A , 2 )) then select case ( size ( A , 1 )) case ( 2 ) detA = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) case ( 3 ) detA = & + A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) )& - A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 ) )& + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) ) end select elseif ( size ( A , 1 ) == 3 . and . size ( A , 2 ) == 2 ) then detA = & + A ( 1 , 1 ) * ( A ( 2 , 2 ) * 1.0_rk - A ( 3 , 2 ) * 1.0_rk )& - A ( 1 , 2 ) * ( A ( 2 , 1 ) * 1.0_rk - A ( 3 , 1 ) * 1.0_rk )& + 1.0_rk * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 3 , 1 ) * A ( 2 , 2 ) ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause recursive pure function inv ( A ) result ( A_inv ) real ( rk ), intent ( in ) :: A (:,:) real ( rk ), allocatable :: A_inv (:,:) if ( size ( A , 1 ) == size ( A , 2 )) then select case ( size ( A , 1 )) case ( 2 ) allocate ( A_inv ( size ( A , 1 ), size ( A , 2 ))) A_inv ( 1 , 1 ) = A ( 2 , 2 ) A_inv ( 1 , 2 ) = - A ( 1 , 2 ) A_inv ( 2 , 1 ) = - A ( 2 , 1 ) A_inv ( 2 , 2 ) = A ( 1 , 1 ) A_inv = A_inv / det ( A ) case ( 3 ) allocate ( A_inv ( size ( A , 1 ), size ( A , 2 ))) A_inv ( 1 , 1 ) = A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) A_inv ( 1 , 2 ) = A ( 1 , 3 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 3 ) A_inv ( 1 , 3 ) = A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 ) A_inv ( 2 , 1 ) = A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 ) A_inv ( 2 , 2 ) = A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 ) A_inv ( 2 , 3 ) = A ( 1 , 3 ) * A ( 2 , 1 ) - A ( 1 , 1 ) * A ( 2 , 3 ) A_inv ( 3 , 1 ) = A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) A_inv ( 3 , 2 ) = A ( 1 , 2 ) * A ( 3 , 1 ) - A ( 1 , 1 ) * A ( 3 , 2 ) A_inv ( 3 , 3 ) = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) A_inv = A_inv / det ( A ) end select elseif ( size ( A , 1 ) > size ( A , 2 )) then allocate ( A_inv ( size ( A , 2 ), size ( A , 1 ))) A_inv = transpose ( A ) A_inv = matmul ( inv ( matmul ( A_inv , A )), A_inv ) elseif ( size ( A , 1 ) < size ( A , 2 )) then allocate ( A_inv ( size ( A , 2 ), size ( A , 1 ))) A_inv = transpose ( A ) A_inv = matmul ( A_inv , inv ( matmul ( A , A_inv ))) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function dyad_t1_t1 ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) real ( rk ), intent ( in ), contiguous :: b (:) real ( rk ), allocatable :: c (:,:) integer :: i allocate ( c ( size ( a ), size ( b ))) do concurrent ( i = 1 : size ( c , 1 )) c ( i , :) = a ( i ) * b (:) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_1D ( interval , degree , Xksi , Wksi ) real ( rk ), intent ( in ) :: interval ( 2 ) integer , intent ( in ) :: degree real ( rk ), allocatable , intent ( out ) :: Xksi (:), Wksi (:) allocate ( Xksi ( degree + 1 ), Wksi ( degree + 1 )) call gauss_legendre ( Xksi , Wksi , interval ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_2D ( interval1 , interval2 , degree , Xksi , Wksi ) real ( rk ), intent ( in ) :: interval1 ( 2 ), interval2 ( 2 ) integer , intent ( in ) :: degree ( 2 ) real ( rk ), allocatable , intent ( out ) :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: Xksi1 (:), Wksi1 (:), Xksi2 (:), Wksi2 (:) allocate ( Xksi1 ( degree ( 1 ) + 1 ), Wksi1 ( degree ( 1 ) + 1 )) allocate ( Xksi2 ( degree ( 2 ) + 1 ), Wksi2 ( degree ( 2 ) + 1 )) call gauss_legendre ( Xksi1 , Wksi1 , interval1 ) call gauss_legendre ( Xksi2 , Wksi2 , interval2 ) call ndgrid ( Xksi1 , Xksi2 , Xksi ) Wksi = kron ( Wksi1 , Wksi2 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_3D ( interval1 , interval2 , interval3 , degree , Xksi , Wksi ) real ( rk ), intent ( in ) :: interval1 ( 2 ), interval2 ( 2 ), interval3 ( 2 ) integer , intent ( in ) :: degree ( 3 ) real ( rk ), allocatable , intent ( out ) :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: Xksi1 (:), Wksi1 (:), Xksi2 (:), Wksi2 (:), Xksi3 (:), Wksi3 (:) allocate ( Xksi1 ( degree ( 1 ) + 1 ), Wksi1 ( degree ( 1 ) + 1 )) allocate ( Xksi2 ( degree ( 2 ) + 1 ), Wksi2 ( degree ( 2 ) + 1 )) allocate ( Xksi3 ( degree ( 3 ) + 1 ), Wksi3 ( degree ( 3 ) + 1 )) call gauss_legendre ( Xksi1 , Wksi1 , interval1 ) call gauss_legendre ( Xksi2 , Wksi2 , interval2 ) call gauss_legendre ( Xksi3 , Wksi3 , interval3 ) call ndgrid ( Xksi1 , Xksi2 , Xksi3 , Xksi ) Wksi = kron ( kron ( Wksi3 , Wksi2 ), Wksi1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre ( x , w , interval ) real ( rk ), intent ( out ) :: x (:), w (:) real ( rk ), intent ( in ) :: interval ( 2 ) real ( rk ) :: xi , delta , p_next , dp_next , p_prev , p_curr , dp_prev , dp_curr , midpoint , half_length integer :: i , j , k , n real ( rk ), parameter :: pi = acos ( - 1.0_rk ) real ( rk ), parameter :: tol = 4.0_rk * epsilon ( 1.0_rk ) integer , parameter :: maxit = 100 logical :: converged if ( interval ( 1 ) >= interval ( 2 )) error stop \"gauss_legendre: Invalid interval, interval(1) must be less than interval(2)\" n = size ( x ) ! Gauss-Legendre points are symmetric, only compute half do concurrent ( i = 1 :( n + 1 ) / 2 ) ! Initial guess (Chebyshev approximation) xi = - cos ( pi * ( i - 0.25_rk ) / ( n + 0.5_rk )) ! Newton iteration j = 0 converged = . false . do while (. not . converged . and . j < maxit ) j = j + 1 ! Compute Legendre polynomial and derivative via recurrence p_prev = 1.0_rk ! P_0(xi) p_curr = xi ! P_1(xi) dp_prev = 0.0_rk ! P_0'(xi) dp_curr = 1.0_rk ! P_1'(xi) do k = 2 , n p_next = (( 2 * k - 1 ) * xi * p_curr - ( k - 1 ) * p_prev ) / k dp_next = (( 2 * k - 1 ) * ( xi * dp_curr + p_curr ) - ( k - 1 ) * dp_prev ) / k p_prev = p_curr p_curr = p_next dp_prev = dp_curr dp_curr = dp_next end do ! Newton correction delta = - p_curr / dp_curr xi = xi + delta ! Check for convergence converged = ( abs ( delta ) <= tol * abs ( xi )) end do if (. not . converged ) error stop \"gauss_legendre: Newton iteration did not converge\" ! Store symmetric nodes and weights x ( i ) = xi x ( n + 1 - i ) = - xi w ( i ) = 2.0_rk / (( 1.0_rk - xi ** 2 ) * dp_curr ** 2 ) w ( n + 1 - i ) = w ( i ) end do ! Transform from [-1,1] to [interval(1), interval(2)] midpoint = 0.5_rk * ( interval ( 1 ) + interval ( 2 )) half_length = 0.5_rk * ( interval ( 2 ) - interval ( 1 )) x = midpoint + half_length * x w = half_length * w end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_vtk_legacy ( filename , points , elemConn , vtkCellType , encoding ) character ( len =* ), intent ( in ) :: filename real ( rk ), intent ( in ) :: points (:,:) integer , intent ( in ) :: elemConn (:,:) integer , intent ( in ) :: vtkCellType character ( len =* ), intent ( in ), optional :: encoding integer :: i , ne , np , nn , n , nunit character ( len = 6 ) :: encoding_ integer , parameter :: dp = kind ( 1.0d0 ) ne = size ( elemConn , 1 ) nn = size ( elemConn , 2 ) np = size ( points , 1 ) n = ne * ( nn + 1 ) if ( present ( encoding )) then select case ( trim ( encoding )) case ( 'ascii' ) encoding_ = 'ASCII' case ( 'binary' ) encoding_ = 'BINARY' case default error stop 'Invalid encoding type. Use \"ASCII\" or \"BINARY\".' end select else encoding_ = 'BINARY' end if if ( trim ( encoding_ ) == 'ASCII' ) then open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,1x,g0,1x,a)' ) 'POINTS' , np , 'double' if ( size ( points , 2 ) == 2 ) then write ( nunit , '(g0,1x,g0,1x,g0)' ) ( points ( i , 1 ), points ( i , 2 ), 0.0_rk , i = 1 , np ) elseif ( size ( points , 2 ) == 3 ) then write ( nunit , '(g0,1x,g0,1x,g0)' ) ( points ( i , 1 ), points ( i , 2 ), points ( i , 3 ) , i = 1 , np ) else error stop 'Invalid dimension for points.' end if write ( nunit , '(a,1x,g0,1x,g0)' ) 'CELLS' , ne , n select case ( nn ) case ( 2 ) write ( nunit , '(g0,1x,g0,1x,g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , ne ) case ( 4 ) write ( nunit , '(g0,1x,g0,1x,g0,1x,g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , ne ) case ( 8 ) write ( nunit , '(g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0,1x,g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , ne ) case default error stop 'Invalid number of nodes per element.' end select write ( nunit , '(a,1x,g0)' ) 'CELL_TYPES' , ne write ( nunit , '(g0)' ) ( vtkCellType , i = 1 , ne ) close ( nunit ) end if if ( trim ( encoding_ ) == 'BINARY' ) then open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'BINARY' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' close ( nunit ) open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0,1x,a)' ) 'POINTS' , np , 'double' close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = \"stream\" , form = \"unformatted\" ,& action = \"write\" , convert = \"big_endian\" , status = \"unknown\" ) if ( size ( points , 2 ) == 2 ) then write ( nunit ) ( real ( points ( i , 1 ), dp ), real ( points ( i , 2 ), dp ), real ( 0.0_rk , dp ) , i = 1 , np ) elseif ( size ( points , 2 ) == 3 ) then write ( nunit ) ( real ( points ( i , 1 ), dp ), real ( points ( i , 2 ), dp ), real ( points ( i , 3 ), dp ) , i = 1 , np ) else error stop 'Invalid dimension for points.' end if close ( nunit ) open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0,1x,g0)' ) 'CELLS' , ne , n close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = \"stream\" , form = \"unformatted\" ,& action = \"write\" , convert = \"big_endian\" , status = \"unknown\" ) select case ( nn ) case ( 2 ) write ( nunit )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , ne ) case ( 4 ) write ( nunit )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , ne ) case ( 8 ) write ( nunit )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , ne ) case default error stop 'Invalid number of nodes per element.' end select close ( nunit ) open ( newunit = nunit , file = filename , form = 'formatted' , action = 'write' , position = 'append' ) write ( nunit , '(a,1x,g0)' ) 'CELL_TYPES' , ne close ( nunit ) open ( newunit = nunit , file = filename , position = 'append' , access = \"stream\" , form = \"unformatted\" ,& action = \"write\" , convert = \"big_endian\" , status = \"unknown\" ) write ( nunit ) ( vtkCellType , i = 1 , ne ) close ( nunit ) end if end subroutine !=============================================================================== end module forcad_utils","tags":"","url":"sourcefile/forcad_utils.f90.html"},{"title":"fdm_curve.f90 – ForCAD","text":"This file depends on sourcefile~~fdm_curve.f90~~EfferentGraph sourcefile~fdm_curve.f90 fdm_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~fdm_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_kinds.f90 forcad_kinds.F90 sourcefile~forcad.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_kinds.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_utils.f90->sourcefile~forcad_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program fdm_test_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: curve !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector real ( rk ) :: Xtp , tol , Xt , Xtm real ( rk ), allocatable :: Tgc (:), dTgc (:), Tgcp (:), dTgcp (:), Tgcm (:), dTgcm (:), d2Tgc (:), d2Tgcp (:), d2Tgcm (:) !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 1.1_rk , 1.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call curve % set ( knot , Xc , Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call curve % create ( res = 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- tol = 1.0e-6_rk Xt = 0.5_rk call curve % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) Xtm = Xt - tol call curve % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt + tol call curve % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 (( Tgc - Tgcm ) / tol - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 (( Tgcp - Tgcm ) / ( 2.0_rk * tol ) - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 (( Tgcp - Tgc ) / tol - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 (( dTgc - dTgcm ) / tol - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 (( dTgcp - dTgcm ) / ( 2.0_rk * tol ) - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 (( dTgcp - dTgc ) / tol - d2Tgc ) !> Finalize the NURBS curve object call curve % finalize () deallocate ( Xc , Wc ) !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points for the NURBS curve object. !> Wc is optional call curve % set ( knot , Xc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call curve % create ( res = 20 ) !----------------------------------------------------------------------------- ! Finite Difference Derivative Test !----------------------------------------------------------------------------- tol = 1.0e-6_rk Xt = 0.5_rk call curve % derivative2 ( Xt = Xt , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) Xtm = Xt - tol call curve % derivative2 ( Xt = Xtm , d2Tgc = d2Tgcm , dTgc = dTgcm , Tgc = Tgcm ) Xtp = Xt + tol call curve % derivative2 ( Xt = Xtp , d2Tgc = d2Tgcp , dTgc = dTgcp , Tgc = Tgcp ) print * , 'Tolerance:' , tol print * , 'Error BFD dTgc:  ' , norm2 (( Tgc - Tgcm ) / tol - dTgc ) print * , 'Error CFD dTgc:  ' , norm2 (( Tgcp - Tgcm ) / ( 2.0_rk * tol ) - dTgc ) print * , 'Error FFD dTgc:  ' , norm2 (( Tgcp - Tgc ) / tol - dTgc ) print * , 'Error BFD d2Tgc: ' , norm2 (( dTgc - dTgcm ) / tol - d2Tgc ) print * , 'Error CFD d2Tgc: ' , norm2 (( dTgcp - dTgcm ) / ( 2.0_rk * tol ) - d2Tgc ) print * , 'Error FFD d2Tgc: ' , norm2 (( dTgcp - dTgc ) / tol - d2Tgc ) !> Finalize the NURBS curve object call curve % finalize () deallocate ( Xc ) end program","tags":"","url":"sourcefile/fdm_curve.f90.html"}]}