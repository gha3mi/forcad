var tipuesearch = {"pages":[{"title":" ForCAD ","text":"ForCAD ForCAD : A Fortran library for Geometric Modeling. ForCAD supports B-Spline , NURBS , Bezier , and Rational Bezier curves, surfaces, and volumes. fpm dependency If you want to use ForCAD as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forcad = { git = \"https://github.com/gha3mi/forcad.git\" } How to run examples To get started, follow these steps: Clone the repository: Clone the ForCAD repository from GitHub: git clone https://github.com/gha3mi/forcad.git cd forcad Using fpm fpm run --example <file name excluding the .f90 extension> Once the examples have been executed, .vtk files will be generated within the vtk directory. These files can then be visualized using tools such as ParaView . API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForCAD using ford run the following\ncommand: ford ford.yml ToDo B-Splines and NURBS [x] Add insert_knot() method for curves. [ ] Add insert_knot() method for surfaces and volumes. [ ] Add remove_knot() method for curves, surfaces and volumes. [x] Add elevate_degree() method for curves. [ ] Add elevate_degree() method for surfaces and volumes. [ ] Add reduce_degree() method for curves, surfaces and volumes. [x] Add derivative() method for curves, surfaces and volumes. [ ] Add support for multiple patches. [ ] Add extraction of piecewise Bezier objects from NURBS. Bezier and Rational Bezier [x] Add elevate_degree() method for curves. [ ] Add elevate_degree() method for surfaces and volumes. [ ] Add reduce_degree() method for curves, surfaces and volumes. [ ] Add derivative() method. [ ] Add support for multiple patches. Contributing Contributions to ForCAD are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. References The NURBS Book by Les Piegl, Wayne Tiller An Introduction to NURBS by David F. Rogers Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"nurbs_surface – ForCAD ","text":"type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction real(kind=rk), private, allocatable :: knot1 (:) knot vector real(kind=rk), private, allocatable :: knot2 (:) knot vector integer, private :: nc (2) number of control points in each direction integer, private :: ng (2) number of geometry points in each direction integer, private :: order (2) degree of each direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS surface private pure subroutine basis (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, Xt1, Xt2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) procedure, public :: derivative Compute the derivative of the NURBS surface private pure subroutine derivative (this, res1, res2, Xt1, Xt2, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS surface object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Get continuity of the surface private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_elem_Xc Generate connectivity for control points private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_elem_Xg Generate connectivity for geometry points private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_knot Get knot vector private pure function get_knot (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Get multiplicity of the knot vector private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of required control points private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: get_order Get order of the Bezier curve private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir generic, public :: set => set1 , set2 private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, order, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) procedure, public :: set1 Set control points and weights private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) procedure, public :: set2 Set control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, order, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"type/nurbs_surface.html"},{"title":"nurbs_curve – ForCAD ","text":"type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt (:) evaluation points real(kind=rk), private, allocatable :: knot (:) knot vector integer, private :: nc number of control points integer, private :: ng number of geometry points integer, private :: order order of the curve Type-Bound Procedures procedure, public :: basis private pure subroutine basis (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, public :: create Generate geometry points private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) procedure, public :: derivative private pure subroutine derivative (this, res, Xt, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) procedure, public :: elevate_degree Elevate the degree of the curve private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the Bezier curve object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Get continuity of the curve private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_elem_Xc Generate connectivity for control points private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p procedure, public :: get_elem_Xg Generate connectivity for geometry points private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p procedure, public :: get_knot Get knot vector private pure function get_knot (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Get multiplicity of the knot vector private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of required control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_order Get order of the Bezier curve private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: insert_knot Insert a new knot private pure subroutine insert_knot (this, Xth) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xth (:) procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir generic, public :: set => set1 , set2 private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: knot (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) private pure subroutine set2 (this, Xth_dir, order, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir (:) integer, intent(in) :: order integer, intent(in) :: continuity (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) procedure, public :: set1 Set control points and weights private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: knot (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) procedure, public :: set2 Set control points and weights private pure subroutine set2 (this, Xth_dir, order, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir (:) integer, intent(in) :: order integer, intent(in) :: continuity (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"type/nurbs_curve.html"},{"title":"bezier_curve – ForCAD ","text":"type, public :: bezier_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights real(kind=rk), private, allocatable :: Xc (:,:) Control points real(kind=rk), private, allocatable :: Xg (:,:) Geometry points real(kind=rk), private, allocatable :: Xt (:) Parameter values integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: create Generate geometry points private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Generate geometry points of the Bezier curve. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) procedure, public :: elevate_degree Elevate the degree of the Bezier curve private pure subroutine elevate_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Elevate the degree of the Bezier curve by one. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Export control points to a VTK file. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Export geometry points to a VTK file. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the Bezier curve object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Finalize the Bezier curve object by deallocating memory. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_elem_Xc Generate connectivity for control points private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Generate connectivity for control points. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p procedure, public :: get_elem_Xg Generate connectivity for geometry points private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Generate connectivity for geometry points. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p procedure, public :: get_nc Get number of control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer procedure, public :: get_order Get order of the Bezier curve private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Modify weight of a control point given its index. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Modify coordinate of a control point given its index and direction. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: set Set control points and weights private pure subroutine set (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"type/bezier_curve.html"},{"title":"bezier_surface – ForCAD ","text":"type, public :: bezier_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction integer, private :: nc (2) number of control points in each direction integer, private :: ng (2) number of geometry points in each direction Type-Bound Procedures procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, Xt1, Xt2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the Bezier surface object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_elem_Xc Generate connectivity for control points private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_elem_Xg Generate connectivity for geometry points private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_nc Get number of control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: get_order Get order of the Bezier surface private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Modify weight of a control point given its index. Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Modify coordinate of a control point given its index and direction. Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: set Set control points and weights private pure subroutine set (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this integer, intent(in) :: nc (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"type/bezier_surface.html"},{"title":"bezier_volume – ForCAD ","text":"type, public :: bezier_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction real(kind=rk), private, allocatable :: Xt3 (:) parameter values in the third direction integer, private :: nc (3) number of control points in each direction integer, private :: ng (3) number of geometry points in each direction Type-Bound Procedures procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the Bezier volume object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_elem_Xc Generate connectivity for control points private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_elem_Xg Generate connectivity for geometry points private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_nc Get number of control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: get_order Get order of the Bezier surface private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: set Set control points and weights private pure subroutine set (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this integer, intent(in) :: nc (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Source Code type bezier_volume real ( rk ), allocatable , private :: Xc (:,:) !! control points real ( rk ), allocatable , private :: Xg (:,:) !! geometry points real ( rk ), allocatable , private :: Wc (:) !! weights real ( rk ), allocatable , private :: Xt1 (:) !! parameter values in the first direction real ( rk ), allocatable , private :: Xt2 (:) !! parameter values in the second direction real ( rk ), allocatable , private :: Xt3 (:) !! parameter values in the third direction integer , private :: nc ( 3 ) !! number of control points in each direction integer , private :: ng ( 3 ) !! number of geometry points in each direction contains procedure :: set !!> Set control points and weights procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_nc !!> Get number of control points procedure :: get_ng !!> Get number of geometry points procedure :: get_order !!> Get order of the Bezier surface procedure :: finalize !!> Finalize the Bezier volume object procedure :: get_elem_Xc !!> Generate connectivity for control points procedure :: get_elem_Xg !!> Generate connectivity for geometry points procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights end type bezier_volume","tags":"","loc":"type/bezier_volume.html"},{"title":"nurbs_volume – ForCAD ","text":"type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction real(kind=rk), private, allocatable :: Xt3 (:) parameter values in the third direction real(kind=rk), private, allocatable :: knot1 (:) knot vector real(kind=rk), private, allocatable :: knot2 (:) knot vector real(kind=rk), private, allocatable :: knot3 (:) knot vector integer, private :: nc (3) number of control points in each direction integer, private :: ng (3) number of geometry points in each direction integer, private :: order (3) degree of the first direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS curve private pure subroutine basis (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) procedure, public :: derivative Compute the derivative of the NURBS curve private pure subroutine derivative (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS curve object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Get continuity of the curve private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_elem_Xc Generate connectivity for control points private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_elem_Xg Generate connectivity for geometry points private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) procedure, public :: get_knot Get knot vector private pure function get_knot (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Get multiplicity of the knot vector private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of required control points private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: get_order Get order of the Bezier curve private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir generic, public :: set => set1 , set2 private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: knot3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, order, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) real(kind=rk), intent(in) :: Xth_dir3 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) integer, intent(in) :: continuity3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) procedure, public :: set1 Set control points and weights private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: knot3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) procedure, public :: set2 Set control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, order, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) real(kind=rk), intent(in) :: Xth_dir3 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) integer, intent(in) :: continuity3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"type/nurbs_volume.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), dimension(:,:), allocatable Called by proc~~generate_xc~~CalledByGraph proc~generate_xc generate_Xc program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~generate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), dimension(:,:), allocatable Called by proc~~generate_xc~2~~CalledByGraph proc~generate_xc~2 generate_Xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~generate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~2.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~~CallsGraph proc~get_continuity nurbs_surface%get_continuity proc~compute_multiplicity compute_multiplicity proc~get_continuity->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity.html"},{"title":"get_knot – ForCAD","text":"private pure function get_knot(this, dir) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_knot.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~~CallsGraph proc~get_multiplicity nurbs_surface%get_multiplicity proc~compute_multiplicity compute_multiplicity proc~get_multiplicity->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~~CalledByGraph proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_order nurbs_surface%get_order proc~get_order->proc~get_multiplicity proc~set1 nurbs_surface%set1 proc~set1->proc~get_order none~set nurbs_surface%set none~set->proc~set1 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this, dir) result(nc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc~~CallsGraph proc~get_nc nurbs_surface%get_nc proc~compute_multiplicity compute_multiplicity proc~get_nc->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc~~CalledByGraph proc~get_nc nurbs_surface%get_nc proc~set1 nurbs_surface%set1 proc~set1->proc~get_nc proc~set2 nurbs_surface%set2 proc~set2->proc~get_nc none~set nurbs_surface%set none~set->proc~set1 none~set->proc~set2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2)","tags":"","loc":"proc/get_ng.html"},{"title":"get_order – ForCAD","text":"private pure function get_order(this) result(order) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Calls proc~~get_order~~CallsGraph proc~get_order nurbs_surface%get_order proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_order->proc~get_multiplicity proc~compute_multiplicity compute_multiplicity proc~get_multiplicity->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_order~~CalledByGraph proc~get_order nurbs_surface%get_order proc~set1 nurbs_surface%set1 proc~set1->proc~get_order none~set nurbs_surface%set none~set->proc~set1 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_order.html"},{"title":"basis – ForCAD","text":"private pure subroutine basis(this, res1, res2, Xt1, Xt2, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis~~CallsGraph proc~basis nurbs_surface%basis interface~ndgrid ndgrid proc~basis->interface~ndgrid proc~basis_bspline basis_bspline proc~basis->proc~basis_bspline proc~kron kron proc~basis->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, Xt1, Xt2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) Calls proc~~create~~CallsGraph proc~create nurbs_surface%create interface~ndgrid ndgrid proc~create->interface~ndgrid proc~basis_bspline basis_bspline proc~create->proc~basis_bspline proc~kron kron proc~create->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~~CalledByGraph proc~create nurbs_surface%create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create.html"},{"title":"derivative – ForCAD","text":"private pure subroutine derivative(this, res1, res2, Xt1, Xt2, dTgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) Calls proc~~derivative~~CallsGraph proc~derivative nurbs_surface%derivative interface~ndgrid ndgrid proc~derivative->interface~ndgrid proc~basis_bspline_der basis_bspline_der proc~derivative->proc~basis_bspline_der proc~kron kron proc~derivative->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~~CallsGraph proc~export_xc nurbs_surface%export_Xc proc~get_elem_xc nurbs_surface%get_elem_Xc proc~export_xc->proc~get_elem_xc interface~elemconn_c0 elemConn_C0 proc~get_elem_xc->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~~CalledByGraph proc~export_xc nurbs_surface%export_Xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~~CallsGraph proc~export_xg nurbs_surface%export_Xg proc~get_elem_xg nurbs_surface%get_elem_Xg proc~export_xg->proc~get_elem_xg interface~elemconn_c0 elemConn_C0 proc~get_elem_xg->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~~CalledByGraph proc~export_xg nurbs_surface%export_Xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this Called by proc~~finalize~~CalledByGraph proc~finalize nurbs_surface%finalize program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize.html"},{"title":"get_elem_Xc – ForCAD","text":"private pure subroutine get_elem_Xc(this, elemConn, p) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xc~~CallsGraph proc~get_elem_xc nurbs_surface%get_elem_Xc interface~elemconn_c0 elemConn_C0 proc~get_elem_xc->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xc~~CalledByGraph proc~get_elem_xc nurbs_surface%get_elem_Xc proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~get_elem_xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xc.html"},{"title":"get_elem_Xg – ForCAD","text":"private pure subroutine get_elem_Xg(this, elemConn, p) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xg~~CallsGraph proc~get_elem_xg nurbs_surface%get_elem_Xg interface~elemconn_c0 elemConn_C0 proc~get_elem_xg->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xg~~CalledByGraph proc~get_elem_xg nurbs_surface%get_elem_Xg proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~get_elem_xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xg.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~~CallsGraph proc~modify_wc nurbs_surface%modify_Wc none~set nurbs_surface%set proc~modify_wc->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~get_order nurbs_surface%get_order proc~set1->proc~get_order proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc->proc~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_order->proc~get_multiplicity proc~get_multiplicity->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~~CallsGraph proc~modify_xc nurbs_surface%modify_Xc none~set nurbs_surface%set proc~modify_xc->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~get_order nurbs_surface%get_order proc~set1->proc~get_order proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc->proc~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_order->proc~get_multiplicity proc~get_multiplicity->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, Xc, Wc) Set control points and weights for the NURBS surface object. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Calls proc~~set1~~CallsGraph proc~set1 nurbs_surface%set1 proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~get_order nurbs_surface%get_order proc~set1->proc~get_order proc~compute_multiplicity compute_multiplicity proc~get_nc->proc~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_order->proc~get_multiplicity proc~get_multiplicity->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~~CalledByGraph proc~set1 nurbs_surface%set1 none~set nurbs_surface%set none~set->proc~set1 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, order, continuity1, continuity2, Xc, Wc) Set control points and weights for the NURBS surface object. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Calls proc~~set2~~CallsGraph proc~set2 nurbs_surface%set2 proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~get_nc nurbs_surface%get_nc proc~set2->proc~get_nc proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~~CalledByGraph proc~set2 nurbs_surface%set2 none~set nurbs_surface%set none~set->proc~set2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2.html"},{"title":"bincoeff – ForCAD","text":"private pure function bincoeff(n, k) result(b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) Calls proc~~bincoeff~~CallsGraph proc~bincoeff bincoeff proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bincoeff~~CalledByGraph proc~bincoeff bincoeff proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->proc~bincoeff program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/bincoeff.html"},{"title":"factln – ForCAD","text":"private pure function factln(n) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~factln~~CalledByGraph proc~factln factln proc~bincoeff bincoeff proc~bincoeff->proc~factln proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->proc~bincoeff program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/factln.html"},{"title":"findspan – ForCAD","text":"private pure function findspan(n, order, Xth, knot) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: order real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in) :: knot (:) Return Value integer Called by proc~~findspan~~CalledByGraph proc~findspan findspan proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->proc~findspan program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~insert_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/findspan.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc~2.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc~2.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg~2.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this) result(Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~2.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this) result(c) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_continuity~2~~CallsGraph proc~get_continuity~2 nurbs_curve%get_continuity proc~compute_multiplicity compute_multiplicity proc~get_continuity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity~2.html"},{"title":"get_knot – ForCAD","text":"private pure function get_knot(this) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_knot~2.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this) result(m) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~2~~CallsGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~2~~CalledByGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2 nurbs_curve%get_order proc~get_order~2->proc~get_multiplicity~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~get_order~2 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->none~set~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity~2.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Calls proc~~get_nc~2~~CallsGraph proc~get_nc~2 nurbs_curve%get_nc proc~compute_multiplicity compute_multiplicity proc~get_nc~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc~2.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer","tags":"","loc":"proc/get_ng~2.html"},{"title":"get_order – ForCAD","text":"private pure function get_order(this) result(order) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Calls proc~~get_order~2~~CallsGraph proc~get_order~2 nurbs_curve%get_order proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2->proc~get_multiplicity~2 proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_order~2~~CalledByGraph proc~get_order~2 nurbs_curve%get_order proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~get_order~2 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->none~set~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_order~2.html"},{"title":"basis – ForCAD","text":"private pure subroutine basis(this, res, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis~2~~CallsGraph proc~basis~2 nurbs_curve%basis proc~basis_bspline basis_bspline proc~basis~2->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis~2.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res, Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) Calls proc~~create~2~~CallsGraph proc~create~2 nurbs_curve%create proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~2~~CalledByGraph proc~create~2 nurbs_curve%create proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->proc~create~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~2.html"},{"title":"derivative – ForCAD","text":"private pure subroutine derivative(this, res, Xt, dTgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) Calls proc~~derivative~2~~CallsGraph proc~derivative~2 nurbs_curve%derivative proc~basis_bspline_der basis_bspline_der proc~derivative~2->proc~basis_bspline_der proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative~2.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, t) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t Calls proc~~elevate_degree~~CallsGraph proc~elevate_degree nurbs_curve%elevate_degree none~set~2 nurbs_curve%set proc~elevate_degree->none~set~2 proc~bincoeff bincoeff proc~elevate_degree->proc~bincoeff proc~compute_multiplicity compute_multiplicity proc~elevate_degree->proc~compute_multiplicity proc~create~2 nurbs_curve%create proc~elevate_degree->proc~create~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~factln factln proc~bincoeff->proc~factln proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline proc~get_order~2 nurbs_curve%get_order proc~set1~2->proc~get_order~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2->proc~get_multiplicity~2 proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~~CalledByGraph proc~elevate_degree nurbs_curve%elevate_degree program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~2~~CallsGraph proc~export_xc~2 nurbs_curve%export_Xc proc~get_elem_xc~2 nurbs_curve%get_elem_Xc proc~export_xc~2->proc~get_elem_xc~2 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~2~~CalledByGraph proc~export_xc~2 nurbs_curve%export_Xc program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~2.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~2~~CallsGraph proc~export_xg~2 nurbs_curve%export_Xg proc~get_elem_xg~2 nurbs_curve%get_elem_Xg proc~export_xg~2->proc~get_elem_xg~2 interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~2~~CalledByGraph proc~export_xg~2 nurbs_curve%export_Xg program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~2.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Called by proc~~finalize~2~~CalledByGraph proc~finalize~2 nurbs_curve%finalize program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~finalize~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~2.html"},{"title":"get_elem_Xc – ForCAD","text":"private pure subroutine get_elem_Xc(this, elemConn, p) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p Calls proc~~get_elem_xc~2~~CallsGraph proc~get_elem_xc~2 nurbs_curve%get_elem_Xc interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xc~2~~CalledByGraph proc~get_elem_xc~2 nurbs_curve%get_elem_Xc proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~get_elem_xc~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xc~2.html"},{"title":"get_elem_Xg – ForCAD","text":"private pure subroutine get_elem_Xg(this, elemConn, p) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p Calls proc~~get_elem_xg~2~~CallsGraph proc~get_elem_xg~2 nurbs_curve%get_elem_Xg interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xg~2~~CalledByGraph proc~get_elem_xg~2 nurbs_curve%get_elem_Xg proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~get_elem_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xg~2.html"},{"title":"insert_knot – ForCAD","text":"private pure subroutine insert_knot(this, Xth) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xth (:) Calls proc~~insert_knot~~CallsGraph proc~insert_knot nurbs_curve%insert_knot none~set~2 nurbs_curve%set proc~insert_knot->none~set~2 proc~create~2 nurbs_curve%create proc~insert_knot->proc~create~2 proc~findspan findspan proc~insert_knot->proc~findspan proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline proc~get_order~2 nurbs_curve%get_order proc~set1~2->proc~get_order~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2->proc~get_multiplicity~2 proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knot~~CalledByGraph proc~insert_knot nurbs_curve%insert_knot program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~insert_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knot.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~2~~CallsGraph proc~modify_wc~2 nurbs_curve%modify_Wc none~set~2 nurbs_curve%set proc~modify_wc~2->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~get_order~2 nurbs_curve%get_order proc~set1~2->proc~get_order~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2->proc~get_multiplicity~2 proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~2.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~2~~CallsGraph proc~modify_xc~2 nurbs_curve%modify_Xc none~set~2 nurbs_curve%set proc~modify_xc~2->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~get_order~2 nurbs_curve%get_order proc~set1~2->proc~get_order~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2->proc~get_multiplicity~2 proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~2.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot, Xc, Wc) Set control points and weights for the Bezier curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: knot (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Calls proc~~set1~2~~CallsGraph proc~set1~2 nurbs_curve%set1 proc~get_order~2 nurbs_curve%get_order proc~set1~2->proc~get_order~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2->proc~get_multiplicity~2 proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~2~~CalledByGraph proc~set1~2 nurbs_curve%set1 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->none~set~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1~2.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir, order, continuity, Xc, Wc) Set control points and weights for the Bezier curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir (:) integer, intent(in) :: order integer, intent(in) :: continuity (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Calls proc~~set2~2~~CallsGraph proc~set2~2 nurbs_curve%set2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~2~~CalledByGraph proc~set2~2 nurbs_curve%set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->none~set~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2~2.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc~3.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc~3.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg~3.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this) result(Xt) Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~3.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer","tags":"","loc":"proc/get_nc~3.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer","tags":"","loc":"proc/get_ng~3.html"},{"title":"get_order – ForCAD","text":"private pure function get_order(this) result(order) Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer","tags":"","loc":"proc/get_order~3.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res, Xt) Generate geometry points of the Bezier curve. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) Calls proc~~create~3~~CallsGraph proc~create~3 bezier_curve%create proc~basis_bernstein basis_bernstein proc~create~3->proc~basis_bernstein Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~3~~CalledByGraph proc~create~3 bezier_curve%create proc~elevate_degree~2 bezier_curve%elevate_degree proc~elevate_degree~2->proc~create~3 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~create~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~3.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this) Elevate the degree of the Bezier curve by one. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this Calls proc~~elevate_degree~2~~CallsGraph proc~elevate_degree~2 bezier_curve%elevate_degree proc~create~3 bezier_curve%create proc~elevate_degree~2->proc~create~3 proc~set bezier_curve%set proc~elevate_degree~2->proc~set proc~basis_bernstein basis_bernstein proc~create~3->proc~basis_bernstein Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree~2.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Export control points to a VTK file. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~3~~CallsGraph proc~export_xc~3 bezier_curve%export_Xc proc~get_elem_xc~3 bezier_curve%get_elem_Xc proc~export_xc~3->proc~get_elem_xc~3 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~3~~CalledByGraph proc~export_xc~3 bezier_curve%export_Xc program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~3.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Export geometry points to a VTK file. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~3~~CallsGraph proc~export_xg~3 bezier_curve%export_Xg proc~get_elem_xg~3 bezier_curve%get_elem_Xg proc~export_xg~3->proc~get_elem_xg~3 interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~3~~CalledByGraph proc~export_xg~3 bezier_curve%export_Xg program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~3.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Finalize the Bezier curve object by deallocating memory. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this Called by proc~~finalize~3~~CalledByGraph proc~finalize~3 bezier_curve%finalize program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~finalize~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~3.html"},{"title":"get_elem_Xc – ForCAD","text":"private pure subroutine get_elem_Xc(this, elemConn, p) Generate connectivity for control points. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p Calls proc~~get_elem_xc~3~~CallsGraph proc~get_elem_xc~3 bezier_curve%get_elem_Xc interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xc~3~~CalledByGraph proc~get_elem_xc~3 bezier_curve%get_elem_Xc proc~export_xc~3 bezier_curve%export_Xc proc~export_xc~3->proc~get_elem_xc~3 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xc~3.html"},{"title":"get_elem_Xg – ForCAD","text":"private pure subroutine get_elem_Xg(this, elemConn, p) Generate connectivity for geometry points. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p Calls proc~~get_elem_xg~3~~CallsGraph proc~get_elem_xg~3 bezier_curve%get_elem_Xg interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xg~3~~CalledByGraph proc~get_elem_xg~3 bezier_curve%get_elem_Xg proc~export_xg~3 bezier_curve%export_Xg proc~export_xg~3->proc~get_elem_xg~3 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xg~3.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Modify weight of a control point given its index. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~3~~CallsGraph proc~modify_wc~3 bezier_curve%modify_Wc proc~set bezier_curve%set proc~modify_wc~3->proc~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~3.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Modify coordinate of a control point given its index and direction. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~3~~CallsGraph proc~modify_xc~3 bezier_curve%modify_Xc proc~set bezier_curve%set proc~modify_xc~3->proc~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~3.html"},{"title":"set – ForCAD","text":"private pure subroutine set(this, Xc, Wc) Set control points and weights for the Bezier curve object. Type Bound bezier_curve Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Called by proc~~set~~CalledByGraph proc~set bezier_curve%set proc~elevate_degree~2 bezier_curve%elevate_degree proc~elevate_degree~2->proc~set proc~modify_wc~3 bezier_curve%modify_Wc proc~modify_wc~3->proc~set proc~modify_xc~3 bezier_curve%modify_Xc proc~modify_xc~3->proc~set program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set.html"},{"title":"basis_bernstein – ForCAD","text":"public pure function basis_bernstein(Xt, nc) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) Called by proc~~basis_bernstein~~CalledByGraph proc~basis_bernstein basis_bernstein proc~create~3 bezier_curve%create proc~create~3->proc~basis_bernstein proc~create~4 bezier_surface%create proc~create~4->proc~basis_bernstein proc~create~5 bezier_volume%create proc~create~5->proc~basis_bernstein proc~elevate_degree~2 bezier_curve%elevate_degree proc~elevate_degree~2->proc~create~3 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~create~3 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~create~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~create~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bernstein.html"},{"title":"basis_bspline – ForCAD","text":"public pure function basis_bspline(Xt, knot, nc, order) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in) :: knot (:) integer, intent(in) :: nc integer, intent(in) :: order Return Value real(kind=rk), allocatable, (:) Called by proc~~basis_bspline~~CalledByGraph proc~basis_bspline basis_bspline proc~basis nurbs_surface%basis proc~basis->proc~basis_bspline proc~basis~2 nurbs_curve%basis proc~basis~2->proc~basis_bspline proc~basis~3 nurbs_volume%basis proc~basis~3->proc~basis_bspline proc~create nurbs_surface%create proc~create->proc~basis_bspline proc~create~2 nurbs_curve%create proc~create~2->proc~basis_bspline proc~create~6 nurbs_volume%create proc~create~6->proc~basis_bspline proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->proc~create~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bspline.html"},{"title":"basis_bspline_der – ForCAD","text":"public pure function basis_bspline_der(Xt, knot, nc, order) result(dB) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in) :: knot (:) integer, intent(in) :: nc integer, intent(in) :: order Return Value real(kind=rk), allocatable, (:) Calls proc~~basis_bspline_der~~CallsGraph proc~basis_bspline_der basis_bspline_der proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_bspline_der~~CalledByGraph proc~basis_bspline_der basis_bspline_der proc~derivative nurbs_surface%derivative proc~derivative->proc~basis_bspline_der proc~derivative~2 nurbs_curve%derivative proc~derivative~2->proc~basis_bspline_der proc~derivative~3 nurbs_volume%derivative proc~derivative~3->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bspline_der.html"},{"title":"compute_knot_vector – ForCAD","text":"public pure function compute_knot_vector(Xth_dir, order, continuity) result(knot) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xth_dir (:) integer, intent(in) :: order integer, intent(in) :: continuity (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_knot_vector~~CallsGraph proc~compute_knot_vector compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_knot_vector~~CalledByGraph proc~compute_knot_vector compute_knot_vector proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~6 nurbs_volume%set none~set~6->proc~set2~3 proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->none~set~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->none~set~2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_knot_vector.html"},{"title":"compute_multiplicity – ForCAD","text":"public pure function compute_multiplicity(knot) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: knot (:) Return Value integer, dimension(:), allocatable Called by proc~~compute_multiplicity~~CalledByGraph proc~compute_multiplicity compute_multiplicity proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->proc~compute_multiplicity none~set~2 nurbs_curve%set proc~elevate_degree->none~set~2 proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->proc~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->proc~compute_multiplicity proc~get_continuity~3 nurbs_volume%get_continuity proc~get_continuity~3->proc~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->proc~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->proc~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_multiplicity~3->proc~compute_multiplicity proc~get_nc nurbs_surface%get_nc proc~get_nc->proc~compute_multiplicity proc~get_nc~2 nurbs_curve%get_nc proc~get_nc~2->proc~compute_multiplicity proc~get_nc~6 nurbs_volume%get_nc proc~get_nc~6->proc~compute_multiplicity proc~get_order nurbs_surface%get_order proc~get_order->proc~get_multiplicity proc~get_order~2 nurbs_curve%get_order proc~get_order~2->proc~get_multiplicity~2 proc~get_order~6 nurbs_volume%get_order proc~get_order~6->proc~get_multiplicity~3 proc~set1 nurbs_surface%set1 proc~set1->proc~get_nc proc~set1->proc~get_order proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~get_nc~6 proc~set1~3->proc~get_order~6 proc~set2 nurbs_surface%set2 proc~set2->proc~get_nc proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~get_nc~6 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->none~set~2 proc~insert_knot nurbs_curve%insert_knot program~example_nurbs_curve->proc~insert_knot none~set nurbs_surface%set none~set->proc~set1 none~set->proc~set2 none~set~6 nurbs_volume%set none~set~6->proc~set1~3 none~set~6->proc~set2~3 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~get_order~2 none~set~2->proc~set1~2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 proc~insert_knot->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_multiplicity.html"},{"title":"kron – ForCAD","text":"public pure function kron(u, v) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk), dimension(size(u)*size(v)) Called by proc~~kron~~CalledByGraph proc~kron kron proc~basis nurbs_surface%basis proc~basis->proc~kron proc~basis~3 nurbs_volume%basis proc~basis~3->proc~kron proc~create nurbs_surface%create proc~create->proc~kron proc~create~4 bezier_surface%create proc~create~4->proc~kron proc~create~5 bezier_volume%create proc~create~5->proc~kron proc~create~6 nurbs_volume%create proc~create~6->proc~kron proc~derivative nurbs_surface%derivative proc~derivative->proc~kron proc~derivative~3 nurbs_volume%derivative proc~derivative~3->proc~kron program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~create~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~create~5 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/kron.html"},{"title":"cmp_elemConn_C0_L – ForCAD","text":"private pure function cmp_elemConn_C0_L(nnode, p) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, dimension(:,:), allocatable Called by proc~~cmp_elemconn_c0_l~~CalledByGraph proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~get_elem_xc nurbs_surface%get_elem_Xc proc~get_elem_xc->interface~elemconn_c0 proc~get_elem_xc~2 nurbs_curve%get_elem_Xc proc~get_elem_xc~2->interface~elemconn_c0 proc~get_elem_xc~3 bezier_curve%get_elem_Xc proc~get_elem_xc~3->interface~elemconn_c0 proc~get_elem_xc~4 bezier_surface%get_elem_Xc proc~get_elem_xc~4->interface~elemconn_c0 proc~get_elem_xc~5 bezier_volume%get_elem_Xc proc~get_elem_xc~5->interface~elemconn_c0 proc~get_elem_xc~6 nurbs_volume%get_elem_Xc proc~get_elem_xc~6->interface~elemconn_c0 proc~get_elem_xg nurbs_surface%get_elem_Xg proc~get_elem_xg->interface~elemconn_c0 proc~get_elem_xg~2 nurbs_curve%get_elem_Xg proc~get_elem_xg~2->interface~elemconn_c0 proc~get_elem_xg~3 bezier_curve%get_elem_Xg proc~get_elem_xg~3->interface~elemconn_c0 proc~get_elem_xg~4 bezier_surface%get_elem_Xg proc~get_elem_xg~4->interface~elemconn_c0 proc~get_elem_xg~5 bezier_volume%get_elem_Xg proc~get_elem_xg~5->interface~elemconn_c0 proc~get_elem_xg~6 nurbs_volume%get_elem_Xg proc~get_elem_xg~6->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~get_elem_xc proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~get_elem_xc~2 proc~export_xc~3 bezier_curve%export_Xc proc~export_xc~3->proc~get_elem_xc~3 proc~export_xc~4 bezier_surface%export_Xc proc~export_xc~4->proc~get_elem_xc~4 proc~export_xc~5 bezier_volume%export_Xc proc~export_xc~5->proc~get_elem_xc~5 proc~export_xc~6 nurbs_volume%export_Xc proc~export_xc~6->proc~get_elem_xc~6 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~get_elem_xg proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~get_elem_xg~2 proc~export_xg~3 bezier_curve%export_Xg proc~export_xg~3->proc~get_elem_xg~3 proc~export_xg~4 bezier_surface%export_Xg proc~export_xg~4->proc~get_elem_xg~4 proc~export_xg~5 bezier_volume%export_Xg proc~export_xg~5->proc~get_elem_xg~5 proc~export_xg~6 nurbs_volume%export_Xg proc~export_xg~6->proc~get_elem_xg~6 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xc~3 program~example_bezier_curve->proc~export_xg~3 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xc~4 program~example_bezier_surface->proc~export_xg~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xc~5 program~example_bezier_volume->proc~export_xg~5 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~6 program~example_nurbs_volume->proc~export_xg~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_l.html"},{"title":"cmp_elemConn_C0_S – ForCAD","text":"private pure function cmp_elemConn_C0_S(nnode1, nnode2, p1, p2) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, dimension(:,:), allocatable Called by proc~~cmp_elemconn_c0_s~~CalledByGraph proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~get_elem_xc nurbs_surface%get_elem_Xc proc~get_elem_xc->interface~elemconn_c0 proc~get_elem_xc~2 nurbs_curve%get_elem_Xc proc~get_elem_xc~2->interface~elemconn_c0 proc~get_elem_xc~3 bezier_curve%get_elem_Xc proc~get_elem_xc~3->interface~elemconn_c0 proc~get_elem_xc~4 bezier_surface%get_elem_Xc proc~get_elem_xc~4->interface~elemconn_c0 proc~get_elem_xc~5 bezier_volume%get_elem_Xc proc~get_elem_xc~5->interface~elemconn_c0 proc~get_elem_xc~6 nurbs_volume%get_elem_Xc proc~get_elem_xc~6->interface~elemconn_c0 proc~get_elem_xg nurbs_surface%get_elem_Xg proc~get_elem_xg->interface~elemconn_c0 proc~get_elem_xg~2 nurbs_curve%get_elem_Xg proc~get_elem_xg~2->interface~elemconn_c0 proc~get_elem_xg~3 bezier_curve%get_elem_Xg proc~get_elem_xg~3->interface~elemconn_c0 proc~get_elem_xg~4 bezier_surface%get_elem_Xg proc~get_elem_xg~4->interface~elemconn_c0 proc~get_elem_xg~5 bezier_volume%get_elem_Xg proc~get_elem_xg~5->interface~elemconn_c0 proc~get_elem_xg~6 nurbs_volume%get_elem_Xg proc~get_elem_xg~6->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~get_elem_xc proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~get_elem_xc~2 proc~export_xc~3 bezier_curve%export_Xc proc~export_xc~3->proc~get_elem_xc~3 proc~export_xc~4 bezier_surface%export_Xc proc~export_xc~4->proc~get_elem_xc~4 proc~export_xc~5 bezier_volume%export_Xc proc~export_xc~5->proc~get_elem_xc~5 proc~export_xc~6 nurbs_volume%export_Xc proc~export_xc~6->proc~get_elem_xc~6 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~get_elem_xg proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~get_elem_xg~2 proc~export_xg~3 bezier_curve%export_Xg proc~export_xg~3->proc~get_elem_xg~3 proc~export_xg~4 bezier_surface%export_Xg proc~export_xg~4->proc~get_elem_xg~4 proc~export_xg~5 bezier_volume%export_Xg proc~export_xg~5->proc~get_elem_xg~5 proc~export_xg~6 nurbs_volume%export_Xg proc~export_xg~6->proc~get_elem_xg~6 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xc~3 program~example_bezier_curve->proc~export_xg~3 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xc~4 program~example_bezier_surface->proc~export_xg~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xc~5 program~example_bezier_volume->proc~export_xg~5 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~6 program~example_nurbs_volume->proc~export_xg~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_s.html"},{"title":"cmp_elemConn_C0_V – ForCAD","text":"private pure function cmp_elemConn_C0_V(nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, dimension(:,:), allocatable Called by proc~~cmp_elemconn_c0_v~~CalledByGraph proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_elem_xc nurbs_surface%get_elem_Xc proc~get_elem_xc->interface~elemconn_c0 proc~get_elem_xc~2 nurbs_curve%get_elem_Xc proc~get_elem_xc~2->interface~elemconn_c0 proc~get_elem_xc~3 bezier_curve%get_elem_Xc proc~get_elem_xc~3->interface~elemconn_c0 proc~get_elem_xc~4 bezier_surface%get_elem_Xc proc~get_elem_xc~4->interface~elemconn_c0 proc~get_elem_xc~5 bezier_volume%get_elem_Xc proc~get_elem_xc~5->interface~elemconn_c0 proc~get_elem_xc~6 nurbs_volume%get_elem_Xc proc~get_elem_xc~6->interface~elemconn_c0 proc~get_elem_xg nurbs_surface%get_elem_Xg proc~get_elem_xg->interface~elemconn_c0 proc~get_elem_xg~2 nurbs_curve%get_elem_Xg proc~get_elem_xg~2->interface~elemconn_c0 proc~get_elem_xg~3 bezier_curve%get_elem_Xg proc~get_elem_xg~3->interface~elemconn_c0 proc~get_elem_xg~4 bezier_surface%get_elem_Xg proc~get_elem_xg~4->interface~elemconn_c0 proc~get_elem_xg~5 bezier_volume%get_elem_Xg proc~get_elem_xg~5->interface~elemconn_c0 proc~get_elem_xg~6 nurbs_volume%get_elem_Xg proc~get_elem_xg~6->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~get_elem_xc proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~get_elem_xc~2 proc~export_xc~3 bezier_curve%export_Xc proc~export_xc~3->proc~get_elem_xc~3 proc~export_xc~4 bezier_surface%export_Xc proc~export_xc~4->proc~get_elem_xc~4 proc~export_xc~5 bezier_volume%export_Xc proc~export_xc~5->proc~get_elem_xc~5 proc~export_xc~6 nurbs_volume%export_Xc proc~export_xc~6->proc~get_elem_xc~6 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~get_elem_xg proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~get_elem_xg~2 proc~export_xg~3 bezier_curve%export_Xg proc~export_xg~3->proc~get_elem_xg~3 proc~export_xg~4 bezier_surface%export_Xg proc~export_xg~4->proc~get_elem_xg~4 proc~export_xg~5 bezier_volume%export_Xg proc~export_xg~5->proc~get_elem_xg~5 proc~export_xg~6 nurbs_volume%export_Xg proc~export_xg~6->proc~get_elem_xg~6 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xc~3 program~example_bezier_curve->proc~export_xg~3 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xc~4 program~example_bezier_surface->proc~export_xg~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xc~5 program~example_bezier_volume->proc~export_xg~5 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~6 program~example_nurbs_volume->proc~export_xg~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_v.html"},{"title":"isinf – ForCAD","text":"private pure elemental function isinf(x) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical Called by proc~~isinf~~CalledByGraph proc~isinf isinf proc~basis_bspline_der basis_bspline_der proc~basis_bspline_der->proc~isinf proc~derivative nurbs_surface%derivative proc~derivative->proc~basis_bspline_der proc~derivative~2 nurbs_curve%derivative proc~derivative~2->proc~basis_bspline_der proc~derivative~3 nurbs_volume%derivative proc~derivative~3->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/isinf.html"},{"title":"repelem – ForCAD","text":"private pure function repelem(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: a integer, intent(in), dimension(:), contiguous :: b Return Value real(kind=rk), dimension(sum(b)) Called by proc~~repelem~~CalledByGraph proc~repelem repelem proc~compute_knot_vector compute_knot_vector proc~compute_knot_vector->proc~repelem proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~6 nurbs_volume%set none~set~6->proc~set2~3 proc~elevate_degree nurbs_curve%elevate_degree proc~elevate_degree->none~set~2 proc~insert_knot nurbs_curve%insert_knot proc~insert_knot->none~set~2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_curve->proc~elevate_degree program~example_nurbs_curve->proc~insert_knot program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function repelem ( a , b ) result ( c ) real ( rk ), dimension (:), intent ( in ), contiguous :: a integer , dimension (:), intent ( in ), contiguous :: b real ( rk ), dimension ( sum ( b )) :: c integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function repelem","tags":"","loc":"proc/repelem.html"},{"title":"ndgrid2 – ForCAD","text":"private pure subroutine ndgrid2(X_dir1, X_dir2, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt Called by proc~~ndgrid2~~CalledByGraph proc~ndgrid2 ndgrid2 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid2 proc~basis nurbs_surface%basis proc~basis->interface~ndgrid proc~basis~3 nurbs_volume%basis proc~basis~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~4 bezier_surface%create proc~create~4->interface~ndgrid proc~create~5 bezier_volume%create proc~create~5->interface~ndgrid proc~create~6 nurbs_volume%create proc~create~6->interface~ndgrid proc~derivative nurbs_surface%derivative proc~derivative->interface~ndgrid proc~derivative~3 nurbs_volume%derivative proc~derivative~3->interface~ndgrid program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~create~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~create~5 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid2.html"},{"title":"ndgrid3 – ForCAD","text":"private pure subroutine ndgrid3(X_dir1, X_dir2, X_dir3, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir3 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt Called by proc~~ndgrid3~~CalledByGraph proc~ndgrid3 ndgrid3 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid3 proc~basis nurbs_surface%basis proc~basis->interface~ndgrid proc~basis~3 nurbs_volume%basis proc~basis~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~4 bezier_surface%create proc~create~4->interface~ndgrid proc~create~5 bezier_volume%create proc~create~5->interface~ndgrid proc~create~6 nurbs_volume%create proc~create~6->interface~ndgrid proc~derivative nurbs_surface%derivative proc~derivative->interface~ndgrid proc~derivative~3 nurbs_volume%derivative proc~derivative~3->interface~ndgrid program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~create~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~create~5 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid3.html"},{"title":"elemConn_C0 – ForCAD","text":"public interface elemConn_C0 Calls interface~~elemconn_c0~~CallsGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_c0~~CalledByGraph interface~elemconn_c0 elemConn_C0 proc~get_elem_xc nurbs_surface%get_elem_Xc proc~get_elem_xc->interface~elemconn_c0 proc~get_elem_xc~2 nurbs_curve%get_elem_Xc proc~get_elem_xc~2->interface~elemconn_c0 proc~get_elem_xc~3 bezier_curve%get_elem_Xc proc~get_elem_xc~3->interface~elemconn_c0 proc~get_elem_xc~4 bezier_surface%get_elem_Xc proc~get_elem_xc~4->interface~elemconn_c0 proc~get_elem_xc~5 bezier_volume%get_elem_Xc proc~get_elem_xc~5->interface~elemconn_c0 proc~get_elem_xc~6 nurbs_volume%get_elem_Xc proc~get_elem_xc~6->interface~elemconn_c0 proc~get_elem_xg nurbs_surface%get_elem_Xg proc~get_elem_xg->interface~elemconn_c0 proc~get_elem_xg~2 nurbs_curve%get_elem_Xg proc~get_elem_xg~2->interface~elemconn_c0 proc~get_elem_xg~3 bezier_curve%get_elem_Xg proc~get_elem_xg~3->interface~elemconn_c0 proc~get_elem_xg~4 bezier_surface%get_elem_Xg proc~get_elem_xg~4->interface~elemconn_c0 proc~get_elem_xg~5 bezier_volume%get_elem_Xg proc~get_elem_xg~5->interface~elemconn_c0 proc~get_elem_xg~6 nurbs_volume%get_elem_Xg proc~get_elem_xg~6->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~get_elem_xc proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~get_elem_xc~2 proc~export_xc~3 bezier_curve%export_Xc proc~export_xc~3->proc~get_elem_xc~3 proc~export_xc~4 bezier_surface%export_Xc proc~export_xc~4->proc~get_elem_xc~4 proc~export_xc~5 bezier_volume%export_Xc proc~export_xc~5->proc~get_elem_xc~5 proc~export_xc~6 nurbs_volume%export_Xc proc~export_xc~6->proc~get_elem_xc~6 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~get_elem_xg proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~get_elem_xg~2 proc~export_xg~3 bezier_curve%export_Xg proc~export_xg~3->proc~get_elem_xg~3 proc~export_xg~4 bezier_surface%export_Xg proc~export_xg~4->proc~get_elem_xg~4 proc~export_xg~5 bezier_volume%export_Xg proc~export_xg~5->proc~get_elem_xg~5 proc~export_xg~6 nurbs_volume%export_Xg proc~export_xg~6->proc~get_elem_xg~6 program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~export_xc~3 program~example_bezier_curve->proc~export_xg~3 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xc~4 program~example_bezier_surface->proc~export_xg~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xc~5 program~example_bezier_volume->proc~export_xg~5 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~6 program~example_nurbs_volume->proc~export_xg~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, dimension(:,:), allocatable private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, dimension(:,:), allocatable private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, dimension(:,:), allocatable","tags":"","loc":"interface/elemconn_c0.html"},{"title":"ndgrid – ForCAD","text":"public interface ndgrid Calls interface~~ndgrid~~CallsGraph interface~ndgrid ndgrid proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~ndgrid~~CalledByGraph interface~ndgrid ndgrid proc~basis nurbs_surface%basis proc~basis->interface~ndgrid proc~basis~3 nurbs_volume%basis proc~basis~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~4 bezier_surface%create proc~create~4->interface~ndgrid proc~create~5 bezier_volume%create proc~create~5->interface~ndgrid proc~create~6 nurbs_volume%create proc~create~6->interface~ndgrid proc~derivative nurbs_surface%derivative proc~derivative->interface~ndgrid proc~derivative~3 nurbs_volume%derivative proc~derivative~3->interface~ndgrid program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~create~4 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~create~5 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir3 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt","tags":"","loc":"interface/ndgrid.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc~4.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc~4.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg~4.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~4.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2)","tags":"","loc":"proc/get_nc~4.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2)","tags":"","loc":"proc/get_ng~4.html"},{"title":"get_order – ForCAD","text":"private pure function get_order(this) result(order) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2)","tags":"","loc":"proc/get_order~4.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, Xt1, Xt2) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) Calls proc~~create~4~~CallsGraph proc~create~4 bezier_surface%create interface~ndgrid ndgrid proc~create~4->interface~ndgrid proc~basis_bernstein basis_bernstein proc~create~4->proc~basis_bernstein proc~kron kron proc~create~4->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~4~~CalledByGraph proc~create~4 bezier_surface%create program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~create~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine create ( this , res1 , res2 , Xt1 , Xt2 ) class ( bezier_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:) integer :: i , j real ( rk ), dimension (:), allocatable :: Tgc1 , Tgc2 , Tgc real ( rk ), dimension (:,:), allocatable :: Xt ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng ( 1 ) * this % ng ( 2 ), size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then ! Rational Bezier surface do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bernstein ( Xt ( i , 1 ), this % nc ( 1 )) Tgc2 = basis_bernstein ( Xt ( i , 2 ), this % nc ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else ! Non-rational Bezier surface do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bernstein ( Xt ( i , 1 ), this % nc ( 1 )) Tgc2 = basis_bernstein ( Xt ( i , 2 ), this % nc ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine create","tags":"","loc":"proc/create~4.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~4~~CallsGraph proc~export_xc~4 bezier_surface%export_Xc proc~get_elem_xc~4 bezier_surface%get_elem_Xc proc~export_xc~4->proc~get_elem_xc~4 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~4->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~4~~CalledByGraph proc~export_xc~4 bezier_surface%export_Xc program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~4.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~4~~CallsGraph proc~export_xg~4 bezier_surface%export_Xg proc~get_elem_xg~4 bezier_surface%get_elem_Xg proc~export_xg~4->proc~get_elem_xg~4 interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~4->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~4~~CalledByGraph proc~export_xg~4 bezier_surface%export_Xg program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xg~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~4.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this Called by proc~~finalize~4~~CalledByGraph proc~finalize~4 bezier_surface%finalize program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~finalize~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~4.html"},{"title":"get_elem_Xc – ForCAD","text":"private pure subroutine get_elem_Xc(this, elemConn, p) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xc~4~~CallsGraph proc~get_elem_xc~4 bezier_surface%get_elem_Xc interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~4->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xc~4~~CalledByGraph proc~get_elem_xc~4 bezier_surface%get_elem_Xc proc~export_xc~4 bezier_surface%export_Xc proc~export_xc~4->proc~get_elem_xc~4 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xc~4.html"},{"title":"get_elem_Xg – ForCAD","text":"private pure subroutine get_elem_Xg(this, elemConn, p) Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xg~4~~CallsGraph proc~get_elem_xg~4 bezier_surface%get_elem_Xg interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~4->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xg~4~~CalledByGraph proc~get_elem_xg~4 bezier_surface%get_elem_Xg proc~export_xg~4 bezier_surface%export_Xg proc~export_xg~4->proc~get_elem_xg~4 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~export_xg~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xg~4.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Modify weight of a control point given its index. Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~4~~CallsGraph proc~modify_wc~4 bezier_surface%modify_Wc proc~set~2 bezier_surface%set proc~modify_wc~4->proc~set~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~4.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Modify coordinate of a control point given its index and direction. Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~4~~CallsGraph proc~modify_xc~4 bezier_surface%modify_Xc proc~set~2 bezier_surface%set proc~modify_xc~4->proc~set~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~4.html"},{"title":"set – ForCAD","text":"private pure subroutine set(this, nc, Xc, Wc) Set control points and weights for the Bezier curve object. Type Bound bezier_surface Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this integer, intent(in) :: nc (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Called by proc~~set~2~~CalledByGraph proc~set~2 bezier_surface%set proc~modify_wc~4 bezier_surface%modify_Wc proc~modify_wc~4->proc~set~2 proc~modify_xc~4 bezier_surface%modify_Xc proc~modify_xc~4->proc~set~2 program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~set~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set~2.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), dimension(:,:), allocatable Called by proc~~generate_xc~3~~CalledByGraph proc~generate_xc~3 generate_Xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~generate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~3.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), dimension(:,:), allocatable Called by proc~~generate_xc~4~~CalledByGraph proc~generate_xc~4 generate_Xc program~example_bezier_surface example_bezier_surface program~example_bezier_surface->proc~generate_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~4.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), dimension(:,:), allocatable Called by proc~~generate_xc~5~~CalledByGraph proc~generate_xc~5 generate_Xc program~example_bezier_curve example_bezier_curve program~example_bezier_curve->proc~generate_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~5.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc~5.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc~5.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg~5.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~5.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3)","tags":"","loc":"proc/get_nc~5.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3)","tags":"","loc":"proc/get_ng~5.html"},{"title":"get_order – ForCAD","text":"private pure function get_order(this) result(order) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3)","tags":"","loc":"proc/get_order~5.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, res3, Xt1, Xt2, Xt3) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) Calls proc~~create~5~~CallsGraph proc~create~5 bezier_volume%create interface~ndgrid ndgrid proc~create~5->interface~ndgrid proc~basis_bernstein basis_bernstein proc~create~5->proc~basis_bernstein proc~kron kron proc~create~5->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~5~~CalledByGraph proc~create~5 bezier_volume%create program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~create~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~5.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~5~~CallsGraph proc~export_xc~5 bezier_volume%export_Xc proc~get_elem_xc~5 bezier_volume%get_elem_Xc proc~export_xc~5->proc~get_elem_xc~5 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~5->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~5~~CalledByGraph proc~export_xc~5 bezier_volume%export_Xc program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~5.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~5~~CallsGraph proc~export_xg~5 bezier_volume%export_Xg proc~get_elem_xg~5 bezier_volume%get_elem_Xg proc~export_xg~5->proc~get_elem_xg~5 interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~5->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~5~~CalledByGraph proc~export_xg~5 bezier_volume%export_Xg program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xg~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~5.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this Called by proc~~finalize~5~~CalledByGraph proc~finalize~5 bezier_volume%finalize program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~finalize~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~5.html"},{"title":"get_elem_Xc – ForCAD","text":"private pure subroutine get_elem_Xc(this, elemConn, p) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xc~5~~CallsGraph proc~get_elem_xc~5 bezier_volume%get_elem_Xc interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~5->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xc~5~~CalledByGraph proc~get_elem_xc~5 bezier_volume%get_elem_Xc proc~export_xc~5 bezier_volume%export_Xc proc~export_xc~5->proc~get_elem_xc~5 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xc~5.html"},{"title":"get_elem_Xg – ForCAD","text":"private pure subroutine get_elem_Xg(this, elemConn, p) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xg~5~~CallsGraph proc~get_elem_xg~5 bezier_volume%get_elem_Xg interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~5->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xg~5~~CalledByGraph proc~get_elem_xg~5 bezier_volume%get_elem_Xg proc~export_xg~5 bezier_volume%export_Xg proc~export_xg~5->proc~get_elem_xg~5 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~export_xg~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xg~5.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~5~~CallsGraph proc~modify_wc~5 bezier_volume%modify_Wc proc~set~3 bezier_volume%set proc~modify_wc~5->proc~set~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~5.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~5~~CallsGraph proc~modify_xc~5 bezier_volume%modify_Xc proc~set~3 bezier_volume%set proc~modify_xc~5->proc~set~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~5.html"},{"title":"set – ForCAD","text":"private pure subroutine set(this, nc, Xc, Wc) Set control points and weights for the Bezier curve object. Type Bound bezier_volume Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this integer, intent(in) :: nc (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Called by proc~~set~3~~CalledByGraph proc~set~3 bezier_volume%set proc~modify_wc~5 bezier_volume%modify_Wc proc~modify_wc~5->proc~set~3 proc~modify_xc~5 bezier_volume%modify_Xc proc~modify_xc~5->proc~set~3 program~example_bezier_volume example_bezier_volume program~example_bezier_volume->proc~set~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set~3.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc~6.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc~6.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg~6.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~6.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~3~~CallsGraph proc~get_continuity~3 nurbs_volume%get_continuity proc~compute_multiplicity compute_multiplicity proc~get_continuity~3->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity~3.html"},{"title":"get_knot – ForCAD","text":"private pure function get_knot(this, dir) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_knot~3.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~3~~CallsGraph proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~3~~CalledByGraph proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_order~6 nurbs_volume%get_order proc~get_order~6->proc~get_multiplicity~3 proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~get_order~6 none~set~6 nurbs_volume%set none~set~6->proc~set1~3 proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity~3.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this, dir) result(nc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc~6~~CallsGraph proc~get_nc~6 nurbs_volume%get_nc proc~compute_multiplicity compute_multiplicity proc~get_nc~6->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc~6~~CalledByGraph proc~get_nc~6 nurbs_volume%get_nc proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~get_nc~6 proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~get_nc~6 none~set~6 nurbs_volume%set none~set~6->proc~set1~3 none~set~6->proc~set2~3 proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc~6.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3)","tags":"","loc":"proc/get_ng~6.html"},{"title":"get_order – ForCAD","text":"private pure function get_order(this) result(order) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Calls proc~~get_order~6~~CallsGraph proc~get_order~6 nurbs_volume%get_order proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_order~6->proc~get_multiplicity~3 proc~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_order~6~~CalledByGraph proc~get_order~6 nurbs_volume%get_order proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~get_order~6 none~set~6 nurbs_volume%set none~set~6->proc~set1~3 proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_order~6.html"},{"title":"basis – ForCAD","text":"private pure subroutine basis(this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis~3~~CallsGraph proc~basis~3 nurbs_volume%basis interface~ndgrid ndgrid proc~basis~3->interface~ndgrid proc~basis_bspline basis_bspline proc~basis~3->proc~basis_bspline proc~kron kron proc~basis~3->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis~3.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, res3, Xt1, Xt2, Xt3) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) Calls proc~~create~6~~CallsGraph proc~create~6 nurbs_volume%create interface~ndgrid ndgrid proc~create~6->interface~ndgrid proc~basis_bspline basis_bspline proc~create~6->proc~basis_bspline proc~kron kron proc~create~6->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~6~~CalledByGraph proc~create~6 nurbs_volume%create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~6.html"},{"title":"derivative – ForCAD","text":"private pure subroutine derivative(this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) Calls proc~~derivative~3~~CallsGraph proc~derivative~3 nurbs_volume%derivative interface~ndgrid ndgrid proc~derivative~3->interface~ndgrid proc~basis_bspline_der basis_bspline_der proc~derivative~3->proc~basis_bspline_der proc~kron kron proc~derivative~3->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative~3.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~6~~CallsGraph proc~export_xc~6 nurbs_volume%export_Xc proc~get_elem_xc~6 nurbs_volume%get_elem_Xc proc~export_xc~6->proc~get_elem_xc~6 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~6->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~6~~CalledByGraph proc~export_xc~6 nurbs_volume%export_Xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~6.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~6~~CallsGraph proc~export_xg~6 nurbs_volume%export_Xg proc~get_elem_xg~6 nurbs_volume%get_elem_Xg proc~export_xg~6->proc~get_elem_xg~6 interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~6->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~6~~CalledByGraph proc~export_xg~6 nurbs_volume%export_Xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~6.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this Called by proc~~finalize~6~~CalledByGraph proc~finalize~6 nurbs_volume%finalize program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~finalize~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~6.html"},{"title":"get_elem_Xc – ForCAD","text":"private pure subroutine get_elem_Xc(this, elemConn, p) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xc~6~~CallsGraph proc~get_elem_xc~6 nurbs_volume%get_elem_Xc interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~6->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xc~6~~CalledByGraph proc~get_elem_xc~6 nurbs_volume%get_elem_Xc proc~export_xc~6 nurbs_volume%export_Xc proc~export_xc~6->proc~get_elem_xc~6 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xc~6.html"},{"title":"get_elem_Xg – ForCAD","text":"private pure subroutine get_elem_Xg(this, elemConn, p) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) Calls proc~~get_elem_xg~6~~CallsGraph proc~get_elem_xg~6 nurbs_volume%get_elem_Xg interface~elemconn_c0 elemConn_C0 proc~get_elem_xg~6->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_elem_xg~6~~CalledByGraph proc~get_elem_xg~6 nurbs_volume%get_elem_Xg proc~export_xg~6 nurbs_volume%export_Xg proc~export_xg~6->proc~get_elem_xg~6 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_elem_xg~6.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~6~~CallsGraph proc~modify_wc~6 nurbs_volume%modify_Wc none~set~6 nurbs_volume%set proc~modify_wc~6->none~set~6 proc~set1~3 nurbs_volume%set1 none~set~6->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~6->proc~set2~3 proc~get_nc~6 nurbs_volume%get_nc proc~set1~3->proc~get_nc~6 proc~get_order~6 nurbs_volume%get_order proc~set1~3->proc~get_order~6 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->proc~get_nc~6 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc~6->proc~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_order~6->proc~get_multiplicity~3 proc~get_multiplicity~3->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~6.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~6~~CallsGraph proc~modify_xc~6 nurbs_volume%modify_Xc none~set~6 nurbs_volume%set proc~modify_xc~6->none~set~6 proc~set1~3 nurbs_volume%set1 none~set~6->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~6->proc~set2~3 proc~get_nc~6 nurbs_volume%get_nc proc~set1~3->proc~get_nc~6 proc~get_order~6 nurbs_volume%get_order proc~set1~3->proc~get_order~6 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->proc~get_nc~6 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc~6->proc~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_order~6->proc~get_multiplicity~3 proc~get_multiplicity~3->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~6.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, knot3, Xc, Wc) Set control points and weights for the NURBS curve object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: knot3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Calls proc~~set1~3~~CallsGraph proc~set1~3 nurbs_volume%set1 proc~get_nc~6 nurbs_volume%get_nc proc~set1~3->proc~get_nc~6 proc~get_order~6 nurbs_volume%get_order proc~set1~3->proc~get_order~6 proc~compute_multiplicity compute_multiplicity proc~get_nc~6->proc~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_order~6->proc~get_multiplicity~3 proc~get_multiplicity~3->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~3~~CalledByGraph proc~set1~3 nurbs_volume%set1 none~set~6 nurbs_volume%set none~set~6->proc~set1~3 proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1~3.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, Xth_dir3, order, continuity1, continuity2, continuity3, Xc, Wc) Set control points and weights for the NURBS curve object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) real(kind=rk), intent(in) :: Xth_dir3 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) integer, intent(in) :: continuity3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) Calls proc~~set2~3~~CallsGraph proc~set2~3 nurbs_volume%set2 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~get_nc~6 nurbs_volume%get_nc proc~set2~3->proc~get_nc~6 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc~6->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~3~~CalledByGraph proc~set2~3 nurbs_volume%set2 none~set~6 nurbs_volume%set none~set~6->proc~set2~3 proc~modify_wc~6 nurbs_volume%modify_Wc proc~modify_wc~6->none~set~6 proc~modify_xc~6 nurbs_volume%modify_Xc proc~modify_xc~6->none~set~6 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2~3.html"},{"title":"forcad_nurbs_surface – ForCAD","text":"Uses forcad_utils module~~forcad_nurbs_surface~~UsesGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad_utils forcad_utils module~forcad_nurbs_surface->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_surface~~UsedByGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad forcad module~forcad->module~forcad_nurbs_surface program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction real(kind=rk), private, allocatable :: knot1 (:) knot vector real(kind=rk), private, allocatable :: knot2 (:) knot vector integer, private :: nc (2) number of control points in each direction integer, private :: ng (2) number of geometry points in each direction integer, private :: order (2) degree of each direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS surface Read more… procedure, public :: create Generate geometry points Read more… procedure, public :: derivative Compute the derivative of the NURBS surface Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS surface object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Get continuity of the surface Read more… procedure, public :: get_elem_Xc Generate connectivity for control points Read more… procedure, public :: get_elem_Xg Generate connectivity for geometry points Read more… procedure, public :: get_knot Get knot vector Read more… procedure, public :: get_multiplicity Get multiplicity of the knot vector Read more… procedure, public :: get_nc Get number of required control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: get_order Get order of the Bezier curve Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… generic, public :: set => set1 , set2 procedure, public :: set1 Set control points and weights Read more… procedure, public :: set2 Set control points and weights Read more… Functions private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_knot (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Subroutines private pure subroutine basis (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, Xt1, Xt2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) private pure subroutine derivative (this, res1, res2, Xt1, Xt2, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, order, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"module/forcad_nurbs_surface.html"},{"title":"forcad_nurbs_curve – ForCAD","text":"Uses forcad_utils module~~forcad_nurbs_curve~~UsesGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_curve~~UsedByGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad forcad module~forcad->module~forcad_nurbs_curve program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt (:) evaluation points real(kind=rk), private, allocatable :: knot (:) knot vector integer, private :: nc number of control points integer, private :: ng number of geometry points integer, private :: order order of the curve Type-Bound Procedures procedure, public :: basis Read more… procedure, public :: create Generate geometry points Read more… procedure, public :: derivative Read more… procedure, public :: elevate_degree Elevate the degree of the curve Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the Bezier curve object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Get continuity of the curve Read more… procedure, public :: get_elem_Xc Generate connectivity for control points Read more… procedure, public :: get_elem_Xg Generate connectivity for geometry points Read more… procedure, public :: get_knot Get knot vector Read more… procedure, public :: get_multiplicity Get multiplicity of the knot vector Read more… procedure, public :: get_nc Get number of required control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: get_order Get order of the Bezier curve Read more… procedure, public :: insert_knot Insert a new knot Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… generic, public :: set => set1 , set2 procedure, public :: set1 Set control points and weights Read more… procedure, public :: set2 Set control points and weights Read more… Functions private pure function bincoeff (n, k) result(b) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) private pure function factln (n) result(f) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) private pure function findspan (n, order, Xth, knot) result(s) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: order real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in) :: knot (:) Return Value integer private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_knot (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Subroutines private pure subroutine basis (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) private pure subroutine derivative (this, res, Xt, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p private pure subroutine insert_knot (this, Xth) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xth (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: knot (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) private pure subroutine set2 (this, Xth_dir, order, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir (:) integer, intent(in) :: order integer, intent(in) :: continuity (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"module/forcad_nurbs_curve.html"},{"title":"forcad_bezier_curve – ForCAD","text":"Uses forcad_utils module~~forcad_bezier_curve~~UsesGraph module~forcad_bezier_curve forcad_bezier_curve module~forcad_utils forcad_utils module~forcad_bezier_curve->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_bezier_curve~~UsedByGraph module~forcad_bezier_curve forcad_bezier_curve module~forcad forcad module~forcad->module~forcad_bezier_curve program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: bezier_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights real(kind=rk), private, allocatable :: Xc (:,:) Control points real(kind=rk), private, allocatable :: Xg (:,:) Geometry points real(kind=rk), private, allocatable :: Xt (:) Parameter values integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: create Generate geometry points Read more… procedure, public :: elevate_degree Elevate the degree of the Bezier curve Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the Bezier curve object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_elem_Xc Generate connectivity for control points Read more… procedure, public :: get_elem_Xg Generate connectivity for geometry points Read more… procedure, public :: get_nc Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: get_order Get order of the Bezier curve Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: set Set control points and weights Read more… Functions private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this Return Value integer Subroutines private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Generate geometry points of the Bezier curve. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional :: Xt (:) private pure subroutine elevate_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Elevate the degree of the Bezier curve by one. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Export control points to a VTK file. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Export geometry points to a VTK file. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Finalize the Bezier curve object by deallocating memory. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Generate connectivity for control points. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Generate connectivity for geometry points. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Modify weight of a control point given its index. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Modify coordinate of a control point given its index and direction. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine set (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( bezier_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"module/forcad_bezier_curve.html"},{"title":"forcad_utils – ForCAD","text":"Used by module~~forcad_utils~~UsedByGraph module~forcad_utils forcad_utils module~forcad forcad module~forcad->module~forcad_utils module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = kind(1.0d0) Interfaces public        interface elemConn_C0 private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, dimension(:,:), allocatable private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, dimension(:,:), allocatable private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, dimension(:,:), allocatable public        interface ndgrid private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir3 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt Functions public pure function basis_bernstein (Xt, nc) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline (Xt, knot, nc, order) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in) :: knot (:) integer, intent(in) :: nc integer, intent(in) :: order Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline_der (Xt, knot, nc, order) result(dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in) :: knot (:) integer, intent(in) :: nc integer, intent(in) :: order Return Value real(kind=rk), allocatable, (:) public pure function compute_knot_vector (Xth_dir, order, continuity) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xth_dir (:) integer, intent(in) :: order integer, intent(in) :: continuity (:) Return Value real(kind=rk), allocatable, (:) public pure function compute_multiplicity (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: knot (:) Return Value integer, dimension(:), allocatable public pure function kron (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk), dimension(size(u)*size(v)) private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, dimension(:,:), allocatable private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, dimension(:,:), allocatable private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, dimension(:,:), allocatable private pure elemental function isinf (x) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical private pure function repelem (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: a integer, intent(in), dimension(:), contiguous :: b Return Value real(kind=rk), dimension(sum(b)) Subroutines private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: X_dir1 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir2 real(kind=rk), intent(in), dimension(:), contiguous :: X_dir3 real(kind=rk), intent(out), dimension(:,:), allocatable :: Xt","tags":"","loc":"module/forcad_utils.html"},{"title":"forcad – ForCAD","text":"Uses forcad_nurbs_volume forcad_bezier_surface forcad_bezier_curve forcad_utils forcad_nurbs_surface forcad_nurbs_curve forcad_bezier_volume module~~forcad~~UsesGraph module~forcad forcad module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad~~UsedByGraph module~forcad forcad program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forcad.html"},{"title":"forcad_bezier_surface – ForCAD","text":"Uses forcad_utils module~~forcad_bezier_surface~~UsesGraph module~forcad_bezier_surface forcad_bezier_surface module~forcad_utils forcad_utils module~forcad_bezier_surface->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_bezier_surface~~UsedByGraph module~forcad_bezier_surface forcad_bezier_surface module~forcad forcad module~forcad->module~forcad_bezier_surface program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: bezier_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction integer, private :: nc (2) number of control points in each direction integer, private :: ng (2) number of geometry points in each direction Type-Bound Procedures procedure, public :: create Generate geometry points Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the Bezier surface object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_elem_Xc Generate connectivity for control points Read more… procedure, public :: get_elem_Xg Generate connectivity for geometry points Read more… procedure, public :: get_nc Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: get_order Get order of the Bezier surface Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: set Set control points and weights Read more… Functions private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2) private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2) private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this Return Value integer, (2) Subroutines private pure subroutine create (this, res1, res2, Xt1, Xt2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Modify weight of a control point given its index. Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Modify coordinate of a control point given its index and direction. Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine set (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( bezier_surface ), intent(inout) :: this integer, intent(in) :: nc (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"module/forcad_bezier_surface.html"},{"title":"forcad_bezier_volume – ForCAD","text":"Uses forcad_utils module~~forcad_bezier_volume~~UsesGraph module~forcad_bezier_volume forcad_bezier_volume module~forcad_utils forcad_utils module~forcad_bezier_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_bezier_volume~~UsedByGraph module~forcad_bezier_volume forcad_bezier_volume module~forcad forcad module~forcad->module~forcad_bezier_volume program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: bezier_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction real(kind=rk), private, allocatable :: Xt3 (:) parameter values in the third direction integer, private :: nc (3) number of control points in each direction integer, private :: ng (3) number of geometry points in each direction Type-Bound Procedures procedure, public :: create Generate geometry points Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the Bezier volume object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_elem_Xc Generate connectivity for control points Read more… procedure, public :: get_elem_Xg Generate connectivity for geometry points Read more… procedure, public :: get_nc Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: get_order Get order of the Bezier surface Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: set Set control points and weights Read more… Functions private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3) private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3) private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this Return Value integer, (3) Subroutines private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine set (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the Bezier curve object. Arguments Type Intent Optional Attributes Name class( bezier_volume ), intent(inout) :: this integer, intent(in) :: nc (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"module/forcad_bezier_volume.html"},{"title":"forcad_nurbs_volume – ForCAD","text":"Uses forcad_utils module~~forcad_nurbs_volume~~UsesGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_volume~~UsedByGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad forcad module~forcad->module~forcad_nurbs_volume program~example_bezier_curve example_bezier_curve program~example_bezier_curve->module~forcad program~example_bezier_surface example_bezier_surface program~example_bezier_surface->module~forcad program~example_bezier_volume example_bezier_volume program~example_bezier_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) weights real(kind=rk), private, allocatable :: Xc (:,:) control points real(kind=rk), private, allocatable :: Xg (:,:) geometry points real(kind=rk), private, allocatable :: Xt1 (:) parameter values in the first direction real(kind=rk), private, allocatable :: Xt2 (:) parameter values in the second direction real(kind=rk), private, allocatable :: Xt3 (:) parameter values in the third direction real(kind=rk), private, allocatable :: knot1 (:) knot vector real(kind=rk), private, allocatable :: knot2 (:) knot vector real(kind=rk), private, allocatable :: knot3 (:) knot vector integer, private :: nc (3) number of control points in each direction integer, private :: ng (3) number of geometry points in each direction integer, private :: order (3) degree of the first direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS curve Read more… procedure, public :: create Generate geometry points Read more… procedure, public :: derivative Compute the derivative of the NURBS curve Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS curve object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Get continuity of the curve Read more… procedure, public :: get_elem_Xc Generate connectivity for control points Read more… procedure, public :: get_elem_Xg Generate connectivity for geometry points Read more… procedure, public :: get_knot Get knot vector Read more… procedure, public :: get_multiplicity Get multiplicity of the knot vector Read more… procedure, public :: get_nc Get number of required control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: get_order Get order of the Bezier curve Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… generic, public :: set => set1 , set2 procedure, public :: set1 Set control points and weights Read more… procedure, public :: set2 Set control points and weights Read more… Functions private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_knot (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_order (this) result(order) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Subroutines private pure subroutine basis (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) private pure subroutine derivative (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional :: Xt1 (:) real(kind=rk), intent(in), optional :: Xt2 (:) real(kind=rk), intent(in), optional :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this private pure subroutine get_elem_Xc (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine get_elem_Xg (this, elemConn, p) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(out), dimension(:,:), allocatable :: elemConn integer, intent(in), optional :: p (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: knot1 (:) real(kind=rk), intent(in) :: knot2 (:) real(kind=rk), intent(in) :: knot3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, order, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: Xth_dir1 (:) real(kind=rk), intent(in) :: Xth_dir2 (:) real(kind=rk), intent(in) :: Xth_dir3 (:) integer, intent(in) :: order (:) integer, intent(in) :: continuity1 (:) integer, intent(in) :: continuity2 (:) integer, intent(in) :: continuity3 (:) real(kind=rk), intent(in) :: Xc (:,:) real(kind=rk), intent(in), optional :: Wc (:)","tags":"","loc":"module/forcad_nurbs_volume.html"},{"title":"example_bezier_volume – ForCAD","text":"Uses forcad program~~example_bezier_volume~~UsesGraph program~example_bezier_volume example_bezier_volume module~forcad forcad program~example_bezier_volume->module~forcad module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a Bezier volume object to create, and finalize a Bezier volume.\nIt sets up control points and weights, generates the volume, and exports the control points\nand the volume to VTK files at various stages. Define control points for the Bezier volume Define weights for the control points Set control points and weights for the bezier volume object Export initial control points to a VTK file Generate the Bezier volume with a resolution of 10x10x10 Export the generated volume to a VTK file Finalize the Bezier volume object Calls program~~example_bezier_volume~~CallsGraph program~example_bezier_volume example_bezier_volume proc~create~5 bezier_volume%create program~example_bezier_volume->proc~create~5 proc~export_xc~5 bezier_volume%export_Xc program~example_bezier_volume->proc~export_xc~5 proc~export_xg~5 bezier_volume%export_Xg program~example_bezier_volume->proc~export_xg~5 proc~finalize~5 bezier_volume%finalize program~example_bezier_volume->proc~finalize~5 proc~generate_xc generate_Xc program~example_bezier_volume->proc~generate_xc proc~set~3 bezier_volume%set program~example_bezier_volume->proc~set~3 interface~ndgrid ndgrid proc~create~5->interface~ndgrid proc~basis_bernstein basis_bernstein proc~create~5->proc~basis_bernstein proc~kron kron proc~create~5->proc~kron proc~get_elem_xc~5 bezier_volume%get_elem_Xc proc~export_xc~5->proc~get_elem_xc~5 proc~get_elem_xg~5 bezier_volume%get_elem_Xg proc~export_xg~5->proc~get_elem_xg~5 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~5->interface~elemconn_c0 proc~get_elem_xg~5->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( bezier_volume ) :: bezier Declare a bezier volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), dimension(:,:), allocatable Source Code program example_bezier_volume use forcad , only : rk , bezier_volume implicit none type ( bezier_volume ) :: bezier !! Declare a bezier volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the bezier volume !----------------------------------------------------------------------------- !> Define control points for the Bezier volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the bezier volume object call bezier % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Export initial control points to a VTK file call bezier % export_Xc ( 'vtk/bezier_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the bezier volume !----------------------------------------------------------------------------- !> Generate the Bezier volume with a resolution of 10x10x10 call bezier % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call bezier % export_Xg ( 'vtk/bezier_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the Bezier volume object call bezier % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), dimension (:,:), allocatable :: control_points real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_bezier_volume","tags":"","loc":"program/example_bezier_volume.html"},{"title":"example_nurbs_surface – ForCAD","text":"Uses forcad program~~example_nurbs_surface~~UsesGraph program~example_nurbs_surface example_nurbs_surface module~forcad forcad program~example_nurbs_surface->module~forcad module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. Define control points for the NURBS surface Define weights for the control points\nDefine knot vectors for both dimensions\nSet knot vectors, control points, and weights for the NURBS surface object Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Finalize the NURBS surface object Calls program~~example_nurbs_surface~~CallsGraph program~example_nurbs_surface example_nurbs_surface none~set nurbs_surface%set program~example_nurbs_surface->none~set proc~create nurbs_surface%create program~example_nurbs_surface->proc~create proc~export_xc nurbs_surface%export_Xc program~example_nurbs_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example_nurbs_surface->proc~export_xg proc~finalize nurbs_surface%finalize program~example_nurbs_surface->proc~finalize proc~generate_xc~2 generate_Xc program~example_nurbs_surface->proc~generate_xc~2 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 interface~ndgrid ndgrid proc~create->interface~ndgrid proc~basis_bspline basis_bspline proc~create->proc~basis_bspline proc~kron kron proc~create->proc~kron proc~get_elem_xc nurbs_surface%get_elem_Xc proc~export_xc->proc~get_elem_xc proc~get_elem_xg nurbs_surface%get_elem_Xg proc~export_xg->proc~get_elem_xg proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc->interface~elemconn_c0 proc~get_elem_xg->interface~elemconn_c0 proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~get_order nurbs_surface%get_order proc~set1->proc~get_order proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc->proc~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_order->proc~get_multiplicity proc~get_multiplicity->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (6) Arrays for knot vectors in both dimensions real(kind=rk) :: knot2 (6) Arrays for knot vectors in both dimensions type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), dimension(:,:), allocatable Source Code program example_nurbs_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), dimension (:,:), allocatable :: control_points integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 ) y_spacing = 1.0_rk / real ( num_rows - 1 ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"program/example_nurbs_surface.html"},{"title":"example_nurbs_volume – ForCAD","text":"Uses forcad program~~example_nurbs_volume~~UsesGraph program~example_nurbs_volume example_nurbs_volume module~forcad forcad program~example_nurbs_volume->module~forcad module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. Define the control points for the NURBS volume Define weights for the control points Define knot vectors for all three dimensions\nSet knot vectors, control points, and weights for the NURBS volume object Export the control points to a VTK file Generate the NURBS volume with resolutions of 15, 15, and 15 in the three dimensions Export the generated volume to a VTK file Finalize the NURBS volume object Calls program~~example_nurbs_volume~~CallsGraph program~example_nurbs_volume example_nurbs_volume none~set~6 nurbs_volume%set program~example_nurbs_volume->none~set~6 proc~create~6 nurbs_volume%create program~example_nurbs_volume->proc~create~6 proc~export_xc~6 nurbs_volume%export_Xc program~example_nurbs_volume->proc~export_xc~6 proc~export_xg~6 nurbs_volume%export_Xg program~example_nurbs_volume->proc~export_xg~6 proc~finalize~6 nurbs_volume%finalize program~example_nurbs_volume->proc~finalize~6 proc~generate_xc~3 generate_Xc program~example_nurbs_volume->proc~generate_xc~3 proc~set1~3 nurbs_volume%set1 none~set~6->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~6->proc~set2~3 interface~ndgrid ndgrid proc~create~6->interface~ndgrid proc~basis_bspline basis_bspline proc~create~6->proc~basis_bspline proc~kron kron proc~create~6->proc~kron proc~get_elem_xc~6 nurbs_volume%get_elem_Xc proc~export_xc~6->proc~get_elem_xc~6 proc~get_elem_xg~6 nurbs_volume%get_elem_Xg proc~export_xg~6->proc~get_elem_xg~6 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~6->interface~elemconn_c0 proc~get_elem_xg~6->interface~elemconn_c0 proc~get_nc~6 nurbs_volume%get_nc proc~set1~3->proc~get_nc~6 proc~get_order~6 nurbs_volume%get_order proc~set1~3->proc~get_order~6 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set2~3->proc~get_nc~6 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity compute_multiplicity proc~get_nc~6->proc~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_order~6->proc~get_multiplicity~3 proc~get_multiplicity~3->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot2 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot3 (4) Arrays for knot vectors in all three dimensions type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), dimension(:,:), allocatable Source Code program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 15, 15, and 15 in the three dimensions call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), dimension (:,:), allocatable :: control_points real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"program/example_nurbs_volume.html"},{"title":"example_bezier_surface – ForCAD","text":"Uses forcad program~~example_bezier_surface~~UsesGraph program~example_bezier_surface example_bezier_surface module~forcad forcad program~example_bezier_surface->module~forcad module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a Bezier surface object to create, and finalize a Bezier surface.\nIt sets up control points and weights, generates the surface, and exports the control points\nand the surface to VTK files at various stages. Define control points for the Bezier surface Define weights for the control points Set control points and weights for the bezier surface object Export initial control points to a VTK file Generate the Bezier surface with a resolution of 100x100 Export the generated surface to a VTK file Finalize the Bezier surface object Calls program~~example_bezier_surface~~CallsGraph program~example_bezier_surface example_bezier_surface proc~create~4 bezier_surface%create program~example_bezier_surface->proc~create~4 proc~export_xc~4 bezier_surface%export_Xc program~example_bezier_surface->proc~export_xc~4 proc~export_xg~4 bezier_surface%export_Xg program~example_bezier_surface->proc~export_xg~4 proc~finalize~4 bezier_surface%finalize program~example_bezier_surface->proc~finalize~4 proc~generate_xc~4 generate_Xc program~example_bezier_surface->proc~generate_xc~4 proc~set~2 bezier_surface%set program~example_bezier_surface->proc~set~2 interface~ndgrid ndgrid proc~create~4->interface~ndgrid proc~basis_bernstein basis_bernstein proc~create~4->proc~basis_bernstein proc~kron kron proc~create~4->proc~kron proc~get_elem_xc~4 bezier_surface%get_elem_Xc proc~export_xc~4->proc~get_elem_xc~4 proc~get_elem_xg~4 bezier_surface%get_elem_Xg proc~export_xg~4->proc~get_elem_xg~4 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~4->interface~elemconn_c0 proc~get_elem_xg~4->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( bezier_surface ) :: bezier Declare a bezier surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), dimension(:,:), allocatable Source Code program example_bezier_surface use forcad , only : rk , bezier_surface implicit none type ( bezier_surface ) :: bezier !! Declare a bezier surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the bezier surface !----------------------------------------------------------------------------- !> Define control points for the Bezier surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the bezier surface object call bezier % set ([ 10 , 10 ], Xc , Wc ) !> Export initial control points to a VTK file call bezier % export_Xc ( 'vtk/bezier_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the bezier surface !----------------------------------------------------------------------------- !> Generate the Bezier surface with a resolution of 100x100 call bezier % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call bezier % export_Xg ( 'vtk/bezier_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the Bezier surface object call bezier % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), dimension (:,:), allocatable :: control_points integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 ) y_spacing = 1.0_rk / real ( num_rows - 1 ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_bezier_surface","tags":"","loc":"program/example_bezier_surface.html"},{"title":"example_bezier_curve – ForCAD","text":"Uses forcad program~~example_bezier_curve~~UsesGraph program~example_bezier_curve example_bezier_curve module~forcad forcad program~example_bezier_curve->module~forcad module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a Bezier curve object to create, and finalize a Bezier curve.\nIt sets up control points and weights, generates the curve, and exports the control points\nand the curve to VTK files at various stages. Define control points for the Bezier curve Define weights for the control points Set control points and weights for the bezier curve object Export initial control points to a VTK file Generate the Bezier curve with a resolution of 1000 Export the generated curve to a VTK file Finalize the Bezier curve object Calls program~~example_bezier_curve~~CallsGraph program~example_bezier_curve example_bezier_curve proc~create~3 bezier_curve%create program~example_bezier_curve->proc~create~3 proc~export_xc~3 bezier_curve%export_Xc program~example_bezier_curve->proc~export_xc~3 proc~export_xg~3 bezier_curve%export_Xg program~example_bezier_curve->proc~export_xg~3 proc~finalize~3 bezier_curve%finalize program~example_bezier_curve->proc~finalize~3 proc~generate_xc~5 generate_Xc program~example_bezier_curve->proc~generate_xc~5 proc~set bezier_curve%set program~example_bezier_curve->proc~set proc~basis_bernstein basis_bernstein proc~create~3->proc~basis_bernstein proc~get_elem_xc~3 bezier_curve%get_elem_Xc proc~export_xc~3->proc~get_elem_xc~3 proc~get_elem_xg~3 bezier_curve%get_elem_Xg proc~export_xg~3->proc~get_elem_xg~3 interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~3->interface~elemconn_c0 proc~get_elem_xg~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( bezier_curve ) :: bezier Declare a bezier curve object Functions function generate_Xc (num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), dimension(:,:), allocatable Source Code program example_bezier_curve use forcad , only : rk , bezier_curve implicit none type ( bezier_curve ) :: bezier !! Declare a bezier curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the bezier curve !----------------------------------------------------------------------------- !> Define control points for the Bezier curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the bezier curve object call bezier % set ( Xc = Xc , Wc = Wc ) !> Export initial control points to a VTK file call bezier % export_Xc ( 'vtk/bezier_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the bezier curve !----------------------------------------------------------------------------- !> Generate the Bezier curve with a resolution of 1000 call bezier % create ( res = 500 ) !> Export the generated curve to a VTK file call bezier % export_Xg ( 'vtk/bezier_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the Bezier curve object call bezier % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), dimension (:,:), allocatable :: control_points integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * ( coil - 1 ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_bezier_curve","tags":"","loc":"program/example_bezier_curve.html"},{"title":"example_nurbs_curve – ForCAD","text":"Uses forcad program~~example_nurbs_curve~~UsesGraph program~example_nurbs_curve example_nurbs_curve module~forcad forcad program~example_nurbs_curve->module~forcad module~forcad_bezier_curve forcad_bezier_curve module~forcad->module~forcad_bezier_curve module~forcad_bezier_surface forcad_bezier_surface module~forcad->module~forcad_bezier_surface module~forcad_bezier_volume forcad_bezier_volume module~forcad->module~forcad_bezier_volume module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_bezier_curve->module~forcad_utils module~forcad_bezier_surface->module~forcad_utils module~forcad_bezier_volume->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. Calls program~~example_nurbs_curve~~CallsGraph program~example_nurbs_curve example_nurbs_curve none~set~2 nurbs_curve%set program~example_nurbs_curve->none~set~2 proc~create~2 nurbs_curve%create program~example_nurbs_curve->proc~create~2 proc~elevate_degree nurbs_curve%elevate_degree program~example_nurbs_curve->proc~elevate_degree proc~export_xc~2 nurbs_curve%export_Xc program~example_nurbs_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~example_nurbs_curve->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~example_nurbs_curve->proc~finalize~2 proc~insert_knot nurbs_curve%insert_knot program~example_nurbs_curve->proc~insert_knot proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline proc~elevate_degree->none~set~2 proc~elevate_degree->proc~create~2 proc~bincoeff bincoeff proc~elevate_degree->proc~bincoeff proc~compute_multiplicity compute_multiplicity proc~elevate_degree->proc~compute_multiplicity proc~get_elem_xc~2 nurbs_curve%get_elem_Xc proc~export_xc~2->proc~get_elem_xc~2 proc~get_elem_xg~2 nurbs_curve%get_elem_Xg proc~export_xg~2->proc~get_elem_xg~2 proc~insert_knot->none~set~2 proc~insert_knot->proc~create~2 proc~findspan findspan proc~insert_knot->proc~findspan proc~factln factln proc~bincoeff->proc~factln interface~elemconn_c0 elemConn_C0 proc~get_elem_xc~2->interface~elemconn_c0 proc~get_elem_xg~2->interface~elemconn_c0 proc~get_order~2 nurbs_curve%get_order proc~set1~2->proc~get_order~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_order~2->proc~get_multiplicity~2 proc~get_multiplicity~2->proc~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot (6) Array for knot vector type( nurbs_curve ) :: nurbs Declare a NURBS curve object Source Code program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- ! Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] ! Define weights for the control points allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights for the NURBS curve object call nurbs % set ( knot , Xc , Wc ) ! Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- ! Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) ! Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- ! Insert knots call nurbs % insert_knot ([ 0.25_rk , 0.75_rk ]) ! Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) ! Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) ! Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- ! Finalize the NURBS curve object call nurbs % finalize () end program example_nurbs_curve","tags":"","loc":"program/example_nurbs_curve.html"},{"title":"bezier_volume.f90 – ForCAD","text":"This file depends on sourcefile~~bezier_volume.f90~~EfferentGraph sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a Bezier volume object to create, and finalize a Bezier volume. !> It sets up control points and weights, generates the volume, and exports the control points !> and the volume to VTK files at various stages. program example_bezier_volume use forcad , only : rk , bezier_volume implicit none type ( bezier_volume ) :: bezier !! Declare a bezier volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the bezier volume !----------------------------------------------------------------------------- !> Define control points for the Bezier volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the bezier volume object call bezier % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Export initial control points to a VTK file call bezier % export_Xc ( 'vtk/bezier_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the bezier volume !----------------------------------------------------------------------------- !> Generate the Bezier volume with a resolution of 10x10x10 call bezier % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call bezier % export_Xg ( 'vtk/bezier_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the Bezier volume object call bezier % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), dimension (:,:), allocatable :: control_points real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_bezier_volume","tags":"","loc":"sourcefile/bezier_volume.f90.html"},{"title":"nurbs_surface.f90 – ForCAD","text":"This file depends on sourcefile~~nurbs_surface.f90~~EfferentGraph sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. program example_nurbs_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), dimension (:,:), allocatable :: control_points integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 ) y_spacing = 1.0_rk / real ( num_rows - 1 ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"sourcefile/nurbs_surface.f90.html"},{"title":"forcad_nurbs_surface.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_surface.f90~~EfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_surface.f90~~AfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad_nurbs_surface use forcad_utils , only : rk , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der implicit none private public nurbs_surface !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_surface real ( rk ), allocatable , private :: Xc (:,:) !! control points real ( rk ), allocatable , private :: Xg (:,:) !! geometry points real ( rk ), allocatable , private :: Wc (:) !! weights real ( rk ), allocatable , private :: Xt1 (:) !! parameter values in the first direction real ( rk ), allocatable , private :: Xt2 (:) !! parameter values in the second direction real ( rk ), allocatable , private :: knot1 (:) !! knot vector real ( rk ), allocatable , private :: knot2 (:) !! knot vector integer , private :: order ( 2 ) !! degree of each direction integer , private :: nc ( 2 ) !! number of control points in each direction integer , private :: ng ( 2 ) !! number of geometry points in each direction contains procedure :: set1 !!> Set control points and weights procedure :: set2 !!> Set control points and weights generic :: set => set1 , set2 procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure :: get_knot !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: get_order !!> Get order of the Bezier curve procedure :: finalize !!> Finalize the NURBS surface object procedure :: get_elem_Xc !!> Generate connectivity for control points procedure :: get_elem_Xg !!> Generate connectivity for geometry points procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Get multiplicity of the knot vector procedure :: get_continuity !!> Get continuity of the surface procedure :: get_nc !!> Get number of required control points procedure :: derivative !!> Compute the derivative of the NURBS surface procedure :: basis !!> Compute the basis functions of the NURBS surface end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS surface object. pure subroutine set1 ( this , knot1 , knot2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: knot1 (:) real ( rk ), intent ( in ) :: knot2 (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % knot1 = knot1 this % knot2 = knot2 this % order = this % get_order () this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS surface object. pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , order , continuity1 , continuity2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xth_dir1 (:), Xth_dir2 (:) integer , intent ( in ) :: order (:) integer , intent ( in ) :: continuity1 (:), continuity2 (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , order ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , order ( 2 ), continuity2 ) this % order ( 1 ) = order ( 1 ) this % order ( 2 ) = order ( 2 ) this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , Xt1 , Xt2 ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:) integer :: i , j real ( rk ), dimension (:), allocatable :: Tgc1 , Tgc2 , Tgc real ( rk ), dimension (:,:), allocatable :: Xt ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng ( 1 ) * this % ng ( 2 ), size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then ! NURBS surface do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The Bezier curve is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_surface ), intent ( in ) :: this integer :: ng ( 2 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_order ( this ) result ( order ) class ( nurbs_surface ), intent ( in ) :: this integer :: order ( 2 ) integer , allocatable :: m1 (:), m2 (:) m1 = this % get_multiplicity ( 1 ) m2 = this % get_multiplicity ( 2 ) order ( 1 ) = m1 ( 1 ) - 1 order ( 2 ) = m2 ( 1 ) - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot ( this , dir ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_surface ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xc ( this , elemConn , p ) class ( nurbs_surface ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xg ( this , elemConn , p ) class ( nurbs_surface ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if call this % get_elem_Xc ( elemConn ) nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if call this % get_elem_Xg ( elemConn ) ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , Xc = this % Xc , Wc = this % Wc ) else error stop 'The NURBS surface is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % order ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % order ( 2 ) - compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this , dir ) result ( nc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % order ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % order ( 2 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative ( this , res1 , res2 , Xt1 , Xt2 , dTgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable :: dTgci (:) integer :: i real ( rk ), dimension (:), allocatable :: dTgc1 , dTgc2 real ( rk ), dimension (:,:), allocatable :: Xt ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) allocate ( dTgc ( this % ng ( 1 ) * this % ng ( 2 ), this % nc ( 1 ) * this % nc ( 2 ))) if ( allocated ( this % Wc )) then ! NURBS surface do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) dTgci = kron ( dTgc2 , dTgc1 ) dTgci = dTgci * ( this % Wc / ( dot_product ( dTgci , this % Wc ))) dTgc ( i ,:) = dTgci end do else do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) dTgci = kron ( dTgc2 , dTgc1 ) dTgc ( i ,:) = dTgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis ( this , res1 , res2 , Xt1 , Xt2 , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i real ( rk ), dimension (:), allocatable :: Tgc1 , Tgc2 real ( rk ), dimension (:,:), allocatable :: Xt ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) allocate ( Tgc ( this % ng ( 1 ) * this % ng ( 2 ), this % nc ( 1 ) * this % nc ( 2 ))) if ( allocated ( this % Wc )) then ! NURBS surface do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgci = kron ( Tgc2 , Tgc1 ) Tgci = Tgci * ( this % Wc / ( dot_product ( Tgci , this % Wc ))) Tgc ( i ,:) = Tgci end do else do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgci = kron ( Tgc2 , Tgc1 ) Tgc ( i ,:) = Tgci end do end if end subroutine !=============================================================================== end module forcad_nurbs_surface","tags":"","loc":"sourcefile/forcad_nurbs_surface.f90.html"},{"title":"forcad_nurbs_curve.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_curve.f90~~EfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_curve.f90~~AfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad_nurbs_curve use forcad_utils , only : rk , basis_bspline , elemConn_C0 , compute_multiplicity , compute_knot_vector , basis_bspline_der implicit none private public nurbs_curve !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_curve real ( rk ), allocatable , private :: Xc (:,:) !! control points real ( rk ), allocatable , private :: Xg (:,:) !! geometry points real ( rk ), allocatable , private :: Wc (:) !! weights real ( rk ), allocatable , private :: Xt (:) !! evaluation points real ( rk ), allocatable , private :: knot (:) !! knot vector integer , private :: order !! order of the curve integer , private :: nc !! number of control points integer , private :: ng !! number of geometry points contains procedure :: set1 !!> Set control points and weights procedure :: set2 !!> Set control points and weights generic :: set => set1 , set2 procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure :: get_knot !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: get_order !!> Get order of the Bezier curve procedure :: finalize !!> Finalize the Bezier curve object procedure :: get_elem_Xc !!> Generate connectivity for control points procedure :: get_elem_Xg !!> Generate connectivity for geometry points procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Get multiplicity of the knot vector procedure :: get_continuity !!> Get continuity of the curve procedure :: get_nc !!> Get number of required control points procedure :: insert_knot !!> Insert a new knot procedure :: elevate_degree !!> Elevate the degree of the curve procedure :: derivative !!> procedure :: basis !!> end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the Bezier curve object. pure subroutine set1 ( this , knot , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: knot (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % knot = knot this % order = this % get_order () this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the Bezier curve object. pure subroutine set2 ( this , Xth_dir , order , continuity , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xth_dir (:) integer , intent ( in ) :: order integer , intent ( in ) :: continuity (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % knot = compute_knot_vector ( Xth_dir , order , continuity ) this % order = order this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res , Xt ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), optional :: Xt (:) real ( rk ), allocatable :: Tgc (:) integer :: i , j ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt ) ! Allocate memory for geometry points if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng , size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then do i = 1 , size ( this % Xt , 1 ) Tgc = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % order ) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else do i = 1 , size ( this % Xt , 1 ) Tgc = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % order ) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The Bezier curve is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this ) result ( Xt ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xt (:) if ( allocated ( this % Xt )) then Xt = this % Xt else error stop 'Parameter values are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_curve ), intent ( in ) :: this integer :: ng ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_order ( this ) result ( order ) class ( nurbs_curve ), intent ( in ) :: this integer :: order integer , allocatable :: m (:) m = this % get_multiplicity () order = m ( 1 ) - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot ( this ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: knot (:) if ( allocated ( this % knot )) then knot = this % knot else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_curve ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot )) deallocate ( this % knot ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xc ( this , elemConn , p ) class ( nurbs_curve ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % nc , p ) else elemConn = elemConn_C0 ( this % nc , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xg ( this , elemConn , p ) class ( nurbs_curve ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % ng , p ) else elemConn = elemConn_C0 ( this % ng , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if call this % get_elem_Xc ( elemConn ) nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension of the control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if call this % get_elem_Xg ( elemConn ) ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension of the geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( knot = this % knot , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( knot = this % knot , Xc = this % Xc , Wc = this % Wc ) else error stop 'The Bezier curve is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this ) result ( m ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: m (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this ) result ( c ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: c (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else c = this % order - compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( nurbs_curve ), intent ( in ) :: this integer :: nc nc = sum ( compute_multiplicity ( this % knot )) - this % order - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knot ( this , Xth ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xth (:) real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) real ( rk ) :: alpha integer :: dim , nc , nXth , nknot , a , b , r , l , i , j , m , n , s , q , ind if ( allocated ( this % Wc )) then allocate ( Xcw ( size ( this % Xc , 1 ), size ( this % Xc , 2 ) + 1 )) do i = 1 , size ( this % Xc , 2 ) Xcw (:, i ) = ( this % Xc (:, i ) * this % Wc ) end do Xcw (:, size ( this % Xc , 2 ) + 1 ) = this % Wc else allocate ( Xcw ( size ( this % Xc , 1 ), size ( this % Xc , 2 ))) do i = 1 , size ( this % Xc , 2 ) Xcw (:, i ) = ( this % Xc (:, i )) end do end if nc = size ( Xcw , 1 ) dim = size ( Xcw , 2 ) nXth = size ( Xth ) nknot = size ( this % knot ) allocate ( Xcw_new ( nc + nXth , dim ), source = 0.0_rk ) allocate ( knot_new ( nknot + nXth ), source = 0.0_rk ) n = nc - 1 r = nXth - 1 m = n + this % order + 1 a = findspan ( n , this % order , Xth ( 1 ), this % knot ) b = findspan ( n , this % order , Xth ( r + 1 ), this % knot ) b = b + 1 do q = 0 , dim - 1 do j = 0 , a - this % order Xcw_new ( j + 1 , q + 1 ) = Xcw ( j + 1 , q + 1 ) end do do j = b - 1 , n Xcw_new ( j + r + 2 , q + 1 ) = Xcw ( j + 1 , q + 1 ) end do end do do j = 0 , a knot_new ( j + 1 ) = this % knot ( j + 1 ) end do do j = b + this % order , m knot_new ( j + r + 2 ) = this % knot ( j + 1 ) end do i = b + this % order - 1 s = b + this % order + r do j = r , 0 , - 1 do while ( Xth ( j + 1 ) <= this % knot ( i + 1 ) . and . i > a ) do q = 0 , dim - 1 Xcw_new ( s - this % order , q + 1 ) = Xcw ( i - this % order , q + 1 ) end do knot_new ( s + 1 ) = this % knot ( i + 1 ) s = s - 1 i = i - 1 end do do q = 0 , dim - 1 Xcw_new ( s - this % order , q + 1 ) = Xcw_new ( s - this % order + 1 , q + 1 ) end do do l = 1 , this % order ind = s - this % order + l alpha = knot_new ( s + l + 1 ) - Xth ( j + 1 ) if ( abs ( alpha ) == 0 ) then do q = 0 , dim - 1 Xcw_new ( ind , q + 1 ) = Xcw_new ( ind + 1 , q + 1 ) end do else alpha = alpha / ( knot_new ( s + l + 1 ) - this % knot ( i - this % order + l + 1 )) do q = 0 , dim - 1 Xcw_new ( ind , q + 1 ) = ( 1.0_rk - alpha ) * Xcw_new ( ind + 1 , q + 1 ) + alpha * Xcw_new ( ind , q + 1 ) end do end if end do knot_new ( s + 1 ) = Xth ( j + 1 ) s = s - 1 end do if ( allocated ( this % Wc )) then Xc_new = Xcw_new (:, 1 : size ( this % Xc , 2 )) Wc_new = Xcw_new (:, size ( this % Xc , 2 ) + 1 ) do concurrent ( i = 1 : size ( this % Xc , 2 )) Xc_new (:, i ) = Xc_new (:, i ) / Wc_new (:) end do deallocate ( this % Xc , this % knot , this % Xg , this % Wc ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) call this % create () else Xc_new = Xcw_new ( 1 : size ( this % Xc , 2 ),:) deallocate ( this % Xc , this % knot , this % Xg ) call this % set ( knot = knot_new , Xc = Xc_new ) call this % create () end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function findspan ( n , order , Xth , knot ) result ( s ) integer , intent ( in ) :: n , order real ( rk ), intent ( in ) :: Xth real ( rk ), intent ( in ) :: knot (:) integer :: s integer :: low , high , mid if ( Xth == knot ( n + 2 )) then s = n return end if low = order high = n + 1 mid = ( low + high ) / 2 do while ( Xth < knot ( mid + 1 ) . or . Xth >= knot ( mid + 2 )) if ( Xth < knot ( mid + 1 )) then high = mid else low = mid end if mid = ( low + high ) / 2 end do s = mid end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , t ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) real ( rk ), allocatable :: bezalfs (:,:), bpts (:,:), ebpts (:,:), Nextbpts (:,:), alfs (:) real ( rk ) :: inv , alpha1 , alpha2 , Xth1 , Xth2 , numer , den integer :: n , lbz , rbz , sv , tr , kj , first , knoti , last , alpha3 , ii , dim , nc , nc_new integer :: i , j , q , s , m , ph , ph2 , mpi , mh , r , a , b , Xcwi , oldr , mul integer , allocatable :: mlp (:) if ( allocated ( this % Wc )) then allocate ( Xcw ( size ( this % Xc , 1 ), size ( this % Xc , 2 ) + 1 )) do i = 1 , size ( this % Xc , 2 ) Xcw (:, i ) = ( this % Xc (:, i ) * this % Wc ) end do Xcw (:, size ( this % Xc , 2 ) + 1 ) = this % Wc else allocate ( Xcw ( size ( this % Xc , 1 ), size ( this % Xc , 2 ))) do i = 1 , size ( this % Xc , 2 ) Xcw (:, i ) = ( this % Xc (:, i )) end do end if nc = size ( Xcw , 1 ) dim = size ( Xcw , 2 ) mlp = compute_multiplicity ( this % knot ) mlp = mlp + t nc_new = sum ( mlp ) - ( mlp ( 1 ) - 1 ) - 1 allocate ( Xcw_new ( nc_new , dim ), source = 0.0_rk ) allocate ( bezalfs ( this % order + 1 , this % order + t + 1 ), source = 0.0_rk ) allocate ( bpts ( this % order + 1 , dim ), source = 0.0_rk ) allocate ( ebpts ( this % order + t + 1 , dim ), source = 0.0_rk ) allocate ( Nextbpts ( this % order + 1 , dim ), source = 0.0_rk ) allocate ( alfs ( this % order ), source = 0.0_rk ) n = nc - 1 m = n + this % order + 1 ph = this % order + t ph2 = ph / 2 bezalfs ( 1 , 1 ) = 1.0_rk bezalfs ( this % order + 1 , ph + 1 ) = 1.0_rk do i = 1 , ph2 inv = 1.0_rk / bincoeff ( ph , i ) mpi = min ( this % order , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = inv * bincoeff ( this % order , j ) * bincoeff ( t , i - j ) end do end do do i = ph2 + 1 , ph - 1 mpi = min ( this % order , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = bezalfs ( this % order - j + 1 , ph - i + 1 ) end do end do mh = ph knoti = ph + 1 r = - 1 a = this % order b = this % order + 1 Xcwi = 1 Xth1 = this % knot ( 1 ) do ii = 0 , dim - 1 Xcw_new ( 1 , ii + 1 ) = Xcw ( 1 , ii + 1 ) end do allocate ( knot_new ( sum ( mlp )), source = 0.0_rk ) do i = 0 , ph knot_new ( i + 1 ) = Xth1 end do do i = 0 , this % order do ii = 0 , dim - 1 bpts ( i + 1 , ii + 1 ) = Xcw ( i + 1 , ii + 1 ) end do end do do while ( b < m ) i = b do while ( b < m . and . this % knot ( b + 1 ) == this % knot ( b + 2 )) b = b + 1 if ( b + 2 > size ( this % knot )) then exit end if end do mul = b - i + 1 mh = mh + mul + t Xth2 = this % knot ( b + 1 ) oldr = r r = this % order - mul if ( oldr > 0 ) then lbz = ( oldr + 2 ) / 2 else lbz = 1 end if if ( r > 0 ) then rbz = ph - ( r + 1 ) / 2 else rbz = ph end if if ( r > 0 ) then numer = Xth2 - Xth1 do q = this % order , mul + 1 , - 1 alfs ( q - mul ) = numer / ( this % knot ( a + q + 1 ) - Xth1 ) end do do j = 1 , r sv = r - j s = mul + j do q = this % order , s , - 1 do ii = 0 , dim - 1 bpts ( q + 1 , ii + 1 ) = ( 1.0_rk - alfs ( q - s + 1 )) * bpts ( q , ii + 1 ) + alfs ( q - s + 1 ) * bpts ( q + 1 , ii + 1 ) end do end do do ii = 0 , dim - 1 Nextbpts ( sv + 1 , ii + 1 ) = bpts ( this % order + 1 , ii + 1 ) end do end do end if do i = lbz , ph do ii = 0 , dim - 1 ebpts ( i + 1 , ii + 1 ) = 0.0_rk end do mpi = min ( this % order , i ) do j = max ( 0 , i - t ), mpi do ii = 0 , dim - 1 ebpts ( i + 1 , ii + 1 ) = bezalfs ( j + 1 , i + 1 ) * bpts ( j + 1 , ii + 1 ) + ebpts ( i + 1 , ii + 1 ) end do end do end do if ( oldr > 1 ) then first = knoti - 2 last = knoti den = Xth2 - Xth1 alpha3 = floor (( Xth2 - this % knot ( knoti )) / den ) do tr = 1 , oldr - 1 i = first j = last kj = j - knoti + 1 do while ( j - i > tr ) if ( i < Xcwi ) then alpha1 = ( Xth2 - this % knot ( i + 1 )) / ( Xth1 - this % knot ( i + 1 )) do ii = 0 , dim - 1 Xcw_new ( i + 1 , ii + 1 ) = ( 1 - alpha1 ) * Xcw_new ( i , ii + 1 ) + alpha1 * Xcw_new ( i + 1 , ii + 1 ) end do end if if ( j >= lbz ) then if ( j - tr <= knoti - ph + oldr ) then alpha2 = ( Xth2 - knot_new ( j - tr + 1 )) / den do ii = 0 , dim - 1 ebpts ( kj + 1 , ii + 1 ) = alpha2 * ebpts ( kj + 1 , ii + 1 ) + ( 1 - alpha2 ) * ebpts ( kj + 2 , ii + 1 ) end do else do ii = 0 , dim - 1 ebpts ( kj + 1 , ii + 1 ) = ( 1 - alpha3 ) * ebpts ( ii + 1 , kj + 2 ) + alpha3 * ebpts ( kj + 1 , ii + 1 ) end do end if end if i = i + 1 j = j - 1 kj = kj - 1 end do first = first - 1 last = last + 1 end do end if if ( a /= this % order ) then do i = 0 , ph - oldr - 1 knot_new ( knoti + 1 ) = Xth1 knoti = knoti + 1 end do end if do j = lbz , rbz do ii = 0 , dim - 1 Xcw_new ( Xcwi + 1 , ii + 1 ) = ebpts ( j + 1 , ii + 1 ) end do Xcwi = Xcwi + 1 end do if ( b < m ) then do j = 0 , r - 1 do ii = 0 , dim - 1 bpts ( j + 1 , ii + 1 ) = Nextbpts ( j + 1 , ii + 1 ) end do end do do j = r , this % order do ii = 0 , dim - 1 bpts ( j + 1 , ii + 1 ) = Xcw ( b - this % order + j + 1 , ii + 1 ) end do end do a = b b = b + 1 Xth1 = Xth2 else do i = 0 , ph knot_new ( knoti + i + 1 ) = Xth2 end do end if end do if ( allocated ( this % Wc )) then Xc_new = Xcw_new (:, 1 : size ( this % Xc , 2 )) Wc_new = Xcw_new (:, size ( this % Xc , 2 ) + 1 ) do concurrent ( i = 1 : size ( this % Xc , 2 )) Xc_new (:, i ) = Xc_new (:, i ) / Wc_new (:) end do deallocate ( this % Xc , this % knot , this % Xg , this % Wc ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) call this % create () else Xc_new = Xcw_new ( 1 : size ( this % Xc , 2 ),:) deallocate ( this % Xc , this % knot , this % Xg ) call this % set ( knot = knot_new , Xc = Xc_new ) call this % create () end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function bincoeff ( n , k ) result ( b ) integer , intent ( in ) :: n , k real ( rk ) :: b b = floor ( 0.5_rk + exp ( factln ( n ) - factln ( k ) - factln ( n - k ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function factln ( n ) result ( f ) integer , intent ( in ) :: n real ( rk ) :: f if ( n <= 1 ) then f = 0.0_rk return end if f = log ( gamma ( real ( n + 1 , rk ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative ( this , res , Xt , dTgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable :: dTgci (:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if allocate ( dTgc ( size ( this % Xt , 1 ), this % nc )) if ( allocated ( this % Wc )) then do i = 1 , size ( this % Xt , 1 ) dTgci = basis_bspline_der ( this % Xt ( i ), this % knot , this % nc , this % order ) dTgci = dTgci * ( this % Wc / ( dot_product ( dTgci , this % Wc ))) dTgc ( i ,:) = dTgci end do else do i = 1 , size ( this % Xt , 1 ) dTgci = basis_bspline_der ( this % Xt ( i ), this % knot , this % nc , this % order ) dTgc ( i ,:) = dTgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis ( this , res , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if allocate ( Tgc ( size ( this % Xt , 1 ), this % nc )) if ( allocated ( this % Wc )) then do i = 1 , size ( this % Xt , 1 ) Tgci = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % order ) Tgci = Tgci * ( this % Wc / ( dot_product ( Tgci , this % Wc ))) Tgc ( i ,:) = Tgci end do else do i = 1 , size ( this % Xt , 1 ) Tgci = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % order ) Tgc ( i ,:) = Tgci end do end if end subroutine !=============================================================================== end module forcad_nurbs_curve","tags":"","loc":"sourcefile/forcad_nurbs_curve.f90.html"},{"title":"forcad_bezier_curve.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_bezier_curve.f90~~EfferentGraph sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_bezier_curve.f90~~AfferentGraph sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad_bezier_curve use forcad_utils , only : rk , basis_bernstein , elemConn_C0 implicit none private public bezier_curve !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type bezier_curve real ( rk ), allocatable , private :: Xc (:,:) !! Control points real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points real ( rk ), allocatable , private :: Wc (:) !! Weights real ( rk ), allocatable , private :: Xt (:) !! Parameter values integer , private :: nc !! Number of control points integer , private :: ng !! Number of geometry points contains procedure :: set !!> Set control points and weights procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure :: get_nc !!> Get number of control points procedure :: get_ng !!> Get number of geometry points procedure :: get_order !!> Get order of the Bezier curve procedure :: finalize !!> Finalize the Bezier curve object procedure :: get_elem_Xc !!> Generate connectivity for control points procedure :: get_elem_Xg !!> Generate connectivity for geometry points procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: elevate_degree !!> Elevate the degree of the Bezier curve end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the Bezier curve object. pure subroutine set ( this , Xc , Wc ) class ( bezier_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Generate geometry points of the Bezier curve. pure subroutine create ( this , res , Xt ) class ( bezier_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), optional :: Xt (:) real ( rk ), allocatable :: Tgc (:) integer :: i , j ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) ! Allocate memory for geometry points if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng , size ( this % Xc , 2 ))) ! Compute geometry points if ( allocated ( this % Wc )) then ! Rational Bezier curve do i = 1 , size ( this % Xt , 1 ) Tgc = basis_bernstein ( this % Xt ( i ), this % nc ) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else ! Non-rational Bezier curve do i = 1 , size ( this % Xt , 1 ) Tgc = basis_bernstein ( this % Xt ( i ), this % nc ) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( bezier_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( bezier_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( bezier_curve ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The Bezier curve is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this ) result ( Xt ) class ( bezier_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xt (:) if ( allocated ( this % Xt )) then Xt = this % Xt else error stop 'Parameter values are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( bezier_curve ), intent ( in ) :: this integer :: nc nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( bezier_curve ), intent ( in ) :: this integer :: ng ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_order ( this ) result ( order ) class ( bezier_curve ), intent ( in ) :: this integer :: order order = this % nc - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Finalize the Bezier curve object by deallocating memory. pure subroutine finalize ( this ) class ( bezier_curve ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Generate connectivity for control points. pure subroutine get_elem_Xc ( this , elemConn , p ) class ( bezier_curve ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % nc , p ) else elemConn = elemConn_C0 ( this % nc , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Generate connectivity for geometry points. pure subroutine get_elem_Xg ( this , elemConn , p ) class ( bezier_curve ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % ng , p ) else elemConn = elemConn_C0 ( this % ng , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Export control points to a VTK file. impure subroutine export_Xc ( this , filename ) class ( bezier_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if call this % get_elem_Xc ( elemConn ) nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension of control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Export geometry points to a VTK file. impure subroutine export_Xg ( this , filename ) class ( bezier_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if call this % get_elem_Xg ( elemConn ) ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension of geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Modify coordinate of a control point given its index and direction. pure subroutine modify_Xc ( this , X , num , dir ) class ( bezier_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Modify weight of a control point given its index. pure subroutine modify_Wc ( this , W , num ) class ( bezier_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( Xc = this % Xc , Wc = this % Wc ) else error stop 'The Bezier curve is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Elevate the degree of the Bezier curve by one. pure subroutine elevate_degree ( this ) class ( bezier_curve ), intent ( inout ) :: this integer :: nc_new , i real ( rk ), allocatable :: Xc_new (:,:) real ( rk ), allocatable :: Wc_new (:) real ( rk ) :: alpha ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if ( allocated ( this % Wc )) then ! Rational Bezier curve ! Calculate the new number of control points nc_new = this % nc + 1 allocate ( Xc_new ( nc_new , size ( this % Xc , 2 ))) allocate ( Wc_new ( nc_new )) ! Compute new control points and weights Xc_new ( 1 ,:) = this % Xc ( 1 ,:) * this % Wc ( 1 ) Wc_new ( 1 ) = this % Wc ( 1 ) Xc_new ( nc_new ,:) = this % Xc ( this % nc ,:) * this % Wc ( this % nc ) Wc_new ( nc_new ) = this % Wc ( this % nc ) do i = 2 , nc_new - 1 alpha = real ( i , rk ) / real ( nc_new - 1 , rk ) Xc_new ( i , :) = ( 1.0_rk - alpha ) * this % Xc ( i , :) * this % Wc ( i ) + alpha * this % Xc ( i - 1 , :) * this % Wc ( i - 1 ) Wc_new ( i ) = ( 1.0_rk - alpha ) * this % Wc ( i ) + alpha * this % Wc ( i - 1 ) end do ! Normalize the new control points do concurrent ( i = 1 : size ( this % Xc , 2 )) Xc_new (:, i ) = Xc_new (:, i ) / Wc_new (:) end do ! Update geometry points deallocate ( this % Xc , this % Wc ) call this % set ( Xc = Xc_new , Wc = Wc_new ) call this % create ( Xt = this % Xt ) else ! Non-rational Bezier curve ! Calculate the new number of control points nc_new = this % nc + 1 allocate ( Xc_new ( nc_new , size ( this % Xc , 2 ))) ! Compute new control points Xc_new ( 1 ,:) = this % Xc ( 1 ,:) Xc_new ( nc_new ,:) = this % Xc ( this % nc ,:) do i = 2 , nc_new - 1 alpha = real ( i , rk ) / real ( nc_new - 1 , rk ) Xc_new ( i , :) = ( 1.0_rk - alpha ) * this % Xc ( i , :) + alpha * this % Xc ( i - 1 , :) end do ! Update geometry points call this % set ( Xc = Xc_new ) call this % create ( Xt = this % Xt ) end if end subroutine !=============================================================================== end module forcad_bezier_curve","tags":"","loc":"sourcefile/forcad_bezier_curve.f90.html"},{"title":"forcad_utils.f90 – ForCAD","text":"Files dependent on this one sourcefile~~forcad_utils.f90~~AfferentGraph sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad_utils implicit none private public :: rk , basis_bernstein , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der integer , parameter :: rk = kind ( 1.0d0 ) !=============================================================================== interface elemConn_C0 module procedure cmp_elemConn_C0_L module procedure cmp_elemConn_C0_S module procedure cmp_elemConn_C0_V end interface !=============================================================================== !=============================================================================== interface ndgrid module procedure ndgrid2 module procedure ndgrid3 end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bspline ( Xt , knot , nc , order ) result ( B ) integer , intent ( in ) :: order real ( rk ), intent ( in ) :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 real ( rk ), allocatable :: Nt (:,:) integer :: i , p real ( rk ), allocatable :: B (:) temp = abs ( Xt - knot ( size ( knot ))) allocate ( Nt ( nc , 0 : order ), source = 0.0_rk ) do p = 0 , order do i = 1 , nc Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xt >= Xth_i . and . Xt <= Xth_i1 ) Nt ( i , 0 ) = 1.0_rk if ( Xth_ip /= Xth_i ) Nt ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * Nt ( i , p - 1 ) if ( Xth_ip1 /= Xth_i1 ) Nt ( i , p ) = Nt ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * Nt ( i + 1 , p - 1 ) end do end do B = Nt (:, order ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function basis_bspline_der ( Xt , knot , nc , order ) result ( dB ) integer , intent ( in ) :: order real ( rk ), intent ( in ) :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable :: dB (:) real ( rk ), allocatable :: Nt (:,:), dNt_dXt (:,:) real ( rk ) :: R , L , Rp , Lp , knot_i , knot_ip , knot_jk , knot_jkm , knot_end , a , b , c , d integer :: i , p , k , n , m , jk k = order + 1 n = nc - 1 allocate ( Nt ( nc + order , order + 1 )) Nt = 0.0_rk do i = 1 , n + k knot_i = knot ( i ) knot_ip = knot ( i + 1 ) knot_end = knot ( size ( knot )) if ( abs ( Xt - knot_end ) > tiny ( 0.0_rk ) ) then if ( Xt >= knot_i . and . Xt < knot_ip ) Nt ( i , 1 ) = 1.0_rk elseif ( abs ( Xt - knot_end ) < tiny ( 0.0_rk ) ) then if ( Xt >= knot_i . and . Xt <= knot_ip ) Nt ( i , 1 ) = 1.0_rk end if end do allocate ( dNt_dXt ( nc + order , order + 1 )) dNt_dXt = 0.0_rk m = 0 do jk = 2 , k m = m + 1 do i = 1 , n + k - m knot_i = knot ( i ) knot_ip = knot ( i + 1 ) knot_jk = knot ( i + jk ) knot_jkm = knot ( i + jk - 1 ) a = ( knot_jkm - knot_i ) b = ( knot_jk - Xt ) c = ( knot_jk - knot_ip ) d = ( Xt - knot_i ) R = d / a if ( isnan ( R ) . or . isinf ( R ) . or . abs ( R ) < tiny ( 0.0_rk ) ) R = 0.0_rk L = b / c if ( isnan ( L ) . or . isinf ( L ) . or . abs ( L ) < tiny ( 0.0_rk ) ) L = 0.0_rk Nt ( i , jk ) = R * Nt ( i , jk - 1 ) + L * Nt ( i + 1 , jk - 1 ) Rp = ( Nt ( i , jk - 1 ) + d * dNt_dXt ( i , jk - 1 )) / a if ( isnan ( Rp ) . or . isinf ( Rp ) . or . abs ( Rp ) < tiny ( 0.0_rk ) ) Rp = 0.0_rk Lp = ( b * dNt_dXt ( i + 1 , jk - 1 ) - Nt ( i + 1 , jk - 1 )) / c if ( isnan ( Lp ) . or . isinf ( Lp ) . or . abs ( Lp ) < tiny ( 0.0_rk ) ) Lp = 0.0_rk dNt_dXt ( i , jk ) = Rp + Lp end do end do dB = dNt_dXt ( 1 : nc , k ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bernstein ( Xt , nc ) result ( B ) real ( rk ), intent ( in ) :: Xt integer , intent ( in ) :: nc real ( rk ), allocatable :: B (:) integer :: p , order order = nc - 1 allocate ( B ( nc ), source = 0.0_rk ) do concurrent ( p = 0 : order ) B ( p + 1 ) = gamma ( real ( nc , kind = rk )) / ( gamma ( real ( p + 1 , kind = rk )) * gamma ( real ( nc - p , kind = rk ))) if ( Xt == 0.0_rk . and . p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( 1.0_rk - Xt ) ** ( order - p ) else if ( Xt == 0.0_rk . and . order - p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) else B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) * ( 1.0_rk - Xt ) ** ( order - p ) end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron ( u , v ) result ( w ) real ( rk ), dimension (:), intent ( in ), contiguous :: u , v real ( rk ), dimension ( size ( u ) * size ( v )) :: w integer :: i , j , m , n m = size ( u ) n = size ( v ) do i = 1 , m do j = 1 , n w (( i - 1 ) * n + j ) = u ( i ) * v ( j ) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid2 ( X_dir1 , X_dir2 , Xt ) real ( rk ), dimension (:), intent ( in ), contiguous :: X_dir1 , X_dir2 real ( rk ), dimension (:,:), allocatable , intent ( out ) :: Xt integer :: s1 , s2 , i , j , n s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) allocate ( Xt ( s1 * s2 , 2 )) n = 0 do j = 1 , s2 do i = 1 , s1 n = n + 1 Xt ( n , 1 ) = X_dir1 ( i ) Xt ( n , 2 ) = X_dir2 ( j ) end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid3 ( X_dir1 , X_dir2 , X_dir3 , Xt ) real ( rk ), dimension (:), intent ( in ), contiguous :: X_dir1 , X_dir2 , X_dir3 real ( rk ), dimension (:,:), allocatable , intent ( out ) :: Xt integer :: s1 , s2 , s3 , i , j , k , n s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) s3 = size ( X_dir3 ) allocate ( Xt ( s1 * s2 * s3 , 3 )) n = 0 do k = 1 , s3 do j = 1 , s2 do i = 1 , s1 n = n + 1 Xt ( n , 1 ) = X_dir1 ( i ) Xt ( n , 2 ) = X_dir2 ( j ) Xt ( n , 3 ) = X_dir3 ( k ) end do end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function repelem ( a , b ) result ( c ) real ( rk ), dimension (:), intent ( in ), contiguous :: a integer , dimension (:), intent ( in ), contiguous :: b real ( rk ), dimension ( sum ( b )) :: c integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function repelem !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_L ( nnode , p ) result ( elemConn ) integer , intent ( in ) :: nnode integer , intent ( in ) :: p integer , dimension (:,:), allocatable :: elemConn integer :: i , l integer , dimension (:), allocatable :: nodes allocate ( elemConn ( (( nnode - p ) / p ) , 2 )) nodes = [( i , i = 1 , nnode )] l = 0 do i = 1 , nnode - p , p l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p ),[( p + 1 )]) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_S ( nnode1 , nnode2 , p1 , p2 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 integer , intent ( in ) :: p1 , p2 integer , dimension (:,:), allocatable :: elemConn integer :: i , j , l integer , dimension (:,:), allocatable :: nodes allocate ( elemConn ( (( nnode1 - p1 ) / p1 ) * (( nnode2 - p2 ) / p2 ) , 4 )) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 )], [ nnode1 , nnode2 ]) l = 0 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 ),[( p1 + 1 ) * ( p2 + 1 )]) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 , nnode3 integer , intent ( in ) :: p1 , p2 , p3 integer , dimension (:,:), allocatable :: elemConn integer :: i , j , k , l integer , dimension (:,:,:), allocatable :: nodes allocate ( elemConn ( (( nnode1 - p1 ) / p1 ) * (( nnode2 - p2 ) / p2 ) * (( nnode3 - p3 ) / p3 ) , 8 )) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 * nnode3 )], [ nnode1 , nnode2 , nnode3 ]) l = 0 do k = 1 , nnode3 - p3 , p3 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 , k : k + p3 ),[( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 )]) end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity ( knot ) result ( multiplicity ) real ( rk ), intent ( in ) :: knot (:) integer , dimension (:), allocatable :: multiplicity integer :: i , count count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) count = count + 1 end do allocate ( multiplicity ( count )) multiplicity ( 1 ) = 1 count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) then count = count + 1 multiplicity ( count ) = 1 else multiplicity ( count ) = multiplicity ( count ) + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_knot_vector ( Xth_dir , order , continuity ) result ( knot ) real ( rk ), intent ( in ) :: Xth_dir (:) integer , intent ( in ) :: order integer , intent ( in ) :: continuity (:) real ( rk ), allocatable :: knot (:) knot = repelem ( Xth_dir , ( order - continuity )) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause elemental pure function isinf ( x ) result ( output ) real ( rk ), intent ( in ) :: x logical :: output output = . false . if ( x > huge ( x )) output = . true . if ( x < - huge ( x )) output = . true . end function !=============================================================================== end module forcad_utils","tags":"","loc":"sourcefile/forcad_utils.f90.html"},{"title":"forcad.f90 – ForCAD","text":"This file depends on sourcefile~~forcad.f90~~EfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad.f90~~AfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad use forcad_utils use forcad_bezier_curve use forcad_bezier_surface use forcad_bezier_volume use forcad_nurbs_curve use forcad_nurbs_surface use forcad_nurbs_volume private public rk ,& bezier_curve , bezier_surface , bezier_volume ,& nurbs_curve , nurbs_surface , nurbs_volume end module forcad","tags":"","loc":"sourcefile/forcad.f90.html"},{"title":"forcad_bezier_surface.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_bezier_surface.f90~~EfferentGraph sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_bezier_surface.f90~~AfferentGraph sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad_bezier_surface use forcad_utils , only : rk , basis_bernstein , elemConn_C0 , kron , ndgrid implicit none private public bezier_surface !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type bezier_surface real ( rk ), allocatable , private :: Xc (:,:) !! control points real ( rk ), allocatable , private :: Xg (:,:) !! geometry points real ( rk ), allocatable , private :: Wc (:) !! weights real ( rk ), allocatable , private :: Xt1 (:) !! parameter values in the first direction real ( rk ), allocatable , private :: Xt2 (:) !! parameter values in the second direction integer , private :: nc ( 2 ) !! number of control points in each direction integer , private :: ng ( 2 ) !! number of geometry points in each direction contains procedure :: set !!> Set control points and weights procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure :: get_nc !!> Get number of control points procedure :: get_ng !!> Get number of geometry points procedure :: get_order !!> Get order of the Bezier surface procedure :: finalize !!> Finalize the Bezier surface object procedure :: get_elem_Xc !!> Generate connectivity for control points procedure :: get_elem_Xg !!> Generate connectivity for geometry points procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the Bezier curve object. pure subroutine set ( this , nc , Xc , Wc ) class ( bezier_surface ), intent ( inout ) :: this integer , intent ( in ) :: nc (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % Xc = Xc this % nc = nc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , Xt1 , Xt2 ) class ( bezier_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:) integer :: i , j real ( rk ), dimension (:), allocatable :: Tgc1 , Tgc2 , Tgc real ( rk ), dimension (:,:), allocatable :: Xt ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng ( 1 ) * this % ng ( 2 ), size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then ! Rational Bezier surface do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bernstein ( Xt ( i , 1 ), this % nc ( 1 )) Tgc2 = basis_bernstein ( Xt ( i , 2 ), this % nc ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else ! Non-rational Bezier surface do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bernstein ( Xt ( i , 1 ), this % nc ( 1 )) Tgc2 = basis_bernstein ( Xt ( i , 2 ), this % nc ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine create !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( bezier_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( bezier_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( bezier_surface ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The Bezier curve is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( bezier_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( bezier_surface ), intent ( in ) :: this integer :: nc ( 2 ) nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( bezier_surface ), intent ( in ) :: this integer :: ng ( 2 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_order ( this ) result ( order ) class ( bezier_surface ), intent ( in ) :: this integer :: order ( 2 ) order = this % nc - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( bezier_surface ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xc ( this , elemConn , p ) class ( bezier_surface ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xg ( this , elemConn , p ) class ( bezier_surface ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( bezier_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if call this % get_elem_Xc ( elemConn ) nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( bezier_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if call this % get_elem_Xg ( elemConn ) ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Modify coordinate of a control point given its index and direction. pure subroutine modify_Xc ( this , X , num , dir ) class ( bezier_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( nc = this % nc , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Modify weight of a control point given its index. pure subroutine modify_Wc ( this , W , num ) class ( bezier_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( nc = this % nc , Xc = this % Xc , Wc = this % Wc ) else error stop 'The Bezier curve is not rational.' end if end subroutine !=============================================================================== end module forcad_bezier_surface","tags":"","loc":"sourcefile/forcad_bezier_surface.f90.html"},{"title":"nurbs_volume.f90 – ForCAD","text":"This file depends on sourcefile~~nurbs_volume.f90~~EfferentGraph sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 15, 15, and 15 in the three dimensions call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), dimension (:,:), allocatable :: control_points real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"sourcefile/nurbs_volume.f90.html"},{"title":"bezier_surface.f90 – ForCAD","text":"This file depends on sourcefile~~bezier_surface.f90~~EfferentGraph sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a Bezier surface object to create, and finalize a Bezier surface. !> It sets up control points and weights, generates the surface, and exports the control points !> and the surface to VTK files at various stages. program example_bezier_surface use forcad , only : rk , bezier_surface implicit none type ( bezier_surface ) :: bezier !! Declare a bezier surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the bezier surface !----------------------------------------------------------------------------- !> Define control points for the Bezier surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the bezier surface object call bezier % set ([ 10 , 10 ], Xc , Wc ) !> Export initial control points to a VTK file call bezier % export_Xc ( 'vtk/bezier_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the bezier surface !----------------------------------------------------------------------------- !> Generate the Bezier surface with a resolution of 100x100 call bezier % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call bezier % export_Xg ( 'vtk/bezier_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the Bezier surface object call bezier % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), dimension (:,:), allocatable :: control_points integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 ) y_spacing = 1.0_rk / real ( num_rows - 1 ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_bezier_surface","tags":"","loc":"sourcefile/bezier_surface.f90.html"},{"title":"bezier_curve.f90 – ForCAD","text":"This file depends on sourcefile~~bezier_curve.f90~~EfferentGraph sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a Bezier curve object to create, and finalize a Bezier curve. !> It sets up control points and weights, generates the curve, and exports the control points !> and the curve to VTK files at various stages. program example_bezier_curve use forcad , only : rk , bezier_curve implicit none type ( bezier_curve ) :: bezier !! Declare a bezier curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the bezier curve !----------------------------------------------------------------------------- !> Define control points for the Bezier curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the bezier curve object call bezier % set ( Xc = Xc , Wc = Wc ) !> Export initial control points to a VTK file call bezier % export_Xc ( 'vtk/bezier_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the bezier curve !----------------------------------------------------------------------------- !> Generate the Bezier curve with a resolution of 1000 call bezier % create ( res = 500 ) !> Export the generated curve to a VTK file call bezier % export_Xg ( 'vtk/bezier_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the Bezier curve object call bezier % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), dimension (:,:), allocatable :: control_points integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * ( coil - 1 ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_bezier_curve","tags":"","loc":"sourcefile/bezier_curve.f90.html"},{"title":"forcad_bezier_volume.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_bezier_volume.f90~~EfferentGraph sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_bezier_volume.f90~~AfferentGraph sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad_bezier_volume use forcad_utils , only : rk , basis_bernstein , elemConn_C0 , kron , ndgrid implicit none private public bezier_volume !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type bezier_volume real ( rk ), allocatable , private :: Xc (:,:) !! control points real ( rk ), allocatable , private :: Xg (:,:) !! geometry points real ( rk ), allocatable , private :: Wc (:) !! weights real ( rk ), allocatable , private :: Xt1 (:) !! parameter values in the first direction real ( rk ), allocatable , private :: Xt2 (:) !! parameter values in the second direction real ( rk ), allocatable , private :: Xt3 (:) !! parameter values in the third direction integer , private :: nc ( 3 ) !! number of control points in each direction integer , private :: ng ( 3 ) !! number of geometry points in each direction contains procedure :: set !!> Set control points and weights procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_nc !!> Get number of control points procedure :: get_ng !!> Get number of geometry points procedure :: get_order !!> Get order of the Bezier surface procedure :: finalize !!> Finalize the Bezier volume object procedure :: get_elem_Xc !!> Generate connectivity for control points procedure :: get_elem_Xg !!> Generate connectivity for geometry points procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights end type bezier_volume !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the Bezier curve object. pure subroutine set ( this , nc , Xc , Wc ) class ( bezier_volume ), intent ( inout ) :: this integer , intent ( in ) :: nc (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % Xc = Xc this % nc = nc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 ) class ( bezier_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:), Xt3 (:) integer :: i , j real ( rk ), dimension (:), allocatable :: Tgc1 , Tgc2 , Tgc3 , Tgc real ( rk ), dimension (:,:), allocatable :: Xt integer , intent ( in ), optional :: res1 , res2 , res3 ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bernstein ( Xt ( i , 1 ), this % nc ( 1 )) Tgc2 = basis_bernstein ( Xt ( i , 2 ), this % nc ( 2 )) Tgc3 = basis_bernstein ( Xt ( i , 3 ), this % nc ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bernstein ( Xt ( i , 1 ), this % nc ( 1 )) Tgc2 = basis_bernstein ( Xt ( i , 2 ), this % nc ( 2 )) Tgc3 = basis_bernstein ( Xt ( i , 3 ), this % nc ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( bezier_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( bezier_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( bezier_volume ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The Bezier curve is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( bezier_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % Xt3 )) then Xt = this % Xt3 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( bezier_volume ), intent ( in ) :: this integer :: nc ( 3 ) nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( bezier_volume ), intent ( in ) :: this integer :: ng ( 3 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_order ( this ) result ( order ) class ( bezier_volume ), intent ( in ) :: this integer :: order ( 3 ) order = this % nc - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( bezier_volume ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xc ( this , elemConn , p ) class ( bezier_volume ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), 1 , 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xg ( this , elemConn , p ) class ( bezier_volume ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), 1 , 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( bezier_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if call this % get_elem_Xc ( elemConn ) nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( bezier_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if call this % get_elem_Xg ( elemConn ) ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( bezier_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( nc = this % nc , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( bezier_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( nc = this % nc , Xc = this % Xc , Wc = this % Wc ) else error stop 'The Bezier curve is not rational.' end if end subroutine !=============================================================================== end module forcad_bezier_volume","tags":"","loc":"sourcefile/forcad_bezier_volume.f90.html"},{"title":"nurbs_curve.f90 – ForCAD","text":"This file depends on sourcefile~~nurbs_curve.f90~~EfferentGraph sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_bezier_curve.f90 forcad_bezier_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_curve.f90 sourcefile~forcad_bezier_surface.f90 forcad_bezier_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_surface.f90 sourcefile~forcad_bezier_volume.f90 forcad_bezier_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_bezier_volume.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_bezier_volume.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- ! Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] ! Define weights for the control points allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights for the NURBS curve object call nurbs % set ( knot , Xc , Wc ) ! Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- ! Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) ! Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- ! Insert knots call nurbs % insert_knot ([ 0.25_rk , 0.75_rk ]) ! Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) ! Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) ! Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- ! Finalize the NURBS curve object call nurbs % finalize () end program example_nurbs_curve","tags":"","loc":"sourcefile/nurbs_curve.f90.html"},{"title":"forcad_nurbs_volume.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_volume.f90~~EfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_volume.f90~~AfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~bezier_curve.f90 bezier_curve.f90 sourcefile~bezier_curve.f90->sourcefile~forcad.f90 sourcefile~bezier_surface.f90 bezier_surface.f90 sourcefile~bezier_surface.f90->sourcefile~forcad.f90 sourcefile~bezier_volume.f90 bezier_volume.f90 sourcefile~bezier_volume.f90->sourcefile~forcad.f90 sourcefile~nurbs_curve.f90 nurbs_curve.f90 sourcefile~nurbs_curve.f90->sourcefile~forcad.f90 sourcefile~nurbs_surface.f90 nurbs_surface.f90 sourcefile~nurbs_surface.f90->sourcefile~forcad.f90 sourcefile~nurbs_volume.f90 nurbs_volume.f90 sourcefile~nurbs_volume.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forcad_nurbs_volume use forcad_utils , only : rk , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der implicit none private public nurbs_volume !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_volume real ( rk ), allocatable , private :: Xc (:,:) !! control points real ( rk ), allocatable , private :: Xg (:,:) !! geometry points real ( rk ), allocatable , private :: Wc (:) !! weights real ( rk ), allocatable , private :: Xt1 (:) !! parameter values in the first direction real ( rk ), allocatable , private :: Xt2 (:) !! parameter values in the second direction real ( rk ), allocatable , private :: Xt3 (:) !! parameter values in the third direction real ( rk ), allocatable , private :: knot1 (:) !! knot vector real ( rk ), allocatable , private :: knot2 (:) !! knot vector real ( rk ), allocatable , private :: knot3 (:) !! knot vector integer , private :: order ( 3 ) !! degree of the first direction integer , private :: nc ( 3 ) !! number of control points in each direction integer , private :: ng ( 3 ) !! number of geometry points in each direction contains procedure :: set1 !!> Set control points and weights procedure :: set2 !!> Set control points and weights generic :: set => set1 , set2 procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure :: get_knot !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: get_order !!> Get order of the Bezier curve procedure :: finalize !!> Finalize the NURBS curve object procedure :: get_elem_Xc !!> Generate connectivity for control points procedure :: get_elem_Xg !!> Generate connectivity for geometry points procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Get multiplicity of the knot vector procedure :: get_continuity !!> Get continuity of the curve procedure :: get_nc !!> Get number of required control points procedure :: derivative !!> Compute the derivative of the NURBS curve procedure :: basis !!> Compute the basis functions of the NURBS curve end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS curve object. pure subroutine set1 ( this , knot1 , knot2 , knot3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: knot1 (:), knot2 (:), knot3 (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % knot1 = knot1 this % knot2 = knot2 this % knot3 = knot3 this % order = this % get_order () this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % nc ( 3 ) = this % get_nc ( 3 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS curve object. pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , Xth_dir3 , order , continuity1 , continuity2 , continuity3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xth_dir1 (:), Xth_dir2 (:), Xth_dir3 (:) integer , intent ( in ) :: order (:) integer , intent ( in ) :: continuity1 (:), continuity2 (:), continuity3 (:) real ( rk ), intent ( in ) :: Xc (:,:) real ( rk ), intent ( in ), optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , order ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , order ( 2 ), continuity2 ) this % knot3 = compute_knot_vector ( Xth_dir3 , order ( 3 ), continuity3 ) this % order ( 1 ) = order ( 1 ) this % order ( 2 ) = order ( 2 ) this % order ( 3 ) = order ( 3 ) this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % nc ( 3 ) = this % get_nc ( 3 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:), Xt3 (:) integer :: i , j real ( rk ), dimension (:), allocatable :: Tgc1 , Tgc2 , Tgc3 , Tgc real ( rk ), dimension (:,:), allocatable :: Xt ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % order ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % order ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The Bezier curve is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % Xt3 )) then Xt = this % Xt3 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_volume ), intent ( in ) :: this integer :: ng ( 3 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_order ( this ) result ( order ) class ( nurbs_volume ), intent ( in ) :: this integer :: order ( 3 ) integer , allocatable :: m1 (:), m2 (:), m3 (:) m1 = this % get_multiplicity ( 1 ) m2 = this % get_multiplicity ( 2 ) m3 = this % get_multiplicity ( 3 ) order ( 1 ) = m1 ( 1 ) - 1 order ( 2 ) = m2 ( 1 ) - 1 order ( 3 ) = m3 ( 1 ) - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot ( this , dir ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then knot = this % knot3 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_volume ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xc ( this , elemConn , p ) class ( nurbs_volume ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), 1 , 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine get_elem_Xg ( this , elemConn , p ) class ( nurbs_volume ), intent ( in ) :: this integer , dimension (:,:), allocatable , intent ( out ) :: elemConn integer , intent ( in ), optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), 1 , 1 , 1 ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if call this % get_elem_Xc ( elemConn ) nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , dimension (:,:), allocatable :: elemConn ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if call this % get_elem_Xg ( elemConn ) ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = this % knot3 , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = this % knot3 , Xc = this % Xc , Wc = this % Wc ) else error stop 'The NURBS surface is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % order ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % order ( 2 ) - compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else c = this % order ( 3 ) - compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this , dir ) result ( nc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % order ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % order ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot3 )) - this % order ( 3 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , dTgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable :: dTgci (:) integer :: i real ( rk ), dimension (:), allocatable :: dTgc1 , dTgc2 , dTgc3 real ( rk ), dimension (:,:), allocatable :: Xt ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) allocate ( dTgc ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) dTgc3 = basis_bspline_der ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % order ( 3 )) dTgci = kron ( dTgc3 , kron ( dTgc2 , dTgc1 )) dTgci = dTgci * ( this % Wc / ( dot_product ( dTgci , this % Wc ))) dTgc ( i ,:) = dTgci end do else do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) dTgc3 = basis_bspline_der ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % order ( 3 )) dTgci = kron ( dTgc3 , kron ( dTgc2 , dTgc1 )) dTgc ( i ,:) = dTgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i real ( rk ), dimension (:), allocatable :: Tgc1 , Tgc2 , Tgc3 real ( rk ), dimension (:,:), allocatable :: Xt ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) allocate ( Tgc ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % order ( 3 )) Tgci = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgci = Tgci * ( this % Wc / ( dot_product ( Tgci , this % Wc ))) Tgc ( i ,:) = Tgci end do else do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % order ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % order ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % order ( 3 )) Tgci = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc ( i ,:) = Tgci end do end if end subroutine !=============================================================================== end module forcad_nurbs_volume","tags":"","loc":"sourcefile/forcad_nurbs_volume.f90.html"}]}