var tipuesearch = {"pages":[{"title":" ForCAD ","text":"ForCAD ForCAD : A parallel Fortran library for geometric modeling using NURBS (Non-Uniform Rational B-Splines). ForCAD supports B-Spline , NURBS , Bezier , and Rational Bezier curves, surfaces, and volumes. Main Features Parallelized using OpenMP and do concurrent . Create NURBS objects by specifying control points, weights and knots. Refine NURBS objects by inserting or removing knots and elevating degree. Compute basis functions and derivatives of NURBS objects. Obtain IGA elements connectivity. Obtain visualized elements connectivity and coordinates for geometry and control geometry. Mesh insertion into a NURBS object. Export NURBS objects to VTK files for visualization. Includes predefined NURBS shapes: Circle, Half Circle, Tetragon, Hexahedron, 2D Ring, Half 2D Ring, 3D Ring, Half 3D Ring, C-shapes. Rotate and translate NURBS objects. Visualization using provided python PyVista scripts. Examples Installation Requirements A Fortran compiler, such as GNU Fortran ( gfortran ), Intel Fortran Compiler ( ifx/ifort ) or NVIDIA HPC SDK Fortran compiler ( nvfortran ). The Fortran Package Manager fpm . Optional: PyVista (Recommended) or ParaView for visualization. Clone the repository Clone the ForCAD repository from GitHub: git clone https://github.com/gha3mi/forcad.git cd forcad Install PyVista (Optional) To install PyVista, run the following command: pip install pyvista Running Examples with fpm fpm run --example <file name excluding the .f90 extension> After executing the examples, .vtk files will be generated in the vtk directory. To visualize these files, a show() method is provided which utilizes PyVista. Alternatively, other visualization tools like ParaView can also be used. Using ForCAD as a fpm Dependency If you want to use ForCAD as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forcad = { git = \"https://github.com/gha3mi/forcad.git\" } API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForCAD using ford run the following\ncommand: ford ford.yml Roadmap For a detailed roadmap outlining upcoming features and enhancements, please refer to ROADMAP.md . Contributing To contribute to ForCAD, please review the CONTRIBUTING.md . Citation If you use ForCAD in your research, please cite it as follows: @software { seyed_ali_ghasemi_2024_10904447 , author = {Ghasemi, S. A.} , title = {gha3mi/ForCAD} , year = 2024 , publisher = {Zenodo} , doi = {10.5281/zenodo.10904447} , url = {https://doi.org/10.5281/zenodo.10904447} } References Piegl, L., & Tiller, W. (1995). The NURBS Book. In Monographs in Visual Communications. Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-642-97385-7 An Introduction to NURBS. (2001). Elsevier. https://doi.org/10.1016/b978-1-55860-669-2.x5000-3 Sullivan et al., (2019). PyVista: 3D plotting and mesh analysis through a streamlined interface for the Visualization Toolkit (VTK). Journal of Open Source Software, 4(37), 1450, https://doi.org/10.21105/joss.01450 Ahrens, James, Geveci, Berk, Law, Charles, ParaView: An End-User Tool for Large Data Visualization, Visualization Handbook, Elsevier, 2005, ISBN-13: 9780123875822 Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"nurbs_surface – ForCAD ","text":"type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS surface private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_degree Compute degree of the NURBS surface private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS surface private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS surface private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate degree private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS surface object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the NURBS surface private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knot vector private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of control points private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS surface is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS surface (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS surface (Minimization - Newton's method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 Set NURBS surface private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vectors, control points and weights for the NURBS surface object private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier surface using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_ring Set a half ring private pure subroutine set_half_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_ring Set a ring private pure subroutine set_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 procedure, public :: set_tetragon Set a tetragon private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS surface private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS surface private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS surface private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS surface private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS surface private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative_vector Compute the derivative of the NURBS surface private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_degree_all Get degree of the NURBS surface in both directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk)","tags":"","loc":"type/nurbs_surface.html"},{"title":"nurbs_curve – ForCAD ","text":"type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS curve private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_degree Compute degree of the NURBS curve private pure subroutine cmp_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: create Generate geometry points private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS curve private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS curve private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate the degree of the curve private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS curve object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the curve private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_degree Get degree of the NURBS curve private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knots private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS curve is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS curve (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS curve (Minimization - Newton's method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 Set NURBS curve private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vector, control points and weights for the NURBS curve object private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier curve using control points and weights private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: set_circle Set a circle private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_circle Set a half circle private pure subroutine set_half_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS curve private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS curve private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS curve private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS curve private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS curve private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative_vector Compute the derivative of the NURBS curve private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk)","tags":"","loc":"type/nurbs_curve.html"},{"title":"nurbs_volume – ForCAD ","text":"type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1) ng(2) ng(3), dim] real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS volume private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, public :: cmp_Xg Compute geometry points private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) procedure, public :: cmp_degree Compute degree of the NURBS volume private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: cmp_degreeFace Compute degrees of the faces private pure function cmp_degreeFace (this, face) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elemFace Compute faces of the IGA elements private pure function cmp_elemFace (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elemFace_Xc_vis Compute faces of the control points private pure function cmp_elemFace_Xc_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elemFace_Xg_vis Compute faces of the geometry points private pure function cmp_elemFace_Xg_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_nc Compute number of required control points private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS volume private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS volume private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, public :: elevate_degree Elevate the degree of the NURBS volume private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS volume object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this generic, public :: get_Wc => get_Wc_all , get_Wci Get weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Compute and return the continuity of the NURBS volume private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Compute and return the multiplicity of the knots private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS volume is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: nearest_point Find the nearest point on the NURBS volume (Approximation) private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id procedure, public :: nearest_point2 Find the nearest point on the NURBS volume (Minimization - Newton's method) private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) procedure, public :: put_to_nurbs Put a shape to a NURBS volume private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 Set NURBS volume private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vectors, control points and weights for the NURBS volume object private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier volume using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_C Set a C-shape private pure subroutine set_C (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_half_ring Set a half ring private pure subroutine set_half_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: set_hexahedron Set a hexahedron private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_ring Set a ring private pure subroutine set_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length procedure, public :: show Show the NURBS object using PyVista private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: basis_scalar Compute the basis functions of the NURBS volume private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) procedure, private :: basis_vector Compute the basis functions of the NURBS volume private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, private :: derivative2_scalar Compute the second derivative of the NURBS volume private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative2_vector Compute the second derivative of the NURBS volume private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: derivative_scalar Compute the derivative of the NURBS volume private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) procedure, private :: derivative_vector Compute the derivative of the NURBS volume private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) procedure, private :: get_Wc_all Get all weights private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Wci Get i-th weight private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) procedure, private :: get_Xc_all Get all control points private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xci Get i-th control point private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xcid Get i-th control point in a specific direction private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_Xg_all Get all geometry points private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, private :: get_Xgi Get i-th geometry point private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) procedure, private :: get_Xgid Get i-th geometry point in a specific direction private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) procedure, private :: get_degree_all Get degree of the NURBS volume in all directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk)","tags":"","loc":"type/nurbs_volume.html"},{"title":"compute_Xg_nurbs_2d – ForCAD","text":"impure function compute_Xg_nurbs_2d(Xt, knot1, knot2, degree, nc, ng, Xc, Wc) result(Xg) Uses forcad_utils proc~~compute_xg_nurbs_2d~~UsesGraph proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d module~forcad_utils forcad_utils proc~compute_xg_nurbs_2d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_2d~~CallsGraph proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~basis_bspline basis_bspline proc~compute_xg_nurbs_2d->proc~basis_bspline proc~kron kron proc~compute_xg_nurbs_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_nurbs_2d.html"},{"title":"compute_Xg_nurbs_2d_1point – ForCAD","text":"impure function compute_Xg_nurbs_2d_1point(Xt, knot1, knot2, degree, nc, Xc, Wc) result(Xg) Uses forcad_utils proc~~compute_xg_nurbs_2d_1point~~UsesGraph proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point module~forcad_utils forcad_utils proc~compute_xg_nurbs_2d_1point->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_nurbs_2d_1point~~CallsGraph proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~basis_bspline basis_bspline proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_nurbs_2d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_nurbs_2d_1point.html"},{"title":"compute_Xg_bspline_2d – ForCAD","text":"impure function compute_Xg_bspline_2d(Xt, knot1, knot2, degree, nc, ng, Xc) result(Xg) Uses forcad_utils proc~~compute_xg_bspline_2d~~UsesGraph proc~compute_xg_bspline_2d compute_Xg_bspline_2d module~forcad_utils forcad_utils proc~compute_xg_bspline_2d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_2d~~CallsGraph proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_bspline_2d.html"},{"title":"compute_Xg_bspline_2d_1point – ForCAD","text":"impure function compute_Xg_bspline_2d_1point(Xt, knot1, knot2, degree, nc, Xc) result(Xg) Uses forcad_utils proc~~compute_xg_bspline_2d_1point~~UsesGraph proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point module~forcad_utils forcad_utils proc~compute_xg_bspline_2d_1point->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_bspline_2d_1point~~CallsGraph proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_2d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_bspline_2d_1point.html"},{"title":"compute_Tgc_nurbs_2d_vector – ForCAD","text":"impure function compute_Tgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc) result(Tgc) Uses forcad_utils proc~~compute_tgc_nurbs_2d_vector~~UsesGraph proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector module~forcad_utils forcad_utils proc~compute_tgc_nurbs_2d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_2d_vector~~CallsGraph proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_nurbs_2d_vector.html"},{"title":"compute_Tgc_nurbs_2d_scalar – ForCAD","text":"impure function compute_Tgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc) result(Tgc) Uses forcad_utils proc~~compute_tgc_nurbs_2d_scalar~~UsesGraph proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar module~forcad_utils forcad_utils proc~compute_tgc_nurbs_2d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_2d_scalar~~CallsGraph proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_nurbs_2d_scalar.html"},{"title":"compute_Tgc_bspline_2d_vector – ForCAD","text":"impure function compute_Tgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng) result(Tgc) Uses forcad_utils proc~~compute_tgc_bspline_2d_vector~~UsesGraph proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector module~forcad_utils forcad_utils proc~compute_tgc_bspline_2d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_2d_vector~~CallsGraph proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_bspline_2d_vector.html"},{"title":"compute_Tgc_bspline_2d_scalar – ForCAD","text":"impure function compute_Tgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc) result(Tgc) Uses forcad_utils proc~~compute_tgc_bspline_2d_scalar~~UsesGraph proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar module~forcad_utils forcad_utils proc~compute_tgc_bspline_2d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_2d_scalar~~CallsGraph proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_bspline_2d_scalar.html"},{"title":"nearest_point_help_2d – ForCAD","text":"impure function nearest_point_help_2d(ng, Xg, point_Xg) result(distances) Uses forcad_utils proc~~nearest_point_help_2d~~UsesGraph proc~nearest_point_help_2d nearest_point_help_2d module~forcad_utils forcad_utils proc~nearest_point_help_2d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/nearest_point_help_2d.html"},{"title":"compute_dTgc_nurbs_2d_vector – ForCAD","text":"impure subroutine compute_dTgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_nurbs_2d_vector~~UsesGraph proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector module~forcad_utils forcad_utils proc~compute_dtgc_nurbs_2d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_2d_vector~~CallsGraph proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_nurbs_2d_vector.html"},{"title":"compute_dTgc_nurbs_2d_scalar – ForCAD","text":"impure subroutine compute_dTgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_nurbs_2d_scalar~~UsesGraph proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar module~forcad_utils forcad_utils proc~compute_dtgc_nurbs_2d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_dtgc_nurbs_2d_scalar~~CallsGraph proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_nurbs_2d_scalar.html"},{"title":"compute_dTgc_bspline_2d_vector – ForCAD","text":"impure subroutine compute_dTgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_bspline_2d_vector~~UsesGraph proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector module~forcad_utils forcad_utils proc~compute_dtgc_bspline_2d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_2d_vector~~CallsGraph proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_bspline_2d_vector.html"},{"title":"compute_dTgc_bspline_2d_scalar – ForCAD","text":"impure subroutine compute_dTgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_bspline_2d_scalar~~UsesGraph proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar module~forcad_utils forcad_utils proc~compute_dtgc_bspline_2d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_dtgc_bspline_2d_scalar~~CallsGraph proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_bspline_2d_scalar.html"},{"title":"compute_d2Tgc_nurbs_2d_vector – ForCAD","text":"impure subroutine compute_d2Tgc_nurbs_2d_vector(Xt, knot1, knot2, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_nurbs_2d_vector~~UsesGraph proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector module~forcad_utils forcad_utils proc~compute_d2tgc_nurbs_2d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_2d_vector~~CallsGraph proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_nurbs_2d_vector.html"},{"title":"compute_d2Tgc_nurbs_2d_scalar – ForCAD","text":"impure subroutine compute_d2Tgc_nurbs_2d_scalar(Xt, knot1, knot2, degree, nc, Wc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_nurbs_2d_scalar~~UsesGraph proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar module~forcad_utils forcad_utils proc~compute_d2tgc_nurbs_2d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_2d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_nurbs_2d_scalar.html"},{"title":"compute_d2Tgc_bspline_2d_vector – ForCAD","text":"impure subroutine compute_d2Tgc_bspline_2d_vector(Xt, knot1, knot2, degree, nc, ng, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_bspline_2d_vector~~UsesGraph proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector module~forcad_utils forcad_utils proc~compute_d2tgc_bspline_2d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: ng (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_2d_vector~~CallsGraph proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_2d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_bspline_2d_vector.html"},{"title":"compute_d2Tgc_bspline_2d_scalar – ForCAD","text":"impure subroutine compute_d2Tgc_bspline_2d_scalar(Xt, knot1, knot2, degree, nc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_bspline_2d_scalar~~UsesGraph proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar module~forcad_utils forcad_utils proc~compute_d2tgc_bspline_2d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) integer, intent(in) :: degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_2d_scalar~~CallsGraph proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_2d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_bspline_2d_scalar.html"},{"title":"compute_Xg_nurbs_1d – ForCAD","text":"impure function compute_Xg_nurbs_1d(Xt, knot, degree, nc, ng, Xc, Wc) result(Xg) Uses forcad_utils proc~~compute_xg_nurbs_1d~~UsesGraph proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d module~forcad_utils forcad_utils proc~compute_xg_nurbs_1d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_1d~~CallsGraph proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d proc~basis_bspline basis_bspline proc~compute_xg_nurbs_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_nurbs_1d.html"},{"title":"compute_Xg_nurbs_1d_1point – ForCAD","text":"impure function compute_Xg_nurbs_1d_1point(Xt, knot, degree, nc, Xc, Wc) result(Xg) Uses forcad_utils proc~~compute_xg_nurbs_1d_1point~~UsesGraph proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point module~forcad_utils forcad_utils proc~compute_xg_nurbs_1d_1point->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_nurbs_1d_1point~~CallsGraph proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_nurbs_1d_1point->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_nurbs_1d_1point.html"},{"title":"compute_Xg_bspline_1d – ForCAD","text":"impure function compute_Xg_bspline_1d(Xt, knot, degree, nc, ng, Xc) result(Xg) Uses forcad_utils proc~~compute_xg_bspline_1d~~UsesGraph proc~compute_xg_bspline_1d compute_Xg_bspline_1d module~forcad_utils forcad_utils proc~compute_xg_bspline_1d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_1d~~CallsGraph proc~compute_xg_bspline_1d compute_Xg_bspline_1d proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_bspline_1d.html"},{"title":"compute_Xg_bspline_1d_1point – ForCAD","text":"impure function compute_Xg_bspline_1d_1point(Xt, knot, degree, nc, Xc) result(Xg) Uses forcad_utils proc~~compute_xg_bspline_1d_1point~~UsesGraph proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point module~forcad_utils forcad_utils proc~compute_xg_bspline_1d_1point->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_bspline_1d_1point~~CallsGraph proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_1d_1point->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_bspline_1d_1point.html"},{"title":"compute_Tgc_nurbs_1d_vector – ForCAD","text":"impure function compute_Tgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc) result(Tgc) Uses forcad_utils proc~~compute_tgc_nurbs_1d_vector~~UsesGraph proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector module~forcad_utils forcad_utils proc~compute_tgc_nurbs_1d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_1d_vector~~CallsGraph proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_nurbs_1d_vector.html"},{"title":"compute_Tgc_nurbs_1d_scalar – ForCAD","text":"impure function compute_Tgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc) result(Tgc) Uses forcad_utils proc~~compute_tgc_nurbs_1d_scalar~~UsesGraph proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar module~forcad_utils forcad_utils proc~compute_tgc_nurbs_1d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_1d_scalar~~CallsGraph proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_nurbs_1d_scalar.html"},{"title":"compute_Tgc_bspline_1d_vector – ForCAD","text":"impure function compute_Tgc_bspline_1d_vector(Xt, knot, degree, nc, ng) result(Tgc) Uses forcad_utils proc~~compute_tgc_bspline_1d_vector~~UsesGraph proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector module~forcad_utils forcad_utils proc~compute_tgc_bspline_1d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_1d_vector~~CallsGraph proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_vector->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_bspline_1d_vector.html"},{"title":"compute_Tgc_bspline_1d_scalar – ForCAD","text":"impure function compute_Tgc_bspline_1d_scalar(Xt, knot, degree, nc) result(Tgc) Uses forcad_utils proc~~compute_tgc_bspline_1d_scalar~~UsesGraph proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar module~forcad_utils forcad_utils proc~compute_tgc_bspline_1d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_1d_scalar~~CallsGraph proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_bspline_1d_scalar.html"},{"title":"nearest_point_help_1d – ForCAD","text":"impure function nearest_point_help_1d(ng, Xg, point_Xg) result(distances) Uses forcad_utils proc~~nearest_point_help_1d~~UsesGraph proc~nearest_point_help_1d nearest_point_help_1d module~forcad_utils forcad_utils proc~nearest_point_help_1d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/nearest_point_help_1d.html"},{"title":"compute_dTgc_nurbs_1d_vector – ForCAD","text":"impure subroutine compute_dTgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_nurbs_1d_vector~~UsesGraph proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector module~forcad_utils forcad_utils proc~compute_dtgc_nurbs_1d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_1d_vector~~CallsGraph proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_nurbs_1d_vector.html"},{"title":"compute_dTgc_nurbs_1d_scalar – ForCAD","text":"impure subroutine compute_dTgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_nurbs_1d_scalar~~UsesGraph proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar module~forcad_utils forcad_utils proc~compute_dtgc_nurbs_1d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_dtgc_nurbs_1d_scalar~~CallsGraph proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_nurbs_1d_scalar.html"},{"title":"compute_dTgc_bspline_1d_vector – ForCAD","text":"impure subroutine compute_dTgc_bspline_1d_vector(Xt, knot, degree, nc, ng, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_bspline_1d_vector~~UsesGraph proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector module~forcad_utils forcad_utils proc~compute_dtgc_bspline_1d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_1d_vector~~CallsGraph proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_bspline_1d_vector.html"},{"title":"compute_dTgc_bspline_1d_scalar – ForCAD","text":"impure subroutine compute_dTgc_bspline_1d_scalar(Xt, knot, degree, nc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_bspline_1d_scalar~~UsesGraph proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar module~forcad_utils forcad_utils proc~compute_dtgc_bspline_1d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_dtgc_bspline_1d_scalar~~CallsGraph proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_bspline_1d_scalar.html"},{"title":"compute_d2Tgc_nurbs_1d_vector – ForCAD","text":"impure subroutine compute_d2Tgc_nurbs_1d_vector(Xt, knot, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_nurbs_1d_vector~~UsesGraph proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector module~forcad_utils forcad_utils proc~compute_d2tgc_nurbs_1d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_1d_vector~~CallsGraph proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_nurbs_1d_vector.html"},{"title":"compute_d2Tgc_nurbs_1d_scalar – ForCAD","text":"impure subroutine compute_d2Tgc_nurbs_1d_scalar(Xt, knot, degree, nc, Wc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_nurbs_1d_scalar~~UsesGraph proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar module~forcad_utils forcad_utils proc~compute_d2tgc_nurbs_1d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_1d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_nurbs_1d_scalar.html"},{"title":"compute_d2Tgc_bspline_1d_vector – ForCAD","text":"impure subroutine compute_d2Tgc_bspline_1d_vector(Xt, knot, degree, nc, ng, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_bspline_1d_vector~~UsesGraph proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector module~forcad_utils forcad_utils proc~compute_d2tgc_bspline_1d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc integer, intent(in) :: ng real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_1d_vector~~CallsGraph proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_bspline_1d_vector.html"},{"title":"compute_d2Tgc_bspline_1d_scalar – ForCAD","text":"impure subroutine compute_d2Tgc_bspline_1d_scalar(Xt, knot, degree, nc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_bspline_1d_scalar~~UsesGraph proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar module~forcad_utils forcad_utils proc~compute_d2tgc_bspline_1d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree integer, intent(in) :: nc real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_1d_scalar~~CallsGraph proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_bspline_1d_scalar.html"},{"title":"compute_Xg_nurbs_3d – ForCAD","text":"impure function compute_Xg_nurbs_3d(Xt, knot1, knot2, knot3, degree, nc, ng, Xc, Wc) result(Xg) Uses forcad_utils proc~~compute_xg_nurbs_3d~~UsesGraph proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d module~forcad_utils forcad_utils proc~compute_xg_nurbs_3d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_nurbs_3d~~CallsGraph proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~basis_bspline basis_bspline proc~compute_xg_nurbs_3d->proc~basis_bspline proc~kron kron proc~compute_xg_nurbs_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_nurbs_3d.html"},{"title":"compute_Xg_nurbs_3d_1point – ForCAD","text":"impure function compute_Xg_nurbs_3d_1point(Xt, knot1, knot2, knot3, degree, nc, Xc, Wc) result(Xg) Uses forcad_utils proc~~compute_xg_nurbs_3d_1point~~UsesGraph proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point module~forcad_utils forcad_utils proc~compute_xg_nurbs_3d_1point->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_nurbs_3d_1point~~CallsGraph proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~basis_bspline basis_bspline proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_nurbs_3d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_nurbs_3d_1point.html"},{"title":"compute_Xg_bspline_3d – ForCAD","text":"impure function compute_Xg_bspline_3d(Xt, knot1, knot2, knot3, degree, nc, ng, Xc) result(Xg) Uses forcad_utils proc~~compute_xg_bspline_3d~~UsesGraph proc~compute_xg_bspline_3d compute_Xg_bspline_3d module~forcad_utils forcad_utils proc~compute_xg_bspline_3d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_xg_bspline_3d~~CallsGraph proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_bspline_3d.html"},{"title":"compute_Xg_bspline_3d_1point – ForCAD","text":"impure function compute_Xg_bspline_3d_1point(Xt, knot1, knot2, knot3, degree, nc, Xc) result(Xg) Uses forcad_utils proc~~compute_xg_bspline_3d_1point~~UsesGraph proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point module~forcad_utils forcad_utils proc~compute_xg_bspline_3d_1point->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Xc (:,:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_xg_bspline_3d_1point~~CallsGraph proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~basis_bspline basis_bspline proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~kron kron proc~compute_xg_bspline_3d_1point->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_xg_bspline_3d_1point.html"},{"title":"compute_Tgc_nurbs_3d_vector – ForCAD","text":"impure function compute_Tgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc) result(Tgc) Uses forcad_utils proc~~compute_tgc_nurbs_3d_vector~~UsesGraph proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector module~forcad_utils forcad_utils proc~compute_tgc_nurbs_3d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_nurbs_3d_vector~~CallsGraph proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_nurbs_3d_vector.html"},{"title":"compute_Tgc_nurbs_3d_scalar – ForCAD","text":"impure function compute_Tgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc) result(Tgc) Uses forcad_utils proc~~compute_tgc_nurbs_3d_scalar~~UsesGraph proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar module~forcad_utils forcad_utils proc~compute_tgc_nurbs_3d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_nurbs_3d_scalar~~CallsGraph proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_nurbs_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_nurbs_3d_scalar.html"},{"title":"compute_Tgc_bspline_3d_vector – ForCAD","text":"impure function compute_Tgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng) result(Tgc) Uses forcad_utils proc~~compute_tgc_bspline_3d_vector~~UsesGraph proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector module~forcad_utils forcad_utils proc~compute_tgc_bspline_3d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~compute_tgc_bspline_3d_vector~~CallsGraph proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_bspline_3d_vector.html"},{"title":"compute_Tgc_bspline_3d_scalar – ForCAD","text":"impure function compute_Tgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc) result(Tgc) Uses forcad_utils proc~~compute_tgc_bspline_3d_scalar~~UsesGraph proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar module~forcad_utils forcad_utils proc~compute_tgc_bspline_3d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_tgc_bspline_3d_scalar~~CallsGraph proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~basis_bspline basis_bspline proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~kron kron proc~compute_tgc_bspline_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_tgc_bspline_3d_scalar.html"},{"title":"nearest_point_help_3d – ForCAD","text":"impure function nearest_point_help_3d(ng, Xg, point_Xg) result(distances) Uses forcad_utils proc~~nearest_point_help_3d~~UsesGraph proc~nearest_point_help_3d nearest_point_help_3d module~forcad_utils forcad_utils proc~nearest_point_help_3d->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Xg (:,:) real(kind=rk), intent(in), contiguous :: point_Xg (:) Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/nearest_point_help_3d.html"},{"title":"compute_dTgc_nurbs_3d_vector – ForCAD","text":"impure subroutine compute_dTgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_nurbs_3d_vector~~UsesGraph proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector module~forcad_utils forcad_utils proc~compute_dtgc_nurbs_3d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_nurbs_3d_vector~~CallsGraph proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_nurbs_3d_vector.html"},{"title":"compute_dTgc_nurbs_3d_scalar – ForCAD","text":"impure subroutine compute_dTgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_nurbs_3d_scalar~~UsesGraph proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar module~forcad_utils forcad_utils proc~compute_dtgc_nurbs_3d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_dtgc_nurbs_3d_scalar~~CallsGraph proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_nurbs_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_nurbs_3d_scalar.html"},{"title":"compute_dTgc_bspline_3d_vector – ForCAD","text":"impure subroutine compute_dTgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_bspline_3d_vector~~UsesGraph proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector module~forcad_utils forcad_utils proc~compute_dtgc_bspline_3d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_dtgc_bspline_3d_vector~~CallsGraph proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_bspline_3d_vector.html"},{"title":"compute_dTgc_bspline_3d_scalar – ForCAD","text":"impure subroutine compute_dTgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, dTgc, Tgc) Uses forcad_utils proc~~compute_dtgc_bspline_3d_scalar~~UsesGraph proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar module~forcad_utils forcad_utils proc~compute_dtgc_bspline_3d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_dtgc_bspline_3d_scalar~~CallsGraph proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~kron kron proc~compute_dtgc_bspline_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_dtgc_bspline_3d_scalar.html"},{"title":"compute_d2Tgc_nurbs_3d_vector – ForCAD","text":"impure subroutine compute_d2Tgc_nurbs_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, Wc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_nurbs_3d_vector~~UsesGraph proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector module~forcad_utils forcad_utils proc~compute_d2tgc_nurbs_3d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_nurbs_3d_vector~~CallsGraph proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_nurbs_3d_vector.html"},{"title":"compute_d2Tgc_nurbs_3d_scalar – ForCAD","text":"impure subroutine compute_d2Tgc_nurbs_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, Wc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_nurbs_3d_scalar~~UsesGraph proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar module~forcad_utils forcad_utils proc~compute_d2tgc_nurbs_3d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(in), contiguous :: Wc (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_nurbs_3d_scalar~~CallsGraph proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_nurbs_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_nurbs_3d_scalar.html"},{"title":"compute_d2Tgc_bspline_3d_vector – ForCAD","text":"impure subroutine compute_d2Tgc_bspline_3d_vector(Xt, knot1, knot2, knot3, degree, nc, ng, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_bspline_3d_vector~~UsesGraph proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector module~forcad_utils forcad_utils proc~compute_d2tgc_bspline_3d_vector->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:,:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) integer, intent(in) :: ng (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~compute_d2tgc_bspline_3d_vector~~CallsGraph proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_3d_vector->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_bspline_3d_vector.html"},{"title":"compute_d2Tgc_bspline_3d_scalar – ForCAD","text":"impure subroutine compute_d2Tgc_bspline_3d_scalar(Xt, knot1, knot2, knot3, degree, nc, d2Tgc, dTgc, Tgc) Uses forcad_utils proc~~compute_d2tgc_bspline_3d_scalar~~UsesGraph proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar module~forcad_utils forcad_utils proc~compute_d2tgc_bspline_3d_scalar->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) integer, intent(in) :: degree (3) integer, intent(in) :: nc (3) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~compute_d2tgc_bspline_3d_scalar~~CallsGraph proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~kron kron proc~compute_d2tgc_bspline_3d_scalar->proc~kron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_d2tgc_bspline_3d_scalar.html"},{"title":"basis_bernstein – ForCAD","text":"public pure function basis_bernstein(Xt, nc) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/basis_bernstein.html"},{"title":"basis_bspline – ForCAD","text":"public pure function basis_bspline(Xt, knot, nc, degree) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:) Called by proc~~basis_bspline~~CalledByGraph proc~basis_bspline basis_bspline proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_scalar->proc~basis_bspline proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector proc~compute_tgc_bspline_1d_vector->proc~basis_bspline proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->proc~basis_bspline proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->proc~basis_bspline proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->proc~basis_bspline proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->proc~basis_bspline proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector proc~compute_tgc_nurbs_1d_vector->proc~basis_bspline proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->proc~basis_bspline proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->proc~basis_bspline proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->proc~basis_bspline proc~compute_xg_bspline_1d compute_Xg_bspline_1d proc~compute_xg_bspline_1d->proc~basis_bspline proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point proc~compute_xg_bspline_1d_1point->proc~basis_bspline proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->proc~basis_bspline proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->proc~basis_bspline proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->proc~basis_bspline proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->proc~basis_bspline proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d proc~compute_xg_nurbs_1d->proc~basis_bspline proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point proc~compute_xg_nurbs_1d_1point->proc~basis_bspline proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~compute_xg_nurbs_2d->proc~basis_bspline proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->proc~basis_bspline proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~compute_xg_nurbs_3d->proc~basis_bspline proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->proc~basis_bspline proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~basis_bspline program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bspline.html"},{"title":"compute_knot_vector – ForCAD","text":"public pure function compute_knot_vector(Xth_dir, degree, continuity) result(knot) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_knot_vector~~CallsGraph proc~compute_knot_vector compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_knot_vector~~CalledByGraph proc~compute_knot_vector compute_knot_vector proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~3 nurbs_volume%set none~set~3->proc~set2~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_knot_vector.html"},{"title":"findspan – ForCAD","text":"public pure function findspan(n, degree, Xth, knot) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer Called by proc~~findspan~~CalledByGraph proc~findspan findspan proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~findspan proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~findspan proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->proc~findspan proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~findspan proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~findspan proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->proc~findspan program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/findspan.html"},{"title":"hexahedron_Xc – ForCAD","text":"public pure function hexahedron_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~hexahedron_xc~~CalledByGraph proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->proc~hexahedron_xc program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~hexahedron_xc program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/hexahedron_xc.html"},{"title":"kron – ForCAD","text":"public pure function kron(u, v) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) Called by proc~~kron~~CalledByGraph proc~kron kron proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->proc~kron proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->proc~kron proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->proc~kron proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->proc~kron proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->proc~kron proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->proc~kron proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->proc~kron proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->proc~kron proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->proc~kron proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->proc~kron proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->proc~kron proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->proc~kron proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->proc~kron proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->proc~kron proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->proc~kron proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->proc~kron proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->proc~kron proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->proc~kron proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->proc~kron proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->proc~kron proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->proc~kron proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->proc~kron proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->proc~kron proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->proc~kron proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->proc~kron proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->proc~kron proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->proc~kron proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->proc~kron proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~compute_xg_nurbs_2d->proc~kron proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->proc~kron proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~compute_xg_nurbs_3d->proc~kron proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->proc~kron proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~kron program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/kron.html"},{"title":"rotation – ForCAD","text":"public pure function rotation(alpha, beta, theta) result(R) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) Calls proc~~rotation~~CallsGraph proc~rotation rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation~~CalledByGraph proc~rotation rotation proc~rotate_xc nurbs_surface%rotate_Xc proc~rotate_xc->proc~rotation proc~rotate_xc~2 nurbs_curve%rotate_Xc proc~rotate_xc~2->proc~rotation proc~rotate_xc~3 nurbs_volume%rotate_Xc proc~rotate_xc~3->proc~rotation proc~rotate_xg nurbs_surface%rotate_Xg proc~rotate_xg->proc~rotation proc~rotate_xg~2 nurbs_curve%rotate_Xg proc~rotate_xg~2->proc~rotation proc~rotate_xg~3 nurbs_volume%rotate_Xg proc~rotate_xg~3->proc~rotation program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~2 program~example1_curve->proc~rotate_xg~2 program~example3_surface example3_surface program~example3_surface->proc~rotate_xc program~example3_surface->proc~rotate_xg program~example3_volume example3_volume program~example3_volume->proc~rotate_xc~3 program~example3_volume->proc~rotate_xg~3 program~example_ppm2 example_ppm2 program~example_ppm2->proc~rotate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotation.html"},{"title":"tetragon_Xc – ForCAD","text":"public pure function tetragon_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~tetragon_xc~~CalledByGraph proc~tetragon_xc tetragon_Xc proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->proc~tetragon_xc program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/tetragon_xc.html"},{"title":"bincoeff – ForCAD","text":"private pure function bincoeff(n, k) result(b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) Calls proc~~bincoeff~~CallsGraph proc~bincoeff bincoeff proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bincoeff~~CalledByGraph proc~bincoeff bincoeff proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/bincoeff.html"},{"title":"cmp_elemConn_C0_L – ForCAD","text":"private pure function cmp_elemConn_C0_L(nnode, p) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_l~~CalledByGraph proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_l.html"},{"title":"cmp_elemConn_C0_S – ForCAD","text":"private pure function cmp_elemConn_C0_S(nnode1, nnode2, p1, p2) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_s~~CalledByGraph proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_s.html"},{"title":"cmp_elemConn_C0_V – ForCAD","text":"private pure function cmp_elemConn_C0_V(nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_v~~CalledByGraph proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_v.html"},{"title":"compute_multiplicity1 – ForCAD","text":"private pure function compute_multiplicity1(knot) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) Called by proc~~compute_multiplicity1~~CalledByGraph proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity1 proc~cmp_nc nurbs_surface%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_volume%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_volume%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc nurbs_surface%get_nc proc~get_nc->interface~compute_multiplicity proc~get_nc~3 get_nc proc~get_nc~3->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_volume%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->none~set~3 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_multiplicity1.html"},{"title":"compute_multiplicity2 – ForCAD","text":"private pure function compute_multiplicity2(knot, Xth) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer Called by proc~~compute_multiplicity2~~CalledByGraph proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_nc nurbs_surface%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_volume%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_volume%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc nurbs_surface%get_nc proc~get_nc->interface~compute_multiplicity proc~get_nc~3 get_nc proc~get_nc~3->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_volume%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->none~set~3 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_multiplicity2.html"},{"title":"factln – ForCAD","text":"private pure function factln(n) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~factln~~CalledByGraph proc~factln factln proc~bincoeff bincoeff proc~bincoeff->proc~factln proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/factln.html"},{"title":"isinf – ForCAD","text":"private pure elemental function isinf(x) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical","tags":"","loc":"proc/isinf.html"},{"title":"isnan – ForCAD","text":"private pure elemental function isnan(x) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical","tags":"","loc":"proc/isnan.html"},{"title":"repelem – ForCAD","text":"private pure function repelem(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) Called by proc~~repelem~~CalledByGraph proc~repelem repelem proc~compute_knot_vector compute_knot_vector proc~compute_knot_vector->proc~repelem proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_curve%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 none~set~3 nurbs_volume%set none~set~3->proc~set2~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/repelem.html"},{"title":"unique_integer – ForCAD","text":"private pure function unique_integer(vec) result(output) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable Called by proc~~unique_integer~~CalledByGraph proc~unique_integer unique_integer interface~unique unique interface~unique->proc~unique_integer proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~unique proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~unique program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unique_integer.html"},{"title":"unique_real – ForCAD","text":"private pure function unique_real(vec) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Called by proc~~unique_real~~CalledByGraph proc~unique_real unique_real interface~unique unique interface~unique->proc~unique_real proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~unique proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~unique program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unique_real.html"},{"title":"basis_bspline_2der – ForCAD","text":"public pure subroutine basis_bspline_2der(Xt, knot, nc, degree, d2B, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: d2B (:) real(kind=rk), intent(out), optional, allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:) Called by proc~~basis_bspline_2der~~CalledByGraph proc~basis_bspline_2der basis_bspline_2der proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~compute_d2tgc_bspline_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~compute_d2tgc_nurbs_1d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->proc~basis_bspline_2der proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->proc~basis_bspline_2der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bspline_2der.html"},{"title":"basis_bspline_der – ForCAD","text":"public pure subroutine basis_bspline_der(Xt, knot, nc, degree, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:) Called by proc~~basis_bspline_der~~CalledByGraph proc~basis_bspline_der basis_bspline_der proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~compute_dtgc_bspline_1d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~compute_dtgc_nurbs_1d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->proc~basis_bspline_der proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bspline_der.html"},{"title":"elevate_degree_A_5_9 – ForCAD","text":"public pure subroutine elevate_degree_A_5_9(t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) Calls proc~~elevate_degree_a_5_9~~CallsGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree_a_5_9~~CalledByGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree_a_5_9.html"},{"title":"insert_knot_A_5_1 – ForCAD","text":"public pure subroutine insert_knot_A_5_1(p, UP, Pw, u, k, s, r, nq, UQ, Qw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) Called by proc~~insert_knot_a_5_1~~CalledByGraph proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->proc~insert_knot_a_5_1 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knot_a_5_1.html"},{"title":"remove_knots_A_5_8 – ForCAD","text":"public pure subroutine remove_knots_A_5_8(p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) Called by proc~~remove_knots_a_5_8~~CalledByGraph proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~remove_knots_a_5_8 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~remove_knots_a_5_8 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->proc~remove_knots_a_5_8 program~example1_curve example1_curve program~example1_curve->proc~remove_knots~2 program~example3_surface example3_surface program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots_a_5_8.html"},{"title":"cmp_elemConn_Cn_L – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_L(nnode, p, Xth, vecKnot_mul, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_l~~CalledByGraph proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_l.html"},{"title":"cmp_elemConn_Cn_S – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_S(nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_s~~CalledByGraph proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_s.html"},{"title":"cmp_elemConn_Cn_V – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_V(nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_v~~CalledByGraph proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_v.html"},{"title":"ndgrid2 – ForCAD","text":"private pure subroutine ndgrid2(X_dir1, X_dir2, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid2~~CalledByGraph proc~ndgrid2 ndgrid2 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid2 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~3 nurbs_volume%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~ndgrid none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_vector none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid2.html"},{"title":"ndgrid3 – ForCAD","text":"private pure subroutine ndgrid3(X_dir1, X_dir2, X_dir3, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid3~~CalledByGraph proc~ndgrid3 ndgrid3 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid3 proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~3 nurbs_volume%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~ndgrid none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_vector none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid3.html"},{"title":"compute_multiplicity – ForCAD","text":"public interface compute_multiplicity Calls interface~~compute_multiplicity~~CallsGraph interface~compute_multiplicity compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_multiplicity~~CalledByGraph interface~compute_multiplicity compute_multiplicity proc~cmp_nc nurbs_surface%cmp_nc proc~cmp_nc->interface~compute_multiplicity proc~cmp_nc~2 nurbs_curve%cmp_nc proc~cmp_nc~2->interface~compute_multiplicity proc~cmp_nc~3 nurbs_volume%cmp_nc proc~cmp_nc~3->interface~compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_curve%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_volume%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc nurbs_surface%get_nc proc~get_nc->interface~compute_multiplicity proc~get_nc~3 get_nc proc~get_nc~3->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_volume%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set1->proc~cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set1~3->proc~cmp_degree~3 proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->none~set~2 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example3_volume->proc~cmp_elem~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->none~set~3 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3->proc~cmp_degree proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 proc~set3~3->proc~cmp_degree~3 none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer","tags":"","loc":"interface/compute_multiplicity.html"},{"title":"elemConn_C0 – ForCAD","text":"public interface elemConn_C0 Calls interface~~elemconn_c0~~CallsGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_c0~~CalledByGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example1_curve->proc~export_xg~2 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example3_volume->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~example_nurbs_curve->proc~export_xg~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_nurbs_volume->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~example_put_to_nurbs->proc~export_xg~3 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_c_1d->proc~export_xg~2 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_c_2d->proc~export_xg program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_c_3d->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 program~shape_half_circle->proc~export_xg~2 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_half_ring_2d->proc~export_xg program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_hexahedron->proc~export_xg~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_ring_2d->proc~export_xg program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 program~shape_ring_3d->proc~export_xg~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:)","tags":"","loc":"interface/elemconn_c0.html"},{"title":"elemConn_Cn – ForCAD","text":"public interface elemConn_Cn Calls interface~~elemconn_cn~~CallsGraph interface~elemconn_cn elemConn_Cn proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_cn~~CalledByGraph interface~elemconn_cn elemConn_Cn proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~elemconn_cn program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:)","tags":"","loc":"interface/elemconn_cn.html"},{"title":"ndgrid – ForCAD","text":"public interface ndgrid Calls interface~~ndgrid~~CallsGraph interface~ndgrid ndgrid proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~ndgrid~~CalledByGraph interface~ndgrid ndgrid proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~ndgrid proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~3 nurbs_volume%create proc~create~3->interface~ndgrid proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~ndgrid proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~ndgrid proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~ndgrid proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~ndgrid none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_vector none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","loc":"interface/ndgrid.html"},{"title":"unique – ForCAD","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique unique proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~unique~~CalledByGraph interface~unique unique proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~unique proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->interface~unique proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->interface~unique program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable","tags":"","loc":"interface/unique.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~~CallsGraph proc~cmp_xg nurbs_surface%cmp_Xg interface~compute_xg compute_Xg proc~cmp_xg->interface~compute_xg proc~is_rational nurbs_surface%is_rational proc~cmp_xg->proc~is_rational Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~~CalledByGraph proc~cmp_xg nurbs_surface%cmp_Xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_xg.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~~CallsGraph proc~cmp_elem nurbs_surface%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn interface~unique unique proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~~CallsGraph proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~~CalledByGraph proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xc_vis.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~~CallsGraph proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~~CalledByGraph proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis program~example3_surface example3_surface program~example3_surface->proc~export_xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xg program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xg_vis.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~~CalledByGraph proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc nurbs_surface%get_Wc none~get_wc->proc~get_wc_all proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_wc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_wc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_wc_all.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~~CalledByGraph proc~get_wci nurbs_surface%get_Wci none~get_wc nurbs_surface%get_Wc none~get_wc->proc~get_wci proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_wc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_wc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_wci.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~~CalledByGraph proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc nurbs_surface%get_Xc none~get_xc->proc~get_xc_all proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xc_all.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~~CalledByGraph proc~get_xci nurbs_surface%get_Xci none~get_xc nurbs_surface%get_Xc none~get_xc->proc~get_xci proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xci.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~~CalledByGraph proc~get_xcid nurbs_surface%get_Xcid none~get_xc nurbs_surface%get_Xc none~get_xc->proc~get_xcid proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_xc proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xcid.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xg_all~~CalledByGraph proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg nurbs_surface%get_Xg none~get_xg->proc~get_xg_all program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xg_all.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xgi~~CalledByGraph proc~get_xgi nurbs_surface%get_Xgi none~get_xg nurbs_surface%get_Xg none~get_xg->proc~get_xgi program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xgi.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xgid~~CalledByGraph proc~get_xgid nurbs_surface%get_Xgid none~get_xg nurbs_surface%get_Xg none~get_xg->proc~get_xgid program~example_ppm1 example_ppm1 program~example_ppm1->none~get_xg program~example_ppm2 example_ppm2 program~example_ppm2->none~get_xg program~example_ppm3 example_ppm3 program~example_ppm3->none~get_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xgid.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~~CallsGraph proc~get_continuity nurbs_surface%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_degree_all~~CalledByGraph proc~get_degree_all nurbs_surface%get_degree_all none~get_degree nurbs_surface%get_degree none~get_degree->proc~get_degree_all program~example3_surface example3_surface program~example3_surface->none~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_all.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Called by proc~~get_degree_dir~~CalledByGraph proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree nurbs_surface%get_degree none~get_degree->proc~get_degree_dir program~example3_surface example3_surface program~example3_surface->none~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_dir.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xc_vis.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xg_vis.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~~CalledByGraph proc~get_knot_all nurbs_surface%get_knot_all none~get_knot nurbs_surface%get_knot none~get_knot->proc~get_knot_all proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~get_knot proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~get_knot proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_knot proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_knot proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~get_knot program~example3_surface example3_surface program~example3_surface->none~get_knot program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knot_all.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~~CalledByGraph proc~get_knoti nurbs_surface%get_knoti none~get_knot nurbs_surface%get_knot none~get_knot->proc~get_knoti proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~get_knot proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~get_knot proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~get_knot proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~get_knot proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~get_knot program~example3_surface example3_surface program~example3_surface->none~get_knot program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knoti.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~~CallsGraph proc~get_multiplicity nurbs_surface%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~~CalledByGraph proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree nurbs_surface%cmp_degree proc~cmp_degree->proc~get_multiplicity proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_degree proc~set3 nurbs_surface%set3 proc~set3->proc~cmp_degree none~set nurbs_surface%set none~set->proc~set1 none~set->proc~set3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this, dir) result(nc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc~~CallsGraph proc~get_nc nurbs_surface%get_nc interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Called by proc~~get_ng~~CalledByGraph proc~get_ng nurbs_surface%get_ng program~example_ppm1 example_ppm1 program~example_ppm1->proc~get_ng program~example_ppm2 example_ppm2 program~example_ppm2->proc~get_ng program~example_ppm3 example_ppm3 program~example_ppm3->proc~get_ng Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_ng.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical Called by proc~~is_rational~~CalledByGraph proc~is_rational nurbs_surface%is_rational proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->proc~is_rational proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->proc~is_rational proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->proc~is_rational proc~create nurbs_surface%create proc~create->proc~is_rational proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->proc~is_rational proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->proc~is_rational proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->proc~is_rational proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->proc~is_rational proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~is_rational proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~is_rational proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~is_rational none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create proc~nearest_point2->none~derivative2 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_rational.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~~CallsGraph proc~basis_scalar nurbs_surface%basis_scalar interface~compute_tgc compute_Tgc proc~basis_scalar->interface~compute_tgc proc~is_rational nurbs_surface%is_rational proc~basis_scalar->proc~is_rational Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_scalar.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res1, res2, Xt1, Xt2, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~~CallsGraph proc~basis_vector nurbs_surface%basis_vector interface~compute_tgc compute_Tgc proc~basis_vector->interface~compute_tgc interface~ndgrid ndgrid proc~basis_vector->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~basis_vector->proc~is_rational proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_vector.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_degree~~CallsGraph proc~cmp_degree nurbs_surface%cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~~CalledByGraph proc~cmp_degree nurbs_surface%cmp_degree proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_degree proc~set3 nurbs_surface%set3 proc~set3->proc~cmp_degree none~set nurbs_surface%set none~set->proc~set1 none~set->proc~set3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_degree.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_nc~~CallsGraph proc~cmp_nc nurbs_surface%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~~CalledByGraph proc~cmp_nc nurbs_surface%cmp_nc proc~set1 nurbs_surface%set1 proc~set1->proc~cmp_nc proc~set2 nurbs_surface%set2 proc~set2->proc~cmp_nc none~set nurbs_surface%set none~set->proc~set1 none~set->proc~set2 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_nc.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, Xt1, Xt2, Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~~CallsGraph proc~create nurbs_surface%create interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~~CalledByGraph proc~create nurbs_surface%create proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~~CallsGraph proc~derivative2_scalar nurbs_surface%derivative2_scalar interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~is_rational nurbs_surface%is_rational proc~derivative2_scalar->proc~is_rational Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~~CalledByGraph proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative2_scalar.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~~CallsGraph proc~derivative2_vector nurbs_surface%derivative2_vector interface~compute_d2tgc compute_d2Tgc proc~derivative2_vector->interface~compute_d2tgc interface~ndgrid ndgrid proc~derivative2_vector->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~derivative2_vector->proc~is_rational proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~~CalledByGraph proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative2_vector.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative_scalar~~CallsGraph proc~derivative_scalar nurbs_surface%derivative_scalar interface~compute_dtgc compute_dTgc proc~derivative_scalar->interface~compute_dtgc proc~is_rational nurbs_surface%is_rational proc~derivative_scalar->proc~is_rational Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative_scalar.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res1, res2, Xt1, Xt2, dTgc, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~~CallsGraph proc~derivative_vector nurbs_surface%derivative_vector interface~compute_dtgc compute_dTgc proc~derivative_vector->interface~compute_dtgc interface~ndgrid ndgrid proc~derivative_vector->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~derivative_vector->proc~is_rational proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative_vector.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t Calls proc~~elevate_degree~~CallsGraph proc~elevate_degree nurbs_surface%elevate_degree none~get_knot nurbs_surface%get_knot proc~elevate_degree->none~get_knot none~set nurbs_surface%set proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~is_rational nurbs_surface%is_rational proc~elevate_degree->proc~is_rational proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~~CalledByGraph proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface example3_surface program~example3_surface->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~~CallsGraph proc~export_xc nurbs_surface%export_Xc proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~~CalledByGraph proc~export_xc nurbs_surface%export_Xc program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xc program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xc program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xc program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~~CallsGraph proc~export_xg nurbs_surface%export_Xg proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~~CalledByGraph proc~export_xg nurbs_surface%export_Xg program~example3_surface example3_surface program~example3_surface->proc~export_xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg program~shape_c_2d shape_C_2d program~shape_c_2d->proc~export_xg program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~export_xg program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this Called by proc~~finalize~~CalledByGraph proc~finalize nurbs_surface%finalize proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~finalize program~example3_surface example3_surface program~example3_surface->proc~finalize program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~finalize program~example_ppm1 example_ppm1 program~example_ppm1->proc~finalize program~example_ppm2 example_ppm2 program~example_ppm2->proc~finalize program~example_ppm3 example_ppm3 program~example_ppm3->proc~finalize program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~finalize program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~finalize program~shape_c_2d shape_C_2d program~shape_c_2d->proc~finalize program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~finalize program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~finalize program~shape_tetragon shape_tetragon program~shape_tetragon->proc~finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~~CallsGraph proc~insert_knots nurbs_surface%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity none~get_knot nurbs_surface%get_knot proc~insert_knots->none~get_knot none~set nurbs_surface%set proc~insert_knots->none~set proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~is_rational nurbs_surface%is_rational proc~insert_knots->proc~is_rational proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~~CalledByGraph proc~insert_knots nurbs_surface%insert_knots program~example3_surface example3_surface program~example3_surface->proc~insert_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knots.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~~CallsGraph proc~modify_wc nurbs_surface%modify_Wc none~get_knot nurbs_surface%get_knot proc~modify_wc->none~get_knot none~get_wc nurbs_surface%get_Wc proc~modify_wc->none~get_wc none~get_xc nurbs_surface%get_Xc proc~modify_wc->none~get_xc none~set nurbs_surface%set proc~modify_wc->none~set proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~~CallsGraph proc~modify_xc nurbs_surface%modify_Xc none~get_knot nurbs_surface%get_knot proc~modify_xc->none~get_knot none~get_wc nurbs_surface%get_Wc proc~modify_xc->none~get_wc none~get_xc nurbs_surface%get_Xc proc~modify_xc->none~get_xc none~set nurbs_surface%set proc~modify_xc->none~set proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modify_xc~~CalledByGraph proc~modify_xc nurbs_surface%modify_Xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id Calls proc~~nearest_point~~CallsGraph proc~nearest_point nurbs_surface%nearest_point interface~nearest_point_help_2d nearest_point_help_2d proc~nearest_point->interface~nearest_point_help_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point~~CalledByGraph proc~nearest_point nurbs_surface%nearest_point proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~nearest_point program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~nearest_point Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nearest_point.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) Calls proc~~nearest_point2~~CallsGraph proc~nearest_point2 nurbs_surface%nearest_point2 none~derivative2 nurbs_surface%derivative2 proc~nearest_point2->none~derivative2 proc~cmp_xg nurbs_surface%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~create nurbs_surface%create proc~nearest_point2->proc~create proc~finalize nurbs_surface%finalize proc~nearest_point2->proc~finalize proc~nearest_point nurbs_surface%nearest_point proc~nearest_point2->proc~nearest_point proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2->proc~derivative2_vector interface~compute_xg compute_Xg proc~cmp_xg->interface~compute_xg proc~is_rational nurbs_surface%is_rational proc~cmp_xg->proc~is_rational proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~create->proc~is_rational interface~nearest_point_help_2d nearest_point_help_2d proc~nearest_point->interface~nearest_point_help_2d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~~CalledByGraph proc~nearest_point2 nurbs_surface%nearest_point2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nearest_point2.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~~CallsGraph proc~remove_knots nurbs_surface%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots->interface~compute_multiplicity none~get_knot nurbs_surface%get_knot proc~remove_knots->none~get_knot none~set nurbs_surface%set proc~remove_knots->none~set proc~findspan findspan proc~remove_knots->proc~findspan proc~is_rational nurbs_surface%is_rational proc~remove_knots->proc~is_rational proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~~CalledByGraph proc~remove_knots nurbs_surface%remove_knots program~example3_surface example3_surface program~example3_surface->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~~CallsGraph proc~rotate_xc nurbs_surface%rotate_Xc proc~rotation rotation proc~rotate_xc->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~~CalledByGraph proc~rotate_xc nurbs_surface%rotate_Xc program~example3_surface example3_surface program~example3_surface->proc~rotate_xc program~example_ppm2 example_ppm2 program~example_ppm2->proc~rotate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xc.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~~CallsGraph proc~rotate_xg nurbs_surface%rotate_Xg proc~rotation rotation proc~rotate_xg->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~~CalledByGraph proc~rotate_xg nurbs_surface%rotate_Xg program~example3_surface example3_surface program~example3_surface->proc~rotate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xg.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, Xc, Wc) Set knot vectors, control points and weights for the NURBS surface object. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~~CallsGraph proc~set1 nurbs_surface%set1 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~~CalledByGraph proc~set1 nurbs_surface%set1 none~set nurbs_surface%set none~set->proc~set1 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~~CallsGraph proc~set2 nurbs_surface%set2 proc~cmp_nc nurbs_surface%cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~~CalledByGraph proc~set2 nurbs_surface%set2 none~set nurbs_surface%set none~set->proc~set2 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier surface using control points and weights. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~~CallsGraph proc~set3 nurbs_surface%set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~~CalledByGraph proc~set3 nurbs_surface%set3 none~set nurbs_surface%set none~set->proc~set3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_c nurbs_surface%set_C proc~set_c->none~set proc~set_half_ring nurbs_surface%set_half_ring proc~set_half_ring->none~set proc~set_ring nurbs_surface%set_ring proc~set_ring->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~nearest_point_2d nearest_point_2d program~nearest_point_2d->none~set program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~modify_xc program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set3.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_c~~CallsGraph proc~set_c nurbs_surface%set_C none~set nurbs_surface%set proc~set_c->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~~CalledByGraph proc~set_c nurbs_surface%set_C program~shape_c_2d shape_C_2d program~shape_c_2d->proc~set_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_c.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xc_vis.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xg_vis.html"},{"title":"set_half_ring – ForCAD","text":"private pure subroutine set_half_ring(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_half_ring~~CallsGraph proc~set_half_ring nurbs_surface%set_half_ring none~set nurbs_surface%set proc~set_half_ring->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_ring~~CalledByGraph proc~set_half_ring nurbs_surface%set_half_ring program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_half_ring program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~set_half_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_half_ring.html"},{"title":"set_ring – ForCAD","text":"private pure subroutine set_ring(this, center, radius1, radius2) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 Calls proc~~set_ring~~CallsGraph proc~set_ring nurbs_surface%set_ring none~set nurbs_surface%set proc~set_ring->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_ring~~CalledByGraph proc~set_ring nurbs_surface%set_ring program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_ring program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~set_ring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_ring.html"},{"title":"set_tetragon – ForCAD","text":"private pure subroutine set_tetragon(this, L, nc, Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_tetragon~~CallsGraph proc~set_tetragon nurbs_surface%set_tetragon none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_tetragon~~CalledByGraph proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm1 example_ppm1 program~example_ppm1->proc~set_tetragon program~example_ppm2 example_ppm2 program~example_ppm2->proc~set_tetragon program~example_ppm3 example_ppm3 program~example_ppm3->proc~set_tetragon program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~set_tetragon program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_tetragon.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg Called by proc~~show~~CalledByGraph proc~show nurbs_surface%show program~example3_surface example3_surface program~example3_surface->proc~show program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~show program~shape_c_2d shape_C_2d program~shape_c_2d->proc~show program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~show program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~show program~shape_tetragon shape_tetragon program~shape_tetragon->proc~show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/show.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~~CalledByGraph proc~translate_xc nurbs_surface%translate_Xc program~example3_surface example3_surface program~example3_surface->proc~translate_xc program~example_ppm2 example_ppm2 program~example_ppm2->proc~translate_xc program~example_ppm3 example_ppm3 program~example_ppm3->proc~translate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xc.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~~CalledByGraph proc~translate_xg nurbs_surface%translate_Xg program~example3_surface example3_surface program~example3_surface->proc~translate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xg.html"},{"title":"compute_Tgc – ForCAD","text":"private interface compute_Tgc Called by interface~~compute_tgc~~CalledByGraph interface~compute_tgc compute_Tgc proc~basis_scalar nurbs_surface%basis_scalar proc~basis_scalar->interface~compute_tgc proc~basis_vector nurbs_surface%basis_vector proc~basis_vector->interface~compute_tgc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function compute_Tgc_bspline_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"interface/compute_tgc.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Called by interface~~compute_xg~~CalledByGraph interface~compute_xg compute_Xg proc~cmp_xg nurbs_surface%cmp_Xg proc~cmp_xg->interface~compute_xg proc~create nurbs_surface%create proc~create->interface~compute_xg proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~cmp_xg proc~nearest_point2->proc~create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_ppm1 example_ppm1 program~example_ppm1->proc~create program~example_ppm2 example_ppm2 program~example_ppm2->proc~create program~example_ppm3 example_ppm3 program~example_ppm3->proc~create program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~create program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~create program~shape_c_2d shape_C_2d program~shape_c_2d->proc~create program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->proc~create program~shape_ring_2d shape_ring_2d program~shape_ring_2d->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function compute_Xg_bspline_2d(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d_1point(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_2d(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/compute_xg.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Called by interface~~compute_d2tgc~~CalledByGraph interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar nurbs_surface%derivative2_scalar proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector nurbs_surface%derivative2_vector proc~derivative2_vector->interface~compute_d2tgc none~derivative2 nurbs_surface%derivative2 none~derivative2->proc~derivative2_scalar none~derivative2->proc~derivative2_vector proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->none~derivative2 program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine compute_d2Tgc_bspline_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, nc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, nc, f_ng, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_nurbs_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:)","tags":"","loc":"interface/compute_d2tgc.html"},{"title":"compute_dTgc – ForCAD","text":"private interface compute_dTgc Called by interface~~compute_dtgc~~CalledByGraph interface~compute_dtgc compute_dTgc proc~derivative_scalar nurbs_surface%derivative_scalar proc~derivative_scalar->interface~compute_dtgc proc~derivative_vector nurbs_surface%derivative_vector proc~derivative_vector->interface~compute_dtgc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine compute_dTgc_bspline_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, nc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_bspline_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, nc, f_ng, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_nurbs_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:)","tags":"","loc":"interface/compute_dtgc.html"},{"title":"nearest_point_help_2d – ForCAD","text":"interface Called by interface~~nearest_point_help_2d~~CalledByGraph interface~nearest_point_help_2d nearest_point_help_2d proc~nearest_point nurbs_surface%nearest_point proc~nearest_point->interface~nearest_point_help_2d proc~nearest_point2 nurbs_surface%nearest_point2 proc~nearest_point2->proc~nearest_point program~nearest_point_2d nearest_point_2d program~nearest_point_2d->proc~nearest_point program~nearest_point_2d->proc~nearest_point2 program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->proc~nearest_point Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure function nearest_point_help_2d(f_ng, f_Xg, f_point_Xg) result(f_distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Xg (:,:) real(kind=rk), intent(in), contiguous :: f_point_Xg (:) Return Value real(kind=rk),allocatable,(:)","tags":"","loc":"interface/nearest_point_help_2d.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~~CalledByGraph proc~generate_xc generate_Xc program~example3_surface example3_surface program~example3_surface->proc~generate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~2~~CalledByGraph proc~generate_xc~2 generate_Xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~generate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~2.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~3~~CalledByGraph proc~generate_xc~3 generate_Xc program~example3_volume example3_volume program~example3_volume->proc~generate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~3.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~2~~CallsGraph proc~cmp_xg~2 nurbs_curve%cmp_Xg interface~compute_xg~2 compute_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~cmp_xg~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~2~~CalledByGraph proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_xg~2.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~2~~CallsGraph proc~cmp_elem~2 nurbs_curve%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn interface~unique unique proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem~2.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~2~~CallsGraph proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~2~~CalledByGraph proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2 nurbs_curve%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xc_vis~2.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~2~~CallsGraph proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~2~~CalledByGraph proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2 nurbs_curve%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 program~example1_curve example1_curve program~example1_curve->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xg_vis~2.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~2~~CalledByGraph proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2 nurbs_curve%get_Wc none~get_wc~2->proc~get_wc_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_wc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_wc_all~2.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~2~~CalledByGraph proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2 nurbs_curve%get_Wc none~get_wc~2->proc~get_wci~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_wc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_wc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_wci~2.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~2~~CalledByGraph proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xc_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xc_all~2.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~2~~CalledByGraph proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xci~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xci~2.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~2~~CalledByGraph proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2 nurbs_curve%get_Xc none~get_xc~2->proc~get_xcid~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_xc~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xcid~2.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg_all~2.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xgi~2.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk)","tags":"","loc":"proc/get_xgid~2.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this) result(Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~2.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this) result(c) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_continuity~2~~CallsGraph proc~get_continuity~2 nurbs_curve%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity~2.html"},{"title":"get_degree – ForCAD","text":"private pure function get_degree(this) result(degree) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Called by proc~~get_degree~~CalledByGraph proc~get_degree nurbs_curve%get_degree program~example1_curve example1_curve program~example1_curve->proc~get_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem~2.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xc_vis~2.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xg_vis~2.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~2~~CalledByGraph proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2 nurbs_curve%get_knot none~get_knot~2->proc~get_knot_all~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_knot~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_knot~2 program~example1_curve example1_curve program~example1_curve->none~get_knot~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knot_all~2.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, i) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~2~~CalledByGraph proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2 nurbs_curve%get_knot none~get_knot~2->proc~get_knoti~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~get_knot~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~get_knot~2 program~example1_curve example1_curve program~example1_curve->none~get_knot~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knoti~2.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this) result(m) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~2~~CallsGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~2~~CalledByGraph proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2 nurbs_curve%cmp_degree proc~cmp_degree~2->proc~get_multiplicity~2 proc~cmp_elem~2 nurbs_curve%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity~2.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer","tags":"","loc":"proc/get_nc~2.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer","tags":"","loc":"proc/get_ng~2.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical Called by proc~~is_rational~2~~CalledByGraph proc~is_rational~2 nurbs_curve%is_rational proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->proc~is_rational~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->proc~is_rational~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->proc~is_rational~2 proc~create~2 nurbs_curve%create proc~create~2->proc~is_rational~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->proc~is_rational~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->proc~is_rational~2 proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->proc~is_rational~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->proc~is_rational~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->proc~is_rational~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->proc~is_rational~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->proc~is_rational~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->none~derivative2~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_rational~2.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~2~~CallsGraph proc~basis_scalar~2 nurbs_curve%basis_scalar interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2->interface~compute_tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~basis_scalar~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_scalar~2.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~2~~CallsGraph proc~basis_vector~2 nurbs_curve%basis_vector interface~compute_tgc~2 compute_Tgc proc~basis_vector~2->interface~compute_tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~basis_vector~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_vector~2.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Calls proc~~cmp_degree~2~~CallsGraph proc~cmp_degree~2 nurbs_curve%cmp_degree proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~2~~CalledByGraph proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2 nurbs_curve%set1 proc~set1~2->proc~cmp_degree~2 proc~set3~2 nurbs_curve%set3 proc~set3~2->proc~cmp_degree~2 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_degree~2.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Calls proc~~cmp_nc~2~~CallsGraph proc~cmp_nc~2 nurbs_curve%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_nc~2.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res, Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) Calls proc~~create~2~~CallsGraph proc~create~2 nurbs_curve%create interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~2~~CalledByGraph proc~create~2 nurbs_curve%create proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~2.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~2~~CallsGraph proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative2_scalar~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~2~~CalledByGraph proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative2_scalar~2.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~2~~CallsGraph proc~derivative2_vector~2 nurbs_curve%derivative2_vector interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_vector~2->interface~compute_d2tgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative2_vector~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~2~~CalledByGraph proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative2_vector~2.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative_scalar~2~~CallsGraph proc~derivative_scalar~2 nurbs_curve%derivative_scalar interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_scalar~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative_scalar~2.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res, Xt, dTgc, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~2~~CallsGraph proc~derivative_vector~2 nurbs_curve%derivative_vector interface~compute_dtgc~2 compute_dTgc proc~derivative_vector~2->interface~compute_dtgc~2 proc~is_rational~2 nurbs_curve%is_rational proc~derivative_vector~2->proc~is_rational~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative_vector~2.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, t) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t Calls proc~~elevate_degree~2~~CallsGraph proc~elevate_degree~2 nurbs_curve%elevate_degree none~set~2 nurbs_curve%set proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~is_rational~2 nurbs_curve%is_rational proc~elevate_degree~2->proc~is_rational~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~2~~CalledByGraph proc~elevate_degree~2 nurbs_curve%elevate_degree program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree~2.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~2~~CallsGraph proc~export_xc~2 nurbs_curve%export_Xc proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~2~~CalledByGraph proc~export_xc~2 nurbs_curve%export_Xc program~example1_curve example1_curve program~example1_curve->proc~export_xc~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xc~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~2.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~2~~CallsGraph proc~export_xg~2 nurbs_curve%export_Xg proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~2~~CalledByGraph proc~export_xg~2 nurbs_curve%export_Xg program~example1_curve example1_curve program~example1_curve->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xg~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~2.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Called by proc~~finalize~2~~CalledByGraph proc~finalize~2 nurbs_curve%finalize proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~finalize~2 program~example1_curve example1_curve program~example1_curve->proc~finalize~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~finalize~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~finalize~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~finalize~2 program~shape_circle shape_circle program~shape_circle->proc~finalize~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~finalize~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~2.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, Xth, r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~2~~CallsGraph proc~insert_knots~2 nurbs_curve%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~insert_knots~2->none~set~2 proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~is_rational~2 nurbs_curve%is_rational proc~insert_knots~2->proc~is_rational~2 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~2~~CalledByGraph proc~insert_knots~2 nurbs_curve%insert_knots program~example1_curve example1_curve program~example1_curve->proc~insert_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knots~2.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~2~~CallsGraph proc~modify_wc~2 nurbs_curve%modify_Wc none~get_knot~2 nurbs_curve%get_knot proc~modify_wc~2->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc proc~modify_wc~2->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc proc~modify_wc~2->none~get_xc~2 none~set~2 nurbs_curve%set proc~modify_wc~2->none~set~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~2.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~2~~CallsGraph proc~modify_xc~2 nurbs_curve%modify_Xc none~get_knot~2 nurbs_curve%get_knot proc~modify_xc~2->none~get_knot~2 none~get_wc~2 nurbs_curve%get_Wc proc~modify_xc~2->none~get_wc~2 none~get_xc~2 nurbs_curve%get_Xc proc~modify_xc~2->none~get_xc~2 none~set~2 nurbs_curve%set proc~modify_xc~2->none~set~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~get_wc_all~2 nurbs_curve%get_Wc_all none~get_wc~2->proc~get_wc_all~2 proc~get_wci~2 nurbs_curve%get_Wci none~get_wc~2->proc~get_wci~2 proc~get_xc_all~2 nurbs_curve%get_Xc_all none~get_xc~2->proc~get_xc_all~2 proc~get_xcid~2 nurbs_curve%get_Xcid none~get_xc~2->proc~get_xcid~2 proc~get_xci~2 nurbs_curve%get_Xci none~get_xc~2->proc~get_xci~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~2.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id Calls proc~~nearest_point~2~~CallsGraph proc~nearest_point~2 nurbs_curve%nearest_point interface~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2->interface~nearest_point_help_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point~2~~CalledByGraph proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~nearest_point~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point~2 program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nearest_point~2.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) Calls proc~~nearest_point2~2~~CallsGraph proc~nearest_point2~2 nurbs_curve%nearest_point2 none~derivative2~2 nurbs_curve%derivative2 proc~nearest_point2~2->none~derivative2~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 proc~create~2 nurbs_curve%create proc~nearest_point2~2->proc~create~2 proc~finalize~2 nurbs_curve%finalize proc~nearest_point2~2->proc~finalize~2 proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point2~2->proc~nearest_point~2 proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 interface~compute_xg~2 compute_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~cmp_xg~2->proc~is_rational~2 proc~create~2->interface~compute_xg~2 proc~create~2->proc~is_rational~2 interface~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2->interface~nearest_point_help_1d proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~2~~CalledByGraph proc~nearest_point2~2 nurbs_curve%nearest_point2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nearest_point2~2.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, Xth, r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~2~~CallsGraph proc~remove_knots~2 nurbs_curve%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~2->interface~compute_multiplicity none~set~2 nurbs_curve%set proc~remove_knots~2->none~set~2 proc~findspan findspan proc~remove_knots~2->proc~findspan proc~is_rational~2 nurbs_curve%is_rational proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~2~~CalledByGraph proc~remove_knots~2 nurbs_curve%remove_knots program~example1_curve example1_curve program~example1_curve->proc~remove_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots~2.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~2~~CallsGraph proc~rotate_xc~2 nurbs_curve%rotate_Xc proc~rotation rotation proc~rotate_xc~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~2~~CalledByGraph proc~rotate_xc~2 nurbs_curve%rotate_Xc program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xc~2.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~2~~CallsGraph proc~rotate_xg~2 nurbs_curve%rotate_Xg proc~rotation rotation proc~rotate_xg~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~2~~CalledByGraph proc~rotate_xg~2 nurbs_curve%rotate_Xg program~example1_curve example1_curve program~example1_curve->proc~rotate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xg~2.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot, Xc, Wc) Set knot vector, control points and weights for the NURBS curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~2~~CallsGraph proc~set1~2 nurbs_curve%set1 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~2~~CalledByGraph proc~set1~2 nurbs_curve%set1 none~set~2 nurbs_curve%set none~set~2->proc~set1~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1~2.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir, degree, continuity, Xc, Wc) Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~2~~CallsGraph proc~set2~2 nurbs_curve%set2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~2~~CalledByGraph proc~set2~2 nurbs_curve%set2 none~set~2 nurbs_curve%set none~set~2->proc~set2~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2~2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, Xc, Wc) Set Bezier or Rational Bezier curve using control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~2~~CallsGraph proc~set3~2 nurbs_curve%set3 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~2~~CalledByGraph proc~set3~2 nurbs_curve%set3 none~set~2 nurbs_curve%set none~set~2->proc~set3~2 proc~elevate_degree~2 nurbs_curve%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_curve%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_curve%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_curve%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_curve%remove_knots proc~remove_knots~2->none~set~2 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~2 proc~set_c~2 nurbs_curve%set_C proc~set_c~2->none~set~2 proc~set_half_circle nurbs_curve%set_half_circle proc~set_half_circle->none~set~2 program~example1_curve example1_curve program~example1_curve->none~set~2 program~example1_curve->proc~elevate_degree~2 program~example1_curve->proc~insert_knots~2 program~example1_curve->proc~remove_knots~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->none~set~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set3~2.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_c~2~~CallsGraph proc~set_c~2 nurbs_curve%set_C none~set~2 nurbs_curve%set proc~set_c~2->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~2~~CalledByGraph proc~set_c~2 nurbs_curve%set_C program~shape_c_1d shape_C_1d program~shape_c_1d->proc~set_c~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_c~2.html"},{"title":"set_circle – ForCAD","text":"private pure subroutine set_circle(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_circle~~CallsGraph proc~set_circle nurbs_curve%set_circle none~set~2 nurbs_curve%set proc~set_circle->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_circle~~CalledByGraph proc~set_circle nurbs_curve%set_circle program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_circle.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem~2.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xc_vis~2.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xg_vis~2.html"},{"title":"set_half_circle – ForCAD","text":"private pure subroutine set_half_circle(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_half_circle~~CallsGraph proc~set_half_circle nurbs_curve%set_half_circle none~set~2 nurbs_curve%set proc~set_half_circle->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_circle~~CalledByGraph proc~set_half_circle nurbs_curve%set_half_circle program~shape_half_circle shape_half_circle program~shape_half_circle->proc~set_half_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_half_circle.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg Called by proc~~show~2~~CalledByGraph proc~show~2 nurbs_curve%show program~example1_curve example1_curve program~example1_curve->proc~show~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~show~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~show~2 program~shape_circle shape_circle program~shape_circle->proc~show~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~show~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/show~2.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~2~~CalledByGraph proc~translate_xc~2 nurbs_curve%translate_Xc program~example1_curve example1_curve program~example1_curve->proc~translate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xc~2.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~2~~CalledByGraph proc~translate_xg~2 nurbs_curve%translate_Xg program~example1_curve example1_curve program~example1_curve->proc~translate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xg~2.html"},{"title":"compute_Tgc – ForCAD","text":"private interface compute_Tgc Called by interface~~compute_tgc~2~~CalledByGraph interface~compute_tgc~2 compute_Tgc proc~basis_scalar~2 nurbs_curve%basis_scalar proc~basis_scalar~2->interface~compute_tgc~2 proc~basis_vector~2 nurbs_curve%basis_vector proc~basis_vector~2->interface~compute_tgc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function compute_Tgc_bspline_1d_scalar(f_Xt, f_knot, f_degree, f_nc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"interface/compute_tgc~2.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Called by interface~~compute_xg~2~~CalledByGraph interface~compute_xg~2 compute_Xg proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~cmp_xg~2->interface~compute_xg~2 proc~create~2 nurbs_curve%create proc~create~2->interface~compute_xg~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~cmp_xg~2 proc~nearest_point2~2->proc~create~2 program~example1_curve example1_curve program~example1_curve->proc~create~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~create~2 program~nearest_point_1d->proc~nearest_point2~2 program~shape_c_1d shape_C_1d program~shape_c_1d->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~2 program~shape_half_circle shape_half_circle program~shape_half_circle->proc~create~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function compute_Xg_bspline_1d(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d_1point(f_Xt, f_knot, f_degree, f_nc, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_1d(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point(f_Xt, f_knot, f_degree, f_nc, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/compute_xg~2.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Called by interface~~compute_d2tgc~2~~CalledByGraph interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector proc~derivative2_vector~2->interface~compute_d2tgc~2 none~derivative2~2 nurbs_curve%derivative2 none~derivative2~2->proc~derivative2_scalar~2 none~derivative2~2->proc~derivative2_vector~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->none~derivative2~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine compute_d2Tgc_bspline_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(out), allocatable :: f_d2Tgc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_nurbs_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:)","tags":"","loc":"interface/compute_d2tgc~2.html"},{"title":"compute_dTgc – ForCAD","text":"private interface compute_dTgc Called by interface~~compute_dtgc~2~~CalledByGraph interface~compute_dtgc~2 compute_dTgc proc~derivative_scalar~2 nurbs_curve%derivative_scalar proc~derivative_scalar~2->interface~compute_dtgc~2 proc~derivative_vector~2 nurbs_curve%derivative_vector proc~derivative_vector~2->interface~compute_dtgc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine compute_dTgc_bspline_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_bspline_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_nurbs_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:)","tags":"","loc":"interface/compute_dtgc~2.html"},{"title":"nearest_point_help_1d – ForCAD","text":"interface Called by interface~~nearest_point_help_1d~~CalledByGraph interface~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2 nurbs_curve%nearest_point proc~nearest_point~2->interface~nearest_point_help_1d proc~nearest_point2~2 nurbs_curve%nearest_point2 proc~nearest_point2~2->proc~nearest_point~2 program~nearest_point_1d nearest_point_1d program~nearest_point_1d->proc~nearest_point~2 program~nearest_point_1d->proc~nearest_point2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure function nearest_point_help_1d(f_ng, f_Xg, f_point_Xg) result(f_distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Xg (:,:) real(kind=rk), intent(in), contiguous :: f_point_Xg (:) Return Value real(kind=rk),allocatable,(:)","tags":"","loc":"interface/nearest_point_help_1d.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~4~~CalledByGraph proc~generate_xc~4 generate_Xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~generate_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~4.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~5~~CalledByGraph proc~generate_xc~5 generate_Xc program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~generate_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~5.html"},{"title":"cmp_Xg – ForCAD","text":"private pure function cmp_Xg(this, Xt) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~cmp_xg~3~~CallsGraph proc~cmp_xg~3 nurbs_volume%cmp_Xg interface~compute_xg~3 compute_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~cmp_xg~3->proc~is_rational~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_xg~3~~CalledByGraph proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_xg~3.html"},{"title":"cmp_degreeFace – ForCAD","text":"private pure function cmp_degreeFace(this, face) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) Called by proc~~cmp_degreeface~~CalledByGraph proc~cmp_degreeface nurbs_volume%cmp_degreeFace program~example3_volume example3_volume program~example3_volume->proc~cmp_degreeface Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_degreeface.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~3~~CallsGraph proc~cmp_elem~3 nurbs_volume%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem~3~~CalledByGraph proc~cmp_elem~3 nurbs_volume%cmp_elem program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem~3.html"},{"title":"cmp_elemFace – ForCAD","text":"private pure function cmp_elemFace(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) Called by proc~~cmp_elemface~~CalledByGraph proc~cmp_elemface nurbs_volume%cmp_elemFace program~example3_volume example3_volume program~example3_volume->proc~cmp_elemface Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemface.html"},{"title":"cmp_elemFace_Xc_vis – ForCAD","text":"private pure function cmp_elemFace_Xc_vis(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:)","tags":"","loc":"proc/cmp_elemface_xc_vis.html"},{"title":"cmp_elemFace_Xg_vis – ForCAD","text":"private pure function cmp_elemFace_Xg_vis(this, elem, face) result(elemConn) number of nodes in each direction Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:)","tags":"","loc":"proc/cmp_elemface_xg_vis.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~3~~CallsGraph proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~3~~CalledByGraph proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3 nurbs_volume%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xc_vis~3.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~3~~CallsGraph proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~3~~CalledByGraph proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3 nurbs_volume%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example3_volume example3_volume program~example3_volume->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xg_vis~3.html"},{"title":"get_Wc_all – ForCAD","text":"private pure function get_Wc_all(this) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_wc_all~3~~CalledByGraph proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3 nurbs_volume%get_Wc none~get_wc~3->proc~get_wc_all~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_wc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_wc_all~3.html"},{"title":"get_Wci – ForCAD","text":"private pure function get_Wci(this, n) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~get_wci~3~~CalledByGraph proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3 nurbs_volume%get_Wc none~get_wc~3->proc~get_wci~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_wc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_wc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_wci~3.html"},{"title":"get_Xc_all – ForCAD","text":"private pure function get_Xc_all(this) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) Called by proc~~get_xc_all~3~~CalledByGraph proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3 nurbs_volume%get_Xc none~get_xc~3->proc~get_xc_all~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xc_all~3.html"},{"title":"get_Xci – ForCAD","text":"private pure function get_Xci(this, n) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) Called by proc~~get_xci~3~~CalledByGraph proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3 nurbs_volume%get_Xc none~get_xc~3->proc~get_xci~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xci~3.html"},{"title":"get_Xcid – ForCAD","text":"private pure function get_Xcid(this, n, dir) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) Called by proc~~get_xcid~3~~CalledByGraph proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3 nurbs_volume%get_Xc none~get_xc~3->proc~get_xcid~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_xc~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_xcid~3.html"},{"title":"get_Xg_all – ForCAD","text":"private pure function get_Xg_all(this) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg_all~3.html"},{"title":"get_Xgi – ForCAD","text":"private pure function get_Xgi(this, n) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xgi~3.html"},{"title":"get_Xgid – ForCAD","text":"private pure function get_Xgid(this, n, dir) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk)","tags":"","loc":"proc/get_xgid~3.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~3.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~3~~CallsGraph proc~get_continuity~3 nurbs_volume%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity~3.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Called by proc~~get_degree_all~2~~CalledByGraph proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3 nurbs_volume%get_degree none~get_degree~3->proc~get_degree_all~2 program~example3_volume example3_volume program~example3_volume->none~get_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_all~2.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Called by proc~~get_degree_dir~2~~CalledByGraph proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3 nurbs_volume%get_degree none~get_degree~3->proc~get_degree_dir~2 program~example3_volume example3_volume program~example3_volume->none~get_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_dir~2.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem~3.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xc_vis~3.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xg_vis~3.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~3~~CalledByGraph proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3 nurbs_volume%get_knot none~get_knot~3->proc~get_knot_all~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~get_knot~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~get_knot~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_knot~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_knot~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~get_knot~3 program~example3_volume example3_volume program~example3_volume->none~get_knot~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knot_all~3.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~3~~CalledByGraph proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3 nurbs_volume%get_knot none~get_knot~3->proc~get_knoti~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~get_knot~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~get_knot~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~get_knot~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~get_knot~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~get_knot~3 program~example3_volume example3_volume program~example3_volume->none~get_knot~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knoti~3.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~3~~CallsGraph proc~get_multiplicity~3 nurbs_volume%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~3~~CalledByGraph proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3 nurbs_volume%cmp_degree proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_elem~3 nurbs_volume%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_degree~3 proc~set3~3 nurbs_volume%set3 proc~set3~3->proc~cmp_degree~3 program~example3_volume example3_volume program~example3_volume->proc~cmp_elem~3 none~set~3 nurbs_volume%set program~example3_volume->none~set~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree~3 proc~insert_knots~3 nurbs_volume%insert_knots program~example3_volume->proc~insert_knots~3 proc~remove_knots~3 nurbs_volume%remove_knots program~example3_volume->proc~remove_knots~3 none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~elevate_degree~3->none~set~3 proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity~3.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this, dir) result(nc) Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc~3~~CallsGraph proc~get_nc~3 get_nc interface~compute_multiplicity compute_multiplicity proc~get_nc~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc~3.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3)","tags":"","loc":"proc/get_ng~3.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical Called by proc~~is_rational~3~~CalledByGraph proc~is_rational~3 nurbs_volume%is_rational proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->proc~is_rational~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->proc~is_rational~3 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->proc~is_rational~3 proc~create~3 nurbs_volume%create proc~create~3->proc~is_rational~3 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->proc~is_rational~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->proc~is_rational~3 proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->proc~is_rational~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->proc~is_rational~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->none~derivative2~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_rational~3.html"},{"title":"basis_scalar – ForCAD","text":"private pure subroutine basis_scalar(this, Xt, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) Calls proc~~basis_scalar~3~~CallsGraph proc~basis_scalar~3 nurbs_volume%basis_scalar interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3->interface~compute_tgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~basis_scalar~3->proc~is_rational~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_scalar~3.html"},{"title":"basis_vector – ForCAD","text":"private pure subroutine basis_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis_vector~3~~CallsGraph proc~basis_vector~3 nurbs_volume%basis_vector interface~compute_tgc~3 compute_Tgc proc~basis_vector~3->interface~compute_tgc~3 interface~ndgrid ndgrid proc~basis_vector~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~basis_vector~3->proc~is_rational~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_vector~3.html"},{"title":"cmp_degree – ForCAD","text":"private pure subroutine cmp_degree(this, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_degree~3~~CallsGraph proc~cmp_degree~3 nurbs_volume%cmp_degree proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_degree~3~~CalledByGraph proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_degree~3 proc~set3~3 nurbs_volume%set3 proc~set3~3->proc~cmp_degree~3 none~set~3 nurbs_volume%set none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_degree~3.html"},{"title":"cmp_nc – ForCAD","text":"private pure subroutine cmp_nc(this, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir Calls proc~~cmp_nc~3~~CallsGraph proc~cmp_nc~3 nurbs_volume%cmp_nc interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_nc~3~~CalledByGraph proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3 nurbs_volume%set1 proc~set1~3->proc~cmp_nc~3 proc~set2~3 nurbs_volume%set2 proc~set2~3->proc~cmp_nc~3 none~set~3 nurbs_volume%set none~set~3->proc~set1~3 none~set~3->proc~set2~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_nc~3.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~3~~CallsGraph proc~create~3 nurbs_volume%create interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~3~~CalledByGraph proc~create~3 nurbs_volume%create proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~3.html"},{"title":"derivative2_scalar – ForCAD","text":"private pure subroutine derivative2_scalar(this, Xt, d2Tgc, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative2_scalar~3~~CallsGraph proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~derivative2_scalar~3->proc~is_rational~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_scalar~3~~CalledByGraph proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative2_scalar~3.html"},{"title":"derivative2_vector – ForCAD","text":"private pure subroutine derivative2_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative2_vector~3~~CallsGraph proc~derivative2_vector~3 nurbs_volume%derivative2_vector interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_vector~3->interface~compute_d2tgc~3 interface~ndgrid ndgrid proc~derivative2_vector~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~derivative2_vector~3->proc~is_rational~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~derivative2_vector~3~~CalledByGraph proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative2_vector~3.html"},{"title":"derivative_scalar – ForCAD","text":"private pure subroutine derivative_scalar(this, Xt, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) Calls proc~~derivative_scalar~3~~CallsGraph proc~derivative_scalar~3 nurbs_volume%derivative_scalar interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3->interface~compute_dtgc~3 proc~is_rational~3 nurbs_volume%is_rational proc~derivative_scalar~3->proc~is_rational~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative_scalar~3.html"},{"title":"derivative_vector – ForCAD","text":"private pure subroutine derivative_vector(this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) Calls proc~~derivative_vector~3~~CallsGraph proc~derivative_vector~3 nurbs_volume%derivative_vector interface~compute_dtgc~3 compute_dTgc proc~derivative_vector~3->interface~compute_dtgc~3 interface~ndgrid ndgrid proc~derivative_vector~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~derivative_vector~3->proc~is_rational~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative_vector~3.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t Calls proc~~elevate_degree~3~~CallsGraph proc~elevate_degree~3 nurbs_volume%elevate_degree none~get_knot~3 nurbs_volume%get_knot proc~elevate_degree~3->none~get_knot~3 none~set~3 nurbs_volume%set proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~3~~CalledByGraph proc~elevate_degree~3 nurbs_volume%elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree~3.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~3~~CallsGraph proc~export_xc~3 nurbs_volume%export_Xc proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~3~~CalledByGraph proc~export_xc~3 nurbs_volume%export_Xc program~example3_volume example3_volume program~example3_volume->proc~export_xc~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xc~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xc~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xc~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~3.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~3~~CallsGraph proc~export_xg~3 nurbs_volume%export_Xg proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~3~~CalledByGraph proc~export_xg~3 nurbs_volume%export_Xg program~example3_volume example3_volume program~example3_volume->proc~export_xg~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~export_xg~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~export_xg~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~3.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this Called by proc~~finalize~3~~CalledByGraph proc~finalize~3 nurbs_volume%finalize proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~finalize~3 program~example3_volume example3_volume program~example3_volume->proc~finalize~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~finalize~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~finalize~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~finalize~3 program~nearest_point_3d->proc~nearest_point2~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~finalize~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~finalize~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~finalize~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~finalize~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~3.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~3~~CallsGraph proc~insert_knots~3 nurbs_volume%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity none~get_knot~3 nurbs_volume%get_knot proc~insert_knots~3->none~get_knot~3 none~set~3 nurbs_volume%set proc~insert_knots~3->none~set~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~3~~CalledByGraph proc~insert_knots~3 nurbs_volume%insert_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knots~3.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~3~~CallsGraph proc~modify_wc~3 nurbs_volume%modify_Wc none~get_knot~3 nurbs_volume%get_knot proc~modify_wc~3->none~get_knot~3 none~get_wc~3 nurbs_volume%get_Wc proc~modify_wc~3->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~modify_wc~3->none~get_xc~3 none~set~3 nurbs_volume%set proc~modify_wc~3->none~set~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~3.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~3~~CallsGraph proc~modify_xc~3 nurbs_volume%modify_Xc none~get_knot~3 nurbs_volume%get_knot proc~modify_xc~3->none~get_knot~3 none~get_wc~3 nurbs_volume%get_Wc proc~modify_xc~3->none~get_wc~3 none~get_xc~3 nurbs_volume%get_Xc proc~modify_xc~3->none~get_xc~3 none~set~3 nurbs_volume%set proc~modify_xc~3->none~set~3 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~get_wc_all~3 nurbs_volume%get_Wc_all none~get_wc~3->proc~get_wc_all~3 proc~get_wci~3 nurbs_volume%get_Wci none~get_wc~3->proc~get_wci~3 proc~get_xc_all~3 nurbs_volume%get_Xc_all none~get_xc~3->proc~get_xc_all~3 proc~get_xcid~3 nurbs_volume%get_Xcid none~get_xc~3->proc~get_xcid~3 proc~get_xci~3 nurbs_volume%get_Xci none~get_xc~3->proc~get_xci~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~3.html"},{"title":"nearest_point – ForCAD","text":"private pure subroutine nearest_point(this, point_Xg, nearest_Xg, nearest_Xt, id) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id Calls proc~~nearest_point~3~~CallsGraph proc~nearest_point~3 nurbs_volume%nearest_point interface~nearest_point_help_3d nearest_point_help_3d proc~nearest_point~3->interface~nearest_point_help_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point~3~~CalledByGraph proc~nearest_point~3 nurbs_volume%nearest_point proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~nearest_point~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point~3 program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nearest_point~3.html"},{"title":"nearest_point2 – ForCAD","text":"private impure subroutine nearest_point2(this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) Calls proc~~nearest_point2~3~~CallsGraph proc~nearest_point2~3 nurbs_volume%nearest_point2 none~derivative2~3 nurbs_volume%derivative2 proc~nearest_point2~3->none~derivative2~3 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 proc~create~3 nurbs_volume%create proc~nearest_point2~3->proc~create~3 proc~finalize~3 nurbs_volume%finalize proc~nearest_point2~3->proc~finalize~3 proc~nearest_point~3 nurbs_volume%nearest_point proc~nearest_point2~3->proc~nearest_point~3 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 interface~compute_xg~3 compute_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~is_rational~3 nurbs_volume%is_rational proc~cmp_xg~3->proc~is_rational~3 proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~create~3->proc~is_rational~3 interface~nearest_point_help_3d nearest_point_help_3d proc~nearest_point~3->interface~nearest_point_help_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nearest_point2~3~~CalledByGraph proc~nearest_point2~3 nurbs_volume%nearest_point2 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nearest_point2~3.html"},{"title":"put_to_nurbs – ForCAD","text":"private pure subroutine put_to_nurbs(this, X, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) Calls proc~~put_to_nurbs~~CallsGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~basis_bspline basis_bspline proc~put_to_nurbs->proc~basis_bspline proc~kron kron proc~put_to_nurbs->proc~kron proc~set_elem_xg_vis~3 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~put_to_nurbs~~CalledByGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/put_to_nurbs.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~3~~CallsGraph proc~remove_knots~3 nurbs_volume%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~3->interface~compute_multiplicity none~get_knot~3 nurbs_volume%get_knot proc~remove_knots~3->none~get_knot~3 none~set~3 nurbs_volume%set proc~remove_knots~3->none~set~3 proc~findspan findspan proc~remove_knots~3->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~3~~CalledByGraph proc~remove_knots~3 nurbs_volume%remove_knots program~example3_volume example3_volume program~example3_volume->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots~3.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~3~~CallsGraph proc~rotate_xc~3 nurbs_volume%rotate_Xc proc~rotation rotation proc~rotate_xc~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~3~~CalledByGraph proc~rotate_xc~3 nurbs_volume%rotate_Xc program~example3_volume example3_volume program~example3_volume->proc~rotate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xc~3.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~3~~CallsGraph proc~rotate_xg~3 nurbs_volume%rotate_Xg proc~rotation rotation proc~rotate_xg~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~3~~CalledByGraph proc~rotate_xg~3 nurbs_volume%rotate_Xg program~example3_volume example3_volume program~example3_volume->proc~rotate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xg~3.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, knot3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~3~~CallsGraph proc~set1~3 nurbs_volume%set1 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~3~~CalledByGraph proc~set1~3 nurbs_volume%set1 none~set~3 nurbs_volume%set none~set~3->proc~set1~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1~3.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~3~~CallsGraph proc~set2~3 nurbs_volume%set2 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~3~~CalledByGraph proc~set2~3 nurbs_volume%set2 none~set~3 nurbs_volume%set none~set~3->proc~set2~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2~3.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier volume using control points and weights. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~3~~CallsGraph proc~set3~3 nurbs_volume%set3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~3~~CalledByGraph proc~set3~3 nurbs_volume%set3 none~set~3 nurbs_volume%set none~set~3->proc~set3~3 proc~elevate_degree~3 nurbs_volume%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_volume%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_volume%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_volume%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_volume%remove_knots proc~remove_knots~3->none~set~3 proc~set_c~3 nurbs_volume%set_C proc~set_c~3->none~set~3 proc~set_half_ring~2 nurbs_volume%set_half_ring proc~set_half_ring~2->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~3 proc~set_ring~2 nurbs_volume%set_ring proc~set_ring~2->none~set~3 program~example3_volume example3_volume program~example3_volume->none~set~3 program~example3_volume->proc~elevate_degree~3 program~example3_volume->proc~insert_knots~3 program~example3_volume->proc~remove_knots~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->none~set~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->none~set~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set3~3.html"},{"title":"set_C – ForCAD","text":"private pure subroutine set_C(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_c~3~~CallsGraph proc~set_c~3 nurbs_volume%set_C none~set~3 nurbs_volume%set proc~set_c~3->none~set~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_c~3~~CalledByGraph proc~set_c~3 nurbs_volume%set_C program~shape_c_3d shape_C_3d program~shape_c_3d->proc~set_c~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_c~3.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem~3~~CalledByGraph proc~set_elem~3 nurbs_volume%set_elem program~example3_volume example3_volume program~example3_volume->proc~set_elem~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_elem~3.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xc_vis~3.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~3~~CalledByGraph proc~set_elem_xg_vis~3 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~set_elem_xg_vis~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_elem_xg_vis~3.html"},{"title":"set_half_ring – ForCAD","text":"private pure subroutine set_half_ring(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_half_ring~2~~CallsGraph proc~set_half_ring~2 nurbs_volume%set_half_ring none~set~3 nurbs_volume%set proc~set_half_ring~2->none~set~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_half_ring~2~~CalledByGraph proc~set_half_ring~2 nurbs_volume%set_half_ring program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~set_half_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_half_ring~2.html"},{"title":"set_hexahedron – ForCAD","text":"private pure subroutine set_hexahedron(this, L, nc, Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_hexahedron~~CallsGraph proc~set_hexahedron nurbs_volume%set_hexahedron none~set~3 nurbs_volume%set proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_hexahedron~~CalledByGraph proc~set_hexahedron nurbs_volume%set_hexahedron program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_hexahedron.html"},{"title":"set_ring – ForCAD","text":"private pure subroutine set_ring(this, center, radius1, radius2, length) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length Calls proc~~set_ring~2~~CallsGraph proc~set_ring~2 nurbs_volume%set_ring none~set~3 nurbs_volume%set proc~set_ring~2->none~set~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_ring~2~~CalledByGraph proc~set_ring~2 nurbs_volume%set_ring program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~set_ring~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_ring~2.html"},{"title":"show – ForCAD","text":"private impure subroutine show(this, vtkfile_Xc, vtkfile_Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg Called by proc~~show~3~~CalledByGraph proc~show~3 nurbs_volume%show program~example3_volume example3_volume program~example3_volume->proc~show~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~show~3 program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~show~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~show~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~show~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~show~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~show~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/show~3.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~3~~CalledByGraph proc~translate_xc~3 nurbs_volume%translate_Xc program~example3_volume example3_volume program~example3_volume->proc~translate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xc~3.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~3~~CalledByGraph proc~translate_xg~3 nurbs_volume%translate_Xg program~example3_volume example3_volume program~example3_volume->proc~translate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xg~3.html"},{"title":"compute_Tgc – ForCAD","text":"private interface compute_Tgc Called by interface~~compute_tgc~3~~CalledByGraph interface~compute_tgc~3 compute_Tgc proc~basis_scalar~3 nurbs_volume%basis_scalar proc~basis_scalar~3->interface~compute_tgc~3 proc~basis_vector~3 nurbs_volume%basis_vector proc~basis_vector~3->interface~compute_tgc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function compute_Tgc_bspline_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"interface/compute_tgc~3.html"},{"title":"compute_Xg – ForCAD","text":"private interface compute_Xg Called by interface~~compute_xg~3~~CalledByGraph interface~compute_xg~3 compute_Xg proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~cmp_xg~3->interface~compute_xg~3 proc~create~3 nurbs_volume%create proc~create~3->interface~compute_xg~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~cmp_xg~3 proc~nearest_point2~3->proc~create~3 program~example3_volume example3_volume program~example3_volume->proc~create~3 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~create~3 program~nearest_point_3d->proc~nearest_point2~3 program~shape_c_3d shape_C_3d program~shape_c_3d->proc~create~3 program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~3 program~shape_ring_3d shape_ring_3d program~shape_ring_3d->proc~create~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function compute_Xg_bspline_3d(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d_1point(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_3d(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/compute_xg~3.html"},{"title":"compute_d2Tgc – ForCAD","text":"private interface compute_d2Tgc Called by interface~~compute_d2tgc~3~~CalledByGraph interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector proc~derivative2_vector~3->interface~compute_d2tgc~3 none~derivative2~3 nurbs_volume%derivative2 none~derivative2~3->proc~derivative2_scalar~3 none~derivative2~3->proc~derivative2_vector~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->none~derivative2~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine compute_d2Tgc_bspline_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_nurbs_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:)","tags":"","loc":"interface/compute_d2tgc~3.html"},{"title":"compute_dTgc – ForCAD","text":"private interface compute_dTgc Called by interface~~compute_dtgc~3~~CalledByGraph interface~compute_dtgc~3 compute_dTgc proc~derivative_scalar~3 nurbs_volume%derivative_scalar proc~derivative_scalar~3->interface~compute_dtgc~3 proc~derivative_vector~3 nurbs_volume%derivative_vector proc~derivative_vector~3->interface~compute_dtgc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine compute_dTgc_bspline_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_bspline_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_nurbs_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:)","tags":"","loc":"interface/compute_dtgc~3.html"},{"title":"nearest_point_help_3d – ForCAD","text":"interface Called by interface~~nearest_point_help_3d~~CalledByGraph interface~nearest_point_help_3d nearest_point_help_3d proc~nearest_point~3 nurbs_volume%nearest_point proc~nearest_point~3->interface~nearest_point_help_3d proc~nearest_point2~3 nurbs_volume%nearest_point2 proc~nearest_point2~3->proc~nearest_point~3 program~nearest_point_3d nearest_point_3d program~nearest_point_3d->proc~nearest_point~3 program~nearest_point_3d->proc~nearest_point2~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure function nearest_point_help_3d(f_ng, f_Xg, f_point_Xg) result(f_distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Xg (:,:) real(kind=rk), intent(in), contiguous :: f_point_Xg (:) Return Value real(kind=rk),allocatable,(:)","tags":"","loc":"interface/nearest_point_help_3d.html"},{"title":"forcad_utils – ForCAD","text":"This module contains parameters, functions and subroutines that are used in the library. Used by module~~forcad_utils~~UsedByGraph module~forcad_utils forcad_utils module~forcad forcad module~forcad->module~forcad_utils module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils proc~compute_d2tgc_bspline_1d_scalar compute_d2Tgc_bspline_1d_scalar proc~compute_d2tgc_bspline_1d_scalar->module~forcad_utils proc~compute_d2tgc_bspline_1d_vector compute_d2Tgc_bspline_1d_vector proc~compute_d2tgc_bspline_1d_vector->module~forcad_utils proc~compute_d2tgc_bspline_2d_scalar compute_d2Tgc_bspline_2d_scalar proc~compute_d2tgc_bspline_2d_scalar->module~forcad_utils proc~compute_d2tgc_bspline_2d_vector compute_d2Tgc_bspline_2d_vector proc~compute_d2tgc_bspline_2d_vector->module~forcad_utils proc~compute_d2tgc_bspline_3d_scalar compute_d2Tgc_bspline_3d_scalar proc~compute_d2tgc_bspline_3d_scalar->module~forcad_utils proc~compute_d2tgc_bspline_3d_vector compute_d2Tgc_bspline_3d_vector proc~compute_d2tgc_bspline_3d_vector->module~forcad_utils proc~compute_d2tgc_nurbs_1d_scalar compute_d2Tgc_nurbs_1d_scalar proc~compute_d2tgc_nurbs_1d_scalar->module~forcad_utils proc~compute_d2tgc_nurbs_1d_vector compute_d2Tgc_nurbs_1d_vector proc~compute_d2tgc_nurbs_1d_vector->module~forcad_utils proc~compute_d2tgc_nurbs_2d_scalar compute_d2Tgc_nurbs_2d_scalar proc~compute_d2tgc_nurbs_2d_scalar->module~forcad_utils proc~compute_d2tgc_nurbs_2d_vector compute_d2Tgc_nurbs_2d_vector proc~compute_d2tgc_nurbs_2d_vector->module~forcad_utils proc~compute_d2tgc_nurbs_3d_scalar compute_d2Tgc_nurbs_3d_scalar proc~compute_d2tgc_nurbs_3d_scalar->module~forcad_utils proc~compute_d2tgc_nurbs_3d_vector compute_d2Tgc_nurbs_3d_vector proc~compute_d2tgc_nurbs_3d_vector->module~forcad_utils proc~compute_dtgc_bspline_1d_scalar compute_dTgc_bspline_1d_scalar proc~compute_dtgc_bspline_1d_scalar->module~forcad_utils proc~compute_dtgc_bspline_1d_vector compute_dTgc_bspline_1d_vector proc~compute_dtgc_bspline_1d_vector->module~forcad_utils proc~compute_dtgc_bspline_2d_scalar compute_dTgc_bspline_2d_scalar proc~compute_dtgc_bspline_2d_scalar->module~forcad_utils proc~compute_dtgc_bspline_2d_vector compute_dTgc_bspline_2d_vector proc~compute_dtgc_bspline_2d_vector->module~forcad_utils proc~compute_dtgc_bspline_3d_scalar compute_dTgc_bspline_3d_scalar proc~compute_dtgc_bspline_3d_scalar->module~forcad_utils proc~compute_dtgc_bspline_3d_vector compute_dTgc_bspline_3d_vector proc~compute_dtgc_bspline_3d_vector->module~forcad_utils proc~compute_dtgc_nurbs_1d_scalar compute_dTgc_nurbs_1d_scalar proc~compute_dtgc_nurbs_1d_scalar->module~forcad_utils proc~compute_dtgc_nurbs_1d_vector compute_dTgc_nurbs_1d_vector proc~compute_dtgc_nurbs_1d_vector->module~forcad_utils proc~compute_dtgc_nurbs_2d_scalar compute_dTgc_nurbs_2d_scalar proc~compute_dtgc_nurbs_2d_scalar->module~forcad_utils proc~compute_dtgc_nurbs_2d_vector compute_dTgc_nurbs_2d_vector proc~compute_dtgc_nurbs_2d_vector->module~forcad_utils proc~compute_dtgc_nurbs_3d_scalar compute_dTgc_nurbs_3d_scalar proc~compute_dtgc_nurbs_3d_scalar->module~forcad_utils proc~compute_dtgc_nurbs_3d_vector compute_dTgc_nurbs_3d_vector proc~compute_dtgc_nurbs_3d_vector->module~forcad_utils proc~compute_tgc_bspline_1d_scalar compute_Tgc_bspline_1d_scalar proc~compute_tgc_bspline_1d_scalar->module~forcad_utils proc~compute_tgc_bspline_1d_vector compute_Tgc_bspline_1d_vector proc~compute_tgc_bspline_1d_vector->module~forcad_utils proc~compute_tgc_bspline_2d_scalar compute_Tgc_bspline_2d_scalar proc~compute_tgc_bspline_2d_scalar->module~forcad_utils proc~compute_tgc_bspline_2d_vector compute_Tgc_bspline_2d_vector proc~compute_tgc_bspline_2d_vector->module~forcad_utils proc~compute_tgc_bspline_3d_scalar compute_Tgc_bspline_3d_scalar proc~compute_tgc_bspline_3d_scalar->module~forcad_utils proc~compute_tgc_bspline_3d_vector compute_Tgc_bspline_3d_vector proc~compute_tgc_bspline_3d_vector->module~forcad_utils proc~compute_tgc_nurbs_1d_scalar compute_Tgc_nurbs_1d_scalar proc~compute_tgc_nurbs_1d_scalar->module~forcad_utils proc~compute_tgc_nurbs_1d_vector compute_Tgc_nurbs_1d_vector proc~compute_tgc_nurbs_1d_vector->module~forcad_utils proc~compute_tgc_nurbs_2d_scalar compute_Tgc_nurbs_2d_scalar proc~compute_tgc_nurbs_2d_scalar->module~forcad_utils proc~compute_tgc_nurbs_2d_vector compute_Tgc_nurbs_2d_vector proc~compute_tgc_nurbs_2d_vector->module~forcad_utils proc~compute_tgc_nurbs_3d_scalar compute_Tgc_nurbs_3d_scalar proc~compute_tgc_nurbs_3d_scalar->module~forcad_utils proc~compute_tgc_nurbs_3d_vector compute_Tgc_nurbs_3d_vector proc~compute_tgc_nurbs_3d_vector->module~forcad_utils proc~compute_xg_bspline_1d compute_Xg_bspline_1d proc~compute_xg_bspline_1d->module~forcad_utils proc~compute_xg_bspline_1d_1point compute_Xg_bspline_1d_1point proc~compute_xg_bspline_1d_1point->module~forcad_utils proc~compute_xg_bspline_2d compute_Xg_bspline_2d proc~compute_xg_bspline_2d->module~forcad_utils proc~compute_xg_bspline_2d_1point compute_Xg_bspline_2d_1point proc~compute_xg_bspline_2d_1point->module~forcad_utils proc~compute_xg_bspline_3d compute_Xg_bspline_3d proc~compute_xg_bspline_3d->module~forcad_utils proc~compute_xg_bspline_3d_1point compute_Xg_bspline_3d_1point proc~compute_xg_bspline_3d_1point->module~forcad_utils proc~compute_xg_nurbs_1d compute_Xg_nurbs_1d proc~compute_xg_nurbs_1d->module~forcad_utils proc~compute_xg_nurbs_1d_1point compute_Xg_nurbs_1d_1point proc~compute_xg_nurbs_1d_1point->module~forcad_utils proc~compute_xg_nurbs_2d compute_Xg_nurbs_2d proc~compute_xg_nurbs_2d->module~forcad_utils proc~compute_xg_nurbs_2d_1point compute_Xg_nurbs_2d_1point proc~compute_xg_nurbs_2d_1point->module~forcad_utils proc~compute_xg_nurbs_3d compute_Xg_nurbs_3d proc~compute_xg_nurbs_3d->module~forcad_utils proc~compute_xg_nurbs_3d_1point compute_Xg_nurbs_3d_1point proc~compute_xg_nurbs_3d_1point->module~forcad_utils proc~nearest_point_help_1d nearest_point_help_1d proc~nearest_point_help_1d->module~forcad_utils proc~nearest_point_help_2d nearest_point_help_2d proc~nearest_point_help_2d->module~forcad_utils proc~nearest_point_help_3d nearest_point_help_3d proc~nearest_point_help_3d->module~forcad_utils program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad_utils program~example_put_to_nurbs->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = kind(1.0d0) Interfaces public        interface compute_multiplicity private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer public        interface elemConn_C0 private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) public        interface elemConn_Cn private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) public        interface ndgrid private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) public        interface unique private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Functions public pure function basis_bernstein (Xt, nc) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline (Xt, knot, nc, degree) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:) public pure function compute_knot_vector (Xth_dir, degree, continuity) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) public pure function findspan (n, degree, Xth, knot) result(s) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer public pure function hexahedron_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) public pure function kron (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) public pure function rotation (alpha, beta, theta) result(R) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) public pure function tetragon_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:) private pure function bincoeff (n, k) result(b) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer private pure function factln (n) result(f) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) private pure elemental function isinf (x) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical private pure elemental function isnan (x) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical private pure function repelem (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Subroutines public pure subroutine basis_bspline_2der (Xt, knot, nc, degree, d2B, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: d2B (:) real(kind=rk), intent(out), optional, allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:) public pure subroutine basis_bspline_der (Xt, knot, nc, degree, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:) public pure subroutine elevate_degree_A_5_9 (t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) public pure subroutine insert_knot_A_5_1 (p, UP, Pw, u, k, s, r, nq, UQ, Qw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) public pure subroutine remove_knots_A_5_8 (p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","loc":"module/forcad_utils.html"},{"title":"forcad – ForCAD","text":"Uses forcad_nurbs_curve forcad_nurbs_surface forcad_utils forcad_nurbs_volume module~~forcad~~UsesGraph module~forcad forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad~~UsedByGraph module~forcad forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forcad.html"},{"title":"forcad_nurbs_surface – ForCAD","text":"This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. Uses forcad_utils module~~forcad_nurbs_surface~~UsesGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad_utils forcad_utils module~forcad_nurbs_surface->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_surface~~UsedByGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad forcad module~forcad->module~forcad_nurbs_surface program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces private        interface compute_Tgc private pure function compute_Tgc_bspline_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private        interface compute_Xg private pure function compute_Xg_bspline_2d(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_2d_1point(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_2d(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_2d_1point(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_bspline_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, nc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_bspline_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, nc, f_ng, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_nurbs_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private        interface compute_dTgc private pure subroutine compute_dTgc_bspline_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, nc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_bspline_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, nc, f_ng, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_dTgc_nurbs_2d_scalar(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_nurbs_2d_vector(f_Xt, f_knot1, f_knot2, f_degree, f_nc, f_ng, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) integer, intent(in) :: f_degree (2) integer, intent(in) :: f_nc (2) integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) interface private pure function nearest_point_help_2d(f_ng, f_Xg, f_point_Xg) result(f_distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_ng (2) real(kind=rk), intent(in), contiguous :: f_Xg (:,:) real(kind=rk), intent(in), contiguous :: f_point_Xg (:) Return Value real(kind=rk), allocatable, (:) Derived Types type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS surface Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_degree Compute degree of the NURBS surface Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS surface Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS surface Read more… procedure, public :: elevate_degree Elevate degree Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS surface object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the NURBS surface Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knot vector Read more… procedure, public :: get_nc Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS surface is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS surface (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS surface (Minimization - Newton's method) Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 Set NURBS surface Read more… procedure, public :: set1 Set knot vectors, control points and weights for the NURBS surface object Read more… procedure, public :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier surface using control points and weights Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_ring Set a half ring Read more… procedure, public :: set_ring Set a ring Read more… procedure, public :: set_tetragon Set a tetragon Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS surface Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS surface Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS surface Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS surface Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS surface Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS surface Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_degree_all Get degree of the NURBS surface in both directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… Functions private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical Subroutines private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res1, res2, Xt1, Xt2, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative_vector (this, res1, res2, Xt1, Xt2, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (2) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_ring (this, center, radius1, radius2) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","loc":"module/forcad_nurbs_surface.html"},{"title":"forcad_nurbs_curve – ForCAD","text":"This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. Uses forcad_utils module~~forcad_nurbs_curve~~UsesGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_curve~~UsedByGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad forcad module~forcad->module~forcad_nurbs_curve program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces private        interface compute_Tgc private pure function compute_Tgc_bspline_1d_scalar(f_Xt, f_knot, f_degree, f_nc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private        interface compute_Xg private pure function compute_Xg_bspline_1d(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_1d_1point(f_Xt, f_knot, f_degree, f_nc, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_1d(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_1d_1point(f_Xt, f_knot, f_degree, f_nc, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_bspline_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(out), allocatable :: f_d2Tgc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_bspline_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_nurbs_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private        interface compute_dTgc private pure subroutine compute_dTgc_bspline_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_bspline_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_dTgc_nurbs_1d_scalar(f_Xt, f_knot, f_degree, f_nc, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f_Xt real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_nurbs_1d_vector(f_Xt, f_knot, f_degree, f_nc, f_ng, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot (:) integer, intent(in) :: f_degree integer, intent(in) :: f_nc integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) interface private pure function nearest_point_help_1d(f_ng, f_Xg, f_point_Xg) result(f_distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_ng real(kind=rk), intent(in), contiguous :: f_Xg (:,:) real(kind=rk), intent(in), contiguous :: f_point_Xg (:) Return Value real(kind=rk), allocatable, (:) Derived Types type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS curve Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_degree Compute degree of the NURBS curve Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS curve Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS curve Read more… procedure, public :: elevate_degree Elevate the degree of the curve Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS curve object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the curve Read more… procedure, public :: get_degree Get degree of the NURBS curve Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knots Read more… procedure, public :: get_nc Get number of control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS curve is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS curve (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS curve (Minimization - Newton's method) Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 Set NURBS curve Read more… procedure, public :: set1 Set knot vector, control points and weights for the NURBS curve object Read more… procedure, public :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier curve using control points and weights Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_circle Set a circle Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_circle Set a half circle Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS curve Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS curve Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS curve Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS curve Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS curve Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS curve Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… Functions private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: Xt Return Value real(kind=rk), allocatable, (:) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical Subroutines private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_degree (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine cmp_nc (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: d2Tgc (:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: Xt real(kind=rk), intent(out), allocatable :: dTgc (:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative_vector (this, res, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine insert_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional :: nearest_Xt integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","loc":"module/forcad_nurbs_curve.html"},{"title":"forcad_nurbs_volume – ForCAD","text":"This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. Uses forcad_utils module~~forcad_nurbs_volume~~UsesGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_volume~~UsedByGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad forcad module~forcad->module~forcad_nurbs_volume program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces private        interface compute_Tgc private pure function compute_Tgc_bspline_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_bspline_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Tgc_nurbs_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Tgc_nurbs_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Wc) result(f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private        interface compute_Xg private pure function compute_Xg_bspline_3d(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_bspline_3d_1point(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Xc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) Return Value real(kind=rk), allocatable, (:) private pure function compute_Xg_nurbs_3d(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:,:) private pure function compute_Xg_nurbs_3d_1point(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Xc, f_Wc) result(f_Xg) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Xc (:,:) real(kind=rk), intent(in), contiguous :: f_Wc (:) Return Value real(kind=rk), allocatable, (:) private        interface compute_d2Tgc private pure subroutine compute_d2Tgc_bspline_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_bspline_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_d2Tgc_nurbs_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_d2Tgc_nurbs_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Wc, f_d2Tgc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_d2Tgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private        interface compute_dTgc private pure subroutine compute_dTgc_bspline_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_bspline_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) private pure subroutine compute_dTgc_nurbs_3d_scalar(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:) private pure subroutine compute_dTgc_nurbs_3d_vector(f_Xt, f_knot1, f_knot2, f_knot3, f_degree, f_nc, f_ng, f_Wc, f_dTgc, f_Tgc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: f_Xt (:,:) real(kind=rk), intent(in), contiguous :: f_knot1 (:) real(kind=rk), intent(in), contiguous :: f_knot2 (:) real(kind=rk), intent(in), contiguous :: f_knot3 (:) integer, intent(in) :: f_degree (3) integer, intent(in) :: f_nc (3) integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Wc (:) real(kind=rk), intent(out), allocatable :: f_dTgc (:,:,:) real(kind=rk), intent(out), allocatable :: f_Tgc (:,:) interface private pure function nearest_point_help_3d(f_ng, f_Xg, f_point_Xg) result(f_distances) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_ng (3) real(kind=rk), intent(in), contiguous :: f_Xg (:,:) real(kind=rk), intent(in), contiguous :: f_point_Xg (:) Return Value real(kind=rk), allocatable, (:) Derived Types type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt (:,:) Evaluation parameter values (2D array: [ng(1) ng(2) ng(3), dim] real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures generic, public :: basis => basis_vector , basis_scalar Compute the basis functions of the NURBS volume Read more… procedure, public :: cmp_Xg Compute geometry points Read more… procedure, public :: cmp_degree Compute degree of the NURBS volume Read more… procedure, public :: cmp_degreeFace Compute degrees of the faces Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elemFace Compute faces of the IGA elements Read more… procedure, public :: cmp_elemFace_Xc_vis Compute faces of the control points Read more… procedure, public :: cmp_elemFace_Xg_vis Compute faces of the geometry points Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: cmp_nc Compute number of required control points Read more… procedure, public :: create Generate geometry points Read more… generic, public :: derivative => derivative_vector , derivative_scalar Compute the derivative of the NURBS volume Read more… generic, public :: derivative2 => derivative2_vector , derivative2_scalar Compute the second derivative of the NURBS volume Read more… procedure, public :: elevate_degree Elevate the degree of the NURBS volume Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS volume object Read more… generic, public :: get_Wc => get_Wc_all , get_Wci Get weights Read more… generic, public :: get_Xc => get_Xc_all , get_Xci , get_Xcid Get control points Read more… generic, public :: get_Xg => get_Xg_all , get_Xgi , get_Xgid Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Compute and return the continuity of the NURBS volume Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Compute and return the multiplicity of the knots Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS volume is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: nearest_point Find the nearest point on the NURBS volume (Approximation) Read more… procedure, public :: nearest_point2 Find the nearest point on the NURBS volume (Minimization - Newton's method) Read more… procedure, public :: put_to_nurbs Put a shape to a NURBS volume Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 Set NURBS volume Read more… procedure, public :: set1 Set knot vectors, control points and weights for the NURBS volume object Read more… procedure, public :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier volume using control points and weights Read more… procedure, public :: set_C Set a C-shape Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_half_ring Set a half ring Read more… procedure, public :: set_hexahedron Set a hexahedron Read more… procedure, public :: set_ring Set a ring Read more… procedure, public :: show Show the NURBS object using PyVista Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: basis_scalar Compute the basis functions of the NURBS volume Read more… procedure, private :: basis_vector Compute the basis functions of the NURBS volume Read more… procedure, private :: derivative2_scalar Compute the second derivative of the NURBS volume Read more… procedure, private :: derivative2_vector Compute the second derivative of the NURBS volume Read more… procedure, private :: derivative_scalar Compute the derivative of the NURBS volume Read more… procedure, private :: derivative_vector Compute the derivative of the NURBS volume Read more… procedure, private :: get_Wc_all Get all weights Read more… procedure, private :: get_Wci Get i-th weight Read more… procedure, private :: get_Xc_all Get all control points Read more… procedure, private :: get_Xci Get i-th control point Read more… procedure, private :: get_Xcid Get i-th control point in a specific direction Read more… procedure, private :: get_Xg_all Get all geometry points Read more… procedure, private :: get_Xgi Get i-th geometry point Read more… procedure, private :: get_Xgid Get i-th geometry point in a specific direction Read more… procedure, private :: get_degree_all Get degree of the NURBS volume in all directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… Functions private pure function cmp_Xg (this, Xt) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in), contiguous :: Xt (:) Return Value real(kind=rk), allocatable, (:) private pure function cmp_degreeFace (this, face) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: face Return Value integer, (3) private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elemFace (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elemFace_Xc_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elemFace_Xg_vis (this, elem, face) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause number of nodes in each direction Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: elem integer, intent(in) :: face Return Value integer, allocatable, (:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function get_Wc_all (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Wci (this, n) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk) private pure function get_Xc_all (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xci (this, n) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xcid (this, n, dir) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xg_all (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xgi (this, n) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n Return Value real(kind=rk), allocatable, (:) private pure function get_Xgid (this, n, dir) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: n integer, intent(in) :: dir Return Value real(kind=rk) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical Subroutines private pure subroutine basis_scalar (this, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:) private pure subroutine basis_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine cmp_degree (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine cmp_nc (this, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: dir private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative2_scalar (this, Xt, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative2_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, d2Tgc, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: d2Tgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine derivative_scalar (this, Xt, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:) private pure subroutine derivative_vector (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:,:) real(kind=rk), intent(out), optional, allocatable :: Tgc (:,:) private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine nearest_point (this, point_Xg, nearest_Xg, nearest_Xt, id) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) real(kind=rk), intent(out), optional, allocatable :: nearest_Xt (:) integer, intent(out), optional :: id private impure subroutine nearest_point2 (this, point_Xg, tol, maxit, nearest_Xt, nearest_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: point_Xg (:) real(kind=rk), intent(in) :: tol integer, intent(in) :: maxit real(kind=rk), intent(out) :: nearest_Xt (3) real(kind=rk), intent(out), optional, allocatable :: nearest_Xg (:) private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_C (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_half_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_ring (this, center, radius1, radius2, length) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius1 real(kind=rk), intent(in) :: radius2 real(kind=rk), intent(in) :: length private impure subroutine show (this, vtkfile_Xc, vtkfile_Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this character(len=*), intent(in) :: vtkfile_Xc character(len=*), intent(in) :: vtkfile_Xg private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","loc":"module/forcad_nurbs_volume.html"},{"title":"nearest_point_1d – ForCAD","text":"Uses forcad program~~nearest_point_1d~~UsesGraph program~nearest_point_1d nearest_point_1d module~forcad forcad program~nearest_point_1d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Find the nearest point on the curve to a given point\nFind the nearest point on the curve to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS curve object Calls program~~nearest_point_1d~~CallsGraph program~nearest_point_1d nearest_point_1d none~set~2 nurbs_curve%set program~nearest_point_1d->none~set~2 proc~create~2 nurbs_curve%create program~nearest_point_1d->proc~create~2 proc~finalize~2 nurbs_curve%finalize program~nearest_point_1d->proc~finalize~2 proc~nearest_point2~2 nurbs_curve%nearest_point2 program~nearest_point_1d->proc~nearest_point2~2 proc~nearest_point~2 nurbs_curve%nearest_point program~nearest_point_1d->proc~nearest_point~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~nearest_point2~2->proc~create~2 proc~nearest_point2~2->proc~finalize~2 proc~nearest_point2~2->proc~nearest_point~2 none~derivative2~2 nurbs_curve%derivative2 proc~nearest_point2~2->none~derivative2~2 proc~cmp_xg~2 nurbs_curve%cmp_Xg proc~nearest_point2~2->proc~cmp_xg~2 interface~nearest_point_help_1d nearest_point_help_1d proc~nearest_point~2->interface~nearest_point_help_1d proc~derivative2_scalar~2 nurbs_curve%derivative2_scalar none~derivative2~2->proc~derivative2_scalar~2 proc~derivative2_vector~2 nurbs_curve%derivative2_vector none~derivative2~2->proc~derivative2_vector~2 proc~cmp_xg~2->interface~compute_xg~2 proc~cmp_xg~2->proc~is_rational~2 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~derivative2_scalar~2->proc~is_rational~2 interface~compute_d2tgc~2 compute_d2Tgc proc~derivative2_scalar~2->interface~compute_d2tgc~2 proc~derivative2_vector~2->proc~is_rational~2 proc~derivative2_vector~2->interface~compute_d2tgc~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights integer :: id Variable for the id of the nearest point real(kind=rk) :: knot (6) Array for knot vector real(kind=rk), allocatable :: nearest_Xg (:) Array for the nearest point on the curve real(kind=rk) :: nearest_Xt Array for the parametric coordinates of the nearest point type( nurbs_curve ) :: shape Declare a NURBS curve object","tags":"","loc":"program/nearest_point_1d.html"},{"title":"example_ppm2 – ForCAD","text":"Uses forcad fortime forcolormap forimage program~~example_ppm2~~UsesGraph program~example_ppm2 example_ppm2 forcolormap forcolormap program~example_ppm2->forcolormap forimage forimage program~example_ppm2->forimage fortime fortime program~example_ppm2->fortime module~forcad forcad program~example_ppm2->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm2~~CallsGraph program~example_ppm2 example_ppm2 compute_rgb compute_rgb program~example_ppm2->compute_rgb export_pnm export_pnm program~example_ppm2->export_pnm get_b get_b program~example_ppm2->get_b get_g get_g program~example_ppm2->get_g get_r get_r program~example_ppm2->get_r none~get_xg nurbs_surface%get_Xg program~example_ppm2->none~get_xg proc~create nurbs_surface%create program~example_ppm2->proc~create proc~finalize nurbs_surface%finalize program~example_ppm2->proc~finalize proc~get_ng nurbs_surface%get_ng program~example_ppm2->proc~get_ng proc~rotate_xc nurbs_surface%rotate_Xc program~example_ppm2->proc~rotate_xc proc~set_half_ring nurbs_surface%set_half_ring program~example_ppm2->proc~set_half_ring proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm2->proc~set_tetragon proc~translate_xc nurbs_surface%translate_Xc program~example_ppm2->proc~translate_xc set set program~example_ppm2->set set_pnm set_pnm program~example_ppm2->set_pnm timer_start timer_start program~example_ppm2->timer_start timer_stop timer_stop program~example_ppm2->timer_stop proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~rotation rotation proc~rotate_xc->proc~rotation none~set nurbs_surface%set proc~set_half_ring->none~set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","loc":"program/example_ppm2.html"},{"title":"example1_curve – ForCAD","text":"Uses forcad program~~example1_curve~~UsesGraph program~example1_curve example1_curve module~forcad forcad program~example1_curve->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Deallocate local arrays Export control points to a VTK file Generate the NURBS curve with a resolution of 20 Export the generated curve to a VTK file Show the control geometry and geometry using PyVista Print size of the knot vector Insert knots 0.25, twice and 0.75, once Print size of the updated knot vector Print the degree of the curve Elevate the degree of the curve (2 times) Print the updated degree of the curve Print size of the knot vector Remove knots 0.25, twice and 0.75, once Print size of the updated knot vector Generate the refined curve with a resolution of 20 Export updated control points to a VTK file Export the refined generated curve to a VTK file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example1_curve~~CallsGraph program~example1_curve example1_curve none~get_knot~2 nurbs_curve%get_knot program~example1_curve->none~get_knot~2 none~set~2 nurbs_curve%set program~example1_curve->none~set~2 proc~create~2 nurbs_curve%create program~example1_curve->proc~create~2 proc~elevate_degree~2 nurbs_curve%elevate_degree program~example1_curve->proc~elevate_degree~2 proc~export_xc~2 nurbs_curve%export_Xc program~example1_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~example1_curve->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~example1_curve->proc~finalize~2 proc~get_degree nurbs_curve%get_degree program~example1_curve->proc~get_degree proc~insert_knots~2 nurbs_curve%insert_knots program~example1_curve->proc~insert_knots~2 proc~remove_knots~2 nurbs_curve%remove_knots program~example1_curve->proc~remove_knots~2 proc~rotate_xc~2 nurbs_curve%rotate_Xc program~example1_curve->proc~rotate_xc~2 proc~rotate_xg~2 nurbs_curve%rotate_Xg program~example1_curve->proc~rotate_xg~2 proc~show~2 nurbs_curve%show program~example1_curve->proc~show~2 proc~translate_xc~2 nurbs_curve%translate_Xc program~example1_curve->proc~translate_xc~2 proc~translate_xg~2 nurbs_curve%translate_Xg program~example1_curve->proc~translate_xg~2 proc~get_knot_all~2 nurbs_curve%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_curve%get_knoti none~get_knot~2->proc~get_knoti~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~insert_knots~2->none~set~2 interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~2->proc~is_rational~2 proc~remove_knots~2->none~set~2 proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->proc~findspan proc~remove_knots~2->proc~is_rational~2 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~2->proc~rotation proc~rotate_xg~2->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot (6) Array for knot vector type( nurbs_curve ) :: nurbs Declare a NURBS curve object Source Code program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","loc":"program/example1_curve.html"},{"title":"nearest_point_3d – ForCAD","text":"Uses forcad program~~nearest_point_3d~~UsesGraph program~nearest_point_3d nearest_point_3d module~forcad forcad program~nearest_point_3d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. The weights of the control points (Wc) are optional. Generate the NURBS volume with resolutions of 20, 20, 20 Find the nearest point on the volume to a given point\nFind the nearest point on the volume to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS volume object Calls program~~nearest_point_3d~~CallsGraph program~nearest_point_3d nearest_point_3d none~set~3 nurbs_volume%set program~nearest_point_3d->none~set~3 proc~create~3 nurbs_volume%create program~nearest_point_3d->proc~create~3 proc~finalize~3 nurbs_volume%finalize program~nearest_point_3d->proc~finalize~3 proc~nearest_point2~3 nurbs_volume%nearest_point2 program~nearest_point_3d->proc~nearest_point2~3 proc~nearest_point~3 nurbs_volume%nearest_point program~nearest_point_3d->proc~nearest_point~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~nearest_point2~3->proc~create~3 proc~nearest_point2~3->proc~finalize~3 proc~nearest_point2~3->proc~nearest_point~3 none~derivative2~3 nurbs_volume%derivative2 proc~nearest_point2~3->none~derivative2~3 proc~cmp_xg~3 nurbs_volume%cmp_Xg proc~nearest_point2~3->proc~cmp_xg~3 interface~nearest_point_help_3d nearest_point_help_3d proc~nearest_point~3->interface~nearest_point_help_3d proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar~3 nurbs_volume%derivative2_scalar none~derivative2~3->proc~derivative2_scalar~3 proc~derivative2_vector~3 nurbs_volume%derivative2_vector none~derivative2~3->proc~derivative2_vector~3 proc~cmp_xg~3->interface~compute_xg~3 proc~cmp_xg~3->proc~is_rational~3 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~derivative2_scalar~3->proc~is_rational~3 interface~compute_d2tgc~3 compute_d2Tgc proc~derivative2_scalar~3->interface~compute_d2tgc~3 proc~derivative2_vector~3->interface~ndgrid proc~derivative2_vector~3->proc~is_rational~3 proc~derivative2_vector~3->interface~compute_d2tgc~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (8) Weights of the control points real(kind=rk) :: Xc (8,3) Control points integer :: id id of the nearest point real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the volume real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point type( nurbs_volume ) :: shape Declare a NURBS volume object","tags":"","loc":"program/nearest_point_3d.html"},{"title":"shape_ring_3d – ForCAD","text":"Uses forcad program~~shape_ring_3d~~UsesGraph program~shape_ring_3d shape_ring_3d module~forcad forcad program~shape_ring_3d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_3d~~CallsGraph program~shape_ring_3d shape_ring_3d proc~create~3 nurbs_volume%create program~shape_ring_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_ring_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_ring_3d->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_ring_3d->proc~finalize~3 proc~set_ring~2 nurbs_volume%set_ring program~shape_ring_3d->proc~set_ring~2 proc~show~3 nurbs_volume%show program~shape_ring_3d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 none~set~3 nurbs_volume%set proc~set_ring~2->none~set~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","loc":"program/shape_ring_3d.html"},{"title":"shape_circle – ForCAD","text":"Uses forcad program~~shape_circle~~UsesGraph program~shape_circle shape_circle module~forcad forcad program~shape_circle->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS circle with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_circle~~CallsGraph program~shape_circle shape_circle proc~create~2 nurbs_curve%create program~shape_circle->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_circle->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_circle->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_circle->proc~finalize~2 proc~set_circle nurbs_curve%set_circle program~shape_circle->proc~set_circle proc~show~2 nurbs_curve%show program~shape_circle->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 none~set~2 nurbs_curve%set proc~set_circle->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","loc":"program/shape_circle.html"},{"title":"shape_half_ring_2d – ForCAD","text":"Uses forcad program~~shape_half_ring_2d~~UsesGraph program~shape_half_ring_2d shape_half_ring_2d module~forcad forcad program~shape_half_ring_2d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_2d~~CallsGraph program~shape_half_ring_2d shape_half_ring_2d proc~create nurbs_surface%create program~shape_half_ring_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_half_ring_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_half_ring_2d->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_half_ring_2d->proc~finalize proc~set_half_ring nurbs_surface%set_half_ring program~shape_half_ring_2d->proc~set_half_ring proc~show nurbs_surface%show program~shape_half_ring_2d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis none~set nurbs_surface%set proc~set_half_ring->none~set proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","loc":"program/shape_half_ring_2d.html"},{"title":"shape_half_ring_3d – ForCAD","text":"Uses forcad program~~shape_half_ring_3d~~UsesGraph program~shape_half_ring_3d shape_half_ring_3d module~forcad forcad program~shape_half_ring_3d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_3d~~CallsGraph program~shape_half_ring_3d shape_half_ring_3d proc~create~3 nurbs_volume%create program~shape_half_ring_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_half_ring_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_half_ring_3d->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_half_ring_3d->proc~finalize~3 proc~set_half_ring~2 nurbs_volume%set_half_ring program~shape_half_ring_3d->proc~set_half_ring~2 proc~show~3 nurbs_volume%show program~shape_half_ring_3d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 none~set~3 nurbs_volume%set proc~set_half_ring~2->none~set~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","loc":"program/shape_half_ring_3d.html"},{"title":"nearest_point_2d – ForCAD","text":"Uses forcad program~~nearest_point_2d~~UsesGraph program~nearest_point_2d nearest_point_2d module~forcad forcad program~nearest_point_2d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a surface with 4 control points\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFind the nearest point on the surface to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS surface object Calls program~~nearest_point_2d~~CallsGraph program~nearest_point_2d nearest_point_2d none~set nurbs_surface%set program~nearest_point_2d->none~set proc~create nurbs_surface%create program~nearest_point_2d->proc~create proc~finalize nurbs_surface%finalize program~nearest_point_2d->proc~finalize proc~nearest_point nurbs_surface%nearest_point program~nearest_point_2d->proc~nearest_point proc~nearest_point2 nurbs_surface%nearest_point2 program~nearest_point_2d->proc~nearest_point2 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational interface~nearest_point_help_2d nearest_point_help_2d proc~nearest_point->interface~nearest_point_help_2d proc~nearest_point2->proc~create proc~nearest_point2->proc~finalize proc~nearest_point2->proc~nearest_point none~derivative2 nurbs_surface%derivative2 proc~nearest_point2->none~derivative2 proc~cmp_xg nurbs_surface%cmp_Xg proc~nearest_point2->proc~cmp_xg proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~derivative2_scalar nurbs_surface%derivative2_scalar none~derivative2->proc~derivative2_scalar proc~derivative2_vector nurbs_surface%derivative2_vector none~derivative2->proc~derivative2_vector proc~cmp_xg->interface~compute_xg proc~cmp_xg->proc~is_rational proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~derivative2_scalar->proc~is_rational interface~compute_d2tgc compute_d2Tgc proc~derivative2_scalar->interface~compute_d2tgc proc~derivative2_vector->interface~ndgrid proc~derivative2_vector->proc~is_rational proc~derivative2_vector->interface~compute_d2tgc proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (4) Weights of the control points real(kind=rk) :: Xc (4,3) Control points integer :: id id of the nearest point real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the surface real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point type( nurbs_surface ) :: shape Declare a NURBS surface object","tags":"","loc":"program/nearest_point_2d.html"},{"title":"example_put_to_nurbs – ForCAD","text":"Uses forcad forcad_utils program~~example_put_to_nurbs~~UsesGraph program~example_put_to_nurbs example_put_to_nurbs module~forcad forcad program~example_put_to_nurbs->module~forcad module~forcad_utils forcad_utils program~example_put_to_nurbs->module~forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. You can create your shape or use a predefined one\nRead coordinates from file\nRead element connectivities from file\nSet a control shape that will be used to put the shape into\nThe contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points\nBy modifying the control shape you can modify the shape Map the shape into the shape Deallocate local variables Export the shape and the control shape to vtk files\nShow the control geometry and geometry using PyVista Finalize the control shape Calls program~~example_put_to_nurbs~~CallsGraph program~example_put_to_nurbs example_put_to_nurbs none~set~3 nurbs_volume%set program~example_put_to_nurbs->none~set~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_put_to_nurbs->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_put_to_nurbs->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~example_put_to_nurbs->proc~finalize~3 proc~hexahedron_xc hexahedron_Xc program~example_put_to_nurbs->proc~hexahedron_xc proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_put_to_nurbs->proc~put_to_nurbs proc~show~3 nurbs_volume%show program~example_put_to_nurbs->proc~show~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~basis_bspline basis_bspline proc~put_to_nurbs->proc~basis_bspline proc~kron kron proc~put_to_nurbs->proc~kron proc~set_elem_xg_vis~3 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: X (:,:) type( nurbs_volume ) :: control_shape integer, allocatable :: elem (:,:) integer :: i integer :: nunit","tags":"","loc":"program/example_put_to_nurbs.html"},{"title":"example3_surface – ForCAD","text":"Uses forcad program~~example3_surface~~UsesGraph program~example3_surface example3_surface module~forcad forcad program~example3_surface->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. Define control points for the NURBS surface Define weights for the control points\nDefine knot vectors for both dimensions\nSet knot vectors, control points, and weights for the NURBS surface object Deallocate local arrays Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Print size of the knot vectors\nInsert knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after inserting knots\nPrint the degrees Elevate degree by 2 in both directions\nPrint the degrees after elevating Print size of the knot vectors\nRemove knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after removing knots\nGenerate the refined NURBS surface with resolutions of 30 in both dimensions Export updated control points to a VTK file Export the refined generated surface to a VTK file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~example3_surface~~CallsGraph program~example3_surface example3_surface none~get_degree nurbs_surface%get_degree program~example3_surface->none~get_degree none~get_knot nurbs_surface%get_knot program~example3_surface->none~get_knot none~set nurbs_surface%set program~example3_surface->none~set proc~create nurbs_surface%create program~example3_surface->proc~create proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface->proc~elevate_degree proc~export_xc nurbs_surface%export_Xc program~example3_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example3_surface->proc~export_xg proc~finalize nurbs_surface%finalize program~example3_surface->proc~finalize proc~generate_xc generate_Xc program~example3_surface->proc~generate_xc proc~insert_knots nurbs_surface%insert_knots program~example3_surface->proc~insert_knots proc~remove_knots nurbs_surface%remove_knots program~example3_surface->proc~remove_knots proc~rotate_xc nurbs_surface%rotate_Xc program~example3_surface->proc~rotate_xc proc~rotate_xg nurbs_surface%rotate_Xg program~example3_surface->proc~rotate_xg proc~show nurbs_surface%show program~example3_surface->proc~show proc~translate_xc nurbs_surface%translate_Xc program~example3_surface->proc~translate_xc proc~translate_xg nurbs_surface%translate_Xg program~example3_surface->proc~translate_xg proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~elevate_degree->none~get_knot proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~insert_knots->none~get_knot proc~insert_knots->none~set interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots->proc~is_rational proc~remove_knots->none~get_knot proc~remove_knots->none~set proc~remove_knots->interface~compute_multiplicity proc~remove_knots->proc~findspan proc~remove_knots->proc~is_rational proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc->proc~rotation proc~rotate_xg->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (6) Arrays for knot vectors in both dimensions real(kind=rk) :: knot2 (6) Arrays for knot vectors in both dimensions type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","loc":"program/example3_surface.html"},{"title":"example_nurbs_surface – ForCAD","text":"Uses forcad program~~example_nurbs_surface~~UsesGraph program~example_nurbs_surface example_nurbs_surface module~forcad forcad program~example_nurbs_surface->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface.\nIt sets up control points and weights, generates the surface, and exports the control points\nand the surface to VTK files at various stages. Define control points for the NURBS surface Define weights for the control points Set control points and weights for the NURBS surface object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS surface with a resolution of 30x30 Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~example_nurbs_surface~~CallsGraph program~example_nurbs_surface example_nurbs_surface none~set nurbs_surface%set program~example_nurbs_surface->none~set proc~create nurbs_surface%create program~example_nurbs_surface->proc~create proc~export_xc nurbs_surface%export_Xc program~example_nurbs_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example_nurbs_surface->proc~export_xg proc~finalize nurbs_surface%finalize program~example_nurbs_surface->proc~finalize proc~generate_xc~2 generate_Xc program~example_nurbs_surface->proc~generate_xc~2 proc~show nurbs_surface%show program~example_nurbs_surface->proc~show proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"program/example_nurbs_surface.html"},{"title":"example_ppm3 – ForCAD","text":"Uses forcad fortime forcolormap forimage program~~example_ppm3~~UsesGraph program~example_ppm3 example_ppm3 forcolormap forcolormap program~example_ppm3->forcolormap forimage forimage program~example_ppm3->forimage fortime fortime program~example_ppm3->fortime module~forcad forcad program~example_ppm3->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon Calls program~~example_ppm3~~CallsGraph program~example_ppm3 example_ppm3 compute_rgb compute_rgb program~example_ppm3->compute_rgb export_pnm export_pnm program~example_ppm3->export_pnm get_b get_b program~example_ppm3->get_b get_g get_g program~example_ppm3->get_g get_r get_r program~example_ppm3->get_r none~get_xg nurbs_surface%get_Xg program~example_ppm3->none~get_xg proc~create nurbs_surface%create program~example_ppm3->proc~create proc~finalize nurbs_surface%finalize program~example_ppm3->proc~finalize proc~get_ng nurbs_surface%get_ng program~example_ppm3->proc~get_ng proc~modify_xc nurbs_surface%modify_Xc program~example_ppm3->proc~modify_xc proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm3->proc~set_tetragon proc~translate_xc nurbs_surface%translate_Xc program~example_ppm3->proc~translate_xc set set program~example_ppm3->set set_pnm set_pnm program~example_ppm3->set_pnm timer_start timer_start program~example_ppm3->timer_start timer_stop timer_stop program~example_ppm3->timer_stop proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational none~get_knot nurbs_surface%get_knot proc~modify_xc->none~get_knot none~get_wc nurbs_surface%get_Wc proc~modify_xc->none~get_wc none~get_xc nurbs_surface%get_Xc proc~modify_xc->none~get_xc none~set nurbs_surface%set proc~modify_xc->none~set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~get_wc_all nurbs_surface%get_Wc_all none~get_wc->proc~get_wc_all proc~get_wci nurbs_surface%get_Wci none~get_wc->proc~get_wci proc~get_xc_all nurbs_surface%get_Xc_all none~get_xc->proc~get_xc_all proc~get_xci nurbs_surface%get_Xci none~get_xc->proc~get_xci proc~get_xcid nurbs_surface%get_Xcid none~get_xc->proc~get_xcid proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image integer :: ng (2) integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","loc":"program/example_ppm3.html"},{"title":"example3_volume – ForCAD","text":"Uses forcad program~~example3_volume~~UsesGraph program~example3_volume example3_volume module~forcad forcad program~example3_volume->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. Define the control points for the NURBS volume Define weights for the control points (optional)\nDefine knot vectors for all three dimensions\nSet knot vectors, control points, and weights for the NURBS volume object\nWc is optional. Deallocate local arrays Export the control points to a VTK file Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions Export the generated volume to a VTK file Show the control geometry and geometry using PyVista Print size of knot vectors\nInsert knots 0.25 and 0.75 in all three directions\nPrint size of knot vectors after inserting knots\nPrint degrees Elevate degree by 2 in all three directions\nPrint degrees after elevating Print size of knot vectors\nPrint size of knot vectors after removing knots\nGenerate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions Export updated control points to a VTK file Export the refined generated volume to a VTK file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Show the control geometry and geometry using PyVista first compute and set the connectivities of volume elements get the connectivity of the face1 of the first element\nget the degree of the faces\nFinalize the NURBS volume object Calls program~~example3_volume~~CallsGraph program~example3_volume example3_volume none~get_degree~3 nurbs_volume%get_degree program~example3_volume->none~get_degree~3 none~get_knot~3 nurbs_volume%get_knot program~example3_volume->none~get_knot~3 none~set~3 nurbs_volume%set program~example3_volume->none~set~3 proc~cmp_degreeface nurbs_volume%cmp_degreeFace program~example3_volume->proc~cmp_degreeface proc~cmp_elemface nurbs_volume%cmp_elemFace program~example3_volume->proc~cmp_elemface proc~cmp_elem~3 nurbs_volume%cmp_elem program~example3_volume->proc~cmp_elem~3 proc~create~3 nurbs_volume%create program~example3_volume->proc~create~3 proc~elevate_degree~3 nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree~3 proc~export_xc~3 nurbs_volume%export_Xc program~example3_volume->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example3_volume->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~example3_volume->proc~finalize~3 proc~generate_xc~3 generate_Xc program~example3_volume->proc~generate_xc~3 proc~insert_knots~3 nurbs_volume%insert_knots program~example3_volume->proc~insert_knots~3 proc~remove_knots~3 nurbs_volume%remove_knots program~example3_volume->proc~remove_knots~3 proc~rotate_xc~3 nurbs_volume%rotate_Xc program~example3_volume->proc~rotate_xc~3 proc~rotate_xg~3 nurbs_volume%rotate_Xg program~example3_volume->proc~rotate_xg~3 proc~set_elem~3 nurbs_volume%set_elem program~example3_volume->proc~set_elem~3 proc~show~3 nurbs_volume%show program~example3_volume->proc~show~3 proc~translate_xc~3 nurbs_volume%translate_Xc program~example3_volume->proc~translate_xc~3 proc~translate_xg~3 nurbs_volume%translate_Xg program~example3_volume->proc~translate_xg~3 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~3->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~3->proc~get_degree_dir~2 proc~get_knot_all~3 nurbs_volume%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_volume%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~elevate_degree~3->none~get_knot~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~insert_knots~3->none~get_knot~3 proc~insert_knots~3->none~set~3 interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~remove_knots~3->none~get_knot~3 proc~remove_knots~3->none~set~3 proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~3->proc~rotation proc~rotate_xg~3->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_multiplicity~3->interface~compute_multiplicity cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~cmp_degree~3->proc~get_multiplicity~3 proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot2 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot3 (4) Arrays for knot vectors in all three dimensions type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","loc":"program/example3_volume.html"},{"title":"shape_tetragon – ForCAD","text":"Uses forcad program~~shape_tetragon~~UsesGraph program~shape_tetragon shape_tetragon module~forcad forcad program~shape_tetragon->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~shape_tetragon~~CallsGraph program~shape_tetragon shape_tetragon proc~create nurbs_surface%create program~shape_tetragon->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_tetragon->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_tetragon->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_tetragon->proc~finalize proc~set_tetragon nurbs_surface%set_tetragon program~shape_tetragon->proc~set_tetragon proc~show nurbs_surface%show program~shape_tetragon->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape Declare a NURBS surface object","tags":"","loc":"program/shape_tetragon.html"},{"title":"example_ppm1 – ForCAD","text":"Uses forcad fortime forcolormap forimage program~~example_ppm1~~UsesGraph program~example_ppm1 example_ppm1 forcolormap forcolormap program~example_ppm1->forcolormap forimage forimage program~example_ppm1->forimage fortime fortime program~example_ppm1->fortime module~forcad forcad program~example_ppm1->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm1~~CallsGraph program~example_ppm1 example_ppm1 compute_rgb compute_rgb program~example_ppm1->compute_rgb export_pnm export_pnm program~example_ppm1->export_pnm get_b get_b program~example_ppm1->get_b get_g get_g program~example_ppm1->get_g get_r get_r program~example_ppm1->get_r none~get_xg nurbs_surface%get_Xg program~example_ppm1->none~get_xg proc~create nurbs_surface%create program~example_ppm1->proc~create proc~finalize nurbs_surface%finalize program~example_ppm1->proc~finalize proc~get_ng nurbs_surface%get_ng program~example_ppm1->proc~get_ng proc~set_ring nurbs_surface%set_ring program~example_ppm1->proc~set_ring proc~set_tetragon nurbs_surface%set_tetragon program~example_ppm1->proc~set_tetragon set set program~example_ppm1->set set_pnm set_pnm program~example_ppm1->set_pnm timer_start timer_start program~example_ppm1->timer_start timer_stop timer_stop program~example_ppm1->timer_stop proc~get_xg_all nurbs_surface%get_Xg_all none~get_xg->proc~get_xg_all proc~get_xgi nurbs_surface%get_Xgi none~get_xg->proc~get_xgi proc~get_xgid nurbs_surface%get_Xgid none~get_xg->proc~get_xgid interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational none~set nurbs_surface%set proc~set_ring->none~set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type( nurbs_surface ) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","loc":"program/example_ppm1.html"},{"title":"shape_ring_2d – ForCAD","text":"Uses forcad program~~shape_ring_2d~~UsesGraph program~shape_ring_2d shape_ring_2d module~forcad forcad program~shape_ring_2d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape with inner radius 1.0 and outer radius 2.0. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_2d~~CallsGraph program~shape_ring_2d shape_ring_2d proc~create nurbs_surface%create program~shape_ring_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_ring_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_ring_2d->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_ring_2d->proc~finalize proc~set_ring nurbs_surface%set_ring program~shape_ring_2d->proc~set_ring proc~show nurbs_surface%show program~shape_ring_2d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis none~set nurbs_surface%set proc~set_ring->none~set proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","loc":"program/shape_ring_2d.html"},{"title":"shape_C_2d – ForCAD","text":"Uses forcad program~~shape_c_2d~~UsesGraph program~shape_c_2d shape_C_2d module~forcad forcad program~shape_c_2d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_2d~~CallsGraph program~shape_c_2d shape_C_2d proc~create nurbs_surface%create program~shape_c_2d->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_c_2d->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_c_2d->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_c_2d->proc~finalize proc~set_c nurbs_surface%set_C program~shape_c_2d->proc~set_c proc~show nurbs_surface%show program~shape_c_2d->proc~show interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis none~set nurbs_surface%set proc~set_c->none~set proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_surface ) :: shape","tags":"","loc":"program/shape_c_2d.html"},{"title":"example_nurbs_volume – ForCAD","text":"Uses forcad program~~example_nurbs_volume~~UsesGraph program~example_nurbs_volume example_nurbs_volume module~forcad forcad program~example_nurbs_volume->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume.\nIt sets up control points and weights, generates the volume, and exports the control points\nand the volume to VTK files at various stages. Define control points for the NURBS volume Define weights for the control points Set control points and weights for the NURBS volume object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS volume with a resolution of 15X15X15 Export the generated volume to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS volume object Calls program~~example_nurbs_volume~~CallsGraph program~example_nurbs_volume example_nurbs_volume none~set~3 nurbs_volume%set program~example_nurbs_volume->none~set~3 proc~create~3 nurbs_volume%create program~example_nurbs_volume->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~example_nurbs_volume->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~example_nurbs_volume->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~example_nurbs_volume->proc~finalize~3 proc~generate_xc~4 generate_Xc program~example_nurbs_volume->proc~generate_xc~4 proc~show~3 nurbs_volume%show program~example_nurbs_volume->proc~show~3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"program/example_nurbs_volume.html"},{"title":"shape_half_circle – ForCAD","text":"Uses forcad program~~shape_half_circle~~UsesGraph program~shape_half_circle shape_half_circle module~forcad forcad program~shape_half_circle->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half circle shape centered at the 0,0,0 with a radius of 1 Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_circle~~CallsGraph program~shape_half_circle shape_half_circle proc~create~2 nurbs_curve%create program~shape_half_circle->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_half_circle->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_half_circle->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_half_circle->proc~finalize~2 proc~set_half_circle nurbs_curve%set_half_circle program~shape_half_circle->proc~set_half_circle proc~show~2 nurbs_curve%show program~shape_half_circle->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 none~set~2 nurbs_curve%set proc~set_half_circle->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","loc":"program/shape_half_circle.html"},{"title":"shape_hexahedron – ForCAD","text":"Uses forcad program~~shape_hexahedron~~UsesGraph program~shape_hexahedron shape_hexahedron module~forcad forcad program~shape_hexahedron->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8].\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_hexahedron~~CallsGraph program~shape_hexahedron shape_hexahedron proc~create~3 nurbs_volume%create program~shape_hexahedron->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_hexahedron->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_hexahedron->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_hexahedron->proc~finalize~3 proc~set_hexahedron nurbs_volume%set_hexahedron program~shape_hexahedron->proc~set_hexahedron proc~show~3 nurbs_volume%show program~shape_hexahedron->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 none~set~3 nurbs_volume%set proc~set_hexahedron->none~set~3 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","loc":"program/shape_hexahedron.html"},{"title":"shape_C_1d – ForCAD","text":"Uses forcad program~~shape_c_1d~~UsesGraph program~shape_c_1d shape_C_1d module~forcad forcad program~shape_c_1d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_1d~~CallsGraph program~shape_c_1d shape_C_1d proc~create~2 nurbs_curve%create program~shape_c_1d->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~shape_c_1d->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~shape_c_1d->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~shape_c_1d->proc~finalize~2 proc~set_c~2 nurbs_curve%set_C program~shape_c_1d->proc~set_c~2 proc~show~2 nurbs_curve%show program~shape_c_1d->proc~show~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 none~set~2 nurbs_curve%set proc~set_c~2->none~set~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","loc":"program/shape_c_1d.html"},{"title":"nearest_point_2d_bench – ForCAD","text":"Uses forcad fortime program~~nearest_point_2d_bench~~UsesGraph program~nearest_point_2d_bench nearest_point_2d_bench fortime fortime program~nearest_point_2d_bench->fortime module~forcad forcad program~nearest_point_2d_bench->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFinalize the NURBS surface object Calls program~~nearest_point_2d_bench~~CallsGraph program~nearest_point_2d_bench nearest_point_2d_bench proc~create nurbs_surface%create program~nearest_point_2d_bench->proc~create proc~finalize nurbs_surface%finalize program~nearest_point_2d_bench->proc~finalize proc~nearest_point nurbs_surface%nearest_point program~nearest_point_2d_bench->proc~nearest_point proc~set_tetragon nurbs_surface%set_tetragon program~nearest_point_2d_bench->proc~set_tetragon timer_start timer_start program~nearest_point_2d_bench->timer_start timer_stop timer_stop program~nearest_point_2d_bench->timer_stop interface~compute_xg compute_Xg proc~create->interface~compute_xg interface~ndgrid ndgrid proc~create->interface~ndgrid proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational interface~nearest_point_help_2d nearest_point_help_2d proc~nearest_point->interface~nearest_point_help_2d none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 proc~cmp_degree nurbs_surface%cmp_degree proc~set1->proc~cmp_degree proc~cmp_nc nurbs_surface%cmp_nc proc~set1->proc~cmp_nc proc~set2->proc~cmp_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set3->proc~cmp_degree proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_degree->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~cmp_nc->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: i integer :: id id of the nearest point integer :: j real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the surface real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point real(kind=rk), allocatable :: points (:,:) type( nurbs_surface ) :: shape Declare a NURBS surface object type(timer) :: t","tags":"","loc":"program/nearest_point_2d_bench.html"},{"title":"example_nurbs_curve – ForCAD","text":"Uses forcad program~~example_nurbs_curve~~UsesGraph program~example_nurbs_curve example_nurbs_curve module~forcad forcad program~example_nurbs_curve->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve.\nIt sets up control points and weights, generates the curve, and exports the control points\nand the curve to VTK files at various stages. Define control points for the NURBS curve Define weights for the control points Set control points and weights for the NURBS curve object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS curve with a resolution of 500 Export the generated curve to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example_nurbs_curve~~CallsGraph program~example_nurbs_curve example_nurbs_curve none~set~2 nurbs_curve%set program~example_nurbs_curve->none~set~2 proc~create~2 nurbs_curve%create program~example_nurbs_curve->proc~create~2 proc~export_xc~2 nurbs_curve%export_Xc program~example_nurbs_curve->proc~export_xc~2 proc~export_xg~2 nurbs_curve%export_Xg program~example_nurbs_curve->proc~export_xg~2 proc~finalize~2 nurbs_curve%finalize program~example_nurbs_curve->proc~finalize~2 proc~generate_xc~5 generate_Xc program~example_nurbs_curve->proc~generate_xc~5 proc~show~2 nurbs_curve%show program~example_nurbs_curve->proc~show~2 proc~set1~2 nurbs_curve%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_curve%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_curve%set3 none~set~2->proc~set3~2 interface~compute_xg~2 compute_Xg proc~create~2->interface~compute_xg~2 proc~is_rational~2 nurbs_curve%is_rational proc~create~2->proc~is_rational~2 proc~cmp_elem_xc_vis~2 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_degree~2 nurbs_curve%cmp_degree proc~set1~2->proc~cmp_degree~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set3~2->proc~cmp_degree~2 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_multiplicity~2 nurbs_curve%get_multiplicity proc~cmp_degree~2->proc~get_multiplicity~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_curve ) :: nurbs Declare a NURBS curve object Functions function generate_Xc (num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","loc":"program/example_nurbs_curve.html"},{"title":"shape_C_3d – ForCAD","text":"Uses forcad program~~shape_c_3d~~UsesGraph program~shape_c_3d shape_C_3d module~forcad forcad program~shape_c_3d->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_3d~~CallsGraph program~shape_c_3d shape_C_3d proc~create~3 nurbs_volume%create program~shape_c_3d->proc~create~3 proc~export_xc~3 nurbs_volume%export_Xc program~shape_c_3d->proc~export_xc~3 proc~export_xg~3 nurbs_volume%export_Xg program~shape_c_3d->proc~export_xg~3 proc~finalize~3 nurbs_volume%finalize program~shape_c_3d->proc~finalize~3 proc~set_c~3 nurbs_volume%set_C program~shape_c_3d->proc~set_c~3 proc~show~3 nurbs_volume%show program~shape_c_3d->proc~show~3 interface~compute_xg~3 compute_Xg proc~create~3->interface~compute_xg~3 interface~ndgrid ndgrid proc~create~3->interface~ndgrid proc~is_rational~3 nurbs_volume%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 none~set~3 nurbs_volume%set proc~set_c~3->none~set~3 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~3 nurbs_volume%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_volume%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_volume%set3 none~set~3->proc~set3~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_degree~3 nurbs_volume%cmp_degree proc~set1~3->proc~cmp_degree~3 proc~cmp_nc~3 nurbs_volume%cmp_nc proc~set1~3->proc~cmp_nc~3 proc~set2~3->proc~cmp_nc~3 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~cmp_degree~3 proc~get_multiplicity~3 nurbs_volume%get_multiplicity proc~cmp_degree~3->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~cmp_nc~3->interface~compute_multiplicity proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","loc":"program/shape_c_3d.html"},{"title":"nearest_point_1d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_1d.f90~~EfferentGraph sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector real ( rk ), allocatable :: nearest_Xg (:) !! Array for the nearest point on the curve real ( rk ) :: nearest_Xt !! Array for the parametric coordinates of the nearest point integer :: id !! Variable for the id of the nearest point !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 1.1_rk , 1.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call shape % set ( knot , Xc , Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call shape % create ( 20 ) !----------------------------------------------------------------------------- ! Nearest point on the curve !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 4.5_rk , 4.5_rk , 5.0_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the curve (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) call shape % nearest_point2 ([ 4.5_rk , 4.5_rk , 5.0_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () deallocate ( nearest_Xg , Xc , Wc ) end program","tags":"","loc":"sourcefile/nearest_point_1d.f90.html"},{"title":"example_ppm2.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm2.f90~~EfferentGraph sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm2 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.0_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , 0.0_rk , 2.2_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.08_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.01_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 9 0.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.22_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 0.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm2' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","loc":"sourcefile/example_ppm2.f90.html"},{"title":"forcad_utils.f90 – ForCAD","text":"Files dependent on this one sourcefile~~forcad_utils.f90~~AfferentGraph sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module contains parameters, functions and subroutines that are used in the library. module forcad_utils implicit none private public :: rk , basis_bernstein , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , tetragon_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , basis_bspline_2der integer , parameter :: rk = kind ( 1.0d0 ) !=============================================================================== interface elemConn_C0 module procedure cmp_elemConn_C0_L module procedure cmp_elemConn_C0_S module procedure cmp_elemConn_C0_V end interface !=============================================================================== !=============================================================================== interface elemConn_Cn module procedure cmp_elemConn_Cn_L module procedure cmp_elemConn_Cn_S module procedure cmp_elemConn_Cn_V end interface !=============================================================================== !=============================================================================== interface ndgrid module procedure ndgrid2 module procedure ndgrid3 end interface !=============================================================================== !=============================================================================== interface compute_multiplicity module procedure compute_multiplicity1 module procedure compute_multiplicity2 end interface !=============================================================================== !=============================================================================== interface unique module procedure unique_integer module procedure unique_real end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bspline ( Xt , knot , nc , degree ) result ( B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 real ( rk ), allocatable :: Nt (:,:) integer :: i , p real ( rk ), allocatable :: B (:) temp = abs ( Xt - knot ( size ( knot ))) allocate ( Nt ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xt >= Xth_i . and . Xt <= Xth_i1 ) Nt ( i , 0 ) = 1.0_rk if ( Xth_ip /= Xth_i ) Nt ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * Nt ( i , p - 1 ) if ( Xth_ip1 /= Xth_i1 ) Nt ( i , p ) = Nt ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * Nt ( i + 1 , p - 1 ) end do end do B = Nt (:, degree ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_der ( Xt , knot , nc , degree , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: dB (:) real ( rk ), allocatable , intent ( out ), optional :: B (:) real ( rk ), allocatable :: N (:,:), dN_dXt (:,:) real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 integer :: i , p temp = abs ( Xt - knot ( size ( knot ))) allocate ( N ( nc , 0 : degree ), source = 0.0_rk ) allocate ( dN_dXt ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xth_i <= Xt . and . Xt <= Xth_i1 ) then N ( i , 0 ) = 1.0_rk dN_dXt ( i , 0 ) = 0.0_rk end if if ( Xth_ip /= Xth_i ) then N ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * N ( i , p - 1 ) dN_dXt ( i , p ) = ( N ( i , p - 1 ) + ( Xt - Xth_i ) * dN_dXt ( i , p - 1 ) ) / ( Xth_ip - Xth_i ) end if if ( Xth_ip1 /= Xth_i1 ) then N ( i , p ) = N ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * N ( i + 1 , p - 1 ) dN_dXt ( i , p ) = dN_dXt ( i , p ) - ( N ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * dN_dXt ( i + 1 , p - 1 ) ) / ( Xth_ip1 - Xth_i1 ) end if end do end do dB = dN_dXt (:, degree ) if ( present ( B )) B = N (:, degree ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_2der ( Xt , knot , nc , degree , d2B , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: d2B (:) real ( rk ), allocatable , intent ( out ), optional :: dB (:) real ( rk ), allocatable , intent ( out ), optional :: B (:) real ( rk ), allocatable :: N (:,:), dN_dXt (:,:), d2N_dXt2 (:,:) real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 integer :: i , p temp = abs ( Xt - knot ( size ( knot ))) allocate ( N ( nc , 0 : degree ), source = 0.0_rk ) allocate ( dN_dXt ( nc , 0 : degree ), source = 0.0_rk ) allocate ( d2N_dXt2 ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xth_i <= Xt . and . Xt <= Xth_i1 ) then N ( i , 0 ) = 1.0_rk dN_dXt ( i , 0 ) = 0.0_rk d2N_dXt2 ( i , 0 ) = 0.0_rk end if if ( Xth_ip /= Xth_i ) then N ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * N ( i , p - 1 ) ! dN_dXt(i,p) = p*(N(i,p-1)/(Xth_ip - Xth_i)) dN_dXt ( i , p ) = ( N ( i , p - 1 ) + ( Xt - Xth_i ) * dN_dXt ( i , p - 1 ) ) / ( Xth_ip - Xth_i ) d2N_dXt2 ( i , p ) = ( 2 * dN_dXt ( i , p - 1 ) + ( Xt - Xth_i ) * d2N_dXt2 ( i , p - 1 )) / ( Xth_ip - Xth_i ) end if if ( Xth_ip1 /= Xth_i1 ) then N ( i , p ) = N ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * N ( i + 1 , p - 1 ) ! dN_dXt(i,p) = dN_dXt(i,p) - p*( N(i+1,p-1)/(Xth_ip1 - Xth_i1)) dN_dXt ( i , p ) = dN_dXt ( i , p ) - ( N ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * dN_dXt ( i + 1 , p - 1 ) ) / ( Xth_ip1 - Xth_i1 ) d2N_dXt2 ( i , p ) = d2N_dXt2 ( i , p ) - ( 2 * dN_dXt ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * d2N_dXt2 ( i + 1 , p - 1 )) / ( Xth_ip1 - Xth_i1 ) end if end do end do d2B = d2N_dXt2 (:, degree ) if ( present ( dB )) dB = dN_dXt (:, degree ) if ( present ( B )) B = N (:, degree ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bernstein ( Xt , nc ) result ( B ) real ( rk ), intent ( in ) :: Xt integer , intent ( in ) :: nc real ( rk ), allocatable :: B (:) integer :: p , degree degree = nc - 1 allocate ( B ( nc ), source = 0.0_rk ) do concurrent ( p = 0 : degree ) B ( p + 1 ) = gamma ( real ( nc , kind = rk )) / ( gamma ( real ( p + 1 , kind = rk )) * gamma ( real ( nc - p , kind = rk ))) if ( Xt == 0.0_rk . and . p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( 1.0_rk - Xt ) ** ( degree - p ) else if ( Xt == 0.0_rk . and . degree - p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) else B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) * ( 1.0_rk - Xt ) ** ( degree - p ) end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron ( u , v ) result ( w ) real ( rk ), intent ( in ), contiguous :: u (:), v (:) real ( rk ) :: w ( size ( u ) * size ( v )) integer :: i , j , n n = size ( v ) do concurrent ( i = 1 : size ( u ), j = 1 : n ) w (( i - 1 ) * n + j ) = u ( i ) * v ( j ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid2 ( X_dir1 , X_dir2 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , i , j s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) allocate ( Xt ( s1 * s2 , 2 )) do concurrent ( j = 1 : s2 , i = 1 : s1 ) Xt (( j - 1 ) * s1 + i , 1 ) = X_dir1 ( i ) Xt (( j - 1 ) * s1 + i , 2 ) = X_dir2 ( j ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid3 ( X_dir1 , X_dir2 , X_dir3 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:), X_dir3 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , s3 , i , j , k s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) s3 = size ( X_dir3 ) allocate ( Xt ( s1 * s2 * s3 , 3 )) do concurrent ( k = 1 : s3 , j = 1 : s2 , i = 1 : s1 ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 1 ) = X_dir1 ( i ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 2 ) = X_dir2 ( j ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 3 ) = X_dir3 ( k ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function repelem ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) integer , intent ( in ), contiguous :: b (:) real ( rk ) :: c ( sum ( b )) integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_L ( nnode , p ) result ( elemConn ) integer , intent ( in ) :: nnode integer , intent ( in ) :: p integer , allocatable :: elemConn (:,:) integer :: i , l integer , allocatable :: nodes (:) if ( mod ( nnode - 1 , p ) /= 0 ) error stop 'cmp_elemConn_C0_L: nnode-1 must be divisible by p' allocate ( elemConn ( ( nnode - 1 ) / p , p + 1 )) nodes = [( i , i = 1 , nnode )] l = 0 do i = 1 , nnode - p , p l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p ),[( p + 1 )]) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_S ( nnode1 , nnode2 , p1 , p2 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 integer , intent ( in ) :: p1 , p2 integer , allocatable :: elemConn (:,:) integer :: i , j , l integer , allocatable :: nodes (:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode2-1 must be divisible by p2' allocate ( elemConn ( (( nnode1 - 1 ) / p1 ) * (( nnode2 - 1 ) / p2 ), ( p1 + 1 ) * ( p2 + 1 ))) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 )], [ nnode1 , nnode2 ]) l = 0 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 ),[( p1 + 1 ) * ( p2 + 1 )]) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 , nnode3 integer , intent ( in ) :: p1 , p2 , p3 integer , allocatable :: elemConn (:,:) integer :: i , j , k , l integer , allocatable :: nodes (:,:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode2-1 must be divisible by p2' if ( mod ( nnode3 - 1 , p3 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode3-1 must be divisible by p3' allocate ( elemConn ( (( nnode1 - 1 ) / p1 ) * (( nnode2 - 1 ) / p2 ) * (( nnode3 - 1 ) / p3 ) ,( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 ))) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 * nnode3 )], [ nnode1 , nnode2 , nnode3 ]) l = 0 do k = 1 , nnode3 - p3 , p3 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 , k : k + p3 ),[( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 )]) end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_L ( nnode , p , Xth , vecKnot_mul , elemConn ) integer , intent ( in ) :: p , nnode integer , intent ( in ), contiguous :: vecKnot_mul (:) real ( rk ), intent ( in ), contiguous :: Xth (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:) integer :: i , nnel , m , nelem nnel = p + 1 nodes = [( i , i = 1 , nnode )] nelem = size ( Xth ) - 1 allocate ( elemConn ( nelem , nnel )) m = - p do i = 1 , nelem m = m + vecKnot_mul ( i ) elemConn ( i ,:) = nodes ( m : m + p ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_S ( nnode1 , nnode2 , p1 , p2 ,& Xth1 , Xth2 , vecKnot_mul1 , vecKnot_mul2 , elemConn ) integer , intent ( in ) :: p1 , p2 , nnode1 , nnode2 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:), nodes_vec (:) integer :: nnd_total , i , j , l , nnel1 , nnel2 , m , n , nelem1 , nelem2 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnd_total = nnode1 * nnode2 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem = nelem1 * nelem2 allocate ( elemConn ( nelem , nnel1 * nnel2 )) l = 0 n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 ), [ nnel1 * nnel2 ]) end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ,& Xth1 , Xth2 , Xth3 , vecKnot_mul1 , vecKnot_mul2 , vecKnot_mul3 , elemConn ) integer , intent ( in ) :: p1 , p2 , p3 , nnode1 , nnode2 , nnode3 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:), vecKnot_mul3 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:), Xth3 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:,:), nodes_vec (:) integer :: nnd_total , i , j , k , l , nnel1 , nnel2 , nnel3 , m , n , o , nelem1 , nelem2 , nelem3 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnel3 = p3 + 1 nnd_total = nnode1 * nnode2 * nnode3 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 , nnode3 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem3 = size ( Xth3 ) - 1 nelem = nelem1 * nelem2 * nelem3 allocate ( elemConn ( nelem , nnel1 * nnel2 * nnel3 )) l = 0 o = - p3 do k = 1 , nelem3 o = o + vecKnot_mul3 ( k ) n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 , o : o + p3 ), [ nnel1 * nnel2 * nnel3 ]) end do end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity1 ( knot ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) integer , allocatable :: multiplicity (:) integer :: i , count count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) count = count + 1 end do allocate ( multiplicity ( count )) multiplicity ( 1 ) = 1 count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) then count = count + 1 multiplicity ( count ) = 1 else multiplicity ( count ) = multiplicity ( count ) + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity2 ( knot , Xth ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ) :: Xth integer :: multiplicity integer :: i , count , size_knot size_knot = size ( knot ) multiplicity = 0 i = 1 do while ( i <= size_knot ) if ( knot ( i ) == Xth ) then count = 1 do while ( i + count <= size_knot . and . knot ( i + count ) == Xth ) count = count + 1 end do if ( count > multiplicity ) then multiplicity = count end if i = i + count else i = i + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_knot_vector ( Xth_dir , degree , continuity ) result ( knot ) real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), allocatable :: knot (:) knot = repelem ( Xth_dir , ( degree - continuity )) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause elemental pure function isinf ( x ) result ( output ) real ( rk ), intent ( in ) :: x logical :: output output = . false . if ( x > huge ( x )) output = . true . if ( x < - huge ( x )) output = . true . end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause elemental pure function isnan ( x ) result ( output ) real ( rk ), intent ( in ) :: x logical :: output output = . false . if ( x /= x ) output = . true . end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knot_A_5_1 ( p , UP , Pw , u , k , s , r , nq , UQ , Qw ) integer , intent ( in ) :: p , k , s , r real ( rk ), intent ( in ), contiguous :: UP ( 0 :), Pw ( 0 :,:) real ( rk ), intent ( in ) :: u real ( rk ), allocatable , intent ( out ) :: UQ (:), Qw (:,:) integer , intent ( out ) :: nq integer :: i , j , L , mp , dim , np real ( rk ), allocatable :: Rw (:,:) real ( rk ) :: alpha dim = size ( Pw , 2 ) np = size ( Pw , 1 ) - 1 mp = np + p + 1 nq = np + r allocate ( UQ ( 0 : mp + r )) allocate ( Qw ( 0 : nq , 1 : dim )) allocate ( Rw ( 0 : p , 1 : dim )) UQ ( 0 : k ) = UP ( 0 : k ) UQ ( k + 1 : k + r ) = u UQ ( k + 1 + r : mp + r ) = UP ( k + 1 : mp ) Qw ( 0 : k - p ,:) = Pw ( 0 : k - p ,:) Qw ( k - s + r : np + r ,:) = Pw ( k - s : np ,:) Rw ( 0 : p - s ,:) = Pw ( k - p : k - s ,:) do j = 1 , r L = k - p + j do i = 0 , p - j - s alpha = ( u - UP ( L + i )) / ( UP ( i + k + 1 ) - UP ( L + i )) Rw ( i ,:) = alpha * Rw ( i + 1 ,:) + ( 1.0_rk - alpha ) * Rw ( i ,:) end do Qw ( L ,:) = Rw ( 0 ,:) Qw ( k + r - j - s ,:) = Rw ( p - j - s ,:) end do Qw ( L + 1 : k - s - 1 ,:) = Rw ( 1 : k - s - 1 - L ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function findspan ( n , degree , Xth , knot ) result ( s ) integer , intent ( in ) :: n , degree real ( rk ), intent ( in ) :: Xth real ( rk ), intent ( in ), contiguous :: knot (:) integer :: s integer :: low , high , mid if ( Xth == knot ( n + 2 )) then s = n return end if low = degree high = n + 1 mid = ( low + high ) / 2 do while ( Xth < knot ( mid + 1 ) . or . Xth >= knot ( mid + 2 )) if ( Xth < knot ( mid + 1 )) then high = mid else low = mid end if mid = ( low + high ) / 2 end do s = mid end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree_A_5_9 ( t , knot , degree , Xcw , nc_new , knot_new , Xcw_new ) integer , intent ( in ) :: t real ( rk ), intent ( in ), contiguous :: Xcw (:,:), knot (:) integer , intent ( in ) :: degree integer , intent ( out ) :: nc_new real ( rk ), allocatable , intent ( out ) :: Xcw_new (:,:), knot_new (:) real ( rk ), allocatable :: bezalfs (:,:), bpts (:,:), ebpts (:,:), Nextbpts (:,:), alfs (:) real ( rk ) :: inv , alpha1 , alpha2 , Xth1 , Xth2 , numer , den integer :: n , lbz , rbz , sv , tr , kj , first , knoti , last , alpha3 , dim , nc integer :: i , j , q , s , m , ph , ph2 , mpi , mh , r , a , b , Xcwi , oldr , mul integer , allocatable :: mlp (:) nc = size ( Xcw , 1 ) dim = size ( Xcw , 2 ) mlp = compute_multiplicity ( knot ) mlp = mlp + t nc_new = sum ( mlp ) - ( mlp ( 1 ) - 1 ) - 1 allocate ( Xcw_new ( nc_new , dim ), source = 0.0_rk ) allocate ( bezalfs ( degree + 1 , degree + t + 1 ), source = 0.0_rk ) allocate ( bpts ( degree + 1 , dim ), source = 0.0_rk ) allocate ( ebpts ( degree + t + 1 , dim ), source = 0.0_rk ) allocate ( Nextbpts ( degree + 1 , dim ), source = 0.0_rk ) allocate ( alfs ( degree ), source = 0.0_rk ) n = nc - 1 m = n + degree + 1 ph = degree + t ph2 = ph / 2 bezalfs ( 1 , 1 ) = 1.0_rk bezalfs ( degree + 1 , ph + 1 ) = 1.0_rk do i = 1 , ph2 inv = 1.0_rk / bincoeff ( ph , i ) mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = inv * bincoeff ( degree , j ) * bincoeff ( t , i - j ) end do end do do i = ph2 + 1 , ph - 1 mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = bezalfs ( degree - j + 1 , ph - i + 1 ) end do end do mh = ph knoti = ph + 1 r = - 1 a = degree b = degree + 1 Xcwi = 1 Xth1 = knot ( 1 ) Xcw_new ( 1 ,:) = Xcw ( 1 ,:) allocate ( knot_new ( sum ( mlp )), source = 0.0_rk ) knot_new ( 1 : ph + 1 ) = Xth1 do i = 0 , degree bpts ( i + 1 ,:) = Xcw ( i + 1 ,:) end do do while ( b < m ) i = b do while ( b < m . and . knot ( b + 1 ) == knot ( b + 2 )) b = b + 1 if ( b + 2 > size ( knot )) then exit end if end do mul = b - i + 1 mh = mh + mul + t Xth2 = knot ( b + 1 ) oldr = r r = degree - mul if ( oldr > 0 ) then lbz = ( oldr + 2 ) / 2 else lbz = 1 end if if ( r > 0 ) then rbz = ph - ( r + 1 ) / 2 else rbz = ph end if if ( r > 0 ) then numer = Xth2 - Xth1 do q = degree , mul + 1 , - 1 alfs ( q - mul ) = numer / ( knot ( a + q + 1 ) - Xth1 ) end do do j = 1 , r sv = r - j s = mul + j do q = degree , s , - 1 bpts ( q + 1 ,:) = ( 1.0_rk - alfs ( q - s + 1 )) * bpts ( q ,:) + alfs ( q - s + 1 ) * bpts ( q + 1 ,:) end do Nextbpts ( sv + 1 ,:) = bpts ( degree + 1 ,:) end do end if do i = lbz , ph ebpts ( i + 1 ,:) = 0.0_rk mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi ebpts ( i + 1 ,:) = bezalfs ( j + 1 , i + 1 ) * bpts ( j + 1 ,:) + ebpts ( i + 1 ,:) end do end do if ( oldr > 1 ) then first = knoti - 2 last = knoti den = Xth2 - Xth1 alpha3 = floor (( Xth2 - knot ( knoti )) / den ) do tr = 1 , oldr - 1 i = first j = last kj = j - knoti + 1 do while ( j - i > tr ) if ( i < Xcwi ) then alpha1 = ( Xth2 - knot ( i + 1 )) / ( Xth1 - knot ( i + 1 )) Xcw_new ( i + 1 ,:) = ( 1 - alpha1 ) * Xcw_new ( i ,:) + alpha1 * Xcw_new ( i + 1 ,:) end if if ( j >= lbz ) then if ( j - tr <= knoti - ph + oldr ) then alpha2 = ( Xth2 - knot_new ( j - tr + 1 )) / den ebpts ( kj + 1 ,:) = alpha2 * ebpts ( kj + 1 ,:) + ( 1 - alpha2 ) * ebpts ( kj + 2 ,:) else ebpts ( kj + 1 ,:) = ( 1 - alpha3 ) * ebpts (:, kj + 2 ) + alpha3 * ebpts ( kj + 1 ,:) end if end if i = i + 1 j = j - 1 kj = kj - 1 end do first = first - 1 last = last + 1 end do end if if ( a /= degree ) then do i = 0 , ph - oldr - 1 knot_new ( knoti + 1 ) = Xth1 knoti = knoti + 1 end do end if do j = lbz , rbz Xcw_new ( Xcwi + 1 ,:) = ebpts ( j + 1 ,:) Xcwi = Xcwi + 1 end do if ( b < m ) then do j = 0 , r - 1 bpts ( j + 1 ,:) = Nextbpts ( j + 1 ,:) end do do j = r , degree bpts ( j + 1 ,:) = Xcw ( b - degree + j + 1 ,:) end do a = b b = b + 1 Xth1 = Xth2 else do i = 0 , ph knot_new ( knoti + i + 1 ) = Xth2 end do end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function bincoeff ( n , k ) result ( b ) integer , intent ( in ) :: n , k real ( rk ) :: b b = floor ( 0.5_rk + exp ( factln ( n ) - factln ( k ) - factln ( n - k ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function factln ( n ) result ( f ) integer , intent ( in ) :: n real ( rk ) :: f if ( n <= 1 ) then f = 0.0_rk return end if f = log ( gamma ( real ( n + 1 , rk ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function hexahedron_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy , dz integer :: i , j , k , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) dz = L ( 3 ) / real ( nc ( 3 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) nci = 1 do k = 0 , nc ( 3 ) - 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = real ( k , rk ) * dz nci = nci + 1 end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function tetragon_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy integer :: i , j , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ), 3 )) nci = 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = 0.0_rk nci = nci + 1 end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots_A_5_8 ( p , knot , Pw , u , r , s , num , t , knot_new , Pw_new ) real ( rk ), intent ( in ) :: u integer , intent ( in ) :: p , r , s , num real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Pw (:,:) real ( rk ), allocatable , intent ( out ) :: knot_new (:) real ( rk ), allocatable , intent ( out ) :: Pw_new (:,:) real ( rk ), allocatable :: Pw_copy (:,:), knot_copy (:) integer , intent ( out ) :: t real ( rk ) :: tol , alfi , alfj real ( rk ), allocatable :: temp (:,:) integer :: i , j , ii , jj , remflag , off , first , last , ord , fout , m , k , n , nc , dim , tt dim = size ( Pw , 2 ) nc = size ( Pw , 1 ) n = nc m = n + p + 1 ord = p + 1 fout = ( 2 * r - s - p ) / 2 last = r - s first = r - p Pw_copy = Pw knot_copy = knot ! TODO: tol = 1.0e-6_rk * minval ( Pw (:, dim )) / ( 1.0_rk + maxval ( sqrt ( sum ( Pw ** 2 , 2 )))) allocate ( temp ( 2 * p + 1 , dim ), source = 0.0_rk ) t = 0 do tt = 0 , num - 1 off = first - 1 temp ( 1 ,:) = Pw_copy ( off ,:) temp ( last + 1 - off + 1 ,:) = Pw_copy ( last + 1 ,:) i = first j = last ii = 1 jj = last - off remflag = 0 do while ( j - i > t ) alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) alfj = ( u - knot_copy ( j - t )) / ( knot_copy ( j + ord ) - knot_copy ( j - t )) temp ( ii + 1 ,:) = ( Pw_copy ( i ,:) - ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:)) / alfi temp ( jj + 1 ,:) = ( Pw_copy ( j ,:) - alfj * temp ( jj + 1 + 1 ,:)) / ( 1.0_rk - alfj ) i = i + 1 ii = ii + 1 j = j - 1 jj = jj - 1 end do if ( j - i <= t ) then if ( norm2 ( temp ( ii - 1 + 1 ,:) - temp ( jj + 1 + 1 ,:)) <= tol ) then remflag = 1 else alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) if ( norm2 ( Pw_copy ( i ,:) - ( alfi * temp ( ii + t + 1 + 1 ,:) + ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:))) <= tol ) then remflag = 1 end if end if end if if ( remflag == 0 ) then exit else i = first j = last do while ( j - i > t ) Pw_copy ( i ,:) = temp ( i - off + 1 ,:) Pw_copy ( j ,:) = temp ( j - off + 1 ,:) i = i + 1 j = j - 1 end do end if first = first - 1 last = last + 1 t = t + 1 end do if ( t == 0 ) then return end if do k = r + 1 , m knot_copy ( k - t ) = knot_copy ( k ) end do j = fout i = j do k = 1 , t - 1 if ( mod ( k , 2 ) == 1 ) then i = i + 1 else j = j - 1 end if end do do k = i + 1 , n Pw_copy ( j ,:) = Pw_copy ( k ,:) j = j + 1 end do knot_new = knot_copy ( 1 : size ( knot_copy ) - t ) Pw_new = Pw_copy ( 1 : size ( Pw_copy , 1 ) - t ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_integer ( vec ) result ( output ) integer , dimension (:), intent ( in ), contiguous :: vec integer , dimension (:), allocatable :: output integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) if ( vec ( i ) == output ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_real ( vec ) result ( output ) real ( rk ), dimension (:), intent ( in ), contiguous :: vec real ( rk ), dimension (:), allocatable :: output integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) if ( vec ( i ) == output ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function rotation ( alpha , beta , theta ) result ( R ) real ( rk ), intent ( in ) :: alpha , beta , theta real ( rk ), dimension ( 3 , 3 ) :: R R ( 1 , 1 ) = cosd ( beta ) * cosd ( theta ) R ( 2 , 1 ) = cosd ( beta ) * sind ( theta ) R ( 3 , 1 ) = - sind ( beta ) R ( 1 , 2 ) = sind ( alpha ) * sind ( beta ) * cosd ( theta ) - cosd ( alpha ) * sind ( theta ) R ( 2 , 2 ) = sind ( alpha ) * sind ( beta ) * sind ( theta ) + cosd ( alpha ) * cosd ( theta ) R ( 3 , 2 ) = sind ( alpha ) * cosd ( beta ) R ( 1 , 3 ) = cosd ( alpha ) * sind ( beta ) * cosd ( theta ) + sind ( alpha ) * sind ( theta ) R ( 2 , 3 ) = cosd ( alpha ) * sind ( beta ) * sind ( theta ) - sind ( alpha ) * cosd ( theta ) R ( 3 , 3 ) = cosd ( alpha ) * cosd ( beta ) end function !=============================================================================== end module forcad_utils","tags":"","loc":"sourcefile/forcad_utils.f90.html"},{"title":"example_curve_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_curve_1.f90~~EfferentGraph sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","loc":"sourcefile/example_curve_1.f90.html"},{"title":"nearest_point_3d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_3d.f90~~EfferentGraph sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !! Declare a NURBS volume object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the volume real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 8 , 3 ) !! Control points real ( rk ) :: Wc ( 8 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS hexahedron !----------------------------------------------------------------------------- Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 4.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 4.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 2.0_rk ] Xc ( 6 ,:) = [ 2.0_rk , 0.0_rk , 2.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 4.0_rk , 2.0_rk ] Xc ( 8 ,:) = [ 2.0_rk , 4.0_rk , 2.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 1.11_rk , 1.0_rk , 0.5_rk , 0.5_rk , 1.2_rk , 1.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, 20 call shape % create ( 30 , 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the volume !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.5_rk , 3.5_rk , 1.1_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the volume (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) call shape % nearest_point2 ([ 1.5_rk , 3.5_rk , 1.1_rk ], 1.0e-11_rk , 500 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","loc":"sourcefile/nearest_point_3d.f90.html"},{"title":"forcad.f90 – ForCAD","text":"This file depends on sourcefile~~forcad.f90~~EfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad.f90~~AfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forcad use forcad_utils use forcad_nurbs_curve use forcad_nurbs_surface use forcad_nurbs_volume private public rk , nurbs_curve , nurbs_surface , nurbs_volume end module forcad","tags":"","loc":"sourcefile/forcad.f90.html"},{"title":"shape_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_3d.f90~~EfferentGraph sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_3d_Xc.vtk' , 'vtk/shape_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_ring_3d.f90.html"},{"title":"forcad_nurbs_surface.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_surface.f90~~EfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_surface.f90~~AfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. module forcad_nurbs_surface use forcad_utils , only : rk , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , tetragon_Xc , & elemConn_Cn , unique , rotation implicit none private public nurbs_surface !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_surface real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc(1)*nc(2)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: Xt (:,:) !! Evaluation parameter values (2D array: [ng(1)*ng(2), 2]) real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) integer , private :: degree ( 2 ) !! Degree (order) of the surface integer , private :: nc ( 2 ) !! Number of control points in each direction integer , private :: ng ( 2 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vectors, control points and weights for the NURBS surface object procedure :: set2 !!> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier surface using control points and weights generic :: set => set1 , set2 , set3 !!> Set NURBS surface procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: cmp_degree !!> Compute degree of the NURBS surface procedure , private :: get_degree_all !!> Get degree of the NURBS surface in both directions procedure , private :: get_degree_dir !!> Get degree of the NURBS surface in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS surface procedure :: finalize !!> Finalize the NURBS surface object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knot vector procedure :: get_continuity !!> Compute and return the continuity of the NURBS surface procedure :: cmp_nc !!> Compute number of required control points procedure :: get_nc !!> Get number of control points procedure , private :: basis_vector !!> Compute the basis functions of the NURBS surface procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS surface generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS surface procedure , private :: derivative_vector !!> Compute the derivative of the NURBS surface procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS surface generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS surface procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS surface procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS surface generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS surface procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate degree procedure :: is_rational !!> Check if the NURBS surface is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS surface (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS surface (Minimization - Newton's method) ! Shapes procedure :: set_tetragon !!> Set a tetragon procedure :: set_ring !!> Set a ring procedure :: set_half_ring !!> Set a half ring procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg pure function compute_Xg_nurbs_2d ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_ng , f_Xc , f_Wc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Xg (:,:) end function pure function compute_Xg_bspline_2d ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_ng , f_Xc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:) real ( rk ), intent ( in ), contiguous :: f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), allocatable :: f_Xg (:,:) end function pure function compute_Xg_nurbs_2d_1point ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_Xc , f_Wc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Xg (:) end function pure function compute_Xg_bspline_2d_1point ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_Xc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:) real ( rk ), intent ( in ), contiguous :: f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), allocatable :: f_Xg (:) end function end interface interface compute_dTgc pure subroutine compute_dTgc_nurbs_2d_vector ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_ng , f_Wc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_dTgc_bspline_2d_vector ( f_Xt , f_knot1 , f_knot2 , f_degree , nc , f_ng , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_dTgc_nurbs_2d_scalar ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_Wc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine pure subroutine compute_dTgc_bspline_2d_scalar ( f_Xt , f_knot1 , f_knot2 , f_degree , nc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine end interface interface compute_d2Tgc pure subroutine compute_d2Tgc_nurbs_2d_vector ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_ng , f_Wc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_d2Tgc_bspline_2d_vector ( f_Xt , f_knot1 , f_knot2 , f_degree , nc , f_ng , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_d2Tgc_nurbs_2d_scalar ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_Wc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine pure subroutine compute_d2Tgc_bspline_2d_scalar ( f_Xt , f_knot1 , f_knot2 , f_degree , nc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine end interface interface compute_Tgc pure function compute_Tgc_nurbs_2d_vector ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_ng , f_Wc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Tgc (:,:) end function pure function compute_Tgc_bspline_2d_vector ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_ng ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), allocatable :: f_Tgc (:,:) end function pure function compute_Tgc_nurbs_2d_scalar ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc , f_Wc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Tgc (:) end function pure function compute_Tgc_bspline_2d_scalar ( f_Xt , f_knot1 , f_knot2 , f_degree , f_nc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:) integer , intent ( in ) :: f_degree ( 2 ) integer , intent ( in ) :: f_nc ( 2 ) real ( rk ), allocatable :: f_Tgc (:) end function end interface interface pure function nearest_point_help_2d ( f_ng , f_Xg , f_point_Xg ) result ( f_distances ) import :: rk integer , intent ( in ) :: f_ng ( 2 ) real ( rk ), intent ( in ), contiguous :: f_Xg (:,:) real ( rk ), intent ( in ), contiguous :: f_point_Xg (:) real ( rk ), allocatable :: f_distances (:) end function end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vectors, control points and weights for the NURBS surface object. pure subroutine set1 ( this , knot1 , knot2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot1 = knot1 this % knot2 = knot2 call this % cmp_degree () call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , degree , continuity1 , continuity2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % degree ( 1 ) = degree ( 1 ) this % degree ( 2 ) = degree ( 2 ) call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier surface using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) allocate ( this % knot1 ( 2 * this % nc ( 1 ))) this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) allocate ( this % knot2 ( 2 * this % nc ( 2 ))) this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , Xt1 , Xt2 , Xt ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), contiguous , intent ( in ), optional :: Xt (:,:) integer :: i ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 )) then error stop 'Knot vector(s) is/are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if if ( present ( Xt )) then this % Xt = Xt else ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt ) end if if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), contiguous , intent ( in ) :: Xt (:) real ( rk ), allocatable :: Xg (:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 )) then error stop 'Knot vector(s) is/are not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid direction for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid direction for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS surface is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS surface is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_surface ), intent ( in ) :: this integer :: ng ( 2 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this , dir ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: dir integer , allocatable :: m1 (:), m2 (:) if ( present ( dir )) then if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 else error stop 'Invalid direction for degree.' end if else m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer :: degree ( 2 ) degree = this % degree end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree if ( dir == 1 ) then degree = this % degree ( 1 ) else if ( dir == 2 ) then degree = this % degree ( 2 ) else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_surface ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc ()) end if else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot1 ) . and . allocated ( this % knot2 )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( nc = this % nc , Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else error stop 'The NURBS surface is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this , dir ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: dir if ( present ( dir )) then if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if else error stop 'Invalid direction.' end if else ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this , dir ) result ( nc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res1 , res2 , Xt1 , Xt2 , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res1 , res2 , Xt1 , Xt2 , d2Tgc , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res1 , res2 , Xt1 , Xt2 , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * ( n_new + 1 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * ( n_new + 1 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * ( n_new + 1 ))) do j = 1 , this % nc ( 2 ) * ( n_new + 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc_new = reshape ( Xc_new ,[( this % nc ( 2 )) * ( n_new + 1 ), dim ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new ) end do end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc3 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( n_new + 1 ), dim + 1 ]) allocate ( Xc_new ( 1 :( n_new + 1 ) * this % nc ( 1 ), 1 : dim )) allocate ( Wc_new ( 1 :( n_new + 1 ) * this % nc ( 1 ))) do j = 1 , ( n_new + 1 ) * this % nc ( 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc3 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , dim ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( n_new + 1 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new ) end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) integer :: dim , j , nc_new real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , nc_new , knot_new , Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * nc_new , dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * nc_new , 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * nc_new )) do j = 1 , this % nc ( 2 ) * nc_new Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , nc_new , knot_new , Xc_new ) Xc_new = reshape ( Xc_new ,[ this % nc ( 2 ) * nc_new , dim ], order = [ 1 , 2 ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new ) deallocate ( Xc , Xc_new ) end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 )]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , nc_new , knot_new , Xcw_new ) Xc3 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * nc_new , dim + 1 ]) allocate ( Xc_new ( 1 : nc_new * this % nc ( 1 ), 1 : dim )) allocate ( Wc_new ( 1 : nc_new * this % nc ( 1 ))) do j = 1 , nc_new * this % nc ( 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , nc_new , knot_new , Xc_new ) Xc3 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * nc_new , dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new ) end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_surface ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * ( nc_new ), dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * ( nc_new ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * dim ], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc_new = reshape ( Xc_new ,[( this % nc ( 2 )) * ( nc_new ), dim ], order = [ 1 , 2 ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc3 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), dim + 1 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 1 ), 1 : dim )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 1 ))) do j = 1 , ( nc_new ) * this % nc ( 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc3 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , Xc = Xc_new ) end if end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_tetragon ( this , L , nc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: L ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) call this % set ( nc = nc , Xc = tetragon_Xc ( L , nc ), Wc = Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ),& this % degree ( 1 ), this % degree ( 2 ),& unique ( this % knot1 ), unique ( this % knot2 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg ) class ( nurbs_surface ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len = 3000 ) :: pyvista_script pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=7,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels(\" // achar ( 10 ) // & \"        [point_coords],\" // achar ( 10 ) // & \"        [label],\" // achar ( 10 ) // & \"        font_size=14,\" // achar ( 10 ) // & \"        text_color='black',\" // achar ( 10 ) // & \"        show_points=False,\" // achar ( 10 ) // & \"        fill_shape=False,\" // achar ( 10 ) // & \"        shape=None,\" // achar ( 10 ) // & \"    )\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xg.SetVisibility(flag)\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcp_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='red',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 1 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcw_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='yellow',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 2 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xg_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='cyan',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 3 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Points)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 1 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Control geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 2 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xg (Geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 3 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'https://github.com/gha3mi/forcad',\" // achar ( 10 ) // & \"    position=(0.0, 0.0),\" // achar ( 10 ) // & \"    font_size=7,\" // achar ( 10 ) // & \"    color='blue',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_ring ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i ! Define control points for ring allocate ( Xc ( 14 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 7 , 1 : 2 ) = Xc ( 1 : 7 , 1 : 2 ) * radius1 Xc ( 8 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 11 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 12 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 13 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 14 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 8 : 14 , 1 : 2 ) = Xc ( 8 : 14 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i ! Define control points for C-shape allocate ( Xc ( 10 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 8 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_ring ( this , center , radius1 , radius2 ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:) integer :: i ! Define control points for half ring allocate ( Xc ( 10 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 8 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xt (:) integer , intent ( out ), optional :: id integer :: id_ real ( rk ), allocatable :: distances (:) allocate ( distances ( this % ng ( 1 ) * this % ng ( 2 ))) distances = nearest_point_help_2d ( this % ng , this % Xg , point_Xg ) id_ = minloc ( distances , dim = 1 ) if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt ( 2 ) real ( rk ), allocatable , intent ( out ), optional :: nearest_Xg (:) real ( rk ) :: obj , grad ( 2 ), hess ( 2 , 2 ), dk ( 2 ), alphak , tau , beta , det_inv , Ainv ( 2 , 2 ), lower_bounds ( 2 ), upper_bounds ( 2 ) real ( rk ), allocatable :: Xg (:), xk (:), Tgc (:), dTgc (:,:), d2Tgc (:,:) integer :: k , l logical :: convergenz type ( nurbs_surface ) :: copy_this k = 0 ! lower and upper bounds lower_bounds = [ minval ( this % knot1 ), minval ( this % knot2 )] upper_bounds = [ maxval ( this % knot1 ), maxval ( this % knot2 )] ! guess initial point copy_this = this call copy_this % create ( 10 , 10 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! Check if xk is within the knot vector range if ( xk ( 1 ) < minval ( this % knot1 )) then xk ( 1 ) = minval ( this % knot1 ) else if ( xk ( 1 ) > maxval ( this % knot1 )) then xk ( 1 ) = maxval ( this % knot1 ) end if if ( xk ( 2 ) < minval ( this % knot2 )) then xk ( 2 ) = minval ( this % knot2 ) else if ( xk ( 2 ) > maxval ( this % knot2 )) then xk ( 2 ) = maxval ( this % knot2 ) end if convergenz = . false . allocate ( Xg ( size ( this % Xc , 2 ))) ! allocate(dTgc(size(this%Xc,1), 2)) ! allocate(d2Tgc(size(this%Xc,1), 2)) do while (. not . convergenz . and . k < maxit ) ! objection, gradient and hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc is not needed obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! add a small number to avoid division by zero grad ( 1 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 1 ), this % Xc )) grad ( 2 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 2 ), this % Xc )) hess ( 1 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 2 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ), 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 1 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 2 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + & dot_product (( Xg - point_Xg ), matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ), 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 ! debug print '(i3,1x,2e20.10,1x,e20.10)' , k , xk , norm2 ( grad ) if ( norm2 ( grad ) <= tol ) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else ! Inverse of Hessian det_inv = 1.0_rk / ( hess ( 1 , 1 ) * hess ( 2 , 2 ) - hess ( 1 , 2 ) * hess ( 2 , 1 )) Ainv ( 1 , 1 ) = hess ( 2 , 2 ) Ainv ( 2 , 1 ) = - hess ( 2 , 1 ) Ainv ( 1 , 2 ) = - hess ( 1 , 2 ) Ainv ( 2 , 2 ) = hess ( 1 , 1 ) Ainv = Ainv * det_inv dk = - matmul ( Ainv , grad ) ! Backtracking-Armijo Line Search alphak = 1.0_rk tau = 0.5_rk ! 0 < tau  < 1 beta = 1.0e-4_rk ! 0 < beta < 1 l = 0 do while (. not . norm2 ( this % cmp_Xg ( xk + alphak * dk ) - point_Xg ) <= obj + alphak * beta * dot_product ( grad , dk ) . and . l < 50 ) alphak = tau * alphak l = l + 1 end do xk = xk + alphak * dk ! Check if xk is within the knot vector range xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== end module forcad_nurbs_surface !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_nurbs_2d ( Xt , knot1 , knot2 , degree , nc , ng , Xc , Wc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) real ( rk ), allocatable :: Tgc (:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ), size ( Xc , 2 ))) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) !$OMP PARALLEL DO PRIVATE(Tgc) do i = 1 , ng ( 1 ) * ng ( 2 ) Tgc = kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg ( i ,:) = matmul ( Tgc , Xc ) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_nurbs_2d_1point ( Xt , knot1 , knot2 , degree , nc , Xc , Wc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:) real ( rk ), allocatable :: Tgc (:) allocate ( Xg ( size ( Xc , 2 ))) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_bspline_2d ( Xt , knot1 , knot2 , degree , nc , ng , Xc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ), size ( Xc , 2 ))) !$OMP PARALLEL DO do i = 1 , ng ( 1 ) * ng ( 2 ) Xg ( i ,:) = matmul ( kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))),& Xc ) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_bspline_2d_1point ( Xt , knot1 , knot2 , degree , nc , Xc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:) allocate ( Xg ( size ( Xc , 2 ))) Xg = matmul ( kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))),& Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: dBi (:,:), dB1 (:), dB2 (:) real ( rk ), allocatable :: Bi (:), B1 (:), B2 (:) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 )), dBi ( nc ( 1 ) * nc ( 2 ), 2 )) do i = 1 , size ( Xt , 1 ) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: dB1 (:), dB2 (:), dBi (:,:) real ( rk ), allocatable :: B1 (:), B2 (:), Bi (:) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 ), Tgc ( nc ( 1 ) * nc ( 2 ))) allocate ( dBi ( nc ( 1 ) * nc ( 2 ), 2 ), Bi ( nc ( 1 ) * nc ( 2 ))) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: dB1 (:), dB2 (:) real ( rk ), allocatable :: B1 (:), B2 (:) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 )) !$OMP PARALLEL DO PRIVATE(dB1, dB2) do i = 1 , size ( Xt , 1 ) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) Tgc ( i ,:) = kron ( B2 , B1 ) dTgc ( i ,:, 1 ) = kron ( B2 , dB1 ) dTgc ( i ,:, 2 ) = kron ( dB2 , B1 ) end do !$OMP END PARALLEL DO end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: dTgc1 (:), dTgc2 (:) real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 )) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dTgc1 , Tgc1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dTgc2 , Tgc2 ) Tgc = kron ( Tgc2 , Tgc1 ) dTgc (:, 1 ) = kron ( Tgc2 , dTgc1 ) dTgc (:, 2 ) = kron ( dTgc2 , Tgc1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: d2Bi (:,:), d2B1 (:), d2B2 (:) real ( rk ), allocatable :: dBi (:,:), dB1 (:), dB2 (:) real ( rk ), allocatable :: Bi (:), B1 (:), B2 (:) real ( rk ), allocatable :: Tgci (:), dTgci (:) integer :: i allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ), 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( B1 ( nc ( 1 )), B2 ( nc ( 2 ))) allocate ( dB1 ( nc ( 1 )), dB2 ( nc ( 2 ))) allocate ( d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 )), dBi ( nc ( 1 ) * nc ( 2 ), 2 ), d2Bi ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgci ( nc ( 1 ) * nc ( 2 )), dTgci ( nc ( 1 ) * nc ( 2 ))) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 )), dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 )) do i = 1 , size ( Xt , 1 ) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) * Wc - 2.0_rk * dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) * Wc - dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) * Wc - dTgc ( i ,:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) * Wc - 2.0_rk * dTgc ( i ,:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ), Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: d2Bi (:,:), d2B1 (:), d2B2 (:) real ( rk ), allocatable :: dBi (:,:), dB1 (:), dB2 (:) real ( rk ), allocatable :: Bi (:), B1 (:), B2 (:) allocate ( B1 ( nc ( 1 )), B2 ( nc ( 2 ))) allocate ( dB1 ( nc ( 1 )), dB2 ( nc ( 2 ))) allocate ( d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 )), dBi ( nc ( 1 ) * nc ( 2 ), 2 ), d2Bi ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 )), dTgc ( nc ( 1 ) * nc ( 2 ), 2 ), d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Bi = kron ( B2 , B1 ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( B2 , dB1 ) dBi (:, 2 ) = kron ( dB2 , B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) * Wc - 2.0_rk * dTgc (:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) * Wc - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = & ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) * Wc - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = & ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) * Wc - 2.0_rk * dTgc (:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ), Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: d2B1 (:), d2B2 (:) real ( rk ), allocatable :: dB1 (:), dB2 (:) real ( rk ), allocatable :: B1 (:), B2 (:) integer :: i allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ), 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( dTgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) do i = 1 , size ( Xt , 1 ) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Tgc ( i ,:) = kron ( B2 , B1 ) dTgc ( i ,:, 1 ) = kron ( B2 , dB1 ) dTgc ( i ,:, 2 ) = kron ( dB2 , B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: d2B1 (:), d2B2 (:) real ( rk ), allocatable :: dB1 (:), dB2 (:) real ( rk ), allocatable :: B1 (:), B2 (:) allocate ( d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ), 2 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ), 2 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) Tgc = kron ( B2 , B1 ) dTgc (:, 1 ) = kron ( B2 , dB1 ) dTgc (:, 2 ) = kron ( dB2 , B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 1 ) = kron ( B2 , d2B1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 1 ) = kron ( dB2 , dB1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) , 2 ) = kron ( dB2 , dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ), 2 ) = kron ( d2B2 , B1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_nurbs_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng , Wc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) allocate ( Tgci ( nc ( 1 ) * nc ( 2 ))) !$OMP PARALLEL DO PRIVATE(Tgci) do i = 1 , size ( Xt , 1 ) Tgci = kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_nurbs_2d_scalar ( Xt , knot1 , knot2 , degree , nc , Wc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_bspline_2d_vector ( Xt , knot1 , knot2 , degree , nc , ng ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) integer , intent ( in ) :: ng ( 2 ) real ( rk ), allocatable :: Tgc (:,:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ), nc ( 1 ) * nc ( 2 ))) !$OMP PARALLEL DO do i = 1 , size ( Xt , 1 ) Tgc ( i ,:) = kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ))) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_bspline_2d_scalar ( Xt , knot1 , knot2 , degree , nc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:) integer , intent ( in ) :: degree ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ))) Tgc = kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function nearest_point_help_2d ( ng , Xg , point_Xg ) result ( distances ) use forcad_utils , only : rk implicit none integer , intent ( in ) :: ng ( 2 ) real ( rk ), intent ( in ), contiguous :: Xg (:,:) real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), allocatable :: distances (:) integer :: i allocate ( distances ( ng ( 1 ) * ng ( 2 ))) !$OMP PARALLEL DO do i = 1 , ng ( 1 ) * ng ( 2 ) distances ( i ) = norm2 ( Xg ( i ,:) - point_Xg ) end do !$OMP END PARALLEL DO end function !===============================================================================","tags":"","loc":"sourcefile/forcad_nurbs_surface.f90.html"},{"title":"shape_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_circle.f90~~EfferentGraph sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS circle !----------------------------------------------------------------------------- !> Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_circle ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_circle_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating circle !----------------------------------------------------------------------------- !> Generate the NURBS circle with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_circle_Xc.vtk' , 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_circle.f90.html"},{"title":"shape_half_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_2d.f90~~EfferentGraph sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_2d_Xc.vtk' , 'vtk/shape_half_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_half_ring_2d.f90.html"},{"title":"shape_half_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_3d.f90~~EfferentGraph sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_3d_Xc.vtk' , 'vtk/shape_half_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_half_ring_3d.f90.html"},{"title":"nearest_point_2d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d.f90~~EfferentGraph sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the surface real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 4 , 3 ) !! Control points real ( rk ) :: Wc ( 4 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a surface with 4 control points Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 0.7_rk , 1.0_rk ] call shape % set ( knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the surface (Approximation) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the surface (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) call shape % nearest_point2 ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","loc":"sourcefile/nearest_point_2d.f90.html"},{"title":"put_to_nurbs.f90 – ForCAD","text":"This file depends on sourcefile~~put_to_nurbs.f90~~EfferentGraph sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_put_to_nurbs use forcad use forcad_utils , only : hexahedron_Xc implicit none type ( nurbs_volume ) :: control_shape real ( rk ), allocatable :: X (:,:) integer , allocatable :: elem (:,:) integer :: i , nunit !> You can create your shape or use a predefined one !> Read coordinates from file allocate ( X ( 23200 , 3 )) open ( newunit = nunit , file = 'example/put_to_nurbs_X.txt' ) do i = 1 , 23200 read ( nunit , * ) X ( i , 1 ), X ( i , 2 ), X ( i , 3 ) end do close ( nunit ) !> Read element connectivities from file allocate ( elem ( 20577 , 8 )) open ( newunit = nunit , file = 'example/put_to_nurbs_elem.txt' ) do i = 1 , 20577 read ( nunit , * ) elem ( i , 1 ), elem ( i , 2 ), elem ( i , 4 ), elem ( i , 3 ), elem ( i , 5 ), elem ( i , 6 ), elem ( i , 8 ), elem ( i , 7 ) end do close ( nunit ) !> Set a control shape that will be used to put the shape into !> The contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points !> By modifying the control shape you can modify the shape call control_shape % set ( nc = [ 10 , 5 , 3 ], Xc = hexahedron_Xc ( L = [ 10 0.0_rk , 4 0.0_rk , 1 0.0_rk ], nc = [ 10 , 5 , 3 ])) !> Map the shape into the shape call control_shape % put_to_nurbs ( X , elem ) !> Deallocate local variables deallocate ( X , elem ) !> Export the shape and the control shape to vtk files call control_shape % export_Xc ( 'vtk/control_shape.vtk' ) call control_shape % export_Xg ( 'vtk/shape.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call control_shape % show ( 'vtk/control_shape.vtk' , 'vtk/shape.vtk' ) !> Finalize the control shape call control_shape % finalize () end program","tags":"","loc":"sourcefile/put_to_nurbs.f90.html"},{"title":"example_surface_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_surface_1.f90~~EfferentGraph sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","loc":"sourcefile/example_surface_1.f90.html"},{"title":"demo_surface.f90 – ForCAD","text":"This file depends on sourcefile~~demo_surface.f90~~EfferentGraph sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface. !> It sets up control points and weights, generates the surface, and exports the control points !> and the surface to VTK files at various stages. program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"sourcefile/demo_surface.f90.html"},{"title":"example_ppm3.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm3.f90~~EfferentGraph sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm3 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 2 ]) call shape % translate_Xc ([ 0.01_rk , 0.01_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , 0.0_rk , 2.2_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 2 ]) call shape % translate_Xc ([ 0.51_rk , 0.01_rk , 0.0_rk ]) call shape % modify_Xc ( 0.24_rk , 2 , 2 ) call shape % modify_Xc ( 0.26_rk , 5 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 3 ]) call shape % translate_Xc ([ 0.01_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.26_rk , 3 , 1 ) call shape % modify_Xc ( 0.24_rk , 4 , 1 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 3 ]) call shape % translate_Xc ([ 0.51_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.7_rk , 1 , 2 ) call shape % modify_Xc ( 0.7_rk , 3 , 2 ) call shape % modify_Xc ( 0.8_rk , 7 , 2 ) call shape % modify_Xc ( 0.8_rk , 9 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm3' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","loc":"sourcefile/example_ppm3.f90.html"},{"title":"example_volume_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_volume_1.f90~~EfferentGraph sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","loc":"sourcefile/example_volume_1.f90.html"},{"title":"shape_tetragon.f90 – ForCAD","text":"This file depends on sourcefile~~shape_tetragon.f90~~EfferentGraph sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_tetragon use forcad implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !> Export the control points to a VTK file call shape % export_Xc ( 'vtk/shape_tetragon_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !> Export the generated surface to a VTK file call shape % export_Xg ( 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_tetragon_Xc.vtk' , 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_tetragon.f90.html"},{"title":"example_ppm1.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm1.f90~~EfferentGraph sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm1 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , 0.0_rk , 2.2_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.08_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.01_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.22_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm1' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","loc":"sourcefile/example_ppm1.f90.html"},{"title":"forcad_nurbs_curve.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_curve.f90~~EfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_curve.f90~~AfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. module forcad_nurbs_curve use forcad_utils , only : rk , basis_bspline , elemConn_C0 , compute_multiplicity , compute_knot_vector , basis_bspline_der ,& insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation implicit none private public nurbs_curve !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_curve real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc, dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng, dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc]) real ( rk ), allocatable , private :: Xt (:) !! Evaluation points (1D array: [ng]) real ( rk ), allocatable , private :: knot (:) !! Knot vector (1D array) integer , private :: degree !! Degree (order) of the curve integer , private :: nc !! Number of control points integer , private :: ng !! Number of geometry points integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vector, control points and weights for the NURBS curve object procedure :: set2 !!> Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier curve using control points and weights generic :: set => set1 , set2 , set3 !!> Set NURBS curve procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: cmp_degree !!> Compute degree of the NURBS curve procedure :: get_degree !!> Get degree of the NURBS curve procedure :: finalize !!> Finalize the NURBS curve object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knots procedure :: get_continuity !!> Compute and return the continuity of the curve procedure :: cmp_nc !!> Compute number of required control points procedure :: get_nc !!> Get number of control points procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the curve procedure , private :: basis_vector !!> Compute the basis functions of the NURBS curve procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS curve generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS curve procedure , private :: derivative_vector !!> Compute the derivative of the NURBS curve procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS curve generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS curve procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS curve procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS curve generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS curve procedure :: is_rational !!> Check if the NURBS curve is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS curve (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS curve (Minimization - Newton's method) ! Shapes procedure :: set_circle !!> Set a circle procedure :: set_half_circle !!> Set a half circle procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg pure function compute_Xg_nurbs_1d ( f_Xt , f_knot , f_degree , f_nc , f_ng , f_Xc , f_Wc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Xg (:,:) end function pure function compute_Xg_bspline_1d ( f_Xt , f_knot , f_degree , f_nc , f_ng , f_Xc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), allocatable :: f_Xg (:,:) end function pure function compute_Xg_nurbs_1d_1point ( f_Xt , f_knot , f_degree , f_nc , f_Xc , f_Wc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Xg (:) end function pure function compute_Xg_bspline_1d_1point ( f_Xt , f_knot , f_degree , f_nc , f_Xc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), allocatable :: f_Xg (:) end function end interface interface compute_d2Tgc pure subroutine compute_d2Tgc_nurbs_1d_vector ( f_Xt , f_knot , f_degree , f_nc , f_ng , f_Wc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_d2Tgc_bspline_1d_vector ( f_Xt , f_knot , f_degree , f_nc , f_ng , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_d2Tgc_nurbs_1d_scalar ( f_Xt , f_knot , f_degree , f_nc , f_Wc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine pure subroutine compute_d2Tgc_bspline_1d_scalar ( f_Xt , f_knot , f_degree , f_nc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine end interface interface compute_dTgc pure subroutine compute_dTgc_nurbs_1d_vector ( f_Xt , f_knot , f_degree , f_nc , f_ng , f_Wc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_dTgc_bspline_1d_vector ( f_Xt , f_knot , f_degree , f_nc , f_ng , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_dTgc_nurbs_1d_scalar ( f_Xt , f_knot , f_degree , f_nc , f_Wc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine pure subroutine compute_dTgc_bspline_1d_scalar ( f_Xt , f_knot , f_degree , f_nc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), allocatable , intent ( out ) :: f_dTgc (:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine end interface interface compute_Tgc pure function compute_Tgc_nurbs_1d_vector ( f_Xt , f_knot , f_degree , f_nc , f_ng , f_Wc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Tgc (:,:) end function pure function compute_Tgc_bspline_1d_vector ( f_Xt , f_knot , f_degree , f_nc , f_ng ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc integer , intent ( in ) :: f_ng real ( rk ), allocatable :: f_Tgc (:,:) end function pure function compute_Tgc_nurbs_1d_scalar ( f_Xt , f_knot , f_degree , f_nc , f_Wc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Tgc (:) end function pure function compute_Tgc_bspline_1d_scalar ( f_Xt , f_knot , f_degree , f_nc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ) :: f_Xt real ( rk ), intent ( in ), contiguous :: f_knot (:) integer , intent ( in ) :: f_degree integer , intent ( in ) :: f_nc real ( rk ), allocatable :: f_Tgc (:) end function end interface interface pure function nearest_point_help_1d ( f_ng , f_Xg , f_point_Xg ) result ( f_distances ) import :: rk integer , intent ( in ) :: f_ng real ( rk ), intent ( in ), contiguous :: f_Xg (:,:) real ( rk ), intent ( in ), contiguous :: f_point_Xg (:) real ( rk ), allocatable :: f_distances (:) end function end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vector, control points and weights for the NURBS curve object. pure subroutine set1 ( this , knot , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot = knot call this % cmp_degree () this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. pure subroutine set2 ( this , Xth_dir , degree , continuity , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot = compute_knot_vector ( Xth_dir , degree , continuity ) this % degree = degree this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier curve using control points and weights. pure subroutine set3 ( this , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( allocated ( this % knot )) deallocate ( this % knot ) allocate ( this % knot ( 2 * this % nc )) this % knot ( 1 : this % nc ) = 0.0_rk this % knot ( this % nc + 1 : 2 * this % nc ) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res , Xt ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) integer :: i ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' end if ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt ) ! Allocate memory for geometry points if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable :: Xg (:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS curve is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS curve is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this ) result ( Xt ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xt (:) if ( allocated ( this % Xt )) then Xt = this % Xt else error stop 'Parameter values are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_curve ), intent ( in ) :: this integer :: ng ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this ) class ( nurbs_curve ), intent ( inout ) :: this integer , allocatable :: m (:) m = this % get_multiplicity () this % degree = m ( 1 ) - 1 end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree ( this ) result ( degree ) class ( nurbs_curve ), intent ( in ) :: this integer :: degree degree = this % degree end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: knot (:) if ( allocated ( this % knot )) then knot = this % knot else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , i ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: i real ( rk ) :: knot if ( allocated ( this % knot )) then if ( i < 1 . or . i > size ( this % knot )) then error stop 'Invalid index for knot vector.' else knot = this % knot ( i ) end if else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_curve ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % nc , p ) else elemConn = elemConn_C0 ( this % nc , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % ng , p ) else elemConn = elemConn_C0 ( this % ng , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension of the control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension of the geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot = this % get_knot (), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot = this % get_knot (), Xc = this % get_Xc ()) end if else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot )) then call this % set ( knot = this % get_knot (), Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else error stop 'The NURBS curve is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this ) result ( m ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: m (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this ) result ( c ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: c (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else c = this % degree - compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this ) class ( nurbs_curve ), intent ( inout ) :: this this % nc = sum ( compute_multiplicity ( this % knot )) - this % degree - 1 end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( nurbs_curve ), intent ( in ) :: this integer :: nc nc = this % nc end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , Xth , r ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , n_new real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) call insert_knot_A_5_1 (& this % degree ,& this % knot ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) allocate ( Xc_new ( 1 : n_new + 1 , 1 : dim )) allocate ( Wc_new ( 1 : n_new + 1 )) do j = 1 , n_new + 1 Xc_new ( j , 1 : dim ) = Xcw_new ( j - 1 , 1 : dim ) / Xcw_new ( j - 1 , dim + 1 ) Wc_new ( j ) = Xcw_new ( j - 1 , dim + 1 ) end do call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if call insert_knot_A_5_1 (& this % degree ,& this % knot ,& this % Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) call this % set ( knot = knot_new , Xc = Xc_new ) end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , t ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) integer :: dim , j , nc_new if ( this % is_rational ()) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) Xcw ( j , dim + 1 ) = this % Wc ( j ) end do call elevate_degree_A_5_9 ( t , this % knot , this % degree , Xcw , nc_new , knot_new , Xcw_new ) allocate ( Xc_new ( 1 : nc_new , 1 : dim )) allocate ( Wc_new ( 1 : nc_new )) do j = 1 , nc_new Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) call elevate_degree_A_5_9 ( t , this % knot , this % degree , this % Xc , nc_new , knot_new , Xc_new ) call this % set ( knot = knot_new , Xc = Xc_new ) deallocate ( Xc_new ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res , Xt , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot , this % degree , this % nc , this % Wc , dTgc , Tgc ) else ! B-Spline call compute_dTgc ( Xt , this % knot , this % degree , this % nc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else ! B-Spline call compute_d2Tgc ( Xt , this % knot , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt , 1 ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( this % Xt , this % knot , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: Tgc (:) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot , this % degree , this % nc , this % Wc ) else ! B-Spline Tgc = compute_Tgc ( Xt , this % knot , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_curve ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , Xth , r ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , nc_new , t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) call remove_knots_A_5_8 (& this % degree ,& this % knot ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) allocate ( Xc_new ( nc_new , dim )) allocate ( Wc_new ( nc_new )) do j = 1 , nc_new Xc_new ( j ,:) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) if ( allocated ( Xcw_new )) deallocate ( Xcw_new ) if ( allocated ( Xc_new )) deallocate ( Xc_new ) if ( allocated ( Wc_new )) deallocate ( Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 call remove_knots_A_5_8 (& this % degree ,& this % knot ,& this % Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( t == 0 ) then ! no change else call this % set ( knot = knot_new , Xc = Xc_new ) end if end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_circle ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i ! Define control points for circle allocate ( Xc ( 7 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i ! Define control points for C-shape allocate ( Xc ( 5 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc , this % degree , unique ( this % knot ), this % get_multiplicity (),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg ) class ( nurbs_curve ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len = 3000 ) :: pyvista_script pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=7,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels(\" // achar ( 10 ) // & \"        [point_coords],\" // achar ( 10 ) // & \"        [label],\" // achar ( 10 ) // & \"        font_size=14,\" // achar ( 10 ) // & \"        text_color='black',\" // achar ( 10 ) // & \"        show_points=False,\" // achar ( 10 ) // & \"        fill_shape=False,\" // achar ( 10 ) // & \"        shape=None,\" // achar ( 10 ) // & \"    )\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xg.SetVisibility(flag)\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcp_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='red',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 1 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcw_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='yellow',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 2 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xg_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='cyan',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 3 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Points)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 1 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Control geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 2 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xg (Geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 3 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'https://github.com/gha3mi/forcad',\" // achar ( 10 ) // & \"    position=(0.0, 0.0),\" // achar ( 10 ) // & \"    font_size=7,\" // achar ( 10 ) // & \"    color='blue',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_circle ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i ! Define control points for half circle allocate ( Xc ( 5 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xg (:) real ( rk ), intent ( out ), optional :: nearest_Xt integer , intent ( out ), optional :: id integer :: id_ real ( rk ), allocatable :: distances (:) allocate ( distances ( this % ng )) distances = nearest_point_help_1d ( this % ng , this % Xg , point_Xg ) id_ = minloc ( distances , dim = 1 ) if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt real ( rk ), allocatable , intent ( out ), optional :: nearest_Xg (:) real ( rk ) :: xk , obj , grad , hess , dk , alphak , tau , beta , lower_bounds , upper_bounds real ( rk ), allocatable :: Xg (:), Tgc (:), dTgc (:), d2Tgc (:) integer :: k , l logical :: convergenz type ( nurbs_curve ) :: copy_this k = 0 ! lower and upper bounds lower_bounds = minval ( this % knot ) upper_bounds = maxval ( this % knot ) ! guess initial point copy_this = this call copy_this % create ( 10 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! Check if xk is within the knot vector range if ( xk < minval ( this % knot )) then xk = minval ( this % knot ) else if ( xk > maxval ( this % knot )) then xk = maxval ( this % knot ) end if convergenz = . false . allocate ( Xg ( size ( this % Xc , 2 ))) ! allocate(dTgc(size(this%Xc,1))) ! allocate(d2Tgc(size(this%Xc,1))) do while (. not . convergenz . and . k < maxit ) ! objection, gradient and hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc is not needed obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! add a small number to avoid division by zero grad = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc , this % Xc )) hess = dot_product ( matmul ( dTgc , this % Xc ) - ( Xg - point_Xg ) / obj * grad , matmul ( dTgc , this % Xc )) / obj & + dot_product (( Xg - point_Xg ) / obj , matmul ( d2Tgc , this % Xc )) ! debug print '(i3,1x,e20.10,1x,e20.10)' , k , xk , abs ( grad ) if ( abs ( grad ) <= tol ) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else dk = - grad / hess ! Backtracking-Armijo Line Search alphak = 1.0_rk tau = 0.5_rk ! 0 < tau  < 1 beta = 1.0e-4_rk ! 0 < beta < 1 l = 0 do while (. not . norm2 ( this % cmp_Xg ( xk + alphak * dk ) - point_Xg ) <= obj + alphak * beta * grad * dk . and . l < 50 ) alphak = tau * alphak l = l + 1 end do xk = xk + alphak * dk ! Check if xk is within the knot vector range xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== end module forcad_nurbs_curve !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_nurbs_1d ( Xt , knot , degree , nc , ng , Xc , Wc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) real ( rk ), allocatable :: Tgc (:) integer :: i allocate ( Xg ( ng , size ( Xc , 2 ))) allocate ( Tgc ( nc )) !$OMP PARALLEL DO PRIVATE(Tgc) do i = 1 , ng Tgc = basis_bspline ( Xt ( i ), knot , nc , degree ) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg ( i ,:) = matmul ( Tgc , Xc ) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_nurbs_1d_1point ( Xt , knot , degree , nc , Xc , Wc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:) real ( rk ), allocatable :: Tgc (:) allocate ( Xg ( size ( Xc ))) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_bspline_1d ( Xt , knot , degree , nc , ng , Xc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng , size ( Xc , 2 ))) !$OMP PARALLEL DO do i = 1 , ng Xg ( i ,:) = matmul ( basis_bspline ( Xt ( i ), knot , nc , degree ), Xc ) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_bspline_1d_1point ( Xt , knot , degree , nc , Xc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:) allocate ( Xg ( size ( Xc ))) Xg = matmul ( basis_bspline ( Xt , knot , nc , degree ), Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: dBi (:), Bi (:) integer :: i allocate ( dTgc ( ng , nc ), Tgc ( ng , nc ), dBi ( nc ), Bi ( nc )) do i = 1 , size ( Xt ) call basis_bspline_der ( Xt ( i ), knot , nc , degree , dBi , Bi ) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc ( i ,:) = ( dBi * Wc - Tgc ( i ,:) * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: dBi (:), Bi (:) allocate ( dTgc ( nc ), Tgc ( nc )) call basis_bspline_der ( Xt , knot , nc , degree , dBi , Bi ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc = ( dBi * Wc - Tgc * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_bspline_1d_vector ( Xt , knot , degree , nc , ng , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: dBi (:), Bi (:) integer :: i allocate ( dTgc ( ng , nc ), Tgc ( ng , nc ), dBi ( nc ), Bi ( nc )) do i = 1 , size ( Xt ) call basis_bspline_der ( Xt ( i ), knot , nc , degree , dBi , Bi ) Tgc ( i ,:) = Bi dTgc ( i ,:) = dBi end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_bspline_1d_scalar ( Xt , knot , degree , nc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) allocate ( dTgc ( nc ), Tgc ( nc )) call basis_bspline_der ( Xt , knot , nc , degree , dTgc , Tgc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: d2Bi (:), dBi (:), Tgci (:), dTgci (:), Bi (:) integer :: i allocate ( d2Tgc ( ng , nc ), dTgc ( ng , nc ), Tgc ( ng , nc ), d2Bi ( nc ), dTgci ( nc ), dBi ( nc ), Tgci ( nc ), Bi ( nc )) do i = 1 , size ( Xt ) call basis_bspline_2der ( Xt ( i ), knot , nc , degree , d2Bi , dBi , Bi ) Tgci = Bi * ( Wc / ( dot_product ( Bi , Wc ))) Tgc ( i ,:) = Tgci dTgci = ( dBi * Wc - Tgci * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:) = dTgci d2Tgc ( i ,:) = ( d2Bi * Wc - 2.0_rk * dTgci * dot_product ( dBi , Wc ) - Tgci * dot_product ( d2Bi , Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: d2Bi (:), dBi (:), Bi (:) allocate ( d2Tgc ( nc ), dTgc ( nc ), Tgc ( nc ), d2Bi ( nc ), dBi ( nc ), Bi ( nc )) call basis_bspline_2der ( Xt , knot , nc , degree , d2Bi , dBi , Bi ) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dTgc = ( dBi * Wc - Tgc * dot_product ( dBi , Wc ) ) / dot_product ( Bi , Wc ) d2Tgc = ( d2Bi * Wc - 2.0_rk * dTgc * dot_product ( dBi , Wc ) - Tgc * dot_product ( d2Bi , Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_bspline_1d_vector ( Xt , knot , degree , nc , ng , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: d2Tgci (:), dTgci (:), Tgci (:) integer :: i allocate ( d2Tgc ( ng , nc ), dTgc ( ng , nc ), Tgc ( ng , nc ), dTgci ( nc ), Tgci ( nc ), d2Tgci ( nc )) do i = 1 , size ( Xt ) call basis_bspline_2der ( Xt ( i ), knot , nc , degree , d2Tgci , dTgci , Tgci ) Tgc ( i ,:) = Tgci dTgc ( i ,:) = dTgci d2Tgc ( i ,:) = d2Tgci end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_bspline_1d_scalar ( Xt , knot , degree , nc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), allocatable , intent ( out ) :: d2Tgc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) allocate ( d2Tgc ( nc ), dTgc ( nc ), Tgc ( nc )) call basis_bspline_2der ( Xt , knot , nc , degree , d2Tgc , dTgc , Tgc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_nurbs_1d_vector ( Xt , knot , degree , nc , ng , Wc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i allocate ( Tgc ( ng , nc ), Tgci ( nc )) !$OMP PARALLEL DO PRIVATE(Tgci) do i = 1 , size ( Xt , 1 ) Tgci = basis_bspline ( Xt ( i ), knot , nc , degree ) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_nurbs_1d_scalar ( Xt , knot , degree , nc , Wc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_bspline_1d_vector ( Xt , knot , degree , nc , ng ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc integer , intent ( in ) :: ng real ( rk ), allocatable :: Tgc (:,:) integer :: i allocate ( Tgc ( ng , nc )) !$OMP PARALLEL DO do i = 1 , size ( Xt , 1 ) Tgc ( i ,:) = basis_bspline ( Xt ( i ), knot , nc , degree ) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_bspline_1d_scalar ( Xt , knot , degree , nc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline implicit none real ( rk ), intent ( in ) :: Xt real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: degree integer , intent ( in ) :: nc real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc )) Tgc = basis_bspline ( Xt , knot , nc , degree ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function nearest_point_help_1d ( ng , Xg , point_Xg ) result ( distances ) use forcad_utils , only : rk implicit none integer , intent ( in ) :: ng real ( rk ), intent ( in ), contiguous :: Xg (:,:) real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), allocatable :: distances (:) integer :: i allocate ( distances ( ng )) !$OMP PARALLEL DO do i = 1 , ng distances ( i ) = norm2 ( Xg ( i ,:) - point_Xg ) end do !$OMP END PARALLEL DO end function !===============================================================================","tags":"","loc":"sourcefile/forcad_nurbs_curve.f90.html"},{"title":"shape_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_2d.f90~~EfferentGraph sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a ring shape with inner radius 1.0 and outer radius 2.0. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_2d_Xc.vtk' , 'vtk/shape_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_ring_2d.f90.html"},{"title":"shape_C_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_2d.f90~~EfferentGraph sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_2d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_2d_Xc.vtk' , 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_c_2d.f90.html"},{"title":"demo_volume.f90 – ForCAD","text":"This file depends on sourcefile~~demo_volume.f90~~EfferentGraph sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume. !> It sets up control points and weights, generates the volume, and exports the control points !> and the volume to VTK files at various stages. program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"sourcefile/demo_volume.f90.html"},{"title":"shape_half_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_circle.f90~~EfferentGraph sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !> Set up a half circle shape centered at the 0,0,0 with a radius of 1 call shape % set_half_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_circle_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_circle_Xc.vtk' , 'vtk/shape_half_circle_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_half_circle.f90.html"},{"title":"shape_hexahedron.f90 – ForCAD","text":"This file depends on sourcefile~~shape_hexahedron.f90~~EfferentGraph sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_hexahedron use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8]. !> The weights of the control points (Wc) are optional. call shape % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 6 , 8 ]) ! Additional modifications can be made to control points and weights, or the NURBS can be refined using knot insertion or degree elevation. ! call shape%insert_knots(...) ! call shape%elevate_degree(...) ! ... !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_hexahedron_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 8 , 16 , 32 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_hexahedron_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_hexahedron_Xc.vtk' , 'vtk/shape_hexahedron_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_hexahedron.f90.html"},{"title":"shape_C_1d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_1d.f90~~EfferentGraph sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_1d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_1d_Xc.vtk' , 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_c_1d.f90.html"},{"title":"nearest_point_2d_bench.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d_bench.f90~~EfferentGraph sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d_bench use forcad , only : rk , nurbs_surface use fortime implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the surface real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ), allocatable :: points (:,:) integer :: i , j type ( timer ) :: t !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 100 , 100 ) !----------------------------------------------------------------------------- ! Nearest point on the surface !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) do j = 1 , 40 allocate ( points ( j * 1000 , 3 )) print * , j * 1000 call random_number ( points ) call t % timer_start () do concurrent ( i = 1 : size ( points , 1 )) call shape % nearest_point ( points ( i ,:), nearest_Xg , nearest_Xt , id ) end do call t % timer_stop () deallocate ( points ) end do !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () deallocate ( nearest_Xg , nearest_Xt ) end program","tags":"","loc":"sourcefile/nearest_point_2d_bench.f90.html"},{"title":"demo_curve.f90 – ForCAD","text":"This file depends on sourcefile~~demo_curve.f90~~EfferentGraph sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve. !> It sets up control points and weights, generates the curve, and exports the control points !> and the curve to VTK files at various stages. program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","loc":"sourcefile/demo_curve.f90.html"},{"title":"shape_C_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_3d.f90~~EfferentGraph sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk , length = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_3d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 , 10 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_3d_Xc.vtk' , 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_c_3d.f90.html"},{"title":"forcad_nurbs_volume.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_volume.f90~~EfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_volume.f90~~AfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. module forcad_nurbs_volume use forcad_utils , only : rk , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation implicit none private public nurbs_volume !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_volume real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2)*nc(3), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2)*ng(3), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for the control points (1D array: [nc(1)*nc(2)*nc(3)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: Xt3 (:) !! Evaluation parameter values in the third direction (1D array: [ng(3)]) real ( rk ), allocatable , private :: Xt (:,:) !! Evaluation parameter values (2D array: [ng(1)*ng(2)*ng(3), dim] real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) real ( rk ), allocatable , private :: knot3 (:) !! Knot vector in the third direction (1D array) integer , private :: degree ( 3 ) !! Degree (order) of the volume integer , private :: nc ( 3 ) !! Number of control points in each direction integer , private :: ng ( 3 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vectors, control points and weights for the NURBS volume object procedure :: set2 !!> Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier volume using control points and weights generic :: set => set1 , set2 , set3 !!> Set NURBS volume procedure :: create !!> Generate geometry points procedure :: cmp_Xg !!> Compute geometry points procedure , private :: get_Xc_all !!> Get all control points procedure , private :: get_Xci !!> Get i-th control point procedure , private :: get_Xcid !!> Get i-th control point in a specific direction generic :: get_Xc => get_Xc_all , get_Xci , get_Xcid !!> Get control points procedure , private :: get_Xg_all !!> Get all geometry points procedure , private :: get_Xgi !!> Get i-th geometry point procedure , private :: get_Xgid !!> Get i-th geometry point in a specific direction generic :: get_Xg => get_Xg_all , get_Xgi , get_Xgid !!> Get geometry points procedure , private :: get_Wc_all !!> Get all weights procedure , private :: get_Wci !!> Get i-th weight generic :: get_Wc => get_Wc_all , get_Wci !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: cmp_degree !!> Compute degree of the NURBS volume procedure , private :: get_degree_all !!> Get degree of the NURBS volume in all directions procedure , private :: get_degree_dir !!> Get degree of the NURBS volume in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS volume procedure :: finalize !!> Finalize the NURBS volume object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Compute and return the multiplicity of the knots procedure :: get_continuity !!> Compute and return the continuity of the NURBS volume procedure :: cmp_nc !!> Compute number of required control points procedure , private :: basis_vector !!> Compute the basis functions of the NURBS volume procedure , private :: basis_scalar !!> Compute the basis functions of the NURBS volume generic :: basis => basis_vector , basis_scalar !!> Compute the basis functions of the NURBS volume procedure , private :: derivative_vector !!> Compute the derivative of the NURBS volume procedure , private :: derivative_scalar !!> Compute the derivative of the NURBS volume generic :: derivative => derivative_vector , derivative_scalar !!> Compute the derivative of the NURBS volume procedure , private :: derivative2_vector !!> Compute the second derivative of the NURBS volume procedure , private :: derivative2_scalar !!> Compute the second derivative of the NURBS volume generic :: derivative2 => derivative2_vector , derivative2_scalar !!> Compute the second derivative of the NURBS volume procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the NURBS volume procedure :: is_rational !!> Check if the NURBS volume is rational procedure :: put_to_nurbs !!> Put a shape to a NURBS volume procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points procedure :: show !!> Show the NURBS object using PyVista procedure :: nearest_point !!> Find the nearest point on the NURBS volume (Approximation) procedure :: nearest_point2 !!> Find the nearest point on the NURBS volume (Minimization - Newton's method) ! Faces procedure :: cmp_elemFace_Xc_vis !!> Compute faces of the control points procedure :: cmp_elemFace_Xg_vis !!> Compute faces of the geometry points procedure :: cmp_elemFace !!> Compute faces of the IGA elements procedure :: cmp_degreeFace !!> Compute degrees of the faces ! Shapes procedure :: set_hexahedron !!> Set a hexahedron procedure :: set_ring !!> Set a ring procedure :: set_half_ring !!> Set a half ring procedure :: set_C !!> Set a C-shape end type !=============================================================================== interface compute_Xg pure function compute_Xg_nurbs_3d ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng , f_Xc , f_Wc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Xg (:,:) end function pure function compute_Xg_bspline_3d ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng , f_Xc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), allocatable :: f_Xg (:,:) end function pure function compute_Xg_nurbs_3d_1point ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_Xc , f_Wc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Xg (:) end function pure function compute_Xg_bspline_3d_1point ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_Xc ) result ( f_Xg ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Xc (:,:) real ( rk ), allocatable :: f_Xg (:) end function end interface interface compute_dTgc pure subroutine compute_dTgc_nurbs_3d_vector ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng , f_Wc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_dTgc_bspline_3d_vector ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_dTgc_nurbs_3d_scalar ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_Wc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine pure subroutine compute_dTgc_bspline_3d_scalar ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine end interface interface compute_d2Tgc pure subroutine compute_d2Tgc_nurbs_3d_vector (& f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng , f_Wc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_d2Tgc_bspline_3d_vector (& f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:,:) end subroutine pure subroutine compute_d2Tgc_nurbs_3d_scalar ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_Wc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine pure subroutine compute_d2Tgc_bspline_3d_scalar ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_d2Tgc , f_dTgc , f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), allocatable , intent ( out ) :: f_d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: f_Tgc (:) end subroutine end interface interface compute_Tgc pure function compute_Tgc_nurbs_3d_vector ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng , f_Wc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Tgc (:,:) end function pure function compute_Tgc_bspline_3d_vector ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_ng ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:,:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), allocatable :: f_Tgc (:,:) end function pure function compute_Tgc_nurbs_3d_scalar ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc , f_Wc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Wc (:) real ( rk ), allocatable :: f_Tgc (:) end function pure function compute_Tgc_bspline_3d_scalar ( f_Xt , f_knot1 , f_knot2 , f_knot3 , f_degree , f_nc ) result ( f_Tgc ) import :: rk real ( rk ), intent ( in ), contiguous :: f_Xt (:) real ( rk ), intent ( in ), contiguous :: f_knot1 (:), f_knot2 (:), f_knot3 (:) integer , intent ( in ) :: f_degree ( 3 ) integer , intent ( in ) :: f_nc ( 3 ) real ( rk ), allocatable :: f_Tgc (:) end function end interface interface pure function nearest_point_help_3d ( f_ng , f_Xg , f_point_Xg ) result ( f_distances ) import :: rk integer , intent ( in ) :: f_ng ( 3 ) real ( rk ), intent ( in ), contiguous :: f_Xg (:,:) real ( rk ), intent ( in ), contiguous :: f_point_Xg (:) real ( rk ), allocatable :: f_distances (:) end function end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set1 ( this , knot1 , knot2 , knot3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot1 = knot1 this % knot2 = knot2 this % knot3 = knot3 call this % cmp_degree () call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , Xth_dir3 , degree , continuity1 , continuity2 , continuity3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:), Xth_dir3 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:), continuity3 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % knot3 = compute_knot_vector ( Xth_dir3 , degree ( 3 ), continuity3 ) this % degree ( 1 ) = degree ( 1 ) this % degree ( 2 ) = degree ( 2 ) this % degree ( 3 ) = degree ( 3 ) call this % cmp_nc () this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier volume using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) allocate ( this % knot1 ( 2 * this % nc ( 1 ))) this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) allocate ( this % knot2 ( 2 * this % nc ( 2 ))) this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) allocate ( this % knot3 ( 2 * this % nc ( 3 ))) this % knot3 ( 1 : this % nc ( 3 )) = 0.0_rk this % knot3 ( this % nc ( 3 ) + 1 : 2 * this % nc ( 3 )) = 1.0_rk call this % cmp_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Xt ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), intent ( in ), contiguous , optional :: Xt (:,:) integer :: i ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 ) . or . . not . allocated ( this % knot3 )) then error stop 'Knot vector(s) is/are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if if ( present ( Xt )) then this % Xt = Xt else ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , this % Xt ) end if if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), size ( this % Xc , 2 ))) if ( this % is_rational ()) then ! NURBS this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Xc , this % Wc ) else ! B-Spline this % Xg = compute_Xg (& this % Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Xc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_Xg ( this , Xt ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable :: Xg (:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % knot1 ) . or . . not . allocated ( this % knot2 ) . or . . not . allocated ( this % knot3 )) then error stop 'Knot vector(s) is/are not set.' end if if ( this % is_rational ()) then ! NURBS Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Xc , this % Wc ) else ! B-Spline Xg = compute_Xg ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Xc ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc_all ( this ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xci ( this , n ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xc (:) if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if Xc = this % Xc ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xcid ( this , n , dir ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xc if ( allocated ( this % Xc )) then if ( n < lbound ( this % Xc , 1 ) . or . n > ubound ( this % Xc , 1 )) then error stop 'Invalid index for control points.' end if if ( dir < lbound ( this % Xc , 2 ) . or . dir > ubound ( this % Xc , 2 )) then error stop 'Invalid direction for control points.' end if Xc = this % Xc ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg_all ( this ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgi ( this , n ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ), allocatable :: Xg (:) if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if Xg = this % Xg ( n ,:) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xgid ( this , n , dir ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n integer , intent ( in ) :: dir real ( rk ) :: Xg if ( allocated ( this % Xg )) then if ( n < lbound ( this % Xg , 1 ) . or . n > ubound ( this % Xg , 1 )) then error stop 'Invalid index for geometry points.' end if if ( dir < lbound ( this % Xg , 2 ) . or . dir > ubound ( this % Xg , 2 )) then error stop 'Invalid direction for geometry points.' end if Xg = this % Xg ( n , dir ) else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc_all ( this ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS volume is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wci ( this , n ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: n real ( rk ) :: Wc if ( allocated ( this % Wc )) then if ( n < lbound ( this % Wc , 1 ) . or . n > ubound ( this % Wc , 1 )) then error stop 'Invalid index for weights.' end if Wc = this % Wc ( n ) else error stop 'The NURBS volume is not rational or weights are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % Xt3 )) then Xt = this % Xt3 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_volume ), intent ( in ) :: this integer :: ng ( 3 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_degree ( this , dir ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: dir integer , allocatable :: m1 (:), m2 (:), m3 (:) if ( present ( dir )) then if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 else if ( dir == 3 ) then m3 = this % get_multiplicity ( 3 ) this % degree ( 3 ) = m3 ( 1 ) - 1 else error stop 'Invalid direction for degree.' end if else m1 = this % get_multiplicity ( 1 ) this % degree ( 1 ) = m1 ( 1 ) - 1 m2 = this % get_multiplicity ( 2 ) this % degree ( 2 ) = m2 ( 1 ) - 1 m3 = this % get_multiplicity ( 3 ) this % degree ( 3 ) = m3 ( 1 ) - 1 end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer :: degree ( 3 ) degree ( 1 ) = this % degree ( 1 ) degree ( 2 ) = this % degree ( 2 ) degree ( 3 ) = this % degree ( 3 ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree if ( dir == 1 ) then degree = this % degree ( 1 ) else if ( dir == 2 ) then degree = this % degree ( 2 ) else if ( dir == 3 ) then degree = this % degree ( 3 ) else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then knot = this % knot3 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then if ( i < 1 . or . i > size ( this % knot3 )) then error stop 'Invalid index for knot vector.' else knot = this % knot3 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_volume ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X if ( allocated ( this % Wc )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc ()) end if else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W if ( allocated ( this % knot1 ) . and . allocated ( this % knot2 ) . and . allocated ( this % knot3 )) then call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ),& Xc = this % get_Xc (), Wc = this % get_Wc ()) else call this % set ( nc = this % nc , Xc = this % get_Xc (), Wc = this % get_Wc ()) end if else error stop 'The NURBS volume is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else c = this % degree ( 3 ) - compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_nc ( this , dir ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: dir if ( present ( dir )) then if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else this % nc ( 3 ) = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if else error stop 'Invalid direction.' end if else ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else this % nc ( 1 ) = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else this % nc ( 2 ) = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else this % nc ( 3 ) = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this , dir ) result ( nc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc , dTgc , Tgc ) else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative_scalar ( this , Xt , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc , dTgc , Tgc ) else call compute_dTgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , d2Tgc , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc , d2Tgc , dTgc , Tgc ) else call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative2_scalar ( this , Xt , d2Tgc , dTgc , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: dTgc (:,:) real ( rk ), allocatable , intent ( out ), optional :: Tgc (:) if ( this % is_rational ()) then ! NURBS call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc , d2Tgc , dTgc , Tgc ) else call compute_d2Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , d2Tgc , dTgc , Tgc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_vector ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) integer :: i real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng , this % Wc ) else Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % ng ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_scalar ( this , Xt , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) if ( this % is_rational ()) then ! NURBS Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc , this % Wc ) else Tgc = compute_Tgc ( Xt , this % knot1 , this % knot2 , this % knot3 , this % degree , this % nc ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xcw_new = reshape ( Xcw_new ,[( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 :( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 :( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , ( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc_new = reshape ( Xc_new ,[( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), dim ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end do end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc4 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc4 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end do end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 3 ),& this % knot3 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc4 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ))) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 3 ),& this % knot3 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc4 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , dim ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new ) end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) integer :: nc_new , dim , j real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , nc_new , knot_new , Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ nc_new * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : nc_new * this % nc ( 2 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : nc_new * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , nc_new * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , nc_new , knot_new , Xc_new ) Xc_new = reshape ( Xc_new ,[ nc_new * this % nc ( 2 ) * this % nc ( 3 ), dim ], order = [ 1 , 2 ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 )]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , nc_new , knot_new , Xcw_new ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * nc_new * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * nc_new * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * nc_new * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * nc_new * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , nc_new , knot_new , Xc_new ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * nc_new * this % nc ( 3 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 )]) call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xcw , nc_new , knot_new , Xcw_new ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * nc_new , dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * nc_new , 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * nc_new )) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * nc_new Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xc , nc_new , knot_new , Xc_new ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * nc_new , dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new ) end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_volume ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_hexahedron ( this , L , nc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: L (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( present ( Wc )) then call this % set ( nc , hexahedron_Xc ( L , nc ), Wc ) else call this % set ( nc , hexahedron_Xc ( L , nc )) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine put_to_nurbs ( this , X , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: X (:,:) integer , intent ( in ), contiguous :: elemConn (:,:) integer :: i real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:), Tgc3 (:), Tgc (:) real ( rk ), allocatable :: Xt (:,:) real ( rk ) :: min_X1 , max_X1 , min_X2 , max_X2 , min_X3 , max_X3 ! Assuming knot vectors are in the range [0,1] ! Normalize the X coordinates to the range [0,1] allocate ( Xt ( size ( X , 1 ), size ( X , 2 ))) min_X1 = minval ( X (:, 1 )) max_X1 = maxval ( X (:, 1 )) min_X2 = minval ( X (:, 2 )) max_X2 = maxval ( X (:, 2 )) min_X3 = minval ( X (:, 3 )) max_X3 = maxval ( X (:, 3 )) Xt (:, 1 ) = ( X (:, 1 ) - min_X1 ) / ( max_X1 - min_X1 ) Xt (:, 2 ) = ( X (:, 2 ) - min_X2 ) / ( max_X2 - min_X2 ) Xt (:, 3 ) = ( X (:, 3 ) - min_X3 ) / ( max_X3 - min_X3 ) allocate ( this % Xg ( size ( Xt , 1 ), size ( this % Xc , 2 ))) allocate ( Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) this % Xg ( i ,:) = matmul ( Tgc , this % Xc ) end do else ! B-Spline volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) this % Xg ( i ,:) = matmul ( Tgc , this % Xc ) end do end if call this % set_elem_Xg_vis ( elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , ( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc_new = reshape ( Xc_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), dim ]) call this % set ( knot1 = knot_new , knot2 = this % get_knot ( 2 ), knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = knot_new , knot3 = this % get_knot ( 3 ), Xc = Xc_new ) end if end do end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 )]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), dim ]) call this % set ( knot1 = this % get_knot ( 1 ), knot2 = this % get_knot ( 2 ), knot3 = knot_new , Xc = Xc_new ) end if end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ),& this % degree ( 1 ), this % degree ( 2 ), this % degree ( 3 ),& unique ( this % knot1 ), unique ( this % knot2 ), unique ( this % knot3 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ), this % get_multiplicity ( 3 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine show ( this , vtkfile_Xc , vtkfile_Xg ) class ( nurbs_volume ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: vtkfile_Xc , vtkfile_Xg character ( len = 3000 ) :: pyvista_script pyvista_script = & \"import pyvista as pv\" // achar ( 10 ) // & \"pv.global_theme.color = 'white'\" // achar ( 10 ) // & \"Xc = pv.read('\" // trim ( vtkfile_Xc ) // \"')\" // achar ( 10 ) // & \"Xg = pv.read('\" // trim ( vtkfile_Xg ) // \"')\" // achar ( 10 ) // & \"p = pv.Plotter(lighting='light kit')\" // achar ( 10 ) // & \"actor_Xcp = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    style='points',\" // achar ( 10 ) // & \"    point_size=10,\" // achar ( 10 ) // & \"    color='red',\" // achar ( 10 ) // & \"    render_points_as_spheres=True,\" // achar ( 10 ) // & \"    opacity=0.5,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xcw = p.add_mesh(\" // achar ( 10 ) // & \"    Xc,\" // achar ( 10 ) // & \"    show_edges=True,\" // achar ( 10 ) // & \"    color='yellow',\" // achar ( 10 ) // & \"    line_width=3,\" // achar ( 10 ) // & \"    style='wireframe',\" // achar ( 10 ) // & \"    opacity=0.2\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"actor_Xg = p.add_mesh(\" // achar ( 10 ) // & \"    Xg,\" // achar ( 10 ) // & \"    show_edges=False,\" // achar ( 10 ) // & \"    color='cyan',\" // achar ( 10 ) // & \"    line_width=7,\" // achar ( 10 ) // & \"    metallic=0.6,\" // achar ( 10 ) // & \"    pbr=True,\" // achar ( 10 ) // & \"    split_sharp_edges=True,\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_axes(interactive=False)\" // achar ( 10 ) // & \"def point_picker_callback(point):\" // achar ( 10 ) // & \"    mesh = Xc\" // achar ( 10 ) // & \"    point_id = mesh.find_closest_point(point)\" // achar ( 10 ) // & \"    point_coords = mesh.points[point_id]\" // achar ( 10 ) // & \"    label = f'ID: {point_id + 1}\\n({point_coords[0]:.3f}, {point_coords[1]:.3f}, {point_coords[2]:.3f})'\" // achar ( 10 ) // & \"    p.add_point_labels(\" // achar ( 10 ) // & \"        [point_coords],\" // achar ( 10 ) // & \"        [label],\" // achar ( 10 ) // & \"        font_size=14,\" // achar ( 10 ) // & \"        text_color='black',\" // achar ( 10 ) // & \"        show_points=False,\" // achar ( 10 ) // & \"        fill_shape=False,\" // achar ( 10 ) // & \"        shape=None,\" // achar ( 10 ) // & \"    )\" // achar ( 10 ) // & \"picker = p.enable_point_picking(callback=point_picker_callback, show_message=False)\" // achar ( 10 ) // & \"window_size = p.window_size\" // achar ( 10 ) // & \"y_pos = window_size[1]\" // achar ( 10 ) // & \"def Xcp_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcp.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xcw_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xcw.SetVisibility(flag)\" // achar ( 10 ) // & \"def Xg_toggle_vis(flag):\" // achar ( 10 ) // & \"    actor_Xg.SetVisibility(flag)\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcp_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='red',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 1 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xcw_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='yellow',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 2 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_checkbox_button_widget(\" // achar ( 10 ) // & \"    Xg_toggle_vis,\" // achar ( 10 ) // & \"    value=True,\" // achar ( 10 ) // & \"    color_on='cyan',\" // achar ( 10 ) // & \"    size=25,\" // achar ( 10 ) // & \"    position=(0, y_pos - 3 * 25),\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Points)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 1 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xc (Control geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 2 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'Xg (Geometry)',\" // achar ( 10 ) // & \"    position=(25 + 3, y_pos - 3 * 25),\" // achar ( 10 ) // & \"    font_size=8,\" // achar ( 10 ) // & \"    color='black',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.add_text('ForCAD', position=(0.0, 10.0), font_size=14, color='black', font='times')\" // achar ( 10 ) // & \"p.add_text(\" // achar ( 10 ) // & \"    'https://github.com/gha3mi/forcad',\" // achar ( 10 ) // & \"    position=(0.0, 0.0),\" // achar ( 10 ) // & \"    font_size=7,\" // achar ( 10 ) // & \"    color='blue',\" // achar ( 10 ) // & \"    font='times',\" // achar ( 10 ) // & \")\" // achar ( 10 ) // & \"p.show(title='ForCAD', interactive=True)\" call execute_command_line ( 'python -c \"' // trim ( adjustl ( pyvista_script )) // '\"' ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_ring ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i ! Define control points for ring allocate ( Xc ( 28 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 7 , 1 : 2 ) = Xc ( 1 : 7 , 1 : 2 ) * radius1 Xc ( 8 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 11 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 12 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 13 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 14 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 8 : 14 , 1 : 2 ) = Xc ( 8 : 14 , 1 : 2 ) * radius2 Xc ( 15 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 16 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 17 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 18 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 19 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 20 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), length ] Xc ( 21 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 15 : 21 , 1 : 2 ) = Xc ( 15 : 21 , 1 : 2 ) * radius1 Xc ( 22 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 23 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 24 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 25 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 26 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 27 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), length ] Xc ( 28 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 22 : 28 , 1 : 2 ) = Xc ( 22 : 28 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_C ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i ! Define control points for C-shape allocate ( Xc ( 20 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 8 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 Xc ( 11 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 12 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 13 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 14 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 15 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 11 : 15 , 1 : 2 ) = Xc ( 11 : 15 , 1 : 2 ) * radius1 Xc ( 16 ,:) = [ 1.0_rk , 0.0_rk , length ] Xc ( 17 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), length ] Xc ( 18 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 19 ,:) = [ - 2.0_rk , 0.0_rk , length ] Xc ( 20 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , length ] Xc ( 16 : 20 , 1 : 2 ) = Xc ( 16 : 20 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ,& 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_half_ring ( this , center , radius1 , radius2 , length ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius1 , radius2 , length real ( rk ), allocatable :: Xc (:,:), Wc (:), knot1 (:), knot2 (:), knot3 (:) integer :: i ! Define control points for half ring allocate ( Xc ( 20 , 3 )) Xc ( 1 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 1 : 5 , 1 : 2 ) = Xc ( 1 : 5 , 1 : 2 ) * radius1 Xc ( 6 ,:) = [ 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 7 ,:) = [ 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 8 ,:) = [ 0.0_rk , 0.5_rk , 0.0_rk ] Xc ( 9 ,:) = [ - 0.5_rk , 0.5_rk , 0.0_rk ] Xc ( 10 ,:) = [ - 0.5_rk , 0.0_rk , 0.0_rk ] Xc ( 6 : 10 , 1 : 2 ) = Xc ( 6 : 10 , 1 : 2 ) * radius2 Xc ( 11 ,:) = [ 0.5_rk , 0.0_rk , length ] Xc ( 12 ,:) = [ 0.5_rk , 0.5_rk , length ] Xc ( 13 ,:) = [ 0.0_rk , 0.5_rk , length ] Xc ( 14 ,:) = [ - 0.5_rk , 0.5_rk , length ] Xc ( 15 ,:) = [ - 0.5_rk , 0.0_rk , length ] Xc ( 11 : 15 , 1 : 2 ) = Xc ( 11 : 15 , 1 : 2 ) * radius1 Xc ( 16 ,:) = [ 0.5_rk , 0.0_rk , length ] Xc ( 17 ,:) = [ 0.5_rk , 0.5_rk , length ] Xc ( 18 ,:) = [ 0.0_rk , 0.5_rk , length ] Xc ( 19 ,:) = [ - 0.5_rk , 0.5_rk , length ] Xc ( 20 ,:) = [ - 0.5_rk , 0.0_rk , length ] Xc ( 16 : 20 , 1 : 2 ) = Xc ( 16 : 20 , 1 : 2 ) * radius2 ! Translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) end do ! Define weights for the control points Wc = [ 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ,& 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk , 1.0_rk / sqrt ( 2.0_rk ), 1.0_rk ] ! Define knot vector knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 2.0_rk , & 1.0_rk / 2.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot1 , knot2 , knot3 , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine nearest_point ( this , point_Xg , nearest_Xg , nearest_Xt , id ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xg (:) real ( rk ), intent ( out ), allocatable , optional :: nearest_Xt (:) integer , intent ( out ), optional :: id integer :: id_ real ( rk ), allocatable :: distances (:) allocate ( distances ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ))) distances = nearest_point_help_3d ( this % ng , this % Xg , point_Xg ) id_ = minloc ( distances , dim = 1 ) if ( present ( id )) id = id_ if ( present ( nearest_Xg )) nearest_Xg = this % Xg ( id_ ,:) if ( present ( nearest_Xt )) nearest_Xt = this % Xt ( id_ ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine nearest_point2 ( this , point_Xg , tol , maxit , nearest_Xt , nearest_Xg ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: point_Xg (:) real ( rk ), intent ( in ) :: tol integer , intent ( in ) :: maxit real ( rk ), intent ( out ) :: nearest_Xt ( 3 ) real ( rk ), allocatable , intent ( out ), optional :: nearest_Xg (:) real ( rk ) :: obj , grad ( 3 ), hess ( 3 , 3 ), dk ( 3 ), alphak , tau , beta , det_inv , Ainv ( 3 , 3 ), lower_bounds ( 3 ), upper_bounds ( 3 ) real ( rk ), allocatable :: Xg (:), xk (:), Tgc (:), dTgc (:,:), d2Tgc (:,:) integer :: k , l logical :: convergenz type ( nurbs_volume ) :: copy_this k = 0 ! lower and upper bounds lower_bounds = [ minval ( this % knot1 ), minval ( this % knot2 ), minval ( this % knot3 )] upper_bounds = [ maxval ( this % knot1 ), maxval ( this % knot2 ), maxval ( this % knot3 )] ! guess initial point copy_this = this call copy_this % create ( 50 , 50 , 50 ) call copy_this % nearest_point ( point_Xg = point_Xg , nearest_Xt = xk ) call copy_this % finalize () ! Check if xk is within the knot vector range if ( xk ( 1 ) < minval ( this % knot1 )) then xk ( 1 ) = minval ( this % knot1 ) else if ( xk ( 1 ) > maxval ( this % knot1 )) then xk ( 1 ) = maxval ( this % knot1 ) end if if ( xk ( 2 ) < minval ( this % knot2 )) then xk ( 2 ) = minval ( this % knot2 ) else if ( xk ( 2 ) > maxval ( this % knot2 )) then xk ( 2 ) = maxval ( this % knot2 ) end if if ( xk ( 3 ) < minval ( this % knot3 )) then xk ( 3 ) = minval ( this % knot3 ) else if ( xk ( 3 ) > maxval ( this % knot3 )) then xk ( 3 ) = maxval ( this % knot3 ) end if convergenz = . false . allocate ( Xg ( size ( this % Xc , 2 ))) ! allocate(dTgc(size(this%Xc,1), 2)) ! allocate(d2Tgc(size(this%Xc,1), 2)) do while (. not . convergenz . and . k < maxit ) ! objection, gradient and hessian Xg = this % cmp_Xg ( xk ) call this % derivative2 ( Xt = xk , d2Tgc = d2Tgc , dTgc = dTgc , Tgc = Tgc ) ! Tgc is not needed obj = norm2 ( Xg - point_Xg ) + 0.001_rk ! add a small number to avoid division by zero grad ( 1 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 1 ), this % Xc )) grad ( 2 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 2 ), this % Xc )) grad ( 3 ) = dot_product (( Xg - point_Xg ) / obj , matmul ( dTgc (:, 3 ), this % Xc )) hess ( 1 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 2 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 3 , 1 ) = ( dot_product ( matmul ( dTgc (:, 1 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 1 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 1 ) ) / obj ** 2 hess ( 1 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 2 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 3 , 2 ) = ( dot_product ( matmul ( dTgc (:, 2 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 2 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 2 ) ) / obj ** 2 hess ( 1 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 1 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 1 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 hess ( 2 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 2 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 2 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 hess ( 3 , 3 ) = ( dot_product ( matmul ( dTgc (:, 3 ), this % Xc ), matmul ( dTgc (:, 3 ), this % Xc )) + dot_product (( Xg - point_Xg ), & matmul ( d2Tgc ( 2 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) + 1 : 3 * this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) , 3 ), this % Xc )) ) / obj & - ( dot_product ( Xg - point_Xg , matmul ( dTgc (:, 3 ), this % Xc )) * grad ( 3 ) ) / obj ** 2 ! debug print '(i3,1x,3e20.10,1x,e20.10)' , k , xk , norm2 ( grad ) if ( norm2 ( grad ) <= tol ) then convergenz = . true . nearest_Xt = xk if ( present ( nearest_Xg )) nearest_Xg = this % cmp_Xg ( nearest_Xt ) else ! Inverse of Hessian det_inv = 1.0_rk / (& + hess ( 1 , 1 ) * hess ( 2 , 2 ) * hess ( 3 , 3 ) - hess ( 1 , 1 ) * hess ( 2 , 3 ) * hess ( 3 , 2 )& - hess ( 1 , 2 ) * hess ( 2 , 1 ) * hess ( 3 , 3 ) + hess ( 1 , 2 ) * hess ( 2 , 3 ) * hess ( 3 , 1 )& + hess ( 1 , 3 ) * hess ( 2 , 1 ) * hess ( 3 , 2 ) - hess ( 1 , 3 ) * hess ( 2 , 2 ) * hess ( 3 , 1 )) Ainv ( 1 , 1 ) = + ( hess ( 2 , 2 ) * hess ( 3 , 3 ) - hess ( 2 , 3 ) * hess ( 3 , 2 )) Ainv ( 2 , 1 ) = - ( hess ( 2 , 1 ) * hess ( 3 , 3 ) - hess ( 2 , 3 ) * hess ( 3 , 1 )) Ainv ( 3 , 1 ) = + ( hess ( 2 , 1 ) * hess ( 3 , 2 ) - hess ( 2 , 2 ) * hess ( 3 , 1 )) Ainv ( 1 , 2 ) = - ( hess ( 1 , 2 ) * hess ( 3 , 3 ) - hess ( 1 , 3 ) * hess ( 3 , 2 )) Ainv ( 2 , 2 ) = + ( hess ( 1 , 1 ) * hess ( 3 , 3 ) - hess ( 1 , 3 ) * hess ( 3 , 1 )) Ainv ( 3 , 2 ) = - ( hess ( 1 , 1 ) * hess ( 3 , 2 ) - hess ( 1 , 2 ) * hess ( 3 , 1 )) Ainv ( 1 , 3 ) = + ( hess ( 1 , 2 ) * hess ( 2 , 3 ) - hess ( 1 , 3 ) * hess ( 2 , 2 )) Ainv ( 2 , 3 ) = - ( hess ( 1 , 1 ) * hess ( 2 , 3 ) - hess ( 1 , 3 ) * hess ( 2 , 1 )) Ainv ( 3 , 3 ) = + ( hess ( 1 , 1 ) * hess ( 2 , 2 ) - hess ( 1 , 2 ) * hess ( 2 , 1 )) Ainv = det_inv * Ainv dk = - matmul ( Ainv , grad ) ! Backtracking-Armijo Line Search alphak = 1.0_rk tau = 0.5_rk ! 0 < tau  < 1 beta = 1.0e-4_rk ! 0 < beta < 1 l = 0 do while (. not . norm2 ( this % cmp_Xg ( xk + alphak * dk ) - point_Xg ) <= obj + alphak * beta * dot_product ( grad , dk ) . and . l < 50 ) alphak = tau * alphak l = l + 1 end do xk = xk + alphak * dk ! Check if xk is within the knot vector range xk = max ( min ( xk , upper_bounds ), lower_bounds ) k = k + 1 end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k !> number of nodes in each direction n = this % degree + 1 select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace_Xc_vis ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k !> number of nodes in each direction n = [ 2 , 2 , 2 ] select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xc_vis ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xc_vis ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemFace_Xg_vis ( this , elem , face ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: elem integer , intent ( in ) :: face integer , allocatable :: elemConn (:) integer :: n ( 3 ), ii , jj , k !> number of nodes in each direction n = [ 2 , 2 , 2 ] select case ( face ) case ( 1 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xg_vis ( elem , 1 : n ( 1 ) * n ( 2 )) case ( 2 ) allocate ( elemConn ( n ( 1 ) * n ( 2 ))) elemConn = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * n ( 3 ) - n ( 1 ) * n ( 2 ) + 1 : n ( 1 ) * n ( 2 ) * n ( 3 )) case ( 3 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 ) * n ( 2 )) end do end do case ( 4 ) allocate ( elemConn ( n ( 1 ) * n ( 3 ))) k = 0 do jj = 1 , n ( 3 ) do ii = 1 , n ( 1 ) k = k + 1 elemConn ( k ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * n ( 2 ) * jj + ii - n ( 1 )) end do end do case ( 5 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * ii - n ( 1 ) + 1 ) end do case ( 6 ) allocate ( elemConn ( n ( 2 ) * n ( 3 ))) do ii = 1 , n ( 2 ) * n ( 3 ) elemConn ( ii ) = this % elemConn_Xg_vis ( elem , n ( 1 ) * ii ) end do end select end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_degreeFace ( this , face ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: face integer :: degree ( 3 ) select case ( face ) case ( 1 ) degree = [ this % degree ( 1 ), this % degree ( 2 ), 0 ] case ( 2 ) degree = [ this % degree ( 1 ), this % degree ( 2 ), 0 ] case ( 3 ) degree = [ this % degree ( 1 ), 0 , this % degree ( 3 )] case ( 4 ) degree = [ this % degree ( 1 ), 0 , this % degree ( 3 )] case ( 5 ) degree = [ 0 , this % degree ( 2 ), this % degree ( 3 )] case ( 6 ) degree = [ 0 , this % degree ( 2 ), this % degree ( 3 )] case default error stop 'Invalid face number' end select end function !=============================================================================== end module forcad_nurbs_volume !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_nurbs_3d ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Xc , Wc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:,:) real ( rk ), allocatable :: Tgc (:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), size ( Xc , 2 ))) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) !$OMP PARALLEL DO PRIVATE(Tgc) do i = 1 , ng ( 1 ) * ng ( 2 ) * ng ( 3 ) Tgc = kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )),& kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg ( i ,:) = matmul ( Tgc , Xc ) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_nurbs_3d_1point ( Xt , knot1 , knot2 , knot3 , degree , nc , Xc , Wc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Xg (:) real ( rk ), allocatable :: Tgc (:) allocate ( Xg ( size ( Xc , 2 ))) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )),& kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) Xg = matmul ( Tgc , Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_bspline_3d ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Xc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:,:) integer :: i allocate ( Xg ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), size ( Xc , 2 ))) !$OMP PARALLEL DO do i = 1 , ng ( 1 ) * ng ( 2 ) * ng ( 3 ) Xg ( i ,:) = matmul ( kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))),& Xc ) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Xg_bspline_3d_1point ( Xt , knot1 , knot2 , knot3 , degree , nc , Xc ) result ( Xg ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), allocatable :: Xg (:) allocate ( Xg ( size ( Xc , 2 ))) Xg = matmul ( kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))),& Xc ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: dBi (:,:), dB1 (:), dB2 (:), dB3 (:) real ( rk ), allocatable :: Bi (:), B1 (:), B2 (:), B3 (:) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) do i = 1 , size ( Xt , 1 ) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: dB1 (:), dB2 (:), dB3 (:), dBi (:,:) real ( rk ), allocatable :: B1 (:), B2 (:), B3 (:), Bi (:) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: dB1 (:), dB2 (:), dB3 (:) real ( rk ), allocatable :: B1 (:), B2 (:), B3 (:) integer :: i allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) !$OMP PARALLEL DO PRIVATE(dB1, dB2, dB3) do i = 1 , size ( Xt , 1 ) call basis_bspline_der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Tgc ( i ,:) = kron ( B3 , kron ( B2 , B1 )) dTgc ( i ,:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc ( i ,:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc ( i ,:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) end do !$OMP END PARALLEL DO end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_dTgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: dB1 (:), dB2 (:), dB3 (:) real ( rk ), allocatable :: B1 (:), B2 (:), B3 (:) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), dB1 , B1 ) call basis_bspline_der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), dB2 , B2 ) call basis_bspline_der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), dB3 , B3 ) Tgc = kron ( B3 , kron ( B2 , B1 )) dTgc (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: d2Bi (:,:), d2B1 (:), d2B2 (:), d2B3 (:) real ( rk ), allocatable :: dBi (:,:), dB1 (:), dB2 (:), dB3 (:) real ( rk ), allocatable :: Bi (:), B1 (:), B2 (:), B3 (:) real ( rk ), allocatable :: Tgci (:), dTgci (:) integer :: i allocate ( B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 ))) allocate ( dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 ))) allocate ( d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), d2Bi ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dTgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) do i = 1 , size ( Xt , 1 ) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc ( i ,:) = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc ( i ,:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc ( i ,:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc ( i ,:) * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - 2.0_rk * dTgc ( i , :, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - 2.0_rk * dTgc ( i , :, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc ( i , :, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc ( i , :, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc ( i , :, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - 2.0_rk * dTgc ( i , :, 3 ) * dot_product ( dBi (:, 3 ), Wc ) & - Tgc ( i ,:) * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: d2Bi (:,:), d2B1 (:), d2B2 (:), d2B3 (:) real ( rk ), allocatable :: dBi (:,:), dB1 (:), dB2 (:), dB3 (:) real ( rk ), allocatable :: Bi (:), B1 (:), B2 (:), B3 (:) allocate ( B1 ( nc ( 1 )), B2 ( nc ( 2 )), B3 ( nc ( 3 ))) allocate ( dB1 ( nc ( 1 )), dB2 ( nc ( 2 )), dB3 ( nc ( 3 ))) allocate ( d2B1 ( nc ( 1 )), d2B2 ( nc ( 2 )), d2B3 ( nc ( 3 ))) allocate ( Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 )), dBi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 ), d2Bi ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( d2Tgc ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Bi = kron ( B3 , kron ( B2 , B1 )) Tgc = Bi * ( Wc / ( dot_product ( Bi , Wc ))) dBi (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dBi (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dBi (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) dTgc (:, 1 ) = ( dBi (:, 1 ) * Wc - Tgc * dot_product ( dBi (:, 1 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 2 ) = ( dBi (:, 2 ) * Wc - Tgc * dot_product ( dBi (:, 2 ), Wc ) ) / dot_product ( Bi , Wc ) dTgc (:, 3 ) = ( dBi (:, 3 ) * Wc - Tgc * dot_product ( dBi (:, 3 ), Wc ) ) / dot_product ( Bi , Wc ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - 2.0_rk * dTgc (:, 1 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 2 ), Wc ) - dTgc (:, 2 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - 2.0_rk * dTgc (:, 2 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) * Wc & - dTgc (:, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc (:, 1 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 1 ), Wc ) & - Tgc * dot_product ( d2Bi ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - dTgc (:, 2 ) * dot_product ( dBi (:, 3 ), Wc ) - dTgc (:, 3 ) * dot_product ( dBi (:, 2 ), Wc ) & - Tgc * dot_product ( d2Bi ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) * Wc & - 2.0_rk * dTgc (:, 3 ) * dot_product ( dBi (:, 3 ), Wc ) & - Tgc * dot_product ( d2Bi ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ), Wc )) / dot_product ( Bi , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: d2B1 (:), d2B2 (:), d2B3 (:) real ( rk ), allocatable :: dB1 (:), dB2 (:), dB3 (:) real ( rk ), allocatable :: B1 (:), B2 (:), B3 (:) integer :: i allocate ( d2Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) do i = 1 , size ( Xt , 1 ) call basis_bspline_2der ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Tgc ( i ,:) = kron ( B3 , kron ( B2 , B1 )) dTgc ( i ,:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc ( i ,:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc ( i ,:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( i , 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( i , nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( i , 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine compute_d2Tgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , d2Tgc , dTgc , Tgc ) use forcad_utils , only : rk , basis_bspline_2der , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable , intent ( out ) :: d2Tgc (:,:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable , intent ( out ) :: Tgc (:) real ( rk ), allocatable :: d2B1 (:), d2B2 (:), d2B3 (:) real ( rk ), allocatable :: dB1 (:), dB2 (:), dB3 (:) real ( rk ), allocatable :: B1 (:), B2 (:), B3 (:) allocate ( d2Tgc ( 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( dTgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) call basis_bspline_2der ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 ), d2B1 , dB1 , B1 ) call basis_bspline_2der ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 ), d2B2 , dB2 , B2 ) call basis_bspline_2der ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 ), d2B3 , dB3 , B3 ) Tgc = kron ( B3 , kron ( B2 , B1 )) dTgc (:, 1 ) = kron ( kron ( B3 , B2 ), dB1 ) dTgc (:, 2 ) = kron ( kron ( B3 , dB2 ), B1 ) dTgc (:, 3 ) = kron ( kron ( dB3 , B2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , B2 ), d2B1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 1 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , dB2 ), dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( B3 , d2B2 ), B1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 2 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( 1 : nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , B2 ), dB1 ) d2Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( dB3 , dB2 ), B1 ) d2Tgc ( 2 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) + 1 : 3 * nc ( 1 ) * nc ( 2 ) * nc ( 3 ) , 3 ) = kron ( kron ( d2B3 , B2 ), B1 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_nurbs_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng , Wc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) allocate ( Tgci ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) !$OMP PARALLEL DO PRIVATE(Tgci) do i = 1 , size ( Xt , 1 ) Tgci = kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc ( i ,:) = Tgci * ( Wc / ( dot_product ( Tgci , Wc ))) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_nurbs_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc , Wc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), intent ( in ), contiguous :: Wc (:) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) Tgc = Tgc * ( Wc / ( dot_product ( Tgc , Wc ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_bspline_3d_vector ( Xt , knot1 , knot2 , knot3 , degree , nc , ng ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:,:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) integer , intent ( in ) :: ng ( 3 ) real ( rk ), allocatable :: Tgc (:,:) integer :: i allocate ( Tgc ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ), nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) !$OMP PARALLEL DO do i = 1 , size ( Xt , 1 ) Tgc ( i ,:) = kron ( basis_bspline ( Xt ( i , 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( i , 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( i , 1 ), knot1 , nc ( 1 ), degree ( 1 )))) end do !$OMP END PARALLEL DO end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function compute_Tgc_bspline_3d_scalar ( Xt , knot1 , knot2 , knot3 , degree , nc ) result ( Tgc ) use forcad_utils , only : rk , basis_bspline , kron implicit none real ( rk ), intent ( in ), contiguous :: Xt (:) real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) integer , intent ( in ) :: degree ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable :: Tgc (:) allocate ( Tgc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ))) Tgc = kron ( basis_bspline ( Xt ( 3 ), knot3 , nc ( 3 ), degree ( 3 )), kron (& basis_bspline ( Xt ( 2 ), knot2 , nc ( 2 ), degree ( 2 )),& basis_bspline ( Xt ( 1 ), knot1 , nc ( 1 ), degree ( 1 )))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure function nearest_point_help_3d ( ng , Xg , point_Xg ) result ( distances ) use forcad_utils , only : rk implicit none integer , intent ( in ) :: ng ( 3 ) real ( rk ), intent ( in ), contiguous :: Xg (:,:) real ( rk ), intent ( in ), contiguous :: point_Xg (:) real ( rk ), allocatable :: distances (:) integer :: i allocate ( distances ( ng ( 1 ) * ng ( 2 ) * ng ( 3 ))) !$OMP PARALLEL DO do i = 1 , ng ( 1 ) * ng ( 2 ) * ng ( 3 ) distances ( i ) = norm2 ( Xg ( i ,:) - point_Xg ) end do !$OMP END PARALLEL DO end function !===============================================================================","tags":"","loc":"sourcefile/forcad_nurbs_volume.f90.html"}]}