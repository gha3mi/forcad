var tipuesearch = {"pages":[{"title":" ForCAD ","text":"ForCAD ForCAD : A parallel Fortran library for geometric modeling using NURBS (Non-Uniform Rational B-Splines). ForCAD supports B-Spline , NURBS , Bezier , and Rational Bezier curves, surfaces, and volumes. Main Features Parallelized using OpenMP and do concurrent . Create NURBS objects by specifying control points, weights and knots. Refine NURBS objects by inserting or removing knots and elevating degree. Compute basis functions and derivatives of NURBS objects. Obtain IGA elements connectivity. Obtain visualized elements connectivity and coordinates for geometry and control geometry. Mesh insertion into a NURBS object. Export NURBS objects to VTK files for visualization. Includes predefined NURBS shapes: Circle, Half Circle, Tetragon, Hexahedron, 2D Ring, Half 2D Ring, 3D Ring, Half 3D Ring, C-shapes. Rotate and translate NURBS objects. Visualization using provided python PyVista scripts. Examples Installation Requirements A Fortran compiler, such as GNU Fortran ( gfortran ), Intel Fortran Compiler ( ifx/ifort ) or NVIDIA HPC SDK Fortran compiler ( nvfortran ). The Fortran Package Manager fpm . Optional: PyVista (Recommended) or ParaView for visualization. Clone the repository Clone the ForCAD repository from GitHub: git clone https://github.com/gha3mi/forcad.git cd forcad Install PyVista (Optional) To install PyVista, run the following command: pip install pyvista Running Examples with fpm fpm run --example <file name excluding the .f90 extension> After executing the examples, .vtk files will be generated in the vtk directory. To visualize these files, a show() method is provided which utilizes PyVista. Alternatively, other visualization tools like ParaView can also be used. Using ForCAD as a fpm Dependency If you want to use ForCAD as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forcad = { git = \"https://github.com/gha3mi/forcad.git\" } API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForCAD using ford run the following\ncommand: ford ford.yml Roadmap For a detailed roadmap outlining upcoming features and enhancements, please refer to ROADMAP.md . Contributing To contribute to ForCAD, please review the CONTRIBUTING.md . Citation If you use ForCAD in your research, please cite it as follows: @software { seyed_ali_ghasemi_2024_10904447 , author = {Ghasemi, S. A.} , title = {gha3mi/ForCAD} , year = 2024 , publisher = {Zenodo} , doi = {10.5281/zenodo.10904447} , url = {https://doi.org/10.5281/zenodo.10904447} } References Piegl, L., & Tiller, W. (1995). The NURBS Book. In Monographs in Visual Communications. Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-642-97385-7 An Introduction to NURBS. (2001). Elsevier. https://doi.org/10.1016/b978-1-55860-669-2.x5000-3 Sullivan et al., (2019). PyVista: 3D plotting and mesh analysis through a streamlined interface for the Visualization Toolkit (VTK). Journal of Open Source Software, 4(37), 1450, https://doi.org/10.21105/joss.01450 Ahrens, James, Geveci, Berk, Law, Charles, ParaView: An End-User Tool for Large Data Visualization, Visualization Handbook, Elsevier, 2005, ISBN-13: 9780123875822 Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~~CalledByGraph proc~generate_xc generate_Xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~generate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~2~~CalledByGraph proc~generate_xc~2 generate_Xc program~example3_surface example3_surface program~example3_surface->proc~generate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~2.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~3~~CalledByGraph proc~generate_xc~3 generate_Xc program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~generate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~3.html"},{"title":"basis_bernstein – ForCAD","text":"public pure function basis_bernstein(Xt, nc) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/basis_bernstein.html"},{"title":"basis_bspline – ForCAD","text":"public pure function basis_bspline(Xt, knot, nc, degree) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/basis_bspline.html"},{"title":"compute_knot_vector – ForCAD","text":"public pure function compute_knot_vector(Xth_dir, degree, continuity) result(knot) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_knot_vector~~CallsGraph proc~compute_knot_vector compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_knot_vector.html"},{"title":"det – ForCAD","text":"public pure function det(A) result(detA) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk) Called by proc~~det~~CalledByGraph proc~det det proc~inv inv proc~inv->proc~det proc~inv->proc~inv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/det.html"},{"title":"findspan – ForCAD","text":"public pure function findspan(n, degree, Xth, knot) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer","tags":"","loc":"proc/findspan.html"},{"title":"hexahedron_Xc – ForCAD","text":"public pure function hexahedron_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~hexahedron_xc~~CalledByGraph proc~hexahedron_xc hexahedron_Xc program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->proc~hexahedron_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/hexahedron_xc.html"},{"title":"inv – ForCAD","text":"public pure recursive function inv(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk), allocatable, (:,:) Calls proc~~inv~~CallsGraph proc~inv inv proc~inv->proc~inv proc~det det proc~inv->proc~det Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/inv.html"},{"title":"kron – ForCAD","text":"public pure function kron(u, v) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) Called by proc~~kron~~CalledByGraph proc~kron kron proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->proc~kron interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/kron.html"},{"title":"rotation – ForCAD","text":"public pure function rotation(alpha, beta, theta) result(R) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) Calls proc~~rotation~~CallsGraph proc~rotation rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotation.html"},{"title":"tetragon_Xc – ForCAD","text":"public pure function tetragon_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/tetragon_xc.html"},{"title":"bincoeff – ForCAD","text":"private pure function bincoeff(n, k) result(b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) Calls proc~~bincoeff~~CallsGraph proc~bincoeff bincoeff proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bincoeff~~CalledByGraph proc~bincoeff bincoeff proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/bincoeff.html"},{"title":"cmp_elemConn_C0_L – ForCAD","text":"private pure function cmp_elemConn_C0_L(nnode, p) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_l~~CalledByGraph proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_l Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_l.html"},{"title":"cmp_elemConn_C0_S – ForCAD","text":"private pure function cmp_elemConn_C0_S(nnode1, nnode2, p1, p2) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_s~~CalledByGraph proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_s.html"},{"title":"cmp_elemConn_C0_V – ForCAD","text":"private pure function cmp_elemConn_C0_V(nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_v~~CalledByGraph proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_v.html"},{"title":"compute_multiplicity1 – ForCAD","text":"private pure function compute_multiplicity1(knot) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) Called by proc~~compute_multiplicity1~~CalledByGraph proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity1 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_multiplicity1.html"},{"title":"compute_multiplicity2 – ForCAD","text":"private pure function compute_multiplicity2(knot, Xth) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer Called by proc~~compute_multiplicity2~~CalledByGraph proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_multiplicity2.html"},{"title":"dyad_t1_t1 – ForCAD","text":"private pure function dyad_t1_t1(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~dyad_t1_t1~~CalledByGraph proc~dyad_t1_t1 dyad_t1_t1 interface~dyad dyad interface~dyad->proc~dyad_t1_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dyad_t1_t1.html"},{"title":"factln – ForCAD","text":"private pure function factln(n) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~factln~~CalledByGraph proc~factln factln proc~bincoeff bincoeff proc~bincoeff->proc~factln proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/factln.html"},{"title":"isinf – ForCAD","text":"private pure elemental function isinf(x) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical","tags":"","loc":"proc/isinf.html"},{"title":"isnan – ForCAD","text":"private pure elemental function isnan(x) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical","tags":"","loc":"proc/isnan.html"},{"title":"repelem – ForCAD","text":"private pure function repelem(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) Called by proc~~repelem~~CalledByGraph proc~repelem repelem proc~compute_knot_vector compute_knot_vector proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/repelem.html"},{"title":"unique_integer – ForCAD","text":"private pure function unique_integer(vec) result(output) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable Called by proc~~unique_integer~~CalledByGraph proc~unique_integer unique_integer interface~unique unique interface~unique->proc~unique_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unique_integer.html"},{"title":"unique_real – ForCAD","text":"private pure function unique_real(vec) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Called by proc~~unique_real~~CalledByGraph proc~unique_real unique_real interface~unique unique interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unique_real.html"},{"title":"basis_bspline_2der – ForCAD","text":"public pure subroutine basis_bspline_2der(Xt, knot, nc, degree, d2B, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: d2B (:) real(kind=rk), intent(out), optional, allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:)","tags":"","loc":"proc/basis_bspline_2der.html"},{"title":"basis_bspline_der – ForCAD","text":"public pure subroutine basis_bspline_der(Xt, knot, nc, degree, dB, B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:)","tags":"","loc":"proc/basis_bspline_der.html"},{"title":"elevate_degree_A_5_9 – ForCAD","text":"public pure subroutine elevate_degree_A_5_9(t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) Calls proc~~elevate_degree_a_5_9~~CallsGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree_a_5_9.html"},{"title":"insert_knot_A_5_1 – ForCAD","text":"public pure subroutine insert_knot_A_5_1(p, UP, Pw, u, k, s, r, nq, UQ, Qw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:)","tags":"","loc":"proc/insert_knot_a_5_1.html"},{"title":"remove_knots_A_5_8 – ForCAD","text":"public pure subroutine remove_knots_A_5_8(p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:)","tags":"","loc":"proc/remove_knots_a_5_8.html"},{"title":"cmp_elemConn_Cn_L – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_L(nnode, p, Xth, vecKnot_mul, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_l~~CalledByGraph proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_l Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_l.html"},{"title":"cmp_elemConn_Cn_S – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_S(nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_s~~CalledByGraph proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_s.html"},{"title":"cmp_elemConn_Cn_V – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_V(nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_v~~CalledByGraph proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_v.html"},{"title":"gauss_legendre_1D – ForCAD","text":"private pure subroutine gauss_legendre_1D(interval, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_1d~~CallsGraph proc~gauss_legendre_1d gauss_legendre_1D gauss_legendre gauss_legendre proc~gauss_legendre_1d->gauss_legendre Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_1d~~CalledByGraph proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/gauss_legendre_1d.html"},{"title":"gauss_legendre_2D – ForCAD","text":"private pure subroutine gauss_legendre_2D(interval1, interval2, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_2d~~CallsGraph proc~gauss_legendre_2d gauss_legendre_2D gauss_legendre gauss_legendre proc~gauss_legendre_2d->gauss_legendre interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~kron kron proc~gauss_legendre_2d->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_2d~~CalledByGraph proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/gauss_legendre_2d.html"},{"title":"gauss_legendre_3D – ForCAD","text":"private pure subroutine gauss_legendre_3D(interval1, interval2, interval3, degree, Xksi, Wksi) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) Calls proc~~gauss_legendre_3d~~CallsGraph proc~gauss_legendre_3d gauss_legendre_3D gauss_legendre gauss_legendre proc~gauss_legendre_3d->gauss_legendre interface~ndgrid ndgrid proc~gauss_legendre_3d->interface~ndgrid proc~kron kron proc~gauss_legendre_3d->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gauss_legendre_3d~~CalledByGraph proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/gauss_legendre_3d.html"},{"title":"ndgrid2 – ForCAD","text":"private pure subroutine ndgrid2(X_dir1, X_dir2, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid2~~CalledByGraph proc~ndgrid2 ndgrid2 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid2 proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid2.html"},{"title":"ndgrid3 – ForCAD","text":"private pure subroutine ndgrid3(X_dir1, X_dir2, X_dir3, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid3~~CalledByGraph proc~ndgrid3 ndgrid3 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid3 proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid3.html"},{"title":"compute_multiplicity – ForCAD","text":"public interface compute_multiplicity Calls interface~~compute_multiplicity~~CallsGraph interface~compute_multiplicity compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_multiplicity~~CalledByGraph interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer","tags":"","loc":"interface/compute_multiplicity.html"},{"title":"dyad – ForCAD","text":"public interface dyad Calls interface~~dyad~~CallsGraph interface~dyad dyad proc~dyad_t1_t1 dyad_t1_t1 interface~dyad->proc~dyad_t1_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"interface/dyad.html"},{"title":"elemConn_C0 – ForCAD","text":"public interface elemConn_C0 Calls interface~~elemconn_c0~~CallsGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:)","tags":"","loc":"interface/elemconn_c0.html"},{"title":"elemConn_Cn – ForCAD","text":"public interface elemConn_Cn Calls interface~~elemconn_cn~~CallsGraph interface~elemconn_cn elemConn_Cn proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:)","tags":"","loc":"interface/elemconn_cn.html"},{"title":"gauss_leg – ForCAD","text":"public interface gauss_leg Calls interface~~gauss_leg~~CallsGraph interface~gauss_leg gauss_leg proc~gauss_legendre_1d gauss_legendre_1D interface~gauss_leg->proc~gauss_legendre_1d proc~gauss_legendre_2d gauss_legendre_2D interface~gauss_leg->proc~gauss_legendre_2d proc~gauss_legendre_3d gauss_legendre_3D interface~gauss_leg->proc~gauss_legendre_3d gauss_legendre gauss_legendre proc~gauss_legendre_1d->gauss_legendre proc~gauss_legendre_2d->gauss_legendre interface~ndgrid ndgrid proc~gauss_legendre_2d->interface~ndgrid proc~kron kron proc~gauss_legendre_2d->proc~kron proc~gauss_legendre_3d->gauss_legendre proc~gauss_legendre_3d->interface~ndgrid proc~gauss_legendre_3d->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:)","tags":"","loc":"interface/gauss_leg.html"},{"title":"ndgrid – ForCAD","text":"public interface ndgrid Calls interface~~ndgrid~~CallsGraph interface~ndgrid ndgrid proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~ndgrid~~CalledByGraph interface~ndgrid ndgrid proc~gauss_legendre_2d gauss_legendre_2D proc~gauss_legendre_2d->interface~ndgrid proc~gauss_legendre_3d gauss_legendre_3D proc~gauss_legendre_3d->interface~ndgrid interface~gauss_leg gauss_leg interface~gauss_leg->proc~gauss_legendre_2d interface~gauss_leg->proc~gauss_legendre_3d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","loc":"interface/ndgrid.html"},{"title":"unique – ForCAD","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique unique proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable","tags":"","loc":"interface/unique.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~4~~CalledByGraph proc~generate_xc~4 generate_Xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~generate_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~4.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~5~~CalledByGraph proc~generate_xc~5 generate_Xc program~example3_volume example3_volume program~example3_volume->proc~generate_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~5.html"},{"title":"forcad_utils – ForCAD","text":"This module contains parameters, functions and subroutines that are used in the library. Uses stdlib_quadrature module~~forcad_utils~~UsesGraph module~forcad_utils forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_utils~~UsedByGraph module~forcad_utils forcad_utils module~forcad forcad module~forcad->module~forcad_utils program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad_utils program~example_put_to_nurbs->module~forcad program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = kind(1.0d0) Interfaces public        interface compute_multiplicity private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer public        interface dyad private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) public        interface elemConn_C0 private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) public        interface elemConn_Cn private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) public        interface gauss_leg private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) public        interface ndgrid private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) public        interface unique private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Functions public pure function basis_bernstein (Xt, nc) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline (Xt, knot, nc, degree) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:) public pure function compute_knot_vector (Xth_dir, degree, continuity) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) public pure function det (A) result(detA) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk) public pure function findspan (n, degree, Xth, knot) result(s) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer public pure function hexahedron_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) public pure recursive function inv (A) result(A_inv) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: A (:,:) Return Value real(kind=rk), allocatable, (:,:) public pure function kron (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) public pure function rotation (alpha, beta, theta) result(R) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) public pure function tetragon_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:) private pure function bincoeff (n, k) result(b) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer private pure function dyad_t1_t1 (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) real(kind=rk), intent(in), contiguous :: b (:) Return Value real(kind=rk), allocatable, (:,:) private pure function factln (n) result(f) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) private pure elemental function isinf (x) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical private pure elemental function isnan (x) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical private pure function repelem (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) private pure function unique_integer (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Subroutines public pure subroutine basis_bspline_2der (Xt, knot, nc, degree, d2B, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: d2B (:) real(kind=rk), intent(out), optional, allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:) public pure subroutine basis_bspline_der (Xt, knot, nc, degree, dB, B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: dB (:) real(kind=rk), intent(out), optional, allocatable :: B (:) public pure subroutine elevate_degree_A_5_9 (t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) public pure subroutine insert_knot_A_5_1 (p, UP, Pw, u, k, s, r, nq, UQ, Qw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) public pure subroutine remove_knots_A_5_8 (p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine gauss_legendre_1D (interval, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval (2) integer, intent(in) :: degree real(kind=rk), intent(out), allocatable :: Xksi (:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_2D (interval1, interval2, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) integer, intent(in) :: degree (2) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine gauss_legendre_3D (interval1, interval2, interval3, degree, Xksi, Wksi) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: interval1 (2) real(kind=rk), intent(in) :: interval2 (2) real(kind=rk), intent(in) :: interval3 (2) integer, intent(in) :: degree (3) real(kind=rk), intent(out), allocatable :: Xksi (:,:) real(kind=rk), intent(out), allocatable :: Wksi (:) private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","loc":"module/forcad_utils.html"},{"title":"forcad – ForCAD","text":"Uses forcad_nurbs_curve forcad_nurbs_volume forcad_nurbs_surface forcad_utils module~~forcad~~UsesGraph module~forcad forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad~~UsedByGraph module~forcad forcad program~compute_area compute_area program~compute_area->module~forcad program~compute_length compute_length program~compute_length->module~forcad program~compute_volume compute_volume program~compute_volume->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~example_ppm1 example_ppm1 program~example_ppm1->module~forcad program~example_ppm2 example_ppm2 program~example_ppm2->module~forcad program~example_ppm3 example_ppm3 program~example_ppm3->module~forcad program~example_put_to_nurbs example_put_to_nurbs program~example_put_to_nurbs->module~forcad program~nearest_point_1d nearest_point_1d program~nearest_point_1d->module~forcad program~nearest_point_2d nearest_point_2d program~nearest_point_2d->module~forcad program~nearest_point_2d_bench nearest_point_2d_bench program~nearest_point_2d_bench->module~forcad program~nearest_point_3d nearest_point_3d program~nearest_point_3d->module~forcad program~shape_c_1d shape_C_1d program~shape_c_1d->module~forcad program~shape_c_2d shape_C_2d program~shape_c_2d->module~forcad program~shape_c_3d shape_C_3d program~shape_c_3d->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_half_circle shape_half_circle program~shape_half_circle->module~forcad program~shape_half_ring_2d shape_half_ring_2d program~shape_half_ring_2d->module~forcad program~shape_half_ring_3d shape_half_ring_3d program~shape_half_ring_3d->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_ring_2d shape_ring_2d program~shape_ring_2d->module~forcad program~shape_ring_3d shape_ring_3d program~shape_ring_3d->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forcad.html"},{"title":"example_ppm3 – ForCAD","text":"Uses fortime forcolormap forimage forcad program~~example_ppm3~~UsesGraph program~example_ppm3 example_ppm3 forcolormap forcolormap program~example_ppm3->forcolormap forimage forimage program~example_ppm3->forimage fortime fortime program~example_ppm3->fortime module~forcad forcad program~example_ppm3->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon Calls program~~example_ppm3~~CallsGraph program~example_ppm3 example_ppm3 compute_rgb compute_rgb program~example_ppm3->compute_rgb create create program~example_ppm3->create export_pnm export_pnm program~example_ppm3->export_pnm finalize finalize program~example_ppm3->finalize get_b get_b program~example_ppm3->get_b get_g get_g program~example_ppm3->get_g get_ng get_ng program~example_ppm3->get_ng get_r get_r program~example_ppm3->get_r get_xg get_xg program~example_ppm3->get_xg modify_xc modify_xc program~example_ppm3->modify_xc set set program~example_ppm3->set set_pnm set_pnm program~example_ppm3->set_pnm set_tetragon set_tetragon program~example_ppm3->set_tetragon timer_start timer_start program~example_ppm3->timer_start timer_stop timer_stop program~example_ppm3->timer_stop translate_xc translate_xc program~example_ppm3->translate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image integer :: ng (2) integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type(nurbs_surface) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","loc":"program/example_ppm3.html"},{"title":"shape_C_2d – ForCAD","text":"Uses forcad program~~shape_c_2d~~UsesGraph program~shape_c_2d shape_C_2d module~forcad forcad program~shape_c_2d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_2d~~CallsGraph program~shape_c_2d shape_C_2d create create program~shape_c_2d->create export_xc export_xc program~shape_c_2d->export_xc export_xg export_xg program~shape_c_2d->export_xg finalize finalize program~shape_c_2d->finalize set_c set_c program~shape_c_2d->set_c show show program~shape_c_2d->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_surface) :: shape","tags":"","loc":"program/shape_c_2d.html"},{"title":"shape_half_ring_3d – ForCAD","text":"Uses forcad program~~shape_half_ring_3d~~UsesGraph program~shape_half_ring_3d shape_half_ring_3d module~forcad forcad program~shape_half_ring_3d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_3d~~CallsGraph program~shape_half_ring_3d shape_half_ring_3d create create program~shape_half_ring_3d->create export_xc export_xc program~shape_half_ring_3d->export_xc export_xg export_xg program~shape_half_ring_3d->export_xg finalize finalize program~shape_half_ring_3d->finalize set_half_ring set_half_ring program~shape_half_ring_3d->set_half_ring show show program~shape_half_ring_3d->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_volume) :: shape","tags":"","loc":"program/shape_half_ring_3d.html"},{"title":"shape_C_3d – ForCAD","text":"Uses forcad program~~shape_c_3d~~UsesGraph program~shape_c_3d shape_C_3d module~forcad forcad program~shape_c_3d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_3d~~CallsGraph program~shape_c_3d shape_C_3d create create program~shape_c_3d->create export_xc export_xc program~shape_c_3d->export_xc export_xg export_xg program~shape_c_3d->export_xg finalize finalize program~shape_c_3d->finalize set_c set_c program~shape_c_3d->set_c show show program~shape_c_3d->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_volume) :: shape","tags":"","loc":"program/shape_c_3d.html"},{"title":"compute_area – ForCAD","text":"Uses forcad program~~compute_area~~UsesGraph program~compute_area compute_area module~forcad forcad program~compute_area->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_area~~CallsGraph program~compute_area compute_area cmp_area cmp_area program~compute_area->cmp_area set set program~compute_area->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (4,3) real(kind=rk) :: area type(nurbs_surface) :: shape","tags":"","loc":"program/compute_area.html"},{"title":"example_ppm2 – ForCAD","text":"Uses fortime forcolormap forimage forcad program~~example_ppm2~~UsesGraph program~example_ppm2 example_ppm2 forcolormap forcolormap program~example_ppm2->forcolormap forimage forimage program~example_ppm2->forimage fortime fortime program~example_ppm2->fortime module~forcad forcad program~example_ppm2->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm2~~CallsGraph program~example_ppm2 example_ppm2 compute_rgb compute_rgb program~example_ppm2->compute_rgb create create program~example_ppm2->create export_pnm export_pnm program~example_ppm2->export_pnm finalize finalize program~example_ppm2->finalize get_b get_b program~example_ppm2->get_b get_g get_g program~example_ppm2->get_g get_ng get_ng program~example_ppm2->get_ng get_r get_r program~example_ppm2->get_r get_xg get_xg program~example_ppm2->get_xg rotate_xc rotate_xc program~example_ppm2->rotate_xc set set program~example_ppm2->set set_half_ring set_half_ring program~example_ppm2->set_half_ring set_pnm set_pnm program~example_ppm2->set_pnm set_tetragon set_tetragon program~example_ppm2->set_tetragon timer_start timer_start program~example_ppm2->timer_start timer_stop timer_stop program~example_ppm2->timer_stop translate_xc translate_xc program~example_ppm2->translate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type(nurbs_surface) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","loc":"program/example_ppm2.html"},{"title":"shape_ring_2d – ForCAD","text":"Uses forcad program~~shape_ring_2d~~UsesGraph program~shape_ring_2d shape_ring_2d module~forcad forcad program~shape_ring_2d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape with inner radius 1.0 and outer radius 2.0. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_2d~~CallsGraph program~shape_ring_2d shape_ring_2d create create program~shape_ring_2d->create export_xc export_xc program~shape_ring_2d->export_xc export_xg export_xg program~shape_ring_2d->export_xg finalize finalize program~shape_ring_2d->finalize set_ring set_ring program~shape_ring_2d->set_ring show show program~shape_ring_2d->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_surface) :: shape","tags":"","loc":"program/shape_ring_2d.html"},{"title":"example_nurbs_volume – ForCAD","text":"Uses forcad program~~example_nurbs_volume~~UsesGraph program~example_nurbs_volume example_nurbs_volume module~forcad forcad program~example_nurbs_volume->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume.\nIt sets up control points and weights, generates the volume, and exports the control points\nand the volume to VTK files at various stages. Define control points for the NURBS volume Define weights for the control points Set control points and weights for the NURBS volume object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS volume with a resolution of 15X15X15 Export the generated volume to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS volume object Calls program~~example_nurbs_volume~~CallsGraph program~example_nurbs_volume example_nurbs_volume create create program~example_nurbs_volume->create export_xc export_xc program~example_nurbs_volume->export_xc export_xg export_xg program~example_nurbs_volume->export_xg finalize finalize program~example_nurbs_volume->finalize proc~generate_xc generate_Xc program~example_nurbs_volume->proc~generate_xc set set program~example_nurbs_volume->set show show program~example_nurbs_volume->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type(nurbs_volume) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"program/example_nurbs_volume.html"},{"title":"example3_surface – ForCAD","text":"Uses forcad program~~example3_surface~~UsesGraph program~example3_surface example3_surface module~forcad forcad program~example3_surface->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. Define control points for the NURBS surface Define weights for the control points\nDefine knot vectors for both dimensions\nSet knot vectors, control points, and weights for the NURBS surface object Deallocate local arrays Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Print size of the knot vectors\nInsert knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after inserting knots\nPrint the degrees Elevate degree by 2 in both directions\nPrint the degrees after elevating Print size of the knot vectors\nRemove knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after removing knots\nGenerate the refined NURBS surface with resolutions of 30 in both dimensions Export updated control points to a VTK file Export the refined generated surface to a VTK file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~example3_surface~~CallsGraph program~example3_surface example3_surface create create program~example3_surface->create elevate_degree elevate_degree program~example3_surface->elevate_degree export_xc export_xc program~example3_surface->export_xc export_xg export_xg program~example3_surface->export_xg finalize finalize program~example3_surface->finalize get_degree get_degree program~example3_surface->get_degree get_knot get_knot program~example3_surface->get_knot insert_knots insert_knots program~example3_surface->insert_knots proc~generate_xc~2 generate_Xc program~example3_surface->proc~generate_xc~2 remove_knots remove_knots program~example3_surface->remove_knots rotate_xc rotate_xc program~example3_surface->rotate_xc rotate_xg rotate_xg program~example3_surface->rotate_xg set set program~example3_surface->set show show program~example3_surface->show translate_xc translate_xc program~example3_surface->translate_xc translate_xg translate_xg program~example3_surface->translate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (6) Arrays for knot vectors in both dimensions real(kind=rk) :: knot2 (6) Arrays for knot vectors in both dimensions type(nurbs_surface) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","loc":"program/example3_surface.html"},{"title":"example_ppm1 – ForCAD","text":"Uses fortime forcolormap forimage forcad program~~example_ppm1~~UsesGraph program~example_ppm1 example_ppm1 forcolormap forcolormap program~example_ppm1->forcolormap forimage forimage program~example_ppm1->forimage fortime fortime program~example_ppm1->fortime module~forcad forcad program~example_ppm1->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries\nThis example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. Set the shape parameters for a tetragon\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring\nSet the shape parameters for a ring Calls program~~example_ppm1~~CallsGraph program~example_ppm1 example_ppm1 compute_rgb compute_rgb program~example_ppm1->compute_rgb create create program~example_ppm1->create export_pnm export_pnm program~example_ppm1->export_pnm finalize finalize program~example_ppm1->finalize get_b get_b program~example_ppm1->get_b get_g get_g program~example_ppm1->get_g get_ng get_ng program~example_ppm1->get_ng get_r get_r program~example_ppm1->get_r get_xg get_xg program~example_ppm1->get_xg set set program~example_ppm1->set set_pnm set_pnm program~example_ppm1->set_pnm set_ring set_ring program~example_ppm1->set_ring set_tetragon set_tetragon program~example_ppm1->set_tetragon timer_start timer_start program~example_ppm1->timer_start timer_stop timer_stop program~example_ppm1->timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Xg (:,:) real(kind=rk) :: aspect_ratio type(color) :: background_color integer :: blue real(kind=rk) :: center (3) type(colormap) :: cmap integer :: green integer :: height integer :: i integer, allocatable :: idx (:,:) type(format_pnm) :: image real(kind=rk) :: inner_radius integer :: ng (2) real(kind=rk) :: outer_radius integer(kind=ik), allocatable :: px (:,:) integer :: red integer :: res1 integer :: res2 type(nurbs_surface) :: shape type(timer) :: t integer :: width real(kind=rk), allocatable :: z_values (:)","tags":"","loc":"program/example_ppm1.html"},{"title":"nearest_point_3d – ForCAD","text":"Uses forcad program~~nearest_point_3d~~UsesGraph program~nearest_point_3d nearest_point_3d module~forcad forcad program~nearest_point_3d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. The weights of the control points (Wc) are optional. Generate the NURBS volume with resolutions of 20, 20, 20 Find the nearest point on the volume to a given point\nFind the nearest point on the volume to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS volume object Calls program~~nearest_point_3d~~CallsGraph program~nearest_point_3d nearest_point_3d create create program~nearest_point_3d->create finalize finalize program~nearest_point_3d->finalize nearest_point nearest_point program~nearest_point_3d->nearest_point nearest_point2 nearest_point2 program~nearest_point_3d->nearest_point2 set set program~nearest_point_3d->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (8) Weights of the control points real(kind=rk) :: Xc (8,3) Control points integer :: id id of the nearest point real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the volume real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point type(nurbs_volume) :: shape Declare a NURBS volume object","tags":"","loc":"program/nearest_point_3d.html"},{"title":"nearest_point_2d – ForCAD","text":"Uses forcad program~~nearest_point_2d~~UsesGraph program~nearest_point_2d nearest_point_2d module~forcad forcad program~nearest_point_2d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a surface with 4 control points\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFind the nearest point on the surface to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS surface object Calls program~~nearest_point_2d~~CallsGraph program~nearest_point_2d nearest_point_2d create create program~nearest_point_2d->create finalize finalize program~nearest_point_2d->finalize nearest_point nearest_point program~nearest_point_2d->nearest_point nearest_point2 nearest_point2 program~nearest_point_2d->nearest_point2 set set program~nearest_point_2d->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Wc (4) Weights of the control points real(kind=rk) :: Xc (4,3) Control points integer :: id id of the nearest point real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the surface real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point type(nurbs_surface) :: shape Declare a NURBS surface object","tags":"","loc":"program/nearest_point_2d.html"},{"title":"shape_hexahedron – ForCAD","text":"Uses forcad program~~shape_hexahedron~~UsesGraph program~shape_hexahedron shape_hexahedron module~forcad forcad program~shape_hexahedron->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8].\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_hexahedron~~CallsGraph program~shape_hexahedron shape_hexahedron create create program~shape_hexahedron->create export_xc export_xc program~shape_hexahedron->export_xc export_xg export_xg program~shape_hexahedron->export_xg finalize finalize program~shape_hexahedron->finalize set_hexahedron set_hexahedron program~shape_hexahedron->set_hexahedron show show program~shape_hexahedron->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_volume) :: shape","tags":"","loc":"program/shape_hexahedron.html"},{"title":"nearest_point_1d – ForCAD","text":"Uses forcad program~~nearest_point_1d~~UsesGraph program~nearest_point_1d nearest_point_1d module~forcad forcad program~nearest_point_1d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Generate the NURBS curve with a resolution of 20 Find the nearest point on the curve to a given point\nFind the nearest point on the curve to a given point\nThe optimization method is used to find the nearest point\nThe optimization method is based on the Newton-Raphson method\nFinalize the NURBS curve object Calls program~~nearest_point_1d~~CallsGraph program~nearest_point_1d nearest_point_1d create create program~nearest_point_1d->create finalize finalize program~nearest_point_1d->finalize nearest_point nearest_point program~nearest_point_1d->nearest_point nearest_point2 nearest_point2 program~nearest_point_1d->nearest_point2 set set program~nearest_point_1d->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights integer :: id Variable for the id of the nearest point real(kind=rk) :: knot (6) Array for knot vector real(kind=rk), allocatable :: nearest_Xg (:) Array for the nearest point on the curve real(kind=rk) :: nearest_Xt Array for the parametric coordinates of the nearest point type(nurbs_curve) :: shape Declare a NURBS curve object","tags":"","loc":"program/nearest_point_1d.html"},{"title":"shape_half_ring_2d – ForCAD","text":"Uses forcad program~~shape_half_ring_2d~~UsesGraph program~shape_half_ring_2d shape_half_ring_2d module~forcad forcad program~shape_half_ring_2d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_ring_2d~~CallsGraph program~shape_half_ring_2d shape_half_ring_2d create create program~shape_half_ring_2d->create export_xc export_xc program~shape_half_ring_2d->export_xc export_xg export_xg program~shape_half_ring_2d->export_xg finalize finalize program~shape_half_ring_2d->finalize set_half_ring set_half_ring program~shape_half_ring_2d->set_half_ring show show program~shape_half_ring_2d->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_surface) :: shape","tags":"","loc":"program/shape_half_ring_2d.html"},{"title":"example_nurbs_curve – ForCAD","text":"Uses forcad program~~example_nurbs_curve~~UsesGraph program~example_nurbs_curve example_nurbs_curve module~forcad forcad program~example_nurbs_curve->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve.\nIt sets up control points and weights, generates the curve, and exports the control points\nand the curve to VTK files at various stages. Define control points for the NURBS curve Define weights for the control points Set control points and weights for the NURBS curve object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS curve with a resolution of 500 Export the generated curve to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example_nurbs_curve~~CallsGraph program~example_nurbs_curve example_nurbs_curve create create program~example_nurbs_curve->create export_xc export_xc program~example_nurbs_curve->export_xc export_xg export_xg program~example_nurbs_curve->export_xg finalize finalize program~example_nurbs_curve->finalize proc~generate_xc~3 generate_Xc program~example_nurbs_curve->proc~generate_xc~3 set set program~example_nurbs_curve->set show show program~example_nurbs_curve->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type(nurbs_curve) :: nurbs Declare a NURBS curve object Functions function generate_Xc (num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","loc":"program/example_nurbs_curve.html"},{"title":"compute_volume – ForCAD","text":"Uses forcad program~~compute_volume~~UsesGraph program~compute_volume compute_volume module~forcad forcad program~compute_volume->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_volume~~CallsGraph program~compute_volume compute_volume cmp_volume cmp_volume program~compute_volume->cmp_volume set set program~compute_volume->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (8,3) type(nurbs_volume) :: shape real(kind=rk) :: volume","tags":"","loc":"program/compute_volume.html"},{"title":"shape_circle – ForCAD","text":"Uses forcad program~~shape_circle~~UsesGraph program~shape_circle shape_circle module~forcad forcad program~shape_circle->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS circle with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_circle~~CallsGraph program~shape_circle shape_circle create create program~shape_circle->create export_xc export_xc program~shape_circle->export_xc export_xg export_xg program~shape_circle->export_xg finalize finalize program~shape_circle->finalize set_circle set_circle program~shape_circle->set_circle show show program~shape_circle->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_curve) :: shape","tags":"","loc":"program/shape_circle.html"},{"title":"shape_C_1d – ForCAD","text":"Uses forcad program~~shape_c_1d~~UsesGraph program~shape_c_1d shape_C_1d module~forcad forcad program~shape_c_1d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS C-shape with a resolution of 100 Export the generated cirlce to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~shape_c_1d~~CallsGraph program~shape_c_1d shape_C_1d create create program~shape_c_1d->create export_xc export_xc program~shape_c_1d->export_xc export_xg export_xg program~shape_c_1d->export_xg finalize finalize program~shape_c_1d->finalize set_c set_c program~shape_c_1d->set_c show show program~shape_c_1d->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_curve) :: shape","tags":"","loc":"program/shape_c_1d.html"},{"title":"shape_ring_3d – ForCAD","text":"Uses forcad program~~shape_ring_3d~~UsesGraph program~shape_ring_3d shape_ring_3d module~forcad forcad program~shape_ring_3d->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_ring_3d~~CallsGraph program~shape_ring_3d shape_ring_3d create create program~shape_ring_3d->create export_xc export_xc program~shape_ring_3d->export_xc export_xg export_xg program~shape_ring_3d->export_xg finalize finalize program~shape_ring_3d->finalize set_ring set_ring program~shape_ring_3d->set_ring show show program~shape_ring_3d->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_volume) :: shape","tags":"","loc":"program/shape_ring_3d.html"},{"title":"example_nurbs_surface – ForCAD","text":"Uses forcad program~~example_nurbs_surface~~UsesGraph program~example_nurbs_surface example_nurbs_surface module~forcad forcad program~example_nurbs_surface->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface.\nIt sets up control points and weights, generates the surface, and exports the control points\nand the surface to VTK files at various stages. Define control points for the NURBS surface Define weights for the control points Set control points and weights for the NURBS surface object Deallocate local arrays Export initial control points to a VTK file Generate the NURBS surface with a resolution of 30x30 Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~example_nurbs_surface~~CallsGraph program~example_nurbs_surface example_nurbs_surface create create program~example_nurbs_surface->create export_xc export_xc program~example_nurbs_surface->export_xc export_xg export_xg program~example_nurbs_surface->export_xg finalize finalize program~example_nurbs_surface->finalize proc~generate_xc~4 generate_Xc program~example_nurbs_surface->proc~generate_xc~4 set set program~example_nurbs_surface->set show show program~example_nurbs_surface->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type(nurbs_surface) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"program/example_nurbs_surface.html"},{"title":"example3_volume – ForCAD","text":"Uses forcad program~~example3_volume~~UsesGraph program~example3_volume example3_volume module~forcad forcad program~example3_volume->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. Define the control points for the NURBS volume Define weights for the control points (optional)\nDefine knot vectors for all three dimensions\nSet knot vectors, control points, and weights for the NURBS volume object\nWc is optional. Deallocate local arrays Export the control points to a VTK file Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions Export the generated volume to a VTK file Show the control geometry and geometry using PyVista Print size of knot vectors\nInsert knots 0.25 and 0.75 in all three directions\nPrint size of knot vectors after inserting knots\nPrint degrees Elevate degree by 2 in all three directions\nPrint degrees after elevating Print size of knot vectors\nPrint size of knot vectors after removing knots\nGenerate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions Export updated control points to a VTK file Export the refined generated volume to a VTK file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Show the control geometry and geometry using PyVista first compute and set the connectivities of volume elements get the connectivity of the face1 of the first element\nget the degree of the faces\nFinalize the NURBS volume object Calls program~~example3_volume~~CallsGraph program~example3_volume example3_volume cmp_degreeface cmp_degreeface program~example3_volume->cmp_degreeface cmp_elem cmp_elem program~example3_volume->cmp_elem cmp_elemface cmp_elemface program~example3_volume->cmp_elemface create create program~example3_volume->create elevate_degree elevate_degree program~example3_volume->elevate_degree export_xc export_xc program~example3_volume->export_xc export_xg export_xg program~example3_volume->export_xg finalize finalize program~example3_volume->finalize get_degree get_degree program~example3_volume->get_degree get_knot get_knot program~example3_volume->get_knot insert_knots insert_knots program~example3_volume->insert_knots proc~generate_xc~5 generate_Xc program~example3_volume->proc~generate_xc~5 remove_knots remove_knots program~example3_volume->remove_knots rotate_xc rotate_xc program~example3_volume->rotate_xc rotate_xg rotate_xg program~example3_volume->rotate_xg set set program~example3_volume->set set_elem set_elem program~example3_volume->set_elem show show program~example3_volume->show translate_xc translate_xc program~example3_volume->translate_xc translate_xg translate_xg program~example3_volume->translate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot2 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot3 (4) Arrays for knot vectors in all three dimensions type(nurbs_volume) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","loc":"program/example3_volume.html"},{"title":"example1_curve – ForCAD","text":"Uses forcad program~~example1_curve~~UsesGraph program~example1_curve example1_curve module~forcad forcad program~example1_curve->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Deallocate local arrays Export control points to a VTK file Generate the NURBS curve with a resolution of 20 Export the generated curve to a VTK file Show the control geometry and geometry using PyVista Print size of the knot vector Insert knots 0.25, twice and 0.75, once Print size of the updated knot vector Print the degree of the curve Elevate the degree of the curve (2 times) Print the updated degree of the curve Print size of the knot vector Remove knots 0.25, twice and 0.75, once Print size of the updated knot vector Generate the refined curve with a resolution of 20 Export updated control points to a VTK file Export the refined generated curve to a VTK file Show the control geometry and geometry using PyVista Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS curve object Calls program~~example1_curve~~CallsGraph program~example1_curve example1_curve create create program~example1_curve->create elevate_degree elevate_degree program~example1_curve->elevate_degree export_xc export_xc program~example1_curve->export_xc export_xg export_xg program~example1_curve->export_xg finalize finalize program~example1_curve->finalize get_degree get_degree program~example1_curve->get_degree get_knot get_knot program~example1_curve->get_knot insert_knots insert_knots program~example1_curve->insert_knots remove_knots remove_knots program~example1_curve->remove_knots rotate_xc rotate_xc program~example1_curve->rotate_xc rotate_xg rotate_xg program~example1_curve->rotate_xg set set program~example1_curve->set show show program~example1_curve->show translate_xc translate_xc program~example1_curve->translate_xc translate_xg translate_xg program~example1_curve->translate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot (6) Array for knot vector type(nurbs_curve) :: nurbs Declare a NURBS curve object Source Code program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","loc":"program/example1_curve.html"},{"title":"nearest_point_2d_bench – ForCAD","text":"Uses fortime forcad program~~nearest_point_2d_bench~~UsesGraph program~nearest_point_2d_bench nearest_point_2d_bench fortime fortime program~nearest_point_2d_bench->fortime module~forcad forcad program~nearest_point_2d_bench->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Generate the NURBS surface with resolutions of 30 in both dimensions Find the nearest point on the surface to a given point\nFinalize the NURBS surface object Calls program~~nearest_point_2d_bench~~CallsGraph program~nearest_point_2d_bench nearest_point_2d_bench create create program~nearest_point_2d_bench->create finalize finalize program~nearest_point_2d_bench->finalize nearest_point nearest_point program~nearest_point_2d_bench->nearest_point set_tetragon set_tetragon program~nearest_point_2d_bench->set_tetragon timer_start timer_start program~nearest_point_2d_bench->timer_start timer_stop timer_stop program~nearest_point_2d_bench->timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: i integer :: id id of the nearest point integer :: j real(kind=rk), allocatable :: nearest_Xg (:) Coordinates of the nearest point on the surface real(kind=rk), allocatable :: nearest_Xt (:) Corresponding parametric coordinates of the nearest point real(kind=rk), allocatable :: points (:,:) type(nurbs_surface) :: shape Declare a NURBS surface object type(timer) :: t","tags":"","loc":"program/nearest_point_2d_bench.html"},{"title":"shape_tetragon – ForCAD","text":"Uses forcad program~~shape_tetragon~~UsesGraph program~shape_tetragon shape_tetragon module~forcad forcad program~shape_tetragon->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Show the control geometry and geometry using PyVista Finalize the NURBS surface object Calls program~~shape_tetragon~~CallsGraph program~shape_tetragon shape_tetragon create create program~shape_tetragon->create export_xc export_xc program~shape_tetragon->export_xc export_xg export_xg program~shape_tetragon->export_xg finalize finalize program~shape_tetragon->finalize set_tetragon set_tetragon program~shape_tetragon->set_tetragon show show program~shape_tetragon->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_surface) :: shape Declare a NURBS surface object","tags":"","loc":"program/shape_tetragon.html"},{"title":"compute_length – ForCAD","text":"Uses forcad program~~compute_length~~UsesGraph program~compute_length compute_length module~forcad forcad program~compute_length->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~compute_length~~CallsGraph program~compute_length compute_length cmp_length cmp_length program~compute_length->cmp_length set set program~compute_length->set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: Xc (2,3) real(kind=rk) :: length type(nurbs_curve) :: shape","tags":"","loc":"program/compute_length.html"},{"title":"shape_half_circle – ForCAD","text":"Uses forcad program~~shape_half_circle~~UsesGraph program~shape_half_circle shape_half_circle module~forcad forcad program~shape_half_circle->module~forcad forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a half circle shape centered at the 0,0,0 with a radius of 1 Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Show the control geometry and geometry using PyVista Finalize and clean up the shape object. Calls program~~shape_half_circle~~CallsGraph program~shape_half_circle shape_half_circle create create program~shape_half_circle->create export_xc export_xc program~shape_half_circle->export_xc export_xg export_xg program~shape_half_circle->export_xg finalize finalize program~shape_half_circle->finalize set_half_circle set_half_circle program~shape_half_circle->set_half_circle show show program~shape_half_circle->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(nurbs_curve) :: shape","tags":"","loc":"program/shape_half_circle.html"},{"title":"example_put_to_nurbs – ForCAD","text":"Uses forcad forcad_utils program~~example_put_to_nurbs~~UsesGraph program~example_put_to_nurbs example_put_to_nurbs module~forcad forcad program~example_put_to_nurbs->module~forcad module~forcad_utils forcad_utils program~example_put_to_nurbs->module~forcad_utils module~forcad->module~forcad_utils forcad_nurbs_curve forcad_nurbs_curve module~forcad->forcad_nurbs_curve forcad_nurbs_surface forcad_nurbs_surface module~forcad->forcad_nurbs_surface forcad_nurbs_volume forcad_nurbs_volume module~forcad->forcad_nurbs_volume stdlib_quadrature stdlib_quadrature module~forcad_utils->stdlib_quadrature Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. You can create your shape or use a predefined one\nRead coordinates from file\nRead element connectivities from file\nSet a control shape that will be used to put the shape into\nThe contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points\nBy modifying the control shape you can modify the shape Map the shape into the shape Deallocate local variables Export the shape and the control shape to vtk files\nShow the control geometry and geometry using PyVista Finalize the control shape Calls program~~example_put_to_nurbs~~CallsGraph program~example_put_to_nurbs example_put_to_nurbs export_xc export_xc program~example_put_to_nurbs->export_xc export_xg export_xg program~example_put_to_nurbs->export_xg finalize finalize program~example_put_to_nurbs->finalize proc~hexahedron_xc hexahedron_Xc program~example_put_to_nurbs->proc~hexahedron_xc put_to_nurbs put_to_nurbs program~example_put_to_nurbs->put_to_nurbs set set program~example_put_to_nurbs->set show show program~example_put_to_nurbs->show Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: X (:,:) type(nurbs_volume) :: control_shape integer, allocatable :: elem (:,:) integer :: i integer :: nunit","tags":"","loc":"program/example_put_to_nurbs.html"},{"title":"example_ppm3.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm3.f90~~EfferentGraph sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm3 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 2 ]) call shape % translate_Xc ([ 0.01_rk , 0.01_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , 0.0_rk , 2.2_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 2 ]) call shape % translate_Xc ([ 0.51_rk , 0.01_rk , 0.0_rk ]) call shape % modify_Xc ( 0.24_rk , 2 , 2 ) call shape % modify_Xc ( 0.26_rk , 5 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 2 , 3 ]) call shape % translate_Xc ([ 0.01_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.26_rk , 3 , 1 ) call shape % modify_Xc ( 0.24_rk , 4 , 1 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 0.48_rk , 0.48_rk ], nc = [ 3 , 3 ]) call shape % translate_Xc ([ 0.51_rk , 0.51_rk , 0.0_rk ]) call shape % modify_Xc ( 0.7_rk , 1 , 2 ) call shape % modify_Xc ( 0.7_rk , 3 , 2 ) call shape % modify_Xc ( 0.8_rk , 7 , 2 ) call shape % modify_Xc ( 0.8_rk , 9 , 2 ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm3' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","loc":"sourcefile/example_ppm3.f90.html"},{"title":"shape_C_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_2d.f90~~EfferentGraph sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_2d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_2d_Xc.vtk' , 'vtk/shape_C_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_c_2d.f90.html"},{"title":"shape_half_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_3d.f90~~EfferentGraph sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a half ring centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_3d_Xc.vtk' , 'vtk/shape_half_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_half_ring_3d.f90.html"},{"title":"shape_C_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_3d.f90~~EfferentGraph sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius1 = 1.0_rk , radius2 = 2.0_rk , length = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_3d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( 100 , 60 , 10 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_3d_Xc.vtk' , 'vtk/shape_C_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_c_3d.f90.html"},{"title":"cmp_area.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_area.f90~~EfferentGraph sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_area use forcad implicit none type ( nurbs_surface ) :: shape real ( rk ) :: area real ( rk ) :: Xc ( 4 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_area ( area ) print * , area end program","tags":"","loc":"sourcefile/cmp_area.f90.html"},{"title":"example_ppm2.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm2.f90~~EfferentGraph sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm2 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.0_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 4 5.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , 0.0_rk , 2.2_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- !> Set the shape parameters for a ring call t % timer_start () center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.08_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 4 5.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.25_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.01_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , - 9 0.0_rk ) call shape % translate_Xc ([ 0.25_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.0_rk , 0.0_rk , 0.0_rk ] outer_radius = 0.24_rk * 2.0_rk inner_radius = 0.22_rk * 2.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_half_ring ( center , inner_radius , outer_radius ) call shape % rotate_Xc ( 0.0_rk , 0.0_rk , 0.0_rk ) call shape % translate_Xc ([ 0.75_rk , 0.75_rk , 0.0_rk ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting the colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm2' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","loc":"sourcefile/example_ppm2.f90.html"},{"title":"shape_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_2d.f90~~EfferentGraph sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a ring shape with inner radius 1.0 and outer radius 2.0. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_2d_Xc.vtk' , 'vtk/shape_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_ring_2d.f90.html"},{"title":"demo_volume.f90 – ForCAD","text":"This file depends on sourcefile~~demo_volume.f90~~EfferentGraph sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume. !> It sets up control points and weights, generates the volume, and exports the control points !> and the volume to VTK files at various stages. program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_volume_Xc.vtk' , 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"sourcefile/demo_volume.f90.html"},{"title":"example_surface_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_surface_1.f90~~EfferentGraph sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc.vtk' , 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc2.vtk' , 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_surface_Xc3.vtk' , 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","loc":"sourcefile/example_surface_1.f90.html"},{"title":"example_ppm1.f90 – ForCAD","text":"This file depends on sourcefile~~example_ppm1.f90~~EfferentGraph sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Visualization of NURBS surfaces using ForCAD, ForImage and ForColorMap libraries !> This example converts NURBS surfaces (vector) to an image (raster) using ForCAD, ForImage and ForColorMap libraries. program example_ppm1 use forcad , only : rk , nurbs_surface use forimage , only : ik , format_pnm , color use forcolormap , only : colormap use fortime , only : timer implicit none type ( nurbs_surface ) :: shape type ( format_pnm ) :: image type ( color ) :: background_color type ( colormap ) :: cmap integer ( ik ), allocatable :: px (:, :) real ( rk ), allocatable :: Xg (:,:), z_values (:) real ( rk ) :: center ( 3 ), inner_radius , outer_radius , aspect_ratio integer :: height , width , ng ( 2 ), red , green , blue , res1 , res2 , i integer , allocatable :: idx (:,:) type ( timer ) :: t !----------------------------------------------------------------------------- ! Set the image size and calculate the aspect ratio !----------------------------------------------------------------------------- width = 2000 height = 2000 aspect_ratio = real ( width , rk ) / real ( height , rk ) allocate ( px ( height , 3 * width )) !----------------------------------------------------------------------------- ! Set the background color using ForColor class of ForImage !----------------------------------------------------------------------------- call t % timer_start () call background_color % set ( 'white' , use_library = . true .) do i = 1 , width px (:, 3 * ( i - 1 ) + 1 ) = background_color % get_r () px (:, 3 * ( i - 1 ) + 2 ) = background_color % get_g () px (:, 3 * ( i - 1 ) + 3 ) = background_color % get_b () end do call t % timer_stop ( message = 'Setting the background color' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a tetragon res1 = 2000 res2 = 2000 call shape % set_tetragon ( L = [ 1.0_rk , 1.0_rk ], nc = [ 2 , 2 ]) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a tetragon' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'buda' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.0_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! circular gradient z_values = (( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 )))) ** 2 & + (( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) ** 2 ) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'managua' , 0.0_rk , 2.2_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.25_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.08_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the y-direction z_values = ( Xg (:, 2 ) - minval ( Xg (:, 2 ))) / ( maxval ( Xg (:, 2 )) - minval ( Xg (:, 2 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'lipari' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.25_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.01_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- call cmap % set ( 'oslo10' , 0.0_rk , 1.0_rk ) !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) call cmap % compute_RGB ( z_values ( i ), red , green , blue ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Set a shape object using ForCAD library !----------------------------------------------------------------------------- call t % timer_start () !> Set the shape parameters for a ring center = [ 0.75_rk , 0.75_rk , 0.0_rk ] outer_radius = 0.24_rk inner_radius = 0.22_rk res1 = 3500 res2 = 1000 center ( 2 ) = center ( 2 ) / aspect_ratio call shape % set_ring ( center , inner_radius , outer_radius ) call shape % create ( res1 , res2 ) Xg = shape % get_Xg () ng = shape % get_ng () call shape % finalize () call t % timer_stop ( message = 'Creating a ring' ) !----------------------------------------------------------------------------- ! Set the z-values of the geometry points !----------------------------------------------------------------------------- ! linear gradient in the x-direction z_values = ( Xg (:, 1 ) - minval ( Xg (:, 1 ))) / ( maxval ( Xg (:, 1 )) - minval ( Xg (:, 1 ))) !----------------------------------------------------------------------------- ! Set the colormap using ForColorMap library !----------------------------------------------------------------------------- red = 255 green = 215 blue = 0 !----------------------------------------------------------------------------- ! Set colors to the shape !----------------------------------------------------------------------------- call t % timer_start () Xg (:, 2 ) = Xg (:, 2 ) * aspect_ratio allocate ( idx ( ng ( 1 ) * ng ( 2 ), 2 )) idx (:, 1 ) = min ( max ( 1 , int ( Xg (:, 1 ) * width ) + 1 ), width ) idx (:, 2 ) = min ( max ( 1 , int ( Xg (:, 2 ) * height ) + 1 ), height ) do i = 1 , ng ( 1 ) * ng ( 2 ) px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 1 ) = red px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 2 ) = green px ( idx ( i , 2 ), 3 * ( idx ( i , 1 ) - 1 ) + 3 ) = blue end do deallocate ( idx ) call t % timer_stop ( message = 'Setting colors' ) !----------------------------------------------------------------------------- ! Save the image to a PPM file using ForImage library !----------------------------------------------------------------------------- call t % timer_start () call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'example: ForCAD + ForImage + ForColor + ForColormap' , & pixels = px & ) call image % export_pnm ( 'ppm/example_ppm1' ) call image % finalize () call t % timer_stop ( message = 'Saving the image' ) ! Clean up call cmap % finalize () deallocate ( px , Xg , z_values ) end program","tags":"","loc":"sourcefile/example_ppm1.f90.html"},{"title":"nearest_point_3d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_3d.f90~~EfferentGraph sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !! Declare a NURBS volume object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the volume real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 8 , 3 ) !! Control points real ( rk ) :: Wc ( 8 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS hexahedron !----------------------------------------------------------------------------- Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 4.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 4.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 2.0_rk ] Xc ( 6 ,:) = [ 2.0_rk , 0.0_rk , 2.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 4.0_rk , 2.0_rk ] Xc ( 8 ,:) = [ 2.0_rk , 4.0_rk , 2.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 1.11_rk , 1.0_rk , 0.5_rk , 0.5_rk , 1.2_rk , 1.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, 20 call shape % create ( 30 , 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the volume !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.5_rk , 3.5_rk , 1.1_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the volume (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the volume to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the volume (optional) call shape % nearest_point2 ([ 1.5_rk , 3.5_rk , 1.1_rk ], 1.0e-11_rk , 500 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,g0)' ,& 'Nearest point on the volume:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","loc":"sourcefile/nearest_point_3d.f90.html"},{"title":"nearest_point_2d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d.f90~~EfferentGraph sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the surface real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ) :: Xc ( 4 , 3 ) !! Control points real ( rk ) :: Wc ( 4 ) !! Weights of the control points !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a surface with 4 control points Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] !> The weights of the control points (Wc) are optional. Wc = [ 1.0_rk , 1.1_rk , 0.7_rk , 1.0_rk ] call shape % set ( knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ], Xc = Xc , Wc = Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !----------------------------------------------------------------------------- ! Nearest point on the surface (Approximation) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the surface (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) call shape % nearest_point2 ([ 1.3_rk , 1.0_rk , 1.999999999_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the surface:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () ! deallocate(nearest_Xg, nearest_Xt) end program","tags":"","loc":"sourcefile/nearest_point_2d.f90.html"},{"title":"shape_hexahedron.f90 – ForCAD","text":"This file depends on sourcefile~~shape_hexahedron.f90~~EfferentGraph sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_hexahedron use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8]. !> The weights of the control points (Wc) are optional. call shape % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 6 , 8 ]) ! Additional modifications can be made to control points and weights, or the NURBS can be refined using knot insertion or degree elevation. ! call shape%insert_knots(...) ! call shape%elevate_degree(...) ! ... !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_hexahedron_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 8 , 16 , 32 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_hexahedron_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_hexahedron_Xc.vtk' , 'vtk/shape_hexahedron_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_hexahedron.f90.html"},{"title":"nearest_point_1d.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_1d.f90~~EfferentGraph sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector real ( rk ), allocatable :: nearest_Xg (:) !! Array for the nearest point on the curve real ( rk ) :: nearest_Xt !! Array for the parametric coordinates of the nearest point integer :: id !! Variable for the id of the nearest point !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 1.1_rk , 1.0_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call shape % set ( knot , Xc , Wc ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call shape % create ( 20 ) !----------------------------------------------------------------------------- ! Nearest point on the curve !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) call shape % nearest_point ([ 4.5_rk , 4.5_rk , 5.0_rk ], nearest_Xg , nearest_Xt , id ) print '(a,1x,g0,2x,g0,2x,g0,a,2x,g0,2x,a,1x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt , ' and id:' , id !----------------------------------------------------------------------------- ! Nearest point on the curve (Optimization) !----------------------------------------------------------------------------- !> Find the nearest point on the curve to a given point !> The optimization method is used to find the nearest point !> The optimization method is based on the Newton-Raphson method ! nearest_Xt: Corresponding parametric coordinates of the nearest point ! nearest_Xg: Coordinates of the nearest point on the curve (optional) call shape % nearest_point2 ([ 4.5_rk , 4.5_rk , 5.0_rk ], 1.0e-11_rk , 30 , nearest_Xt , nearest_Xg ) print '(a,1x,g0,2x,g0,a,2x,g0,2x,g0)' ,& 'Nearest point on the curve:' , nearest_Xg , ' with parametric coordinates:' , nearest_Xt !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () deallocate ( nearest_Xg , Xc , Wc ) end program","tags":"","loc":"sourcefile/nearest_point_1d.f90.html"},{"title":"shape_half_ring_2d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_ring_2d.f90~~EfferentGraph sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_ring_2d use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: shape !> Set up a half ring shape centered at 0,0,0 with inner radius 1 and outer radius 2. call shape % set_half_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_ring_2d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_ring_2d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_ring_2d_Xc.vtk' , 'vtk/shape_half_ring_2d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_half_ring_2d.f90.html"},{"title":"demo_curve.f90 – ForCAD","text":"This file depends on sourcefile~~demo_curve.f90~~EfferentGraph sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve. !> It sets up control points and weights, generates the curve, and exports the control points !> and the curve to VTK files at various stages. program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_curve_Xc.vtk' , 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","loc":"sourcefile/demo_curve.f90.html"},{"title":"cmp_volume.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_volume.f90~~EfferentGraph sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_volume use forcad implicit none type ( nurbs_volume ) :: shape real ( rk ) :: volume real ( rk ) :: Xc ( 8 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 0.0_rk , 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ 2.0_rk , 2.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ 0.0_rk , 0.0_rk , 2.0_rk ] Xc ( 6 ,:) = [ 2.0_rk , 0.0_rk , 2.0_rk ] Xc ( 7 ,:) = [ 0.0_rk , 2.0_rk , 2.0_rk ] Xc ( 8 ,:) = [ 2.0_rk , 2.0_rk , 2.0_rk ] call shape % set (& knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_volume ( volume ) print * , volume end program","tags":"","loc":"sourcefile/cmp_volume.f90.html"},{"title":"shape_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_circle.f90~~EfferentGraph sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS circle !----------------------------------------------------------------------------- !> Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_circle ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_circle_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating circle !----------------------------------------------------------------------------- !> Generate the NURBS circle with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_circle_Xc.vtk' , 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_circle.f90.html"},{"title":"shape_C_1d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_c_1d.f90~~EfferentGraph sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_C_1d use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS C-shape !----------------------------------------------------------------------------- !> Set a C-shape with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_C ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_C_1d_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating C-shape !----------------------------------------------------------------------------- !> Generate the NURBS C-shape with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_C_1d_Xc.vtk' , 'vtk/shape_C_1d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_c_1d.f90.html"},{"title":"forcad_utils.f90 – ForCAD","text":"Files dependent on this one sourcefile~~forcad_utils.f90~~AfferentGraph sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module contains parameters, functions and subroutines that are used in the library. module forcad_utils use stdlib_quadrature , only : gauss_legendre implicit none private public :: rk , basis_bernstein , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , tetragon_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation , basis_bspline_2der , det , inv , dyad , gauss_leg integer , parameter :: rk = kind ( 1.0d0 ) !=============================================================================== interface elemConn_C0 module procedure cmp_elemConn_C0_L module procedure cmp_elemConn_C0_S module procedure cmp_elemConn_C0_V end interface !=============================================================================== !=============================================================================== interface elemConn_Cn module procedure cmp_elemConn_Cn_L module procedure cmp_elemConn_Cn_S module procedure cmp_elemConn_Cn_V end interface !=============================================================================== !=============================================================================== interface ndgrid module procedure ndgrid2 module procedure ndgrid3 end interface !=============================================================================== !=============================================================================== interface compute_multiplicity module procedure compute_multiplicity1 module procedure compute_multiplicity2 end interface !=============================================================================== !=============================================================================== interface unique module procedure unique_integer module procedure unique_real end interface !=============================================================================== !=============================================================================== interface dyad module procedure dyad_t1_t1 end interface !=============================================================================== !=============================================================================== interface gauss_leg module procedure gauss_legendre_1D module procedure gauss_legendre_2D module procedure gauss_legendre_3D end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bspline ( Xt , knot , nc , degree ) result ( B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 real ( rk ), allocatable :: Nt (:,:) integer :: i , p real ( rk ), allocatable :: B (:) temp = abs ( Xt - knot ( size ( knot ))) allocate ( Nt ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xt >= Xth_i . and . Xt <= Xth_i1 ) Nt ( i , 0 ) = 1.0_rk if ( Xth_ip /= Xth_i ) Nt ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * Nt ( i , p - 1 ) if ( Xth_ip1 /= Xth_i1 ) Nt ( i , p ) = Nt ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * Nt ( i + 1 , p - 1 ) end do end do B = Nt (:, degree ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_der ( Xt , knot , nc , degree , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: dB (:) real ( rk ), allocatable , intent ( out ), optional :: B (:) real ( rk ), allocatable :: N (:,:), dN_dXt (:,:) real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 integer :: i , p temp = abs ( Xt - knot ( size ( knot ))) allocate ( N ( nc , 0 : degree ), source = 0.0_rk ) allocate ( dN_dXt ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xth_i <= Xt . and . Xt <= Xth_i1 ) then N ( i , 0 ) = 1.0_rk dN_dXt ( i , 0 ) = 0.0_rk end if if ( Xth_ip /= Xth_i ) then N ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * N ( i , p - 1 ) dN_dXt ( i , p ) = ( N ( i , p - 1 ) + ( Xt - Xth_i ) * dN_dXt ( i , p - 1 ) ) / ( Xth_ip - Xth_i ) end if if ( Xth_ip1 /= Xth_i1 ) then N ( i , p ) = N ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * N ( i + 1 , p - 1 ) dN_dXt ( i , p ) = dN_dXt ( i , p ) - ( N ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * dN_dXt ( i + 1 , p - 1 ) ) / ( Xth_ip1 - Xth_i1 ) end if end do end do dB = dN_dXt (:, degree ) if ( present ( B )) B = N (:, degree ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis_bspline_2der ( Xt , knot , nc , degree , d2B , dB , B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable , intent ( out ) :: d2B (:) real ( rk ), allocatable , intent ( out ), optional :: dB (:) real ( rk ), allocatable , intent ( out ), optional :: B (:) real ( rk ), allocatable :: N (:,:), dN_dXt (:,:), d2N_dXt2 (:,:) real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 integer :: i , p temp = abs ( Xt - knot ( size ( knot ))) allocate ( N ( nc , 0 : degree ), source = 0.0_rk ) allocate ( dN_dXt ( nc , 0 : degree ), source = 0.0_rk ) allocate ( d2N_dXt2 ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do concurrent ( i = 1 : nc ) Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xth_i <= Xt . and . Xt <= Xth_i1 ) then N ( i , 0 ) = 1.0_rk dN_dXt ( i , 0 ) = 0.0_rk d2N_dXt2 ( i , 0 ) = 0.0_rk end if if ( Xth_ip /= Xth_i ) then N ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * N ( i , p - 1 ) ! dN_dXt(i,p) = p*(N(i,p-1)/(Xth_ip - Xth_i)) dN_dXt ( i , p ) = ( N ( i , p - 1 ) + ( Xt - Xth_i ) * dN_dXt ( i , p - 1 ) ) / ( Xth_ip - Xth_i ) d2N_dXt2 ( i , p ) = ( 2 * dN_dXt ( i , p - 1 ) + ( Xt - Xth_i ) * d2N_dXt2 ( i , p - 1 )) / ( Xth_ip - Xth_i ) end if if ( Xth_ip1 /= Xth_i1 ) then N ( i , p ) = N ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * N ( i + 1 , p - 1 ) ! dN_dXt(i,p) = dN_dXt(i,p) - p*( N(i+1,p-1)/(Xth_ip1 - Xth_i1)) dN_dXt ( i , p ) = dN_dXt ( i , p ) - ( N ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * dN_dXt ( i + 1 , p - 1 ) ) / ( Xth_ip1 - Xth_i1 ) d2N_dXt2 ( i , p ) = d2N_dXt2 ( i , p ) - ( 2 * dN_dXt ( i + 1 , p - 1 ) - ( Xth_ip1 - Xt ) * d2N_dXt2 ( i + 1 , p - 1 )) / ( Xth_ip1 - Xth_i1 ) end if end do end do d2B = d2N_dXt2 (:, degree ) if ( present ( dB )) dB = dN_dXt (:, degree ) if ( present ( B )) B = N (:, degree ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bernstein ( Xt , nc ) result ( B ) real ( rk ), intent ( in ) :: Xt integer , intent ( in ) :: nc real ( rk ), allocatable :: B (:) integer :: p , degree degree = nc - 1 allocate ( B ( nc ), source = 0.0_rk ) do concurrent ( p = 0 : degree ) B ( p + 1 ) = gamma ( real ( nc , kind = rk )) / ( gamma ( real ( p + 1 , kind = rk )) * gamma ( real ( nc - p , kind = rk ))) if ( Xt == 0.0_rk . and . p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( 1.0_rk - Xt ) ** ( degree - p ) else if ( Xt == 0.0_rk . and . degree - p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) else B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) * ( 1.0_rk - Xt ) ** ( degree - p ) end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron ( u , v ) result ( w ) real ( rk ), intent ( in ), contiguous :: u (:), v (:) real ( rk ) :: w ( size ( u ) * size ( v )) integer :: i , j , n n = size ( v ) do concurrent ( i = 1 : size ( u ), j = 1 : n ) w (( i - 1 ) * n + j ) = u ( i ) * v ( j ) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid2 ( X_dir1 , X_dir2 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , i , j s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) allocate ( Xt ( s1 * s2 , 2 )) do concurrent ( j = 1 : s2 , i = 1 : s1 ) Xt (( j - 1 ) * s1 + i , 1 ) = X_dir1 ( i ) Xt (( j - 1 ) * s1 + i , 2 ) = X_dir2 ( j ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid3 ( X_dir1 , X_dir2 , X_dir3 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:), X_dir3 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , s3 , i , j , k s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) s3 = size ( X_dir3 ) allocate ( Xt ( s1 * s2 * s3 , 3 )) do concurrent ( k = 1 : s3 , j = 1 : s2 , i = 1 : s1 ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 1 ) = X_dir1 ( i ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 2 ) = X_dir2 ( j ) Xt ((( k - 1 ) * s2 + ( j - 1 )) * s1 + i , 3 ) = X_dir3 ( k ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function repelem ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) integer , intent ( in ), contiguous :: b (:) real ( rk ) :: c ( sum ( b )) integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_L ( nnode , p ) result ( elemConn ) integer , intent ( in ) :: nnode integer , intent ( in ) :: p integer , allocatable :: elemConn (:,:) integer :: i , l integer , allocatable :: nodes (:) if ( mod ( nnode - 1 , p ) /= 0 ) error stop 'cmp_elemConn_C0_L: nnode-1 must be divisible by p' allocate ( elemConn ( ( nnode - 1 ) / p , p + 1 )) nodes = [( i , i = 1 , nnode )] l = 0 do i = 1 , nnode - p , p l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p ),[( p + 1 )]) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_S ( nnode1 , nnode2 , p1 , p2 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 integer , intent ( in ) :: p1 , p2 integer , allocatable :: elemConn (:,:) integer :: i , j , l integer , allocatable :: nodes (:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_S: nnode2-1 must be divisible by p2' allocate ( elemConn ( (( nnode1 - 1 ) / p1 ) * (( nnode2 - 1 ) / p2 ), ( p1 + 1 ) * ( p2 + 1 ))) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 )], [ nnode1 , nnode2 ]) l = 0 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 ),[( p1 + 1 ) * ( p2 + 1 )]) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 , nnode3 integer , intent ( in ) :: p1 , p2 , p3 integer , allocatable :: elemConn (:,:) integer :: i , j , k , l integer , allocatable :: nodes (:,:,:) if ( mod ( nnode1 - 1 , p1 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode1-1 must be divisible by p1' if ( mod ( nnode2 - 1 , p2 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode2-1 must be divisible by p2' if ( mod ( nnode3 - 1 , p3 ) /= 0 ) error stop 'cmp_elemConn_C0_V: nnode3-1 must be divisible by p3' allocate ( elemConn ( (( nnode1 - 1 ) / p1 ) * (( nnode2 - 1 ) / p2 ) * (( nnode3 - 1 ) / p3 ) ,( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 ))) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 * nnode3 )], [ nnode1 , nnode2 , nnode3 ]) l = 0 do k = 1 , nnode3 - p3 , p3 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 , k : k + p3 ),[( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 )]) end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_L ( nnode , p , Xth , vecKnot_mul , elemConn ) integer , intent ( in ) :: p , nnode integer , intent ( in ), contiguous :: vecKnot_mul (:) real ( rk ), intent ( in ), contiguous :: Xth (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:) integer :: i , nnel , m , nelem nnel = p + 1 nodes = [( i , i = 1 , nnode )] nelem = size ( Xth ) - 1 allocate ( elemConn ( nelem , nnel )) m = - p do i = 1 , nelem m = m + vecKnot_mul ( i ) elemConn ( i ,:) = nodes ( m : m + p ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_S ( nnode1 , nnode2 , p1 , p2 ,& Xth1 , Xth2 , vecKnot_mul1 , vecKnot_mul2 , elemConn ) integer , intent ( in ) :: p1 , p2 , nnode1 , nnode2 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:), nodes_vec (:) integer :: nnd_total , i , j , l , nnel1 , nnel2 , m , n , nelem1 , nelem2 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnd_total = nnode1 * nnode2 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem = nelem1 * nelem2 allocate ( elemConn ( nelem , nnel1 * nnel2 )) l = 0 n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 ), [ nnel1 * nnel2 ]) end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ,& Xth1 , Xth2 , Xth3 , vecKnot_mul1 , vecKnot_mul2 , vecKnot_mul3 , elemConn ) integer , intent ( in ) :: p1 , p2 , p3 , nnode1 , nnode2 , nnode3 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:), vecKnot_mul3 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:), Xth3 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:,:), nodes_vec (:) integer :: nnd_total , i , j , k , l , nnel1 , nnel2 , nnel3 , m , n , o , nelem1 , nelem2 , nelem3 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnel3 = p3 + 1 nnd_total = nnode1 * nnode2 * nnode3 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 , nnode3 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem3 = size ( Xth3 ) - 1 nelem = nelem1 * nelem2 * nelem3 allocate ( elemConn ( nelem , nnel1 * nnel2 * nnel3 )) l = 0 o = - p3 do k = 1 , nelem3 o = o + vecKnot_mul3 ( k ) n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 , o : o + p3 ), [ nnel1 * nnel2 * nnel3 ]) end do end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity1 ( knot ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) integer , allocatable :: multiplicity (:) integer :: i , count count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) count = count + 1 end do allocate ( multiplicity ( count )) multiplicity ( 1 ) = 1 count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) then count = count + 1 multiplicity ( count ) = 1 else multiplicity ( count ) = multiplicity ( count ) + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity2 ( knot , Xth ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ) :: Xth integer :: multiplicity integer :: i , count , size_knot size_knot = size ( knot ) multiplicity = 0 i = 1 do while ( i <= size_knot ) if ( knot ( i ) == Xth ) then count = 1 do while ( i + count <= size_knot . and . knot ( i + count ) == Xth ) count = count + 1 end do if ( count > multiplicity ) then multiplicity = count end if i = i + count else i = i + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_knot_vector ( Xth_dir , degree , continuity ) result ( knot ) real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), allocatable :: knot (:) knot = repelem ( Xth_dir , ( degree - continuity )) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause elemental pure function isinf ( x ) result ( output ) real ( rk ), intent ( in ) :: x logical :: output output = . false . if ( x > huge ( x )) output = . true . if ( x < - huge ( x )) output = . true . end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause elemental pure function isnan ( x ) result ( output ) real ( rk ), intent ( in ) :: x logical :: output output = . false . if ( x /= x ) output = . true . end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knot_A_5_1 ( p , UP , Pw , u , k , s , r , nq , UQ , Qw ) integer , intent ( in ) :: p , k , s , r real ( rk ), intent ( in ), contiguous :: UP ( 0 :), Pw ( 0 :,:) real ( rk ), intent ( in ) :: u real ( rk ), allocatable , intent ( out ) :: UQ (:), Qw (:,:) integer , intent ( out ) :: nq integer :: i , j , L , mp , dim , np real ( rk ), allocatable :: Rw (:,:) real ( rk ) :: alpha dim = size ( Pw , 2 ) np = size ( Pw , 1 ) - 1 mp = np + p + 1 nq = np + r allocate ( UQ ( 0 : mp + r )) allocate ( Qw ( 0 : nq , 1 : dim )) allocate ( Rw ( 0 : p , 1 : dim )) UQ ( 0 : k ) = UP ( 0 : k ) UQ ( k + 1 : k + r ) = u UQ ( k + 1 + r : mp + r ) = UP ( k + 1 : mp ) Qw ( 0 : k - p ,:) = Pw ( 0 : k - p ,:) Qw ( k - s + r : np + r ,:) = Pw ( k - s : np ,:) Rw ( 0 : p - s ,:) = Pw ( k - p : k - s ,:) do j = 1 , r L = k - p + j do i = 0 , p - j - s alpha = ( u - UP ( L + i )) / ( UP ( i + k + 1 ) - UP ( L + i )) Rw ( i ,:) = alpha * Rw ( i + 1 ,:) + ( 1.0_rk - alpha ) * Rw ( i ,:) end do Qw ( L ,:) = Rw ( 0 ,:) Qw ( k + r - j - s ,:) = Rw ( p - j - s ,:) end do Qw ( L + 1 : k - s - 1 ,:) = Rw ( 1 : k - s - 1 - L ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function findspan ( n , degree , Xth , knot ) result ( s ) integer , intent ( in ) :: n , degree real ( rk ), intent ( in ) :: Xth real ( rk ), intent ( in ), contiguous :: knot (:) integer :: s integer :: low , high , mid if ( Xth == knot ( n + 2 )) then s = n return end if low = degree high = n + 1 mid = ( low + high ) / 2 do while ( Xth < knot ( mid + 1 ) . or . Xth >= knot ( mid + 2 )) if ( Xth < knot ( mid + 1 )) then high = mid else low = mid end if mid = ( low + high ) / 2 end do s = mid end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree_A_5_9 ( t , knot , degree , Xcw , nc_new , knot_new , Xcw_new ) integer , intent ( in ) :: t real ( rk ), intent ( in ), contiguous :: Xcw (:,:), knot (:) integer , intent ( in ) :: degree integer , intent ( out ) :: nc_new real ( rk ), allocatable , intent ( out ) :: Xcw_new (:,:), knot_new (:) real ( rk ), allocatable :: bezalfs (:,:), bpts (:,:), ebpts (:,:), Nextbpts (:,:), alfs (:) real ( rk ) :: inv , alpha1 , alpha2 , Xth1 , Xth2 , numer , den integer :: n , lbz , rbz , sv , tr , kj , first , knoti , last , alpha3 , dim , nc integer :: i , j , q , s , m , ph , ph2 , mpi , mh , r , a , b , Xcwi , oldr , mul integer , allocatable :: mlp (:) nc = size ( Xcw , 1 ) dim = size ( Xcw , 2 ) mlp = compute_multiplicity ( knot ) mlp = mlp + t nc_new = sum ( mlp ) - ( mlp ( 1 ) - 1 ) - 1 allocate ( Xcw_new ( nc_new , dim ), source = 0.0_rk ) allocate ( bezalfs ( degree + 1 , degree + t + 1 ), source = 0.0_rk ) allocate ( bpts ( degree + 1 , dim ), source = 0.0_rk ) allocate ( ebpts ( degree + t + 1 , dim ), source = 0.0_rk ) allocate ( Nextbpts ( degree + 1 , dim ), source = 0.0_rk ) allocate ( alfs ( degree ), source = 0.0_rk ) n = nc - 1 m = n + degree + 1 ph = degree + t ph2 = ph / 2 bezalfs ( 1 , 1 ) = 1.0_rk bezalfs ( degree + 1 , ph + 1 ) = 1.0_rk do i = 1 , ph2 inv = 1.0_rk / bincoeff ( ph , i ) mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = inv * bincoeff ( degree , j ) * bincoeff ( t , i - j ) end do end do do i = ph2 + 1 , ph - 1 mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = bezalfs ( degree - j + 1 , ph - i + 1 ) end do end do mh = ph knoti = ph + 1 r = - 1 a = degree b = degree + 1 Xcwi = 1 Xth1 = knot ( 1 ) Xcw_new ( 1 ,:) = Xcw ( 1 ,:) allocate ( knot_new ( sum ( mlp )), source = 0.0_rk ) knot_new ( 1 : ph + 1 ) = Xth1 do i = 0 , degree bpts ( i + 1 ,:) = Xcw ( i + 1 ,:) end do do while ( b < m ) i = b do while ( b < m . and . knot ( b + 1 ) == knot ( b + 2 )) b = b + 1 if ( b + 2 > size ( knot )) then exit end if end do mul = b - i + 1 mh = mh + mul + t Xth2 = knot ( b + 1 ) oldr = r r = degree - mul if ( oldr > 0 ) then lbz = ( oldr + 2 ) / 2 else lbz = 1 end if if ( r > 0 ) then rbz = ph - ( r + 1 ) / 2 else rbz = ph end if if ( r > 0 ) then numer = Xth2 - Xth1 do q = degree , mul + 1 , - 1 alfs ( q - mul ) = numer / ( knot ( a + q + 1 ) - Xth1 ) end do do j = 1 , r sv = r - j s = mul + j do q = degree , s , - 1 bpts ( q + 1 ,:) = ( 1.0_rk - alfs ( q - s + 1 )) * bpts ( q ,:) + alfs ( q - s + 1 ) * bpts ( q + 1 ,:) end do Nextbpts ( sv + 1 ,:) = bpts ( degree + 1 ,:) end do end if do i = lbz , ph ebpts ( i + 1 ,:) = 0.0_rk mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi ebpts ( i + 1 ,:) = bezalfs ( j + 1 , i + 1 ) * bpts ( j + 1 ,:) + ebpts ( i + 1 ,:) end do end do if ( oldr > 1 ) then first = knoti - 2 last = knoti den = Xth2 - Xth1 alpha3 = floor (( Xth2 - knot ( knoti )) / den ) do tr = 1 , oldr - 1 i = first j = last kj = j - knoti + 1 do while ( j - i > tr ) if ( i < Xcwi ) then alpha1 = ( Xth2 - knot ( i + 1 )) / ( Xth1 - knot ( i + 1 )) Xcw_new ( i + 1 ,:) = ( 1 - alpha1 ) * Xcw_new ( i ,:) + alpha1 * Xcw_new ( i + 1 ,:) end if if ( j >= lbz ) then if ( j - tr <= knoti - ph + oldr ) then alpha2 = ( Xth2 - knot_new ( j - tr + 1 )) / den ebpts ( kj + 1 ,:) = alpha2 * ebpts ( kj + 1 ,:) + ( 1 - alpha2 ) * ebpts ( kj + 2 ,:) else ebpts ( kj + 1 ,:) = ( 1 - alpha3 ) * ebpts (:, kj + 2 ) + alpha3 * ebpts ( kj + 1 ,:) end if end if i = i + 1 j = j - 1 kj = kj - 1 end do first = first - 1 last = last + 1 end do end if if ( a /= degree ) then do i = 0 , ph - oldr - 1 knot_new ( knoti + 1 ) = Xth1 knoti = knoti + 1 end do end if do j = lbz , rbz Xcw_new ( Xcwi + 1 ,:) = ebpts ( j + 1 ,:) Xcwi = Xcwi + 1 end do if ( b < m ) then do j = 0 , r - 1 bpts ( j + 1 ,:) = Nextbpts ( j + 1 ,:) end do do j = r , degree bpts ( j + 1 ,:) = Xcw ( b - degree + j + 1 ,:) end do a = b b = b + 1 Xth1 = Xth2 else do i = 0 , ph knot_new ( knoti + i + 1 ) = Xth2 end do end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function bincoeff ( n , k ) result ( b ) integer , intent ( in ) :: n , k real ( rk ) :: b b = floor ( 0.5_rk + exp ( factln ( n ) - factln ( k ) - factln ( n - k ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function factln ( n ) result ( f ) integer , intent ( in ) :: n real ( rk ) :: f if ( n <= 1 ) then f = 0.0_rk return end if f = log ( gamma ( real ( n + 1 , rk ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function hexahedron_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy , dz integer :: i , j , k , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) dz = L ( 3 ) / real ( nc ( 3 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) nci = 1 do k = 0 , nc ( 3 ) - 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = real ( k , rk ) * dz nci = nci + 1 end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function tetragon_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy integer :: i , j , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ), 3 )) nci = 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = 0.0_rk nci = nci + 1 end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots_A_5_8 ( p , knot , Pw , u , r , s , num , t , knot_new , Pw_new ) real ( rk ), intent ( in ) :: u integer , intent ( in ) :: p , r , s , num real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Pw (:,:) real ( rk ), allocatable , intent ( out ) :: knot_new (:) real ( rk ), allocatable , intent ( out ) :: Pw_new (:,:) real ( rk ), allocatable :: Pw_copy (:,:), knot_copy (:) integer , intent ( out ) :: t real ( rk ) :: tol , alfi , alfj real ( rk ), allocatable :: temp (:,:) integer :: i , j , ii , jj , remflag , off , first , last , ord , fout , m , k , n , nc , dim , tt dim = size ( Pw , 2 ) nc = size ( Pw , 1 ) n = nc m = n + p + 1 ord = p + 1 fout = ( 2 * r - s - p ) / 2 last = r - s first = r - p Pw_copy = Pw knot_copy = knot ! TODO: tol = 1.0e-6_rk * minval ( Pw (:, dim )) / ( 1.0_rk + maxval ( sqrt ( sum ( Pw ** 2 , 2 )))) allocate ( temp ( 2 * p + 1 , dim ), source = 0.0_rk ) t = 0 do tt = 0 , num - 1 off = first - 1 temp ( 1 ,:) = Pw_copy ( off ,:) temp ( last + 1 - off + 1 ,:) = Pw_copy ( last + 1 ,:) i = first j = last ii = 1 jj = last - off remflag = 0 do while ( j - i > t ) alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) alfj = ( u - knot_copy ( j - t )) / ( knot_copy ( j + ord ) - knot_copy ( j - t )) temp ( ii + 1 ,:) = ( Pw_copy ( i ,:) - ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:)) / alfi temp ( jj + 1 ,:) = ( Pw_copy ( j ,:) - alfj * temp ( jj + 1 + 1 ,:)) / ( 1.0_rk - alfj ) i = i + 1 ii = ii + 1 j = j - 1 jj = jj - 1 end do if ( j - i <= t ) then if ( norm2 ( temp ( ii - 1 + 1 ,:) - temp ( jj + 1 + 1 ,:)) <= tol ) then remflag = 1 else alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) if ( norm2 ( Pw_copy ( i ,:) - ( alfi * temp ( ii + t + 1 + 1 ,:) + ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:))) <= tol ) then remflag = 1 end if end if end if if ( remflag == 0 ) then exit else i = first j = last do while ( j - i > t ) Pw_copy ( i ,:) = temp ( i - off + 1 ,:) Pw_copy ( j ,:) = temp ( j - off + 1 ,:) i = i + 1 j = j - 1 end do end if first = first - 1 last = last + 1 t = t + 1 end do if ( t == 0 ) then return end if do k = r + 1 , m knot_copy ( k - t ) = knot_copy ( k ) end do j = fout i = j do k = 1 , t - 1 if ( mod ( k , 2 ) == 1 ) then i = i + 1 else j = j - 1 end if end do do k = i + 1 , n Pw_copy ( j ,:) = Pw_copy ( k ,:) j = j + 1 end do knot_new = knot_copy ( 1 : size ( knot_copy ) - t ) Pw_new = Pw_copy ( 1 : size ( Pw_copy , 1 ) - t ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_integer ( vec ) result ( output ) integer , dimension (:), intent ( in ), contiguous :: vec integer , dimension (:), allocatable :: output integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) if ( vec ( i ) == output ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_real ( vec ) result ( output ) real ( rk ), dimension (:), intent ( in ), contiguous :: vec real ( rk ), dimension (:), allocatable :: output integer :: i , j , k allocate ( output ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( output ) if ( vec ( i ) == output ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then output = [ output , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function rotation ( alpha , beta , theta ) result ( R ) real ( rk ), intent ( in ) :: alpha , beta , theta real ( rk ), dimension ( 3 , 3 ) :: R R ( 1 , 1 ) = cosd ( beta ) * cosd ( theta ) R ( 2 , 1 ) = cosd ( beta ) * sind ( theta ) R ( 3 , 1 ) = - sind ( beta ) R ( 1 , 2 ) = sind ( alpha ) * sind ( beta ) * cosd ( theta ) - cosd ( alpha ) * sind ( theta ) R ( 2 , 2 ) = sind ( alpha ) * sind ( beta ) * sind ( theta ) + cosd ( alpha ) * cosd ( theta ) R ( 3 , 2 ) = sind ( alpha ) * cosd ( beta ) R ( 1 , 3 ) = cosd ( alpha ) * sind ( beta ) * cosd ( theta ) + sind ( alpha ) * sind ( theta ) R ( 2 , 3 ) = cosd ( alpha ) * sind ( beta ) * sind ( theta ) - sind ( alpha ) * cosd ( theta ) R ( 3 , 3 ) = cosd ( alpha ) * cosd ( beta ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function det ( A ) result ( detA ) real ( rk ), intent ( in ) :: A (:,:) real ( rk ) :: detA if ( size ( A , 1 ) == size ( A , 2 )) then select case ( size ( A , 1 )) case ( 2 ) detA = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) case ( 3 ) detA = & + A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) )& - A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 ) )& + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) ) end select elseif ( size ( A , 1 ) == 3 . and . size ( A , 2 ) == 2 ) then detA = & + A ( 1 , 1 ) * ( A ( 2 , 2 ) * 1.0_rk - A ( 3 , 2 ) * 1.0_rk )& - A ( 1 , 2 ) * ( A ( 2 , 1 ) * 1.0_rk - A ( 3 , 1 ) * 1.0_rk )& + 1.0_rk * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 3 , 1 ) * A ( 2 , 2 ) ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause recursive pure function inv ( A ) result ( A_inv ) real ( rk ), intent ( in ) :: A (:,:) real ( rk ), allocatable :: A_inv (:,:) if ( size ( A , 1 ) == size ( A , 2 )) then select case ( size ( A , 1 )) case ( 2 ) allocate ( A_inv ( size ( A , 1 ), size ( A , 2 ))) A_inv ( 1 , 1 ) = A ( 2 , 2 ) A_inv ( 1 , 2 ) = - A ( 1 , 2 ) A_inv ( 2 , 1 ) = - A ( 2 , 1 ) A_inv ( 2 , 2 ) = A ( 1 , 1 ) A_inv = A_inv / det ( A ) case ( 3 ) allocate ( A_inv ( size ( A , 1 ), size ( A , 2 ))) A_inv ( 1 , 1 ) = A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) A_inv ( 1 , 2 ) = A ( 1 , 3 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 3 ) A_inv ( 1 , 3 ) = A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 ) A_inv ( 2 , 1 ) = A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 ) A_inv ( 2 , 2 ) = A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 ) A_inv ( 2 , 3 ) = A ( 1 , 3 ) * A ( 2 , 1 ) - A ( 1 , 1 ) * A ( 2 , 3 ) A_inv ( 3 , 1 ) = A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) A_inv ( 3 , 2 ) = A ( 1 , 2 ) * A ( 3 , 1 ) - A ( 1 , 1 ) * A ( 3 , 2 ) A_inv ( 3 , 3 ) = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) A_inv = A_inv / det ( A ) end select elseif ( size ( A , 1 ) > size ( A , 2 )) then allocate ( A_inv ( size ( A , 2 ), size ( A , 1 ))) A_inv = transpose ( A ) A_inv = matmul ( inv ( matmul ( A_inv , A )), A_inv ) elseif ( size ( A , 1 ) < size ( A , 2 )) then allocate ( A_inv ( size ( A , 2 ), size ( A , 1 ))) A_inv = transpose ( A ) A_inv = matmul ( A_inv , inv ( matmul ( A , A_inv ))) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function dyad_t1_t1 ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) real ( rk ), intent ( in ), contiguous :: b (:) real ( rk ), allocatable :: c (:,:) integer :: i allocate ( c ( size ( a ), size ( b ))) do concurrent ( i = 1 : size ( c , 1 )) c ( i , :) = a ( i ) * b (:) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_1D ( interval , degree , Xksi , Wksi ) real ( rk ), intent ( in ) :: interval ( 2 ) integer , intent ( in ) :: degree real ( rk ), allocatable , intent ( out ) :: Xksi (:), Wksi (:) allocate ( Xksi ( degree + 1 ), Wksi ( degree + 1 )) call gauss_legendre ( Xksi , Wksi , interval ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_2D ( interval1 , interval2 , degree , Xksi , Wksi ) real ( rk ), intent ( in ) :: interval1 ( 2 ), interval2 ( 2 ) integer , intent ( in ) :: degree ( 2 ) real ( rk ), allocatable , intent ( out ) :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: Xksi1 (:), Wksi1 (:), Xksi2 (:), Wksi2 (:) allocate ( Xksi1 ( degree ( 1 ) + 1 ), Wksi1 ( degree ( 1 ) + 1 )) allocate ( Xksi2 ( degree ( 2 ) + 1 ), Wksi2 ( degree ( 2 ) + 1 )) call gauss_legendre ( Xksi1 , Wksi1 , interval1 ) call gauss_legendre ( Xksi2 , Wksi2 , interval2 ) call ndgrid ( Xksi1 , Xksi2 , Xksi ) Wksi = kron ( Wksi1 , Wksi2 ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine gauss_legendre_3D ( interval1 , interval2 , interval3 , degree , Xksi , Wksi ) real ( rk ), intent ( in ) :: interval1 ( 2 ), interval2 ( 2 ), interval3 ( 2 ) integer , intent ( in ) :: degree ( 3 ) real ( rk ), allocatable , intent ( out ) :: Xksi (:,:), Wksi (:) real ( rk ), allocatable :: Xksi1 (:), Wksi1 (:), Xksi2 (:), Wksi2 (:), Xksi3 (:), Wksi3 (:) allocate ( Xksi1 ( degree ( 1 ) + 1 ), Wksi1 ( degree ( 1 ) + 1 )) allocate ( Xksi2 ( degree ( 2 ) + 1 ), Wksi2 ( degree ( 2 ) + 1 )) allocate ( Xksi3 ( degree ( 3 ) + 1 ), Wksi3 ( degree ( 3 ) + 1 )) call gauss_legendre ( Xksi1 , Wksi1 , interval1 ) call gauss_legendre ( Xksi2 , Wksi2 , interval2 ) call gauss_legendre ( Xksi3 , Wksi3 , interval3 ) call ndgrid ( Xksi1 , Xksi2 , Xksi3 , Xksi ) Wksi = kron ( kron ( Wksi3 , Wksi2 ), Wksi1 ) end subroutine !=============================================================================== end module forcad_utils","tags":"","loc":"sourcefile/forcad_utils.f90.html"},{"title":"forcad.f90 – ForCAD","text":"This file depends on sourcefile~~forcad.f90~~EfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad.f90~~AfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_area.f90 cmp_area.f90 sourcefile~cmp_area.f90->sourcefile~forcad.f90 sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~cmp_volume.f90 cmp_volume.f90 sourcefile~cmp_volume.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_ppm1.f90 example_ppm1.f90 sourcefile~example_ppm1.f90->sourcefile~forcad.f90 sourcefile~example_ppm2.f90 example_ppm2.f90 sourcefile~example_ppm2.f90->sourcefile~forcad.f90 sourcefile~example_ppm3.f90 example_ppm3.f90 sourcefile~example_ppm3.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~nearest_point_1d.f90 nearest_point_1d.f90 sourcefile~nearest_point_1d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d.f90 nearest_point_2d.f90 sourcefile~nearest_point_2d.f90->sourcefile~forcad.f90 sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~nearest_point_3d.f90 nearest_point_3d.f90 sourcefile~nearest_point_3d.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_c_1d.f90 shape_C_1d.f90 sourcefile~shape_c_1d.f90->sourcefile~forcad.f90 sourcefile~shape_c_2d.f90 shape_C_2d.f90 sourcefile~shape_c_2d.f90->sourcefile~forcad.f90 sourcefile~shape_c_3d.f90 shape_C_3d.f90 sourcefile~shape_c_3d.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_2d.f90 shape_half_ring_2d.f90 sourcefile~shape_half_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_half_ring_3d.f90 shape_half_ring_3d.f90 sourcefile~shape_half_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_ring_2d.f90 shape_ring_2d.f90 sourcefile~shape_ring_2d.f90->sourcefile~forcad.f90 sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forcad use forcad_utils use forcad_nurbs_curve use forcad_nurbs_surface use forcad_nurbs_volume private public rk , nurbs_curve , nurbs_surface , nurbs_volume end module forcad","tags":"","loc":"sourcefile/forcad.f90.html"},{"title":"shape_ring_3d.f90 – ForCAD","text":"This file depends on sourcefile~~shape_ring_3d.f90~~EfferentGraph sourcefile~shape_ring_3d.f90 shape_ring_3d.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_ring_3d.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_ring_3d use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a ring shape centered at 0,0,0 with inner radius 1, outer radius 2, and length 1. call shape % set_ring ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk , 2.0_rk , 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_ring_3d_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 , 15 , 10 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_ring_3d_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_ring_3d_Xc.vtk' , 'vtk/shape_ring_3d_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_ring_3d.f90.html"},{"title":"demo_surface.f90 – ForCAD","text":"This file depends on sourcefile~~demo_surface.f90~~EfferentGraph sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface. !> It sets up control points and weights, generates the surface, and exports the control points !> and the surface to VTK files at various stages. program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/demo_surface_Xc.vtk' , 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"sourcefile/demo_surface.f90.html"},{"title":"example_volume_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_volume_1.f90~~EfferentGraph sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc.vtk' , 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc2.vtk' , 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_volume_Xc3.vtk' , 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Extract faces !----------------------------------------------------------------------------- !> first compute and set the connectivities of volume elements call nurbs % set_elem ( nurbs % cmp_elem ()) !> get the connectivity of the face1 of the first element print * , 'Face 1 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 1 ) print * , 'Face 2 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 2 ) print * , 'Face 3 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 3 ) print * , 'Face 4 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 4 ) print * , 'Face 5 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 5 ) print * , 'Face 6 of element 1:' , nurbs % cmp_elemFace ( elem = 1 , face = 6 ) !> get the degree of the faces print * , 'Degree of face 1:' , nurbs % cmp_degreeFace ( face = 1 ) print * , 'Degree of face 2:' , nurbs % cmp_degreeFace ( face = 2 ) print * , 'Degree of face 3:' , nurbs % cmp_degreeFace ( face = 3 ) print * , 'Degree of face 4:' , nurbs % cmp_degreeFace ( face = 4 ) print * , 'Degree of face 5:' , nurbs % cmp_degreeFace ( face = 5 ) print * , 'Degree of face 6:' , nurbs % cmp_degreeFace ( face = 6 ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","loc":"sourcefile/example_volume_1.f90.html"},{"title":"example_curve_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_curve_1.f90~~EfferentGraph sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Deallocate local arrays deallocate ( Xc , Wc ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc.vtk' , 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc2.vtk' , 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call nurbs % show ( 'vtk/nurbs_curve_Xc3.vtk' , 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","loc":"sourcefile/example_curve_1.f90.html"},{"title":"nearest_point_2d_bench.f90 – ForCAD","text":"This file depends on sourcefile~~nearest_point_2d_bench.f90~~EfferentGraph sourcefile~nearest_point_2d_bench.f90 nearest_point_2d_bench.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~nearest_point_2d_bench.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program nearest_point_2d_bench use forcad , only : rk , nurbs_surface use fortime implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ), allocatable :: nearest_Xg (:) !! Coordinates of the nearest point on the surface real ( rk ), allocatable :: nearest_Xt (:) !! Corresponding parametric coordinates of the nearest point integer :: id !! id of the nearest point real ( rk ), allocatable :: points (:,:) integer :: i , j type ( timer ) :: t !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 100 , 100 ) !----------------------------------------------------------------------------- ! Nearest point on the surface !----------------------------------------------------------------------------- !> Find the nearest point on the surface to a given point ! nearest_Xg: Coordinates of the nearest point on the surface (optional) ! nearest_Xt: Corresponding parametric coordinates of the nearest point (optional) ! id: id of the nearest point (optional) do j = 1 , 40 allocate ( points ( j * 1000 , 3 )) print * , j * 1000 call random_number ( points ) call t % timer_start () do concurrent ( i = 1 : size ( points , 1 )) call shape % nearest_point ( points ( i ,:), nearest_Xg , nearest_Xt , id ) end do call t % timer_stop () deallocate ( points ) end do !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () deallocate ( nearest_Xg , nearest_Xt ) end program","tags":"","loc":"sourcefile/nearest_point_2d_bench.f90.html"},{"title":"shape_tetragon.f90 – ForCAD","text":"This file depends on sourcefile~~shape_tetragon.f90~~EfferentGraph sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_tetragon use forcad implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !> Export the control points to a VTK file call shape % export_Xc ( 'vtk/shape_tetragon_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !> Export the generated surface to a VTK file call shape % export_Xg ( 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_tetragon_Xc.vtk' , 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_tetragon.f90.html"},{"title":"cmp_length.f90 – ForCAD","text":"This file depends on sourcefile~~cmp_length.f90~~EfferentGraph sourcefile~cmp_length.f90 cmp_length.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~cmp_length.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program compute_length use forcad implicit none type ( nurbs_curve ) :: shape real ( rk ) :: length real ( rk ) :: Xc ( 2 , 3 ) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 2.0_rk , 0.0_rk , 0.0_rk ] call shape % set (& knot = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ],& Xc = Xc ) call shape % cmp_length ( length ) print * , length end program","tags":"","loc":"sourcefile/cmp_length.f90.html"},{"title":"shape_half_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_half_circle.f90~~EfferentGraph sourcefile~shape_half_circle.f90 shape_half_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_half_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_half_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !> Set up a half circle shape centered at the 0,0,0 with a radius of 1 call shape % set_half_circle ([ 0.0_rk , 0.0_rk , 0.0_rk ], 1.0_rk ) !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_half_circle_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 60 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_half_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call shape % show ( 'vtk/shape_half_circle_Xc.vtk' , 'vtk/shape_half_circle_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_half_circle.f90.html"},{"title":"put_to_nurbs.f90 – ForCAD","text":"This file depends on sourcefile~~put_to_nurbs.f90~~EfferentGraph sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_put_to_nurbs use forcad use forcad_utils , only : hexahedron_Xc implicit none type ( nurbs_volume ) :: control_shape real ( rk ), allocatable :: X (:,:) integer , allocatable :: elem (:,:) integer :: i , nunit !> You can create your shape or use a predefined one !> Read coordinates from file allocate ( X ( 23200 , 3 )) open ( newunit = nunit , file = 'example/put_to_nurbs_X.txt' ) do i = 1 , 23200 read ( nunit , * ) X ( i , 1 ), X ( i , 2 ), X ( i , 3 ) end do close ( nunit ) !> Read element connectivities from file allocate ( elem ( 20577 , 8 )) open ( newunit = nunit , file = 'example/put_to_nurbs_elem.txt' ) do i = 1 , 20577 read ( nunit , * ) elem ( i , 1 ), elem ( i , 2 ), elem ( i , 4 ), elem ( i , 3 ), elem ( i , 5 ), elem ( i , 6 ), elem ( i , 8 ), elem ( i , 7 ) end do close ( nunit ) !> Set a control shape that will be used to put the shape into !> The contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points !> By modifying the control shape you can modify the shape call control_shape % set ( nc = [ 10 , 5 , 3 ], Xc = hexahedron_Xc ( L = [ 10 0.0_rk , 4 0.0_rk , 1 0.0_rk ], nc = [ 10 , 5 , 3 ])) !> Map the shape into the shape call control_shape % put_to_nurbs ( X , elem ) !> Deallocate local variables deallocate ( X , elem ) !> Export the shape and the control shape to vtk files call control_shape % export_Xc ( 'vtk/control_shape.vtk' ) call control_shape % export_Xg ( 'vtk/shape.vtk' ) !----------------------------------------------------------------------------- ! Visualization using PyVista ! Note: PyVista is required for visualization. Install it using `pip install pyvista` !----------------------------------------------------------------------------- !> Show the control geometry and geometry using PyVista call control_shape % show ( 'vtk/control_shape.vtk' , 'vtk/shape.vtk' ) !> Finalize the control shape call control_shape % finalize () end program","tags":"","loc":"sourcefile/put_to_nurbs.f90.html"}]}