var tipuesearch = {"pages":[{"title":" ForCAD ","text":"ForCAD ForCAD : A Fortran library for Geometric Modeling using NURBS (Non-Uniform Rational B-Splines). ForCAD supports B-Spline , NURBS , Bezier , and Rational Bezier curves, surfaces, and volumes. Main Features Create NURBS objects by specifying control points, weights and knots. Refine NURBS objects by inserting or removing knots and elevating degree. Compute basis functions and derivatives of NURBS objects. Obtain IGA elements connectivity. Obtain visualized elements connectivity and coordinates for geometry and control geometry. Mesh insertion into a NURBS object. Export NURBS objects to VTK files for visualization. Includes predefined NURBS shapes: Circle, Tetragon, Hexahedron. Rotate and translate NURBS objects. Installation Reuirements A Fortran compiler, such as GNU Fortran ( gfortran ), Intel Fortran Compiler ( ifx/ifort ) or NVIDIA HPC SDK Fortran compiler ( nvfortran ). The Fortran Package Manager fpm . Clone the repository Clone the ForCAD repository from GitHub: git clone https://github.com/gha3mi/forcad.git cd forcad Running Examples with fpm fpm run --example <file name excluding the .f90 extension> Once the examples have been executed, .vtk files will be generated within the vtk directory. These files can then be visualized using tools such as ParaView . Using ForCAD as a fpm Dependency If you want to use ForCAD as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forcad = { git = \"https://github.com/gha3mi/forcad.git\" } API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForCAD using ford run the following\ncommand: ford ford.yml Roadmap For a detailed roadmap outlining upcoming features and enhancements, please refer to ROADMAP.md . Contributing Contributions to ForCAD are welcome! If you find any issues or would like to suggest improvements, please open an issue. If you've implemented new features, fixed bugs, or enhanced existing functionality, please consider submitting a pull request (PR). Please share your examples by submitting a pull request (PR). Citation If you use ForCAD in your research, please cite it as follows: @software { seyed_ali_ghasemi_2024_10938054 , author = {Seyed Ali Ghasemi} , title = {gha3mi/ForCAD} , year = 2024 , publisher = {Zenodo} , doi = {10.5281/zenodo.10938054} , url = {https://doi.org/10.5281/zenodo.10938054} } References Piegl, L., & Tiller, W. (1995). The NURBS Book. In Monographs in Visual Communications. Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-642-97385-7 An Introduction to NURBS. (2001). Elsevier. https://doi.org/10.1016/b978-1-55860-669-2.x5000-3 Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"nurbs_surface – ForCAD ","text":"type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS surface private pure subroutine basis (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) procedure, public :: derivative Compute the derivative of the NURBS surface private pure subroutine derivative (this, res1, res2, Xt1, Xt2, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) procedure, public :: elevate_degree Elevate degree private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS surface object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Get continuity of the surface private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Get multiplicity of the knot vector private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of required control points private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS surface is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 Set NURBS surface private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vectors, control points and weights for the NURBS surface object private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier surface using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_tetragon Set a tetragon private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: get_degree_all Get degree of the NURBS surface in both directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk)","tags":"","loc":"type/nurbs_surface.html"},{"title":"nurbs_volume – ForCAD ","text":"type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS volume private pure subroutine basis (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) procedure, public :: create Generate geometry points private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) procedure, public :: derivative Compute the derivative of the NURBS volume private pure subroutine derivative (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) procedure, public :: elevate_degree Elevate the degree of the NURBS volume private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS volume object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Get continuity of the volume private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Get multiplicity of the knot vector private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of required control points private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS volume is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: put_to_nurbs Put a shape to a NURBS volume private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 Set NURBS volume private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vectors, control points and weights for the NURBS volume object private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier volume using control points and weights private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_hexahedron Set a hexahedron private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: get_degree_all Get degree of the NURBS volume in all directions private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk)","tags":"","loc":"type/nurbs_volume.html"},{"title":"nurbs_curve – ForCAD ","text":"type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS curve private pure subroutine basis (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) procedure, public :: cmp_elem Generate IGA element connectivity private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) procedure, public :: create Generate geometry points private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) procedure, public :: derivative Compute the derivative of the NURBS curve private pure subroutine derivative (this, res, Xt, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) procedure, public :: elevate_degree Elevate the degree of the curve private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t procedure, public :: export_Xc Export control points to VTK file private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: export_Xg Export geometry points to VTK file private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename procedure, public :: finalize Finalize the NURBS curve object private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this procedure, public :: get_Wc Get weights private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_Xc Get control points private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xg Get geometry points private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) procedure, public :: get_Xt Get parameter values private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_continuity Get continuity of the curve private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_degree Get degree of the NURBS curve private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_elem Get IGA element connectivity private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xc_vis Get connectivity for control points private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) procedure, public :: get_elem_Xg_vis Get connectivity for geometry points private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) generic, public :: get_knot => get_knoti , get_knot_all Get knot vector private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, public :: get_multiplicity Get multiplicity of the knot vector private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) procedure, public :: get_nc Get number of required control points private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: get_ng Get number of geometry points private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer procedure, public :: insert_knots Insert knots into the knot vector private pure subroutine insert_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: is_rational Check if the NURBS curve is rational private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical procedure, public :: modify_Wc Modify weights private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num procedure, public :: modify_Xc Modify control points private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir procedure, public :: remove_knots Remove knots from the knot vector private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) procedure, public :: rotate_Xc Rotate control points private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta procedure, public :: rotate_Xg Rotate geometry points private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta generic, public :: set => set1 , set2 , set3 Set NURBS curve private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set1 Set knot vector, control points and weights for the NURBS curve object private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set3 Set Bezier or Rational Bezier curve using control points and weights private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) procedure, public :: set_circle Set a circle private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius procedure, public :: set_elem Set IGA element connectivity private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xc_vis Set connectivity for control points private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: set_elem_Xg_vis Set connectivity for geometry points private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) procedure, public :: translate_Xc Translate control points private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, public :: translate_Xg Translate geometry points private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) procedure, private :: get_knot_all Get all knot vectors private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) procedure, private :: get_knoti Get i-th knot value private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk)","tags":"","loc":"type/nurbs_curve.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~~CallsGraph proc~cmp_elem nurbs_surface%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem->interface~elemconn_cn interface~unique unique proc~cmp_elem->interface~unique proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem->proc~get_multiplicity proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~~CallsGraph proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~~CalledByGraph proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xc_vis.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~~CallsGraph proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~~CalledByGraph proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis program~example3_surface example3_surface program~example3_surface->proc~export_xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xg_vis.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~~CallsGraph proc~get_continuity nurbs_surface%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) Calls proc~~get_degree_all~~CallsGraph proc~get_degree_all nurbs_surface%get_degree_all proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_degree_all~~CalledByGraph proc~get_degree_all nurbs_surface%get_degree_all none~get_degree nurbs_surface%get_degree none~get_degree->proc~get_degree_all proc~set1 nurbs_surface%set1 proc~set1->none~get_degree proc~set3 nurbs_surface%set3 proc~set3->none~get_degree program~example3_surface example3_surface program~example3_surface->none~get_degree none~set nurbs_surface%set program~example3_surface->none~set proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface->proc~elevate_degree proc~insert_knots nurbs_surface%insert_knots program~example3_surface->proc~insert_knots proc~remove_knots nurbs_surface%remove_knots program~example3_surface->proc~remove_knots none~set->proc~set1 none~set->proc~set3 proc~elevate_degree->none~set proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_all.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_degree_dir~~CallsGraph proc~get_degree_dir nurbs_surface%get_degree_dir proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_dir->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_degree_dir~~CalledByGraph proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree nurbs_surface%get_degree none~get_degree->proc~get_degree_dir proc~set1 nurbs_surface%set1 proc~set1->none~get_degree proc~set3 nurbs_surface%set3 proc~set3->none~get_degree program~example3_surface example3_surface program~example3_surface->none~get_degree none~set nurbs_surface%set program~example3_surface->none~set proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface->proc~elevate_degree proc~insert_knots nurbs_surface%insert_knots program~example3_surface->proc~insert_knots proc~remove_knots nurbs_surface%remove_knots program~example3_surface->proc~remove_knots none~set->proc~set1 none~set->proc~set3 proc~elevate_degree->none~set proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_dir.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xc_vis.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xg_vis.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~~CalledByGraph proc~get_knot_all nurbs_surface%get_knot_all none~get_knot nurbs_surface%get_knot none~get_knot->proc~get_knot_all program~example3_surface example3_surface program~example3_surface->none~get_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knot_all.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~~CalledByGraph proc~get_knoti nurbs_surface%get_knoti none~get_knot nurbs_surface%get_knot none~get_knot->proc~get_knoti program~example3_surface example3_surface program~example3_surface->none~get_knot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knoti.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~~CallsGraph proc~get_multiplicity nurbs_surface%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~~CalledByGraph proc~get_multiplicity nurbs_surface%get_multiplicity proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~get_degree_all nurbs_surface%get_degree_all proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir nurbs_surface%get_degree_dir proc~get_degree_dir->proc~get_multiplicity none~get_degree nurbs_surface%get_degree none~get_degree->proc~get_degree_all none~get_degree->proc~get_degree_dir proc~set1 nurbs_surface%set1 proc~set1->none~get_degree proc~set3 nurbs_surface%set3 proc~set3->none~get_degree program~example3_surface example3_surface program~example3_surface->none~get_degree none~set nurbs_surface%set program~example3_surface->none~set proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface->proc~elevate_degree proc~insert_knots nurbs_surface%insert_knots program~example3_surface->proc~insert_knots proc~remove_knots nurbs_surface%remove_knots program~example3_surface->proc~remove_knots none~set->proc~set1 none~set->proc~set3 proc~elevate_degree->none~set proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this, dir) result(nc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc~~CallsGraph proc~get_nc nurbs_surface%get_nc interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc~~CalledByGraph proc~get_nc nurbs_surface%get_nc proc~set1 nurbs_surface%set1 proc~set1->proc~get_nc proc~set2 nurbs_surface%set2 proc~set2->proc~get_nc none~set nurbs_surface%set none~set->proc~set1 none~set->proc~set2 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2)","tags":"","loc":"proc/get_ng.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical Called by proc~~is_rational~~CalledByGraph proc~is_rational nurbs_surface%is_rational proc~basis nurbs_surface%basis proc~basis->proc~is_rational proc~create nurbs_surface%create proc~create->proc~is_rational proc~derivative nurbs_surface%derivative proc~derivative->proc~is_rational proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~is_rational proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~is_rational proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~is_rational program~example3_surface example3_surface program~example3_surface->proc~create program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_rational.html"},{"title":"basis – ForCAD","text":"private pure subroutine basis(this, res1, res2, Xt1, Xt2, Tgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis~~CallsGraph proc~basis nurbs_surface%basis interface~ndgrid ndgrid proc~basis->interface~ndgrid proc~basis_bspline basis_bspline proc~basis->proc~basis_bspline proc~is_rational nurbs_surface%is_rational proc~basis->proc~is_rational proc~kron kron proc~basis->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, Xt1, Xt2, Xt) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~~CallsGraph proc~create nurbs_surface%create interface~ndgrid ndgrid proc~create->interface~ndgrid proc~basis_bspline basis_bspline proc~create->proc~basis_bspline proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~kron kron proc~create->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~~CalledByGraph proc~create nurbs_surface%create program~example3_surface example3_surface program~example3_surface->proc~create program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create.html"},{"title":"derivative – ForCAD","text":"private pure subroutine derivative(this, res1, res2, Xt1, Xt2, dTgc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) Calls proc~~derivative~~CallsGraph proc~derivative nurbs_surface%derivative interface~ndgrid ndgrid proc~derivative->interface~ndgrid proc~basis_bspline_der basis_bspline_der proc~derivative->proc~basis_bspline_der proc~is_rational nurbs_surface%is_rational proc~derivative->proc~is_rational proc~kron kron proc~derivative->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t Calls proc~~elevate_degree~~CallsGraph proc~elevate_degree nurbs_surface%elevate_degree none~set nurbs_surface%set proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~is_rational nurbs_surface%is_rational proc~elevate_degree->proc~is_rational proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_nc->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~~CalledByGraph proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface example3_surface program~example3_surface->proc~elevate_degree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~~CallsGraph proc~export_xc nurbs_surface%export_Xc proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~~CalledByGraph proc~export_xc nurbs_surface%export_Xc program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~~CallsGraph proc~export_xg nurbs_surface%export_Xg proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~~CalledByGraph proc~export_xg nurbs_surface%export_Xg program~example3_surface example3_surface program~example3_surface->proc~export_xg program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xg program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this Called by proc~~finalize~~CalledByGraph proc~finalize nurbs_surface%finalize program~example3_surface example3_surface program~example3_surface->proc~finalize program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~finalize program~shape_tetragon shape_tetragon program~shape_tetragon->proc~finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~~CallsGraph proc~insert_knots nurbs_surface%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~insert_knots->none~set proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~is_rational nurbs_surface%is_rational proc~insert_knots->proc~is_rational proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_nc->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~~CalledByGraph proc~insert_knots nurbs_surface%insert_knots program~example3_surface example3_surface program~example3_surface->proc~insert_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knots.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~~CallsGraph proc~modify_wc nurbs_surface%modify_Wc none~set nurbs_surface%set proc~modify_wc->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~~CallsGraph proc~modify_xc nurbs_surface%modify_Xc none~set nurbs_surface%set proc~modify_xc->none~set proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~~CallsGraph proc~remove_knots nurbs_surface%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~remove_knots->none~set proc~findspan findspan proc~remove_knots->proc~findspan proc~is_rational nurbs_surface%is_rational proc~remove_knots->proc~is_rational proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_nc->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~~CalledByGraph proc~remove_knots nurbs_surface%remove_knots program~example3_surface example3_surface program~example3_surface->proc~remove_knots Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~~CallsGraph proc~rotate_xc nurbs_surface%rotate_Xc proc~rotation rotation proc~rotate_xc->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~~CalledByGraph proc~rotate_xc nurbs_surface%rotate_Xc program~example3_surface example3_surface program~example3_surface->proc~rotate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xc.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~~CallsGraph proc~rotate_xg nurbs_surface%rotate_Xg proc~rotation rotation proc~rotate_xg->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~~CalledByGraph proc~rotate_xg nurbs_surface%rotate_Xg program~example3_surface example3_surface program~example3_surface->proc~rotate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xg.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, Xc, Wc) Set knot vectors, control points and weights for the NURBS surface object. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~~CallsGraph proc~set1 nurbs_surface%set1 none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~~CalledByGraph proc~set1 nurbs_surface%set1 none~set nurbs_surface%set none~set->proc~set1 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~~CallsGraph proc~set2 nurbs_surface%set2 proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~get_nc nurbs_surface%get_nc proc~set2->proc~get_nc proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~~CalledByGraph proc~set2 nurbs_surface%set2 none~set nurbs_surface%set none~set->proc~set2 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier surface using control points and weights. Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~~CallsGraph proc~set3 nurbs_surface%set3 none~get_degree nurbs_surface%get_degree proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~~CalledByGraph proc~set3 nurbs_surface%set3 none~set nurbs_surface%set none~set->proc~set3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set3.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xc_vis.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xg_vis.html"},{"title":"set_tetragon – ForCAD","text":"private pure subroutine set_tetragon(this, L, nc, Wc) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_tetragon~~CallsGraph proc~set_tetragon nurbs_surface%set_tetragon none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_tetragon~~CalledByGraph proc~set_tetragon nurbs_surface%set_tetragon program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_tetragon.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~~CalledByGraph proc~translate_xc nurbs_surface%translate_Xc program~example3_surface example3_surface program~example3_surface->proc~translate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xc.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_surface Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~~CalledByGraph proc~translate_xg nurbs_surface%translate_Xg program~example3_surface example3_surface program~example3_surface->proc~translate_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xg.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~~CalledByGraph proc~generate_xc generate_Xc program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~generate_xc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~2~~CalledByGraph proc~generate_xc~2 generate_Xc program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~generate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~2.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~3~~CalledByGraph proc~generate_xc~3 generate_Xc program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~generate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~3.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~4~~CalledByGraph proc~generate_xc~4 generate_Xc program~example3_surface example3_surface program~example3_surface->proc~generate_xc~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~4.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~2~~CallsGraph proc~cmp_elem~2 nurbs_volume%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~2->interface~elemconn_cn interface~unique unique proc~cmp_elem~2->interface~unique proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem~2.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~2~~CallsGraph proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~2~~CalledByGraph proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~2 nurbs_volume%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 program~example3_volume example3_volume program~example3_volume->proc~export_xc~2 program~example_morph example_morph program~example_morph->proc~export_xc~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xc_vis~2.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~2~~CallsGraph proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~2~~CalledByGraph proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~2 nurbs_volume%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 program~example3_volume example3_volume program~example3_volume->proc~export_xg~2 program~example_morph example_morph program~example_morph->proc~export_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xg_vis~2.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc~2.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc~2.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg~2.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this, dir) result(Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~2.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this, dir) result(c) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_continuity~2~~CallsGraph proc~get_continuity~2 nurbs_volume%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity~2.html"},{"title":"get_degree_all – ForCAD","text":"private pure function get_degree_all(this) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) Calls proc~~get_degree_all~2~~CallsGraph proc~get_degree_all~2 nurbs_volume%get_degree_all proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_degree_all~2~~CalledByGraph proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2 nurbs_volume%get_degree none~get_degree~2->proc~get_degree_all~2 proc~set1~2 nurbs_volume%set1 proc~set1~2->none~get_degree~2 proc~set3~2 nurbs_volume%set3 proc~set3~2->none~get_degree~2 program~example3_volume example3_volume program~example3_volume->none~get_degree~2 none~set~2 nurbs_volume%set program~example3_volume->none~set~2 proc~elevate_degree~2 nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree~2 proc~insert_knots~2 nurbs_volume%insert_knots program~example3_volume->proc~insert_knots~2 proc~remove_knots~2 nurbs_volume%remove_knots program~example3_volume->proc~remove_knots~2 none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~elevate_degree~2->none~set~2 proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2->none~set~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_all~2.html"},{"title":"get_degree_dir – ForCAD","text":"private pure function get_degree_dir(this, dir) result(degree) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_degree_dir~2~~CallsGraph proc~get_degree_dir~2 nurbs_volume%get_degree_dir proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_dir~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_degree_dir~2~~CalledByGraph proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2 nurbs_volume%get_degree none~get_degree~2->proc~get_degree_dir~2 proc~set1~2 nurbs_volume%set1 proc~set1~2->none~get_degree~2 proc~set3~2 nurbs_volume%set3 proc~set3~2->none~get_degree~2 program~example3_volume example3_volume program~example3_volume->none~get_degree~2 none~set~2 nurbs_volume%set program~example3_volume->none~set~2 proc~elevate_degree~2 nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree~2 proc~insert_knots~2 nurbs_volume%insert_knots program~example3_volume->proc~insert_knots~2 proc~remove_knots~2 nurbs_volume%remove_knots program~example3_volume->proc~remove_knots~2 none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~elevate_degree~2->none~set~2 proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2->none~set~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree_dir~2.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem~2.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xc_vis~2.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xg_vis~2.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this, dir) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~2~~CalledByGraph proc~get_knot_all~2 nurbs_volume%get_knot_all none~get_knot~2 nurbs_volume%get_knot none~get_knot~2->proc~get_knot_all~2 program~example3_volume example3_volume program~example3_volume->none~get_knot~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knot_all~2.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, dir, i) result(knot) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~2~~CalledByGraph proc~get_knoti~2 nurbs_volume%get_knoti none~get_knot~2 nurbs_volume%get_knot none~get_knot~2->proc~get_knoti~2 program~example3_volume example3_volume program~example3_volume->none~get_knot~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knoti~2.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this, dir) result(m) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~2~~CallsGraph proc~get_multiplicity~2 nurbs_volume%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~2~~CalledByGraph proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~get_degree_all~2 nurbs_volume%get_degree_all proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir proc~get_degree_dir~2->proc~get_multiplicity~2 none~get_degree~2 nurbs_volume%get_degree none~get_degree~2->proc~get_degree_all~2 none~get_degree~2->proc~get_degree_dir~2 proc~set1~2 nurbs_volume%set1 proc~set1~2->none~get_degree~2 proc~set3~2 nurbs_volume%set3 proc~set3~2->none~get_degree~2 program~example3_volume example3_volume program~example3_volume->none~get_degree~2 none~set~2 nurbs_volume%set program~example3_volume->none~set~2 proc~elevate_degree~2 nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree~2 proc~insert_knots~2 nurbs_volume%insert_knots program~example3_volume->proc~insert_knots~2 proc~remove_knots~2 nurbs_volume%remove_knots program~example3_volume->proc~remove_knots~2 none~set~2->proc~set1~2 none~set~2->proc~set3~2 proc~elevate_degree~2->none~set~2 proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2->none~set~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity~2.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this, dir) result(nc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer Calls proc~~get_nc~2~~CallsGraph proc~get_nc~2 nurbs_volume%get_nc interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nc~2~~CalledByGraph proc~get_nc~2 nurbs_volume%get_nc proc~set1~2 nurbs_volume%set1 proc~set1~2->proc~get_nc~2 proc~set2~2 nurbs_volume%set2 proc~set2~2->proc~get_nc~2 none~set~2 nurbs_volume%set none~set~2->proc~set1~2 none~set~2->proc~set2~2 proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->none~set~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 program~example3_volume example3_volume program~example3_volume->none~set~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc~2.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3)","tags":"","loc":"proc/get_ng~2.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical","tags":"","loc":"proc/is_rational~2.html"},{"title":"basis – ForCAD","text":"private pure subroutine basis(this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis~2~~CallsGraph proc~basis~2 nurbs_volume%basis interface~ndgrid ndgrid proc~basis~2->interface~ndgrid proc~basis_bspline basis_bspline proc~basis~2->proc~basis_bspline proc~kron kron proc~basis~2->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis~2.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) Calls proc~~create~2~~CallsGraph proc~create~2 nurbs_volume%create interface~ndgrid ndgrid proc~create~2->interface~ndgrid proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline proc~kron kron proc~create~2->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~2~~CalledByGraph proc~create~2 nurbs_volume%create program~example3_volume example3_volume program~example3_volume->proc~create~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~2.html"},{"title":"derivative – ForCAD","text":"private pure subroutine derivative(this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) Calls proc~~derivative~2~~CallsGraph proc~derivative~2 nurbs_volume%derivative interface~ndgrid ndgrid proc~derivative~2->interface~ndgrid proc~basis_bspline_der basis_bspline_der proc~derivative~2->proc~basis_bspline_der proc~kron kron proc~derivative~2->proc~kron proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative~2.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, dir, t) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t Calls proc~~elevate_degree~2~~CallsGraph proc~elevate_degree~2 nurbs_volume%elevate_degree none~set~2 nurbs_volume%set proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_nc~2->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~2~~CalledByGraph proc~elevate_degree~2 nurbs_volume%elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree~2.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~2~~CallsGraph proc~export_xc~2 nurbs_volume%export_Xc proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~2~~CalledByGraph proc~export_xc~2 nurbs_volume%export_Xc program~example3_volume example3_volume program~example3_volume->proc~export_xc~2 program~example_morph example_morph program~example_morph->proc~export_xc~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~2.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~2~~CallsGraph proc~export_xg~2 nurbs_volume%export_Xg proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~2~~CalledByGraph proc~export_xg~2 nurbs_volume%export_Xg program~example3_volume example3_volume program~example3_volume->proc~export_xg~2 program~example_morph example_morph program~example_morph->proc~export_xg~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xg~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~2.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this Called by proc~~finalize~2~~CalledByGraph proc~finalize~2 nurbs_volume%finalize program~example3_volume example3_volume program~example3_volume->proc~finalize~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~finalize~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~finalize~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~2.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, dir, Xth, r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~2~~CallsGraph proc~insert_knots~2 nurbs_volume%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_volume%set proc~insert_knots~2->none~set~2 proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_nc~2->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~2~~CalledByGraph proc~insert_knots~2 nurbs_volume%insert_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knots~2.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~2~~CallsGraph proc~modify_wc~2 nurbs_volume%modify_Wc none~set~2 nurbs_volume%set proc~modify_wc~2->none~set~2 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~2.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~2~~CallsGraph proc~modify_xc~2 nurbs_volume%modify_Xc none~set~2 nurbs_volume%set proc~modify_xc~2->none~set~2 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~2.html"},{"title":"put_to_nurbs – ForCAD","text":"private pure subroutine put_to_nurbs(this, X, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) Calls proc~~put_to_nurbs~~CallsGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~basis_bspline basis_bspline proc~put_to_nurbs->proc~basis_bspline proc~kron kron proc~put_to_nurbs->proc~kron proc~set_elem_xg_vis~2 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~put_to_nurbs~~CalledByGraph proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_morph example_morph program~example_morph->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/put_to_nurbs.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, dir, Xth, r) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~2~~CallsGraph proc~remove_knots~2 nurbs_volume%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~2->interface~compute_multiplicity none~set~2 nurbs_volume%set proc~remove_knots~2->none~set~2 proc~findspan findspan proc~remove_knots~2->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_nc~2->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~2~~CalledByGraph proc~remove_knots~2 nurbs_volume%remove_knots program~example3_volume example3_volume program~example3_volume->proc~remove_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots~2.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~2~~CallsGraph proc~rotate_xc~2 nurbs_volume%rotate_Xc proc~rotation rotation proc~rotate_xc~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~2~~CalledByGraph proc~rotate_xc~2 nurbs_volume%rotate_Xc program~example3_volume example3_volume program~example3_volume->proc~rotate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xc~2.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~2~~CallsGraph proc~rotate_xg~2 nurbs_volume%rotate_Xg proc~rotation rotation proc~rotate_xg~2->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~2~~CalledByGraph proc~rotate_xg~2 nurbs_volume%rotate_Xg program~example3_volume example3_volume program~example3_volume->proc~rotate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xg~2.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot1, knot2, knot3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~2~~CallsGraph proc~set1~2 nurbs_volume%set1 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~2~~CalledByGraph proc~set1~2 nurbs_volume%set1 none~set~2 nurbs_volume%set none~set~2->proc~set1~2 proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->none~set~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 program~example3_volume example3_volume program~example3_volume->none~set~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1~2.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Set control points and weights for the NURBS volume object. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~2~~CallsGraph proc~set2~2 nurbs_volume%set2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~get_nc~2 nurbs_volume%get_nc proc~set2~2->proc~get_nc~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~2~~CalledByGraph proc~set2~2 nurbs_volume%set2 none~set~2 nurbs_volume%set none~set~2->proc~set2~2 proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->none~set~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 program~example3_volume example3_volume program~example3_volume->none~set~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2~2.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, nc, Xc, Wc) Set Bezier or Rational Bezier volume using control points and weights. Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~2~~CallsGraph proc~set3~2 nurbs_volume%set3 none~get_degree~2 nurbs_volume%get_degree proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~2~~CalledByGraph proc~set3~2 nurbs_volume%set3 none~set~2 nurbs_volume%set none~set~2->proc~set3~2 proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->none~set~2 proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->none~set~2 proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->none~set~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 program~example3_volume example3_volume program~example3_volume->none~set~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set3~2.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem~2.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xc_vis~2.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) Called by proc~~set_elem_xg_vis~2~~CalledByGraph proc~set_elem_xg_vis~2 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~set_elem_xg_vis~2 program~example_morph example_morph program~example_morph->proc~put_to_nurbs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_elem_xg_vis~2.html"},{"title":"set_hexahedron – ForCAD","text":"private pure subroutine set_hexahedron(this, L, nc, Wc) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set_hexahedron~~CallsGraph proc~set_hexahedron nurbs_volume%set_hexahedron none~set~2 nurbs_volume%set proc~set_hexahedron->none~set~2 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_hexahedron~~CalledByGraph proc~set_hexahedron nurbs_volume%set_hexahedron program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_hexahedron.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~2~~CalledByGraph proc~translate_xc~2 nurbs_volume%translate_Xc program~example3_volume example3_volume program~example3_volume->proc~translate_xc~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xc~2.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_volume Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~2~~CalledByGraph proc~translate_xg~2 nurbs_volume%translate_Xg program~example3_volume example3_volume program~example3_volume->proc~translate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xg~2.html"},{"title":"basis_bernstein – ForCAD","text":"public pure function basis_bernstein(Xt, nc) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/basis_bernstein.html"},{"title":"basis_bspline – ForCAD","text":"public pure function basis_bspline(Xt, knot, nc, degree) result(B) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:) Called by proc~~basis_bspline~~CalledByGraph proc~basis_bspline basis_bspline proc~basis nurbs_surface%basis proc~basis->proc~basis_bspline proc~basis~2 nurbs_volume%basis proc~basis~2->proc~basis_bspline proc~basis~3 nurbs_curve%basis proc~basis~3->proc~basis_bspline proc~create nurbs_surface%create proc~create->proc~basis_bspline proc~create~2 nurbs_volume%create proc~create~2->proc~basis_bspline proc~create~3 nurbs_curve%create proc~create~3->proc~basis_bspline proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~basis_bspline program~example1_curve example1_curve program~example1_curve->proc~create~3 program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~2 program~example_morph example_morph program~example_morph->proc~put_to_nurbs program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~2 program~shape_circle shape_circle program~shape_circle->proc~create~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bspline.html"},{"title":"basis_bspline_der – ForCAD","text":"public pure function basis_bspline_der(Xt, knot, nc, degree) result(dB) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:) Calls proc~~basis_bspline_der~~CallsGraph proc~basis_bspline_der basis_bspline_der proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_bspline_der~~CalledByGraph proc~basis_bspline_der basis_bspline_der proc~derivative nurbs_surface%derivative proc~derivative->proc~basis_bspline_der proc~derivative~2 nurbs_volume%derivative proc~derivative~2->proc~basis_bspline_der proc~derivative~3 nurbs_curve%derivative proc~derivative~3->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis_bspline_der.html"},{"title":"compute_knot_vector – ForCAD","text":"public pure function compute_knot_vector(Xth_dir, degree, continuity) result(knot) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) Calls proc~~compute_knot_vector~~CallsGraph proc~compute_knot_vector compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_knot_vector~~CalledByGraph proc~compute_knot_vector compute_knot_vector proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_volume%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_curve%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_volume%set none~set~2->proc~set2~2 none~set~3 nurbs_curve%set none~set~3->proc~set2~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example1_curve example1_curve program~example1_curve->none~set~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->none~set~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_knot_vector.html"},{"title":"findspan – ForCAD","text":"public pure function findspan(n, degree, Xth, knot) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer Called by proc~~findspan~~CalledByGraph proc~findspan findspan proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~findspan proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->proc~findspan proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->proc~findspan proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~findspan proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->proc~findspan proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->proc~findspan program~example1_curve example1_curve program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/findspan.html"},{"title":"hexahedron_Xc – ForCAD","text":"public pure function hexahedron_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~hexahedron_xc~~CalledByGraph proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->proc~hexahedron_xc program~example_morph example_morph program~example_morph->proc~hexahedron_xc program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/hexahedron_xc.html"},{"title":"kron – ForCAD","text":"public pure function kron(u, v) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) Called by proc~~kron~~CalledByGraph proc~kron kron proc~basis nurbs_surface%basis proc~basis->proc~kron proc~basis~2 nurbs_volume%basis proc~basis~2->proc~kron proc~create nurbs_surface%create proc~create->proc~kron proc~create~2 nurbs_volume%create proc~create~2->proc~kron proc~derivative nurbs_surface%derivative proc~derivative->proc~kron proc~derivative~2 nurbs_volume%derivative proc~derivative~2->proc~kron proc~put_to_nurbs nurbs_volume%put_to_nurbs proc~put_to_nurbs->proc~kron program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~2 program~example_morph example_morph program~example_morph->proc~put_to_nurbs program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/kron.html"},{"title":"rotation – ForCAD","text":"public pure function rotation(alpha, beta, theta) result(R) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) Calls proc~~rotation~~CallsGraph proc~rotation rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotation~~CalledByGraph proc~rotation rotation proc~rotate_xc nurbs_surface%rotate_Xc proc~rotate_xc->proc~rotation proc~rotate_xc~2 nurbs_volume%rotate_Xc proc~rotate_xc~2->proc~rotation proc~rotate_xc~3 nurbs_curve%rotate_Xc proc~rotate_xc~3->proc~rotation proc~rotate_xg nurbs_surface%rotate_Xg proc~rotate_xg->proc~rotation proc~rotate_xg~2 nurbs_volume%rotate_Xg proc~rotate_xg~2->proc~rotation proc~rotate_xg~3 nurbs_curve%rotate_Xg proc~rotate_xg~3->proc~rotation program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~3 program~example1_curve->proc~rotate_xg~3 program~example3_surface example3_surface program~example3_surface->proc~rotate_xc program~example3_surface->proc~rotate_xg program~example3_volume example3_volume program~example3_volume->proc~rotate_xc~2 program~example3_volume->proc~rotate_xg~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotation.html"},{"title":"tetragon_Xc – ForCAD","text":"public pure function tetragon_Xc(L, nc) result(Xc) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:) Called by proc~~tetragon_xc~~CalledByGraph proc~tetragon_xc tetragon_Xc proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->proc~tetragon_xc program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/tetragon_xc.html"},{"title":"bincoeff – ForCAD","text":"private pure function bincoeff(n, k) result(b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) Calls proc~~bincoeff~~CallsGraph proc~bincoeff bincoeff proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bincoeff~~CalledByGraph proc~bincoeff bincoeff proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~3 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/bincoeff.html"},{"title":"cmp_elemConn_C0_L – ForCAD","text":"private pure function cmp_elemConn_C0_L(nnode, p) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_l~~CalledByGraph proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_volume%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_curve%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_volume%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_curve%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~3 program~example1_curve->proc~export_xg~3 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~2 program~example3_volume->proc~export_xg~2 program~example_morph example_morph program~example_morph->proc~export_xc~2 program~example_morph->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~3 program~example_nurbs_curve->proc~export_xg~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~2 program~example_nurbs_volume->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~3 program~shape_circle->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~2 program~shape_hexahedron->proc~export_xg~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_l.html"},{"title":"cmp_elemConn_C0_S – ForCAD","text":"private pure function cmp_elemConn_C0_S(nnode1, nnode2, p1, p2) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_s~~CalledByGraph proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_volume%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_curve%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_volume%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_curve%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~3 program~example1_curve->proc~export_xg~3 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~2 program~example3_volume->proc~export_xg~2 program~example_morph example_morph program~example_morph->proc~export_xc~2 program~example_morph->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~3 program~example_nurbs_curve->proc~export_xg~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~2 program~example_nurbs_volume->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~3 program~shape_circle->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~2 program~shape_hexahedron->proc~export_xg~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_s.html"},{"title":"cmp_elemConn_C0_V – ForCAD","text":"private pure function cmp_elemConn_C0_V(nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) Called by proc~~cmp_elemconn_c0_v~~CalledByGraph proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0 elemConn_C0 interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_volume%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_curve%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_volume%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_curve%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~3 program~example1_curve->proc~export_xg~3 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~2 program~example3_volume->proc~export_xg~2 program~example_morph example_morph program~example_morph->proc~export_xc~2 program~example_morph->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~3 program~example_nurbs_curve->proc~export_xg~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~2 program~example_nurbs_volume->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~3 program~shape_circle->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~2 program~shape_hexahedron->proc~export_xg~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_c0_v.html"},{"title":"compute_multiplicity1 – ForCAD","text":"private pure function compute_multiplicity1(knot) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) Called by proc~~compute_multiplicity1~~CalledByGraph proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity1 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_volume%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_curve%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc nurbs_surface%get_nc proc~get_nc->interface~compute_multiplicity proc~get_nc~2 nurbs_volume%get_nc proc~get_nc~2->interface~compute_multiplicity proc~get_nc~3 nurbs_curve%get_nc proc~get_nc~3->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_volume%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_curve%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~get_degree nurbs_curve%get_degree proc~get_degree->proc~get_multiplicity~3 proc~get_degree_all nurbs_surface%get_degree_all proc~get_degree_all->proc~get_multiplicity proc~get_degree_all~2 nurbs_volume%get_degree_all proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir nurbs_surface%get_degree_dir proc~get_degree_dir->proc~get_multiplicity proc~get_degree_dir~2 nurbs_volume%get_degree_dir proc~get_degree_dir~2->proc~get_multiplicity~2 proc~set1 nurbs_surface%set1 proc~set1->proc~get_nc none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~set1~2 nurbs_volume%set1 proc~set1~2->proc~get_nc~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~set2 nurbs_surface%set2 proc~set2->proc~get_nc proc~set2~2 nurbs_volume%set2 proc~set2~2->proc~get_nc~2 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~get_degree program~example1_curve->none~set~3 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~get_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->none~get_degree~2 program~example3_volume->none~set~2 none~get_degree->proc~get_degree_all none~get_degree->proc~get_degree_dir none~get_degree~2->proc~get_degree_all~2 none~get_degree~2->proc~get_degree_dir~2 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~2->proc~set1~2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 proc~set1~3 nurbs_curve%set1 proc~set1~3->proc~get_degree proc~set3~3 nurbs_curve%set3 proc~set3~3->proc~get_degree none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~set3->none~get_degree proc~set3~2->none~get_degree~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_multiplicity1.html"},{"title":"compute_multiplicity2 – ForCAD","text":"private pure function compute_multiplicity2(knot, Xth) result(multiplicity) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer Called by proc~~compute_multiplicity2~~CalledByGraph proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity compute_multiplicity interface~compute_multiplicity->proc~compute_multiplicity2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_volume%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_curve%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc nurbs_surface%get_nc proc~get_nc->interface~compute_multiplicity proc~get_nc~2 nurbs_volume%get_nc proc~get_nc~2->interface~compute_multiplicity proc~get_nc~3 nurbs_curve%get_nc proc~get_nc~3->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_volume%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_curve%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~get_degree nurbs_curve%get_degree proc~get_degree->proc~get_multiplicity~3 proc~get_degree_all nurbs_surface%get_degree_all proc~get_degree_all->proc~get_multiplicity proc~get_degree_all~2 nurbs_volume%get_degree_all proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir nurbs_surface%get_degree_dir proc~get_degree_dir->proc~get_multiplicity proc~get_degree_dir~2 nurbs_volume%get_degree_dir proc~get_degree_dir~2->proc~get_multiplicity~2 proc~set1 nurbs_surface%set1 proc~set1->proc~get_nc none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~set1~2 nurbs_volume%set1 proc~set1~2->proc~get_nc~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~set2 nurbs_surface%set2 proc~set2->proc~get_nc proc~set2~2 nurbs_volume%set2 proc~set2~2->proc~get_nc~2 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~get_degree program~example1_curve->none~set~3 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~get_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->none~get_degree~2 program~example3_volume->none~set~2 none~get_degree->proc~get_degree_all none~get_degree->proc~get_degree_dir none~get_degree~2->proc~get_degree_all~2 none~get_degree~2->proc~get_degree_dir~2 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~2->proc~set1~2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 proc~set1~3 nurbs_curve%set1 proc~set1~3->proc~get_degree proc~set3~3 nurbs_curve%set3 proc~set3~3->proc~get_degree none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~set3->none~get_degree proc~set3~2->none~get_degree~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/compute_multiplicity2.html"},{"title":"factln – ForCAD","text":"private pure function factln(n) result(f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) Called by proc~~factln~~CalledByGraph proc~factln factln proc~bincoeff bincoeff proc~bincoeff->proc~factln proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->proc~bincoeff proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~3 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/factln.html"},{"title":"isinf – ForCAD","text":"private pure elemental function isinf(x) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical Called by proc~~isinf~~CalledByGraph proc~isinf isinf proc~basis_bspline_der basis_bspline_der proc~basis_bspline_der->proc~isinf proc~derivative nurbs_surface%derivative proc~derivative->proc~basis_bspline_der proc~derivative~2 nurbs_volume%derivative proc~derivative~2->proc~basis_bspline_der proc~derivative~3 nurbs_curve%derivative proc~derivative~3->proc~basis_bspline_der Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/isinf.html"},{"title":"isnan – ForCAD","text":"private pure elemental function isnan(x) result(output) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical","tags":"","loc":"proc/isnan.html"},{"title":"repelem – ForCAD","text":"private pure function repelem(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) Called by proc~~repelem~~CalledByGraph proc~repelem repelem proc~compute_knot_vector compute_knot_vector proc~compute_knot_vector->proc~repelem proc~set2 nurbs_surface%set2 proc~set2->proc~compute_knot_vector proc~set2~2 nurbs_volume%set2 proc~set2~2->proc~compute_knot_vector proc~set2~3 nurbs_curve%set2 proc~set2~3->proc~compute_knot_vector none~set nurbs_surface%set none~set->proc~set2 none~set~2 nurbs_volume%set none~set~2->proc~set2~2 none~set~3 nurbs_curve%set none~set~3->proc~set2~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->none~set proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->none~set proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example1_curve example1_curve program~example1_curve->none~set~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example3_surface example3_surface program~example3_surface->none~set program~example3_surface->proc~elevate_degree program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->none~set~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 program~shape_circle shape_circle program~shape_circle->proc~set_circle program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function repelem ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) integer , intent ( in ), contiguous :: b (:) real ( rk ) :: c ( sum ( b )) integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function repelem","tags":"","loc":"proc/repelem.html"},{"title":"unique_integer – ForCAD","text":"private pure function unique_integer(vec) result(unique) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable Called by proc~~unique_integer~~CalledByGraph proc~unique_integer unique_integer interface~unique unique interface~unique->proc~unique_integer proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~unique proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->interface~unique proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->interface~unique Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unique_integer.html"},{"title":"unique_real – ForCAD","text":"private pure function unique_real(vec) result(unique) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Called by proc~~unique_real~~CalledByGraph proc~unique_real unique_real interface~unique unique interface~unique->proc~unique_real proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~unique proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->interface~unique proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->interface~unique Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/unique_real.html"},{"title":"elevate_degree_A_5_9 – ForCAD","text":"public pure subroutine elevate_degree_A_5_9(t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) Calls proc~~elevate_degree_a_5_9~~CallsGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree_a_5_9~~CalledByGraph proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~3 program~example3_surface example3_surface program~example3_surface->proc~elevate_degree program~example3_volume example3_volume program~example3_volume->proc~elevate_degree~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree_a_5_9.html"},{"title":"insert_knot_A_5_1 – ForCAD","text":"public pure subroutine insert_knot_A_5_1(p, UP, Pw, u, k, s, r, nq, UQ, Qw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) Called by proc~~insert_knot_a_5_1~~CalledByGraph proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->proc~insert_knot_a_5_1 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->proc~insert_knot_a_5_1 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~3 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_volume example3_volume program~example3_volume->proc~insert_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knot_a_5_1.html"},{"title":"remove_knots_A_5_8 – ForCAD","text":"public pure subroutine remove_knots_A_5_8(p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) Called by proc~~remove_knots_a_5_8~~CalledByGraph proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->proc~remove_knots_a_5_8 proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->proc~remove_knots_a_5_8 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->proc~remove_knots_a_5_8 program~example1_curve example1_curve program~example1_curve->proc~remove_knots~3 program~example3_surface example3_surface program~example3_surface->proc~remove_knots program~example3_volume example3_volume program~example3_volume->proc~remove_knots~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots_a_5_8.html"},{"title":"cmp_elemConn_Cn_L – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_L(nnode, p, Xth, vecKnot_mul, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_l~~CalledByGraph proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->interface~elemconn_cn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_l.html"},{"title":"cmp_elemConn_Cn_S – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_S(nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_s~~CalledByGraph proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->interface~elemconn_cn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_s.html"},{"title":"cmp_elemConn_Cn_V – ForCAD","text":"private pure subroutine cmp_elemConn_Cn_V(nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) Called by proc~~cmp_elemconn_cn_v~~CalledByGraph proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn elemConn_Cn interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->interface~elemconn_cn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elemconn_cn_v.html"},{"title":"ndgrid2 – ForCAD","text":"private pure subroutine ndgrid2(X_dir1, X_dir2, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid2~~CalledByGraph proc~ndgrid2 ndgrid2 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid2 proc~basis nurbs_surface%basis proc~basis->interface~ndgrid proc~basis~2 nurbs_volume%basis proc~basis~2->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~2 nurbs_volume%create proc~create~2->interface~ndgrid proc~derivative nurbs_surface%derivative proc~derivative->interface~ndgrid proc~derivative~2 nurbs_volume%derivative proc~derivative~2->interface~ndgrid program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid2.html"},{"title":"ndgrid3 – ForCAD","text":"private pure subroutine ndgrid3(X_dir1, X_dir2, X_dir3, Xt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) Called by proc~~ndgrid3~~CalledByGraph proc~ndgrid3 ndgrid3 interface~ndgrid ndgrid interface~ndgrid->proc~ndgrid3 proc~basis nurbs_surface%basis proc~basis->interface~ndgrid proc~basis~2 nurbs_volume%basis proc~basis~2->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~2 nurbs_volume%create proc~create~2->interface~ndgrid proc~derivative nurbs_surface%derivative proc~derivative->interface~ndgrid proc~derivative~2 nurbs_volume%derivative proc~derivative~2->interface~ndgrid program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ndgrid3.html"},{"title":"compute_multiplicity – ForCAD","text":"public interface compute_multiplicity Calls interface~~compute_multiplicity~~CallsGraph interface~compute_multiplicity compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~compute_multiplicity~~CalledByGraph interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~get_continuity nurbs_surface%get_continuity proc~get_continuity->interface~compute_multiplicity proc~get_continuity~2 nurbs_volume%get_continuity proc~get_continuity~2->interface~compute_multiplicity proc~get_continuity~3 nurbs_curve%get_continuity proc~get_continuity~3->interface~compute_multiplicity proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_multiplicity->interface~compute_multiplicity proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_multiplicity~2->interface~compute_multiplicity proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~get_nc nurbs_surface%get_nc proc~get_nc->interface~compute_multiplicity proc~get_nc~2 nurbs_volume%get_nc proc~get_nc~2->interface~compute_multiplicity proc~get_nc~3 nurbs_curve%get_nc proc~get_nc~3->interface~compute_multiplicity proc~insert_knots nurbs_surface%insert_knots proc~insert_knots->interface~compute_multiplicity none~set nurbs_surface%set proc~insert_knots->none~set proc~insert_knots~2 nurbs_volume%insert_knots proc~insert_knots~2->interface~compute_multiplicity none~set~2 nurbs_volume%set proc~insert_knots~2->none~set~2 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_curve%set proc~insert_knots~3->none~set~3 proc~remove_knots nurbs_surface%remove_knots proc~remove_knots->interface~compute_multiplicity proc~remove_knots->none~set proc~remove_knots~2 nurbs_volume%remove_knots proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->none~set~2 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->none~set~3 proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->proc~get_multiplicity proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->proc~get_multiplicity~2 proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~elevate_degree nurbs_surface%elevate_degree proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->none~set proc~elevate_degree~2 nurbs_volume%elevate_degree proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~elevate_degree~2->none~set~2 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->none~set~3 proc~get_degree nurbs_curve%get_degree proc~get_degree->proc~get_multiplicity~3 proc~get_degree_all nurbs_surface%get_degree_all proc~get_degree_all->proc~get_multiplicity proc~get_degree_all~2 nurbs_volume%get_degree_all proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir nurbs_surface%get_degree_dir proc~get_degree_dir->proc~get_multiplicity proc~get_degree_dir~2 nurbs_volume%get_degree_dir proc~get_degree_dir~2->proc~get_multiplicity~2 proc~set1 nurbs_surface%set1 proc~set1->proc~get_nc none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~set1~2 nurbs_volume%set1 proc~set1~2->proc~get_nc~2 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~set2 nurbs_surface%set2 proc~set2->proc~get_nc proc~set2~2 nurbs_volume%set2 proc~set2~2->proc~get_nc~2 program~example1_curve example1_curve program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~get_degree program~example1_curve->none~set~3 program~example3_surface example3_surface program~example3_surface->proc~insert_knots program~example3_surface->proc~remove_knots program~example3_surface->proc~elevate_degree program~example3_surface->none~get_degree program~example3_surface->none~set program~example3_volume example3_volume program~example3_volume->proc~insert_knots~2 program~example3_volume->proc~remove_knots~2 program~example3_volume->proc~elevate_degree~2 program~example3_volume->none~get_degree~2 program~example3_volume->none~set~2 none~get_degree->proc~get_degree_all none~get_degree->proc~get_degree_dir none~get_degree~2->proc~get_degree_all~2 none~get_degree~2->proc~get_degree_dir~2 none~set->proc~set1 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 none~set~2->proc~set1~2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 proc~set1~3 nurbs_curve%set1 proc~set1~3->proc~get_degree proc~set3~3 nurbs_curve%set3 proc~set3~3->proc~get_degree none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~modify_wc nurbs_surface%modify_Wc proc~modify_wc->none~set proc~modify_wc~2 nurbs_volume%modify_Wc proc~modify_wc~2->none~set~2 proc~modify_xc nurbs_surface%modify_Xc proc~modify_xc->none~set proc~modify_xc~2 nurbs_volume%modify_Xc proc~modify_xc~2->none~set~2 proc~set3->none~get_degree proc~set3~2->none~get_degree~2 proc~set_hexahedron nurbs_volume%set_hexahedron proc~set_hexahedron->none~set~2 proc~set_tetragon nurbs_surface%set_tetragon proc~set_tetragon->none~set program~example_morph example_morph program~example_morph->none~set~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->none~set program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->none~set~2 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~set_hexahedron program~shape_tetragon shape_tetragon program~shape_tetragon->proc~set_tetragon program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer","tags":"","loc":"interface/compute_multiplicity.html"},{"title":"elemConn_C0 – ForCAD","text":"public interface elemConn_C0 Calls interface~~elemconn_c0~~CallsGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_c0~~CalledByGraph interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~export_xc nurbs_surface%export_Xc proc~export_xc->proc~cmp_elem_xc_vis proc~export_xc~2 nurbs_volume%export_Xc proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~export_xc~3 nurbs_curve%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~export_xg nurbs_surface%export_Xg proc~export_xg->proc~cmp_elem_xg_vis proc~export_xg~2 nurbs_volume%export_Xg proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~export_xg~3 nurbs_curve%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~3 program~example1_curve->proc~export_xg~3 program~example3_surface example3_surface program~example3_surface->proc~export_xc program~example3_surface->proc~export_xg program~example3_volume example3_volume program~example3_volume->proc~export_xc~2 program~example3_volume->proc~export_xg~2 program~example_morph example_morph program~example_morph->proc~export_xc~2 program~example_morph->proc~export_xg~2 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~3 program~example_nurbs_curve->proc~export_xg~3 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~export_xc program~example_nurbs_surface->proc~export_xg program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~export_xc~2 program~example_nurbs_volume->proc~export_xg~2 program~shape_circle shape_circle program~shape_circle->proc~export_xc~3 program~shape_circle->proc~export_xg~3 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~export_xc~2 program~shape_hexahedron->proc~export_xg~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~export_xc program~shape_tetragon->proc~export_xg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:)","tags":"","loc":"interface/elemconn_c0.html"},{"title":"elemConn_Cn – ForCAD","text":"public interface elemConn_Cn Calls interface~~elemconn_cn~~CallsGraph interface~elemconn_cn elemConn_Cn proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~elemconn_cn~~CalledByGraph interface~elemconn_cn elemConn_Cn proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~elemconn_cn proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->interface~elemconn_cn proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->interface~elemconn_cn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:)","tags":"","loc":"interface/elemconn_cn.html"},{"title":"ndgrid – ForCAD","text":"public interface ndgrid Calls interface~~ndgrid~~CallsGraph interface~ndgrid ndgrid proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~ndgrid~~CalledByGraph interface~ndgrid ndgrid proc~basis nurbs_surface%basis proc~basis->interface~ndgrid proc~basis~2 nurbs_volume%basis proc~basis~2->interface~ndgrid proc~create nurbs_surface%create proc~create->interface~ndgrid proc~create~2 nurbs_volume%create proc~create~2->interface~ndgrid proc~derivative nurbs_surface%derivative proc~derivative->interface~ndgrid proc~derivative~2 nurbs_volume%derivative proc~derivative~2->interface~ndgrid program~example3_surface example3_surface program~example3_surface->proc~create program~example3_volume example3_volume program~example3_volume->proc~create~2 program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->proc~create program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->proc~create~2 program~shape_hexahedron shape_hexahedron program~shape_hexahedron->proc~create~2 program~shape_tetragon shape_tetragon program~shape_tetragon->proc~create Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","loc":"interface/ndgrid.html"},{"title":"unique – ForCAD","text":"public interface unique Calls interface~~unique~~CallsGraph interface~unique unique proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~unique~~CalledByGraph interface~unique unique proc~cmp_elem nurbs_surface%cmp_elem proc~cmp_elem->interface~unique proc~cmp_elem~2 nurbs_volume%cmp_elem proc~cmp_elem~2->interface~unique proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->interface~unique Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function unique_integer (vec) result(unique) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(unique) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable","tags":"","loc":"interface/unique.html"},{"title":"cmp_elem – ForCAD","text":"private pure function cmp_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem~3~~CallsGraph proc~cmp_elem~3 nurbs_curve%cmp_elem interface~elemconn_cn elemConn_Cn proc~cmp_elem~3->interface~elemconn_cn interface~unique unique proc~cmp_elem~3->interface~unique proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~cmp_elem~3->proc~get_multiplicity~3 proc~cmp_elemconn_cn_l cmp_elemConn_Cn_L interface~elemconn_cn->proc~cmp_elemconn_cn_l proc~cmp_elemconn_cn_s cmp_elemConn_Cn_S interface~elemconn_cn->proc~cmp_elemconn_cn_s proc~cmp_elemconn_cn_v cmp_elemConn_Cn_V interface~elemconn_cn->proc~cmp_elemconn_cn_v proc~unique_integer unique_integer interface~unique->proc~unique_integer proc~unique_real unique_real interface~unique->proc~unique_real interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem~3.html"},{"title":"cmp_elem_Xc_vis – ForCAD","text":"private pure function cmp_elem_Xc_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xc_vis~3~~CallsGraph proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xc_vis~3~~CalledByGraph proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~3 nurbs_curve%export_Xc proc~export_xc~3->proc~cmp_elem_xc_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xc~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xc_vis~3.html"},{"title":"cmp_elem_Xg_vis – ForCAD","text":"private pure function cmp_elem_Xg_vis(this, p) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) Calls proc~~cmp_elem_xg_vis~3~~CallsGraph proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cmp_elem_xg_vis~3~~CalledByGraph proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~3 nurbs_curve%export_Xg proc~export_xg~3->proc~cmp_elem_xg_vis~3 program~example1_curve example1_curve program~example1_curve->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cmp_elem_xg_vis~3.html"},{"title":"get_Wc – ForCAD","text":"private pure function get_Wc(this) result(Wc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_wc~3.html"},{"title":"get_Xc – ForCAD","text":"private pure function get_Xc(this) result(Xc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xc~3.html"},{"title":"get_Xg – ForCAD","text":"private pure function get_Xg(this) result(Xg) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:)","tags":"","loc":"proc/get_xg~3.html"},{"title":"get_Xt – ForCAD","text":"private pure function get_Xt(this) result(Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"proc/get_xt~3.html"},{"title":"get_continuity – ForCAD","text":"private pure function get_continuity(this) result(c) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_continuity~3~~CallsGraph proc~get_continuity~3 nurbs_curve%get_continuity interface~compute_multiplicity compute_multiplicity proc~get_continuity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_continuity~3.html"},{"title":"get_degree – ForCAD","text":"private pure function get_degree(this) result(degree) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Calls proc~~get_degree~~CallsGraph proc~get_degree nurbs_curve%get_degree proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_degree~~CalledByGraph proc~get_degree nurbs_curve%get_degree proc~set1~3 nurbs_curve%set1 proc~set1~3->proc~get_degree proc~set3~3 nurbs_curve%set3 proc~set3~3->proc~get_degree program~example1_curve example1_curve program~example1_curve->proc~get_degree none~set~3 nurbs_curve%set program~example1_curve->none~set~3 proc~elevate_degree~3 nurbs_curve%elevate_degree program~example1_curve->proc~elevate_degree~3 proc~insert_knots~3 nurbs_curve%insert_knots program~example1_curve->proc~insert_knots~3 proc~remove_knots~3 nurbs_curve%remove_knots program~example1_curve->proc~remove_knots~3 none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~elevate_degree~3->none~set~3 proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_degree.html"},{"title":"get_elem – ForCAD","text":"private pure function get_elem(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem~3.html"},{"title":"get_elem_Xc_vis – ForCAD","text":"private pure function get_elem_Xc_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xc_vis~3.html"},{"title":"get_elem_Xg_vis – ForCAD","text":"private pure function get_elem_Xg_vis(this) result(elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:)","tags":"","loc":"proc/get_elem_xg_vis~3.html"},{"title":"get_knot_all – ForCAD","text":"private pure function get_knot_all(this) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) Called by proc~~get_knot_all~3~~CalledByGraph proc~get_knot_all~3 nurbs_curve%get_knot_all none~get_knot~3 nurbs_curve%get_knot none~get_knot~3->proc~get_knot_all~3 program~example1_curve example1_curve program~example1_curve->none~get_knot~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knot_all~3.html"},{"title":"get_knoti – ForCAD","text":"private pure function get_knoti(this, i) result(knot) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) Called by proc~~get_knoti~3~~CalledByGraph proc~get_knoti~3 nurbs_curve%get_knoti none~get_knot~3 nurbs_curve%get_knot none~get_knot~3->proc~get_knoti~3 program~example1_curve example1_curve program~example1_curve->none~get_knot~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_knoti~3.html"},{"title":"get_multiplicity – ForCAD","text":"private pure function get_multiplicity(this) result(m) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) Calls proc~~get_multiplicity~3~~CallsGraph proc~get_multiplicity~3 nurbs_curve%get_multiplicity interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_multiplicity~3~~CalledByGraph proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~cmp_elem~3 nurbs_curve%cmp_elem proc~cmp_elem~3->proc~get_multiplicity~3 proc~get_degree nurbs_curve%get_degree proc~get_degree->proc~get_multiplicity~3 proc~set1~3 nurbs_curve%set1 proc~set1~3->proc~get_degree proc~set3~3 nurbs_curve%set3 proc~set3~3->proc~get_degree program~example1_curve example1_curve program~example1_curve->proc~get_degree none~set~3 nurbs_curve%set program~example1_curve->none~set~3 proc~elevate_degree~3 nurbs_curve%elevate_degree program~example1_curve->proc~elevate_degree~3 proc~insert_knots~3 nurbs_curve%insert_knots program~example1_curve->proc~insert_knots~3 proc~remove_knots~3 nurbs_curve%remove_knots program~example1_curve->proc~remove_knots~3 none~set~3->proc~set1~3 none~set~3->proc~set3~3 proc~elevate_degree~3->none~set~3 proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_multiplicity~3.html"},{"title":"get_nc – ForCAD","text":"private pure function get_nc(this) result(nc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer Calls proc~~get_nc~3~~CallsGraph proc~get_nc~3 nurbs_curve%get_nc interface~compute_multiplicity compute_multiplicity proc~get_nc~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_nc~3.html"},{"title":"get_ng – ForCAD","text":"private pure function get_ng(this) result(ng) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer","tags":"","loc":"proc/get_ng~3.html"},{"title":"is_rational – ForCAD","text":"private pure function is_rational(this) result(r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical Called by proc~~is_rational~3~~CalledByGraph proc~is_rational~3 nurbs_curve%is_rational proc~basis~3 nurbs_curve%basis proc~basis~3->proc~is_rational~3 proc~create~3 nurbs_curve%create proc~create~3->proc~is_rational~3 proc~derivative~3 nurbs_curve%derivative proc~derivative~3->proc~is_rational~3 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->proc~is_rational~3 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->proc~is_rational~3 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->proc~is_rational~3 program~example1_curve example1_curve program~example1_curve->proc~create~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~3 program~shape_circle shape_circle program~shape_circle->proc~create~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_rational~3.html"},{"title":"basis – ForCAD","text":"private pure subroutine basis(this, res, Xt, Tgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) Calls proc~~basis~3~~CallsGraph proc~basis~3 nurbs_curve%basis proc~basis_bspline basis_bspline proc~basis~3->proc~basis_bspline proc~is_rational~3 nurbs_curve%is_rational proc~basis~3->proc~is_rational~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/basis~3.html"},{"title":"create – ForCAD","text":"private pure subroutine create(this, res, Xt) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) Calls proc~~create~3~~CallsGraph proc~create~3 nurbs_curve%create proc~basis_bspline basis_bspline proc~create~3->proc~basis_bspline proc~is_rational~3 nurbs_curve%is_rational proc~create~3->proc~is_rational~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create~3~~CalledByGraph proc~create~3 nurbs_curve%create program~example1_curve example1_curve program~example1_curve->proc~create~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~create~3 program~shape_circle shape_circle program~shape_circle->proc~create~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/create~3.html"},{"title":"derivative – ForCAD","text":"private pure subroutine derivative(this, res, Xt, dTgc) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) Calls proc~~derivative~3~~CallsGraph proc~derivative~3 nurbs_curve%derivative proc~basis_bspline_der basis_bspline_der proc~derivative~3->proc~basis_bspline_der proc~is_rational~3 nurbs_curve%is_rational proc~derivative~3->proc~is_rational~3 proc~isinf isinf proc~basis_bspline_der->proc~isinf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/derivative~3.html"},{"title":"elevate_degree – ForCAD","text":"private pure subroutine elevate_degree(this, t) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t Calls proc~~elevate_degree~3~~CallsGraph proc~elevate_degree~3 nurbs_curve%elevate_degree none~set~3 nurbs_curve%set proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~is_rational~3 nurbs_curve%is_rational proc~elevate_degree~3->proc~is_rational~3 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 interface~compute_multiplicity compute_multiplicity proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~factln factln proc~bincoeff->proc~factln proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~elevate_degree~3~~CalledByGraph proc~elevate_degree~3 nurbs_curve%elevate_degree program~example1_curve example1_curve program~example1_curve->proc~elevate_degree~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/elevate_degree~3.html"},{"title":"export_Xc – ForCAD","text":"private impure subroutine export_Xc(this, filename) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xc~3~~CallsGraph proc~export_xc~3 nurbs_curve%export_Xc proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xc~3~~CalledByGraph proc~export_xc~3 nurbs_curve%export_Xc program~example1_curve example1_curve program~example1_curve->proc~export_xc~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xc~3 program~shape_circle shape_circle program~shape_circle->proc~export_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xc~3.html"},{"title":"export_Xg – ForCAD","text":"private impure subroutine export_Xg(this, filename) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename Calls proc~~export_xg~3~~CallsGraph proc~export_xg~3 nurbs_curve%export_Xg proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_xg~3~~CalledByGraph proc~export_xg~3 nurbs_curve%export_Xg program~example1_curve example1_curve program~example1_curve->proc~export_xg~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~export_xg~3 program~shape_circle shape_circle program~shape_circle->proc~export_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/export_xg~3.html"},{"title":"finalize – ForCAD","text":"private pure subroutine finalize(this) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this Called by proc~~finalize~3~~CalledByGraph proc~finalize~3 nurbs_curve%finalize program~example1_curve example1_curve program~example1_curve->proc~finalize~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->proc~finalize~3 program~shape_circle shape_circle program~shape_circle->proc~finalize~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize~3.html"},{"title":"insert_knots – ForCAD","text":"private pure subroutine insert_knots(this, Xth, r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~insert_knots~3~~CallsGraph proc~insert_knots~3 nurbs_curve%insert_knots interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity none~set~3 nurbs_curve%set proc~insert_knots~3->none~set~3 proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~is_rational~3 nurbs_curve%is_rational proc~insert_knots~3->proc~is_rational~3 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~insert_knots~3~~CalledByGraph proc~insert_knots~3 nurbs_curve%insert_knots program~example1_curve example1_curve program~example1_curve->proc~insert_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/insert_knots~3.html"},{"title":"modify_Wc – ForCAD","text":"private pure subroutine modify_Wc(this, W, num) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num Calls proc~~modify_wc~3~~CallsGraph proc~modify_wc~3 nurbs_curve%modify_Wc none~set~3 nurbs_curve%set proc~modify_wc~3->none~set~3 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_wc~3.html"},{"title":"modify_Xc – ForCAD","text":"private pure subroutine modify_Xc(this, X, num, dir) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir Calls proc~~modify_xc~3~~CallsGraph proc~modify_xc~3 nurbs_curve%modify_Xc none~set~3 nurbs_curve%set proc~modify_xc~3->none~set~3 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/modify_xc~3.html"},{"title":"remove_knots – ForCAD","text":"private pure subroutine remove_knots(this, Xth, r) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) Calls proc~~remove_knots~3~~CallsGraph proc~remove_knots~3 nurbs_curve%remove_knots interface~compute_multiplicity compute_multiplicity proc~remove_knots~3->interface~compute_multiplicity none~set~3 nurbs_curve%set proc~remove_knots~3->none~set~3 proc~findspan findspan proc~remove_knots~3->proc~findspan proc~is_rational~3 nurbs_curve%is_rational proc~remove_knots~3->proc~is_rational~3 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 proc~get_multiplicity~3->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_knots~3~~CalledByGraph proc~remove_knots~3 nurbs_curve%remove_knots program~example1_curve example1_curve program~example1_curve->proc~remove_knots~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/remove_knots~3.html"},{"title":"rotate_Xc – ForCAD","text":"private pure subroutine rotate_Xc(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xc~3~~CallsGraph proc~rotate_xc~3 nurbs_curve%rotate_Xc proc~rotation rotation proc~rotate_xc~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xc~3~~CalledByGraph proc~rotate_xc~3 nurbs_curve%rotate_Xc program~example1_curve example1_curve program~example1_curve->proc~rotate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xc~3.html"},{"title":"rotate_Xg – ForCAD","text":"private pure subroutine rotate_Xg(this, alpha, beta, theta) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Calls proc~~rotate_xg~3~~CallsGraph proc~rotate_xg~3 nurbs_curve%rotate_Xg proc~rotation rotation proc~rotate_xg~3->proc~rotation cosd cosd proc~rotation->cosd sind sind proc~rotation->sind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate_xg~3~~CalledByGraph proc~rotate_xg~3 nurbs_curve%rotate_Xg program~example1_curve example1_curve program~example1_curve->proc~rotate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rotate_xg~3.html"},{"title":"set1 – ForCAD","text":"private pure subroutine set1(this, knot, Xc, Wc) Set knot vector, control points and weights for the NURBS curve object. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set1~3~~CallsGraph proc~set1~3 nurbs_curve%set1 proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set1~3~~CalledByGraph proc~set1~3 nurbs_curve%set1 none~set~3 nurbs_curve%set none~set~3->proc~set1~3 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example1_curve example1_curve program~example1_curve->none~set~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set1~3.html"},{"title":"set2 – ForCAD","text":"private pure subroutine set2(this, Xth_dir, degree, continuity, Xc, Wc) Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set2~3~~CallsGraph proc~set2~3 nurbs_curve%set2 proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set2~3~~CalledByGraph proc~set2~3 nurbs_curve%set2 none~set~3 nurbs_curve%set none~set~3->proc~set2~3 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example1_curve example1_curve program~example1_curve->none~set~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set2~3.html"},{"title":"set3 – ForCAD","text":"private pure subroutine set3(this, Xc, Wc) Set Bezier or Rational Bezier curve using control points and weights. Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) Calls proc~~set3~3~~CallsGraph proc~set3~3 nurbs_curve%set3 proc~get_degree nurbs_curve%get_degree proc~set3~3->proc~get_degree proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set3~3~~CalledByGraph proc~set3~3 nurbs_curve%set3 none~set~3 nurbs_curve%set none~set~3->proc~set3~3 proc~elevate_degree~3 nurbs_curve%elevate_degree proc~elevate_degree~3->none~set~3 proc~insert_knots~3 nurbs_curve%insert_knots proc~insert_knots~3->none~set~3 proc~modify_wc~3 nurbs_curve%modify_Wc proc~modify_wc~3->none~set~3 proc~modify_xc~3 nurbs_curve%modify_Xc proc~modify_xc~3->none~set~3 proc~remove_knots~3 nurbs_curve%remove_knots proc~remove_knots~3->none~set~3 proc~set_circle nurbs_curve%set_circle proc~set_circle->none~set~3 program~example1_curve example1_curve program~example1_curve->none~set~3 program~example1_curve->proc~elevate_degree~3 program~example1_curve->proc~insert_knots~3 program~example1_curve->proc~remove_knots~3 program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->none~set~3 program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set3~3.html"},{"title":"set_circle – ForCAD","text":"private pure subroutine set_circle(this, center, radius) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius Calls proc~~set_circle~~CallsGraph proc~set_circle nurbs_curve%set_circle none~set~3 nurbs_curve%set proc~set_circle->none~set~3 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_circle~~CalledByGraph proc~set_circle nurbs_curve%set_circle program~shape_circle shape_circle program~shape_circle->proc~set_circle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_circle.html"},{"title":"set_elem – ForCAD","text":"private pure subroutine set_elem(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem~3.html"},{"title":"set_elem_Xc_vis – ForCAD","text":"private pure subroutine set_elem_Xc_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xc_vis~3.html"},{"title":"set_elem_Xg_vis – ForCAD","text":"private pure subroutine set_elem_Xg_vis(this, elemConn) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:)","tags":"","loc":"proc/set_elem_xg_vis~3.html"},{"title":"translate_Xc – ForCAD","text":"private pure subroutine translate_Xc(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xc~3~~CalledByGraph proc~translate_xc~3 nurbs_curve%translate_Xc program~example1_curve example1_curve program~example1_curve->proc~translate_xc~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xc~3.html"},{"title":"translate_Xg – ForCAD","text":"private pure subroutine translate_Xg(this, vec) Type Bound nurbs_curve Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) Called by proc~~translate_xg~3~~CalledByGraph proc~translate_xg~3 nurbs_curve%translate_Xg program~example1_curve example1_curve program~example1_curve->proc~translate_xg~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/translate_xg~3.html"},{"title":"generate_Xc – ForCAD","text":"function generate_Xc(L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Called by proc~~generate_xc~5~~CalledByGraph proc~generate_xc~5 generate_Xc program~example3_volume example3_volume program~example3_volume->proc~generate_xc~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/generate_xc~5.html"},{"title":"forcad_nurbs_surface – ForCAD","text":"This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. Uses forcad_utils module~~forcad_nurbs_surface~~UsesGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad_utils forcad_utils module~forcad_nurbs_surface->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_surface~~UsedByGraph module~forcad_nurbs_surface forcad_nurbs_surface module~forcad forcad module~forcad->module~forcad_nurbs_surface program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_morph example_morph program~example_morph->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: nurbs_surface Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc(1)*nc(2)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1)*nc(2), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1)*ng(2), dim]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) integer, private :: degree (2) Degree (order) of the surface integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) integer, private :: nc (2) Number of control points in each direction integer, private :: ng (2) Number of geometry points in each direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS surface Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: create Generate geometry points Read more… procedure, public :: derivative Compute the derivative of the NURBS surface Read more… procedure, public :: elevate_degree Elevate degree Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS surface object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Get continuity of the surface Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS surface Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Get multiplicity of the knot vector Read more… procedure, public :: get_nc Get number of required control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS surface is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 Set NURBS surface Read more… procedure, public :: set1 Set knot vectors, control points and weights for the NURBS surface object Read more… procedure, public :: set2 Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier surface using control points and weights Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_tetragon Set a tetragon Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: get_degree_all Get degree of the NURBS surface in both directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS surface in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… Functions private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value integer, (2) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this Return Value logical Subroutines private pure subroutine basis (this, res1, res2, Xt1, Xt2, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, Xt1, Xt2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative (this, res1, res2, Xt1, Xt2, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vectors, control points and weights for the NURBS surface object. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, degree, continuity1, continuity2, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier surface using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_tetragon (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_surface ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","loc":"module/forcad_nurbs_surface.html"},{"title":"forcad – ForCAD","text":"Uses forcad_utils forcad_nurbs_surface forcad_nurbs_curve forcad_nurbs_volume module~~forcad~~UsesGraph module~forcad forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad~~UsedByGraph module~forcad forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_morph example_morph program~example_morph->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forcad.html"},{"title":"forcad_nurbs_volume – ForCAD","text":"This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. Uses forcad_utils module~~forcad_nurbs_volume~~UsesGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_volume~~UsedByGraph module~forcad_nurbs_volume forcad_nurbs_volume module~forcad forcad module~forcad->module~forcad_nurbs_volume program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_morph example_morph program~example_morph->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: nurbs_volume Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for the control points (1D array: [nc(1) nc(2) nc(3)]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc(1) nc(2) nc(3), dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng(1) ng(2) ng(3), dim]) real(kind=rk), private, allocatable :: Xt1 (:) Evaluation parameter values in the first direction (1D array: [ng(1)]) real(kind=rk), private, allocatable :: Xt2 (:) Evaluation parameter values in the second direction (1D array: [ng(2)]) real(kind=rk), private, allocatable :: Xt3 (:) Evaluation parameter values in the third direction (1D array: [ng(3)]) integer, private :: degree (3) Degree (order) of the volume integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot1 (:) Knot vector in the first direction (1D array) real(kind=rk), private, allocatable :: knot2 (:) Knot vector in the second direction (1D array) real(kind=rk), private, allocatable :: knot3 (:) Knot vector in the third direction (1D array) integer, private :: nc (3) Number of control points in each direction integer, private :: ng (3) Number of geometry points in each direction Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS volume Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: create Generate geometry points Read more… procedure, public :: derivative Compute the derivative of the NURBS volume Read more… procedure, public :: elevate_degree Elevate the degree of the NURBS volume Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS volume object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Get continuity of the volume Read more… generic, public :: get_degree => get_degree_all , get_degree_dir Get degree of the NURBS volume Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Get multiplicity of the knot vector Read more… procedure, public :: get_nc Get number of required control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS volume is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: put_to_nurbs Put a shape to a NURBS volume Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 Set NURBS volume Read more… procedure, public :: set1 Set knot vectors, control points and weights for the NURBS volume object Read more… procedure, public :: set2 Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier volume using control points and weights Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: set_hexahedron Set a hexahedron Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: get_degree_all Get degree of the NURBS volume in all directions Read more… procedure, private :: get_degree_dir Get degree of the NURBS volume in a specific direction Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… Functions private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in), optional, contiguous :: p (:) Return Value integer, allocatable, (:,:) private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this, dir) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this, dir) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_degree_all (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function get_degree_dir (this, dir) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this, dir) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, dir, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this, dir) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer, allocatable, (:) private pure function get_nc (this, dir) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this integer, intent(in) :: dir Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value integer, (3) private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this Return Value logical Subroutines private pure subroutine basis (this, res1, res2, res3, Xt1, Xt2, Xt3, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res1, res2, res3, Xt1, Xt2, Xt3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(in), optional, contiguous :: Xt (:,:) private pure subroutine derivative (this, res1, res2, res3, Xt1, Xt2, Xt3, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), optional :: res1 integer, intent(in), optional :: res2 integer, intent(in), optional :: res3 real(kind=rk), intent(in), optional, contiguous :: Xt1 (:) real(kind=rk), intent(in), optional, contiguous :: Xt2 (:) real(kind=rk), intent(in), optional, contiguous :: Xt3 (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) private pure subroutine elevate_degree (this, dir, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir integer, intent(in) :: t private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this private pure subroutine insert_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine put_to_nurbs (this, X, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: X (:,:) integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine remove_knots (this, dir, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in) :: dir real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot1, knot2, knot3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot1 (:) real(kind=rk), intent(in), contiguous :: knot2 (:) real(kind=rk), intent(in), contiguous :: knot3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir1, Xth_dir2, Xth_dir3, degree, continuity1, continuity2, continuity3, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set control points and weights for the NURBS volume object. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir1 (:) real(kind=rk), intent(in), contiguous :: Xth_dir2 (:) real(kind=rk), intent(in), contiguous :: Xth_dir3 (:) integer, intent(in), contiguous :: degree (:) integer, intent(in), contiguous :: continuity1 (:) integer, intent(in), contiguous :: continuity2 (:) integer, intent(in), contiguous :: continuity3 (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, nc, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier volume using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_hexahedron (this, L, nc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: L (:) integer, intent(in), contiguous :: nc (:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_volume ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","loc":"module/forcad_nurbs_volume.html"},{"title":"forcad_utils – ForCAD","text":"This module contains parameters, functions and subroutines that are used in the library. Used by module~~forcad_utils~~UsedByGraph module~forcad_utils forcad_utils module~forcad forcad module~forcad->module~forcad_utils module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils program~example_morph example_morph program~example_morph->module~forcad_utils program~example_morph->module~forcad program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = kind(1.0d0) Interfaces public        interface compute_multiplicity private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer public        interface elemConn_C0 private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) public        interface elemConn_Cn private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) public        interface ndgrid private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) public        interface unique private pure function unique_integer (vec) result(unique) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(unique) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Functions public pure function basis_bernstein (Xt, nc) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt integer, intent(in) :: nc Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline (Xt, knot, nc, degree) result(B) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:) public pure function basis_bspline_der (Xt, knot, nc, degree) result(dB) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Xt real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: nc integer, intent(in) :: degree Return Value real(kind=rk), allocatable, (:) public pure function compute_knot_vector (Xth_dir, degree, continuity) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) Return Value real(kind=rk), allocatable, (:) public pure function findspan (n, degree, Xth, knot) result(s) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: degree real(kind=rk), intent(in) :: Xth real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer public pure function hexahedron_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (3) integer, intent(in) :: nc (3) Return Value real(kind=rk), allocatable, (:,:) public pure function kron (u, v) result(w) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) Return Value real(kind=rk), (size(u)*size(v)) public pure function rotation (alpha, beta, theta) result(R) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta Return Value real(kind=rk), dimension(3,3) public pure function tetragon_Xc (L, nc) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L (2) integer, intent(in) :: nc (2) Return Value real(kind=rk), allocatable, (:,:) private pure function bincoeff (n, k) result(b) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: k Return Value real(kind=rk) private pure function cmp_elemConn_C0_L (nnode, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_S (nnode1, nnode2, p1, p2) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 Return Value integer, allocatable, (:,:) private pure function cmp_elemConn_C0_V (nnode1, nnode2, nnode3, p1, p2, p3) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 Return Value integer, allocatable, (:,:) private pure function compute_multiplicity1 (knot) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) Return Value integer, allocatable, (:) private pure function compute_multiplicity2 (knot, Xth) result(multiplicity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in) :: Xth Return Value integer private pure function factln (n) result(f) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=rk) private pure elemental function isinf (x) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical private pure elemental function isnan (x) result(output) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value logical private pure function repelem (a, b) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:) integer, intent(in), contiguous :: b (:) Return Value real(kind=rk), (sum(b)) private pure function unique_integer (vec) result(unique) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:), contiguous :: vec Return Value integer, dimension(:), allocatable private pure function unique_real (vec) result(unique) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: vec Return Value real(kind=rk), dimension(:), allocatable Subroutines public pure subroutine elevate_degree_A_5_9 (t, knot, degree, Xcw, nc_new, knot_new, Xcw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: t real(kind=rk), intent(in), contiguous :: knot (:) integer, intent(in) :: degree real(kind=rk), intent(in), contiguous :: Xcw (:,:) integer, intent(out) :: nc_new real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Xcw_new (:,:) public pure subroutine insert_knot_A_5_1 (p, UP, Pw, u, k, s, r, nq, UQ, Qw) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: UP (0:) real(kind=rk), intent(in), contiguous :: Pw (0:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: k integer, intent(in) :: s integer, intent(in) :: r integer, intent(out) :: nq real(kind=rk), intent(out), allocatable :: UQ (:) real(kind=rk), intent(out), allocatable :: Qw (:,:) public pure subroutine remove_knots_A_5_8 (p, knot, Pw, u, r, s, num, t, knot_new, Pw_new) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Pw (:,:) real(kind=rk), intent(in) :: u integer, intent(in) :: r integer, intent(in) :: s integer, intent(in) :: num integer, intent(out) :: t real(kind=rk), intent(out), allocatable :: knot_new (:) real(kind=rk), intent(out), allocatable :: Pw_new (:,:) private pure subroutine cmp_elemConn_Cn_L (nnode, p, Xth, vecKnot_mul, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode integer, intent(in) :: p real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: vecKnot_mul (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_S (nnode1, nnode2, p1, p2, Xth1, Xth2, vecKnot_mul1, vecKnot_mul2, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: p1 integer, intent(in) :: p2 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine cmp_elemConn_Cn_V (nnode1, nnode2, nnode3, p1, p2, p3, Xth1, Xth2, Xth3, vecKnot_mul1, vecKnot_mul2, vecKnot_mul3, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name integer, intent(in) :: nnode1 integer, intent(in) :: nnode2 integer, intent(in) :: nnode3 integer, intent(in) :: p1 integer, intent(in) :: p2 integer, intent(in) :: p3 real(kind=rk), intent(in), contiguous :: Xth1 (:) real(kind=rk), intent(in), contiguous :: Xth2 (:) real(kind=rk), intent(in), contiguous :: Xth3 (:) integer, intent(in), contiguous :: vecKnot_mul1 (:) integer, intent(in), contiguous :: vecKnot_mul2 (:) integer, intent(in), contiguous :: vecKnot_mul3 (:) integer, intent(out), allocatable :: elemConn (:,:) private pure subroutine ndgrid2 (X_dir1, X_dir2, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:) private pure subroutine ndgrid3 (X_dir1, X_dir2, X_dir3, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: X_dir1 (:) real(kind=rk), intent(in), contiguous :: X_dir2 (:) real(kind=rk), intent(in), contiguous :: X_dir3 (:) real(kind=rk), intent(out), allocatable :: Xt (:,:)","tags":"","loc":"module/forcad_utils.html"},{"title":"forcad_nurbs_curve – ForCAD","text":"This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. Uses forcad_utils module~~forcad_nurbs_curve~~UsesGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad_utils forcad_utils module~forcad_nurbs_curve->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forcad_nurbs_curve~~UsedByGraph module~forcad_nurbs_curve forcad_nurbs_curve module~forcad forcad module~forcad->module~forcad_nurbs_curve program~example1_curve example1_curve program~example1_curve->module~forcad program~example3_surface example3_surface program~example3_surface->module~forcad program~example3_volume example3_volume program~example3_volume->module~forcad program~example_morph example_morph program~example_morph->module~forcad program~example_nurbs_curve example_nurbs_curve program~example_nurbs_curve->module~forcad program~example_nurbs_surface example_nurbs_surface program~example_nurbs_surface->module~forcad program~example_nurbs_volume example_nurbs_volume program~example_nurbs_volume->module~forcad program~shape_circle shape_circle program~shape_circle->module~forcad program~shape_hexahedron shape_hexahedron program~shape_hexahedron->module~forcad program~shape_tetragon shape_tetragon program~shape_tetragon->module~forcad Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: nurbs_curve Components Type Visibility Attributes Name Initial real(kind=rk), private, allocatable :: Wc (:) Weights for control points (1D array: [nc]) real(kind=rk), private, allocatable :: Xc (:,:) Control points (2D array: [nc, dim]) real(kind=rk), private, allocatable :: Xg (:,:) Geometry points (2D array: [ng, dim]) real(kind=rk), private, allocatable :: Xt (:) Evaluation points (1D array: [ng]) integer, private :: degree Degree (order) of the curve integer, private, allocatable :: elemConn (:,:) IGA element connectivity integer, private, allocatable :: elemConn_Xc_vis (:,:) Connectivity for visualization of control points integer, private, allocatable :: elemConn_Xg_vis (:,:) Connectivity for visualization of geometry points real(kind=rk), private, allocatable :: knot (:) Knot vector (1D array) integer, private :: nc Number of control points integer, private :: ng Number of geometry points Type-Bound Procedures procedure, public :: basis Compute the basis functions of the NURBS curve Read more… procedure, public :: cmp_elem Generate IGA element connectivity Read more… procedure, public :: cmp_elem_Xc_vis Generate connectivity for control points Read more… procedure, public :: cmp_elem_Xg_vis Generate connectivity for geometry points Read more… procedure, public :: create Generate geometry points Read more… procedure, public :: derivative Compute the derivative of the NURBS curve Read more… procedure, public :: elevate_degree Elevate the degree of the curve Read more… procedure, public :: export_Xc Export control points to VTK file Read more… procedure, public :: export_Xg Export geometry points to VTK file Read more… procedure, public :: finalize Finalize the NURBS curve object Read more… procedure, public :: get_Wc Get weights Read more… procedure, public :: get_Xc Get control points Read more… procedure, public :: get_Xg Get geometry points Read more… procedure, public :: get_Xt Get parameter values Read more… procedure, public :: get_continuity Get continuity of the curve Read more… procedure, public :: get_degree Get degree of the NURBS curve Read more… procedure, public :: get_elem Get IGA element connectivity Read more… procedure, public :: get_elem_Xc_vis Get connectivity for control points Read more… procedure, public :: get_elem_Xg_vis Get connectivity for geometry points Read more… generic, public :: get_knot => get_knoti , get_knot_all Get knot vector Read more… procedure, public :: get_multiplicity Get multiplicity of the knot vector Read more… procedure, public :: get_nc Get number of required control points Read more… procedure, public :: get_ng Get number of geometry points Read more… procedure, public :: insert_knots Insert knots into the knot vector Read more… procedure, public :: is_rational Check if the NURBS curve is rational Read more… procedure, public :: modify_Wc Modify weights Read more… procedure, public :: modify_Xc Modify control points Read more… procedure, public :: remove_knots Remove knots from the knot vector Read more… procedure, public :: rotate_Xc Rotate control points Read more… procedure, public :: rotate_Xg Rotate geometry points Read more… generic, public :: set => set1 , set2 , set3 Set NURBS curve Read more… procedure, public :: set1 Set knot vector, control points and weights for the NURBS curve object Read more… procedure, public :: set2 Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights Read more… procedure, public :: set3 Set Bezier or Rational Bezier curve using control points and weights Read more… procedure, public :: set_circle Set a circle Read more… procedure, public :: set_elem Set IGA element connectivity Read more… procedure, public :: set_elem_Xc_vis Set connectivity for control points Read more… procedure, public :: set_elem_Xg_vis Set connectivity for geometry points Read more… procedure, public :: translate_Xc Translate control points Read more… procedure, public :: translate_Xg Translate geometry points Read more… procedure, private :: get_knot_all Get all knot vectors Read more… procedure, private :: get_knoti Get i-th knot value Read more… Functions private pure function cmp_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xc_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function cmp_elem_Xg_vis (this, p) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in), optional :: p Return Value integer, allocatable, (:,:) private pure function get_Wc (this) result(Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_Xc (this) result(Xc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xg (this) result(Xg) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:,:) private pure function get_Xt (this) result(Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_continuity (this) result(c) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_degree (this) result(degree) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_elem (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xc_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_elem_Xg_vis (this) result(elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:,:) private pure function get_knot_all (this) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value real(kind=rk), allocatable, (:) private pure function get_knoti (this, i) result(knot) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this integer, intent(in) :: i Return Value real(kind=rk) private pure function get_multiplicity (this) result(m) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer, allocatable, (:) private pure function get_nc (this) result(nc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function get_ng (this) result(ng) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value integer private pure function is_rational (this) result(r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this Return Value logical Subroutines private pure subroutine basis (this, res, Xt, Tgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: Tgc (:,:) private pure subroutine create (this, res, Xt) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) private pure subroutine derivative (this, res, Xt, dTgc) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), optional :: res real(kind=rk), intent(in), optional, contiguous :: Xt (:) real(kind=rk), intent(out), allocatable :: dTgc (:,:) private pure subroutine elevate_degree (this, t) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in) :: t private impure subroutine export_Xc (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename private impure subroutine export_Xg (this, filename) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(in) :: this character(len=*), intent(in) :: filename private pure subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this private pure subroutine insert_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine modify_Wc (this, W, num) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: W integer, intent(in) :: num private pure subroutine modify_Xc (this, X, num, dir) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: X integer, intent(in) :: num integer, intent(in) :: dir private pure subroutine remove_knots (this, Xth, r) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth (:) integer, intent(in), contiguous :: r (:) private pure subroutine rotate_Xc (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine rotate_Xg (this, alpha, beta, theta) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: alpha real(kind=rk), intent(in) :: beta real(kind=rk), intent(in) :: theta private pure subroutine set1 (this, knot, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set knot vector, control points and weights for the NURBS curve object. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: knot (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set2 (this, Xth_dir, degree, continuity, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xth_dir (:) integer, intent(in) :: degree integer, intent(in), contiguous :: continuity (:) real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set3 (this, Xc, Wc) Author Seyed Ali Ghasemi License BSD 3-Clause Set Bezier or Rational Bezier curve using control points and weights. Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: Xc (:,:) real(kind=rk), intent(in), optional, contiguous :: Wc (:) private pure subroutine set_circle (this, center, radius) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in), contiguous :: center (:) real(kind=rk), intent(in) :: radius private pure subroutine set_elem (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xc_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine set_elem_Xg_vis (this, elemConn) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this integer, intent(in), contiguous :: elemConn (:,:) private pure subroutine translate_Xc (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:) private pure subroutine translate_Xg (this, vec) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nurbs_curve ), intent(inout) :: this real(kind=rk), intent(in) :: vec (:)","tags":"","loc":"module/forcad_nurbs_curve.html"},{"title":"example_morph – ForCAD","text":"Uses forcad_utils forcad program~~example_morph~~UsesGraph program~example_morph example_morph module~forcad forcad program~example_morph->module~forcad module~forcad_utils forcad_utils program~example_morph->module~forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. You can create your shape or use a predefined one\nRead coordinates from file\nRead element connectivities from file\nSet a control shape that will be used to put the shape into\nThe contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points\nBy modifying the control shape you can modify the shape Map the shape into the shape Export the shape and the control shape to vtk files Calls program~~example_morph~~CallsGraph program~example_morph example_morph none~set~2 nurbs_volume%set program~example_morph->none~set~2 proc~export_xc~2 nurbs_volume%export_Xc program~example_morph->proc~export_xc~2 proc~export_xg~2 nurbs_volume%export_Xg program~example_morph->proc~export_xg~2 proc~hexahedron_xc hexahedron_Xc program~example_morph->proc~hexahedron_xc proc~put_to_nurbs nurbs_volume%put_to_nurbs program~example_morph->proc~put_to_nurbs proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~basis_bspline basis_bspline proc~put_to_nurbs->proc~basis_bspline proc~kron kron proc~put_to_nurbs->proc~kron proc~set_elem_xg_vis~2 nurbs_volume%set_elem_Xg_vis proc~put_to_nurbs->proc~set_elem_xg_vis~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: X (:,:) type( nurbs_volume ) :: control_shape integer, allocatable :: elem (:,:) integer :: i integer :: nunit","tags":"","loc":"program/example_morph.html"},{"title":"example_nurbs_surface – ForCAD","text":"Uses forcad program~~example_nurbs_surface~~UsesGraph program~example_nurbs_surface example_nurbs_surface module~forcad forcad program~example_nurbs_surface->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface.\nIt sets up control points and weights, generates the surface, and exports the control points\nand the surface to VTK files at various stages. Define control points for the NURBS surface Define weights for the control points Set control points and weights for the NURBS surface object Export initial control points to a VTK file Generate the NURBS surface with a resolution of 30x30 Export the generated surface to a VTK file Finalize the NURBS surface object Calls program~~example_nurbs_surface~~CallsGraph program~example_nurbs_surface example_nurbs_surface none~set nurbs_surface%set program~example_nurbs_surface->none~set proc~create nurbs_surface%create program~example_nurbs_surface->proc~create proc~export_xc nurbs_surface%export_Xc program~example_nurbs_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example_nurbs_surface->proc~export_xg proc~finalize nurbs_surface%finalize program~example_nurbs_surface->proc~finalize proc~generate_xc generate_Xc program~example_nurbs_surface->proc~generate_xc proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~ndgrid ndgrid proc~create->interface~ndgrid proc~basis_bspline basis_bspline proc~create->proc~basis_bspline proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~kron kron proc~create->proc~kron proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"program/example_nurbs_surface.html"},{"title":"example_nurbs_curve – ForCAD","text":"Uses forcad program~~example_nurbs_curve~~UsesGraph program~example_nurbs_curve example_nurbs_curve module~forcad forcad program~example_nurbs_curve->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve.\nIt sets up control points and weights, generates the curve, and exports the control points\nand the curve to VTK files at various stages. Define control points for the NURBS curve Define weights for the control points Set control points and weights for the NURBS curve object Export initial control points to a VTK file Generate the NURBS curve with a resolution of 500 Export the generated curve to a VTK file Finalize the NURBS curve object Calls program~~example_nurbs_curve~~CallsGraph program~example_nurbs_curve example_nurbs_curve none~set~3 nurbs_curve%set program~example_nurbs_curve->none~set~3 proc~create~3 nurbs_curve%create program~example_nurbs_curve->proc~create~3 proc~export_xc~3 nurbs_curve%export_Xc program~example_nurbs_curve->proc~export_xc~3 proc~export_xg~3 nurbs_curve%export_Xg program~example_nurbs_curve->proc~export_xg~3 proc~finalize~3 nurbs_curve%finalize program~example_nurbs_curve->proc~finalize~3 proc~generate_xc~2 generate_Xc program~example_nurbs_curve->proc~generate_xc~2 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 proc~basis_bspline basis_bspline proc~create~3->proc~basis_bspline proc~is_rational~3 nurbs_curve%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_curve ) :: nurbs Declare a NURBS curve object Functions function generate_Xc (num_coils, radius, height, num_points_per_coil) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_coils real(kind=rk), intent(in) :: radius real(kind=rk), intent(in) :: height integer, intent(in) :: num_points_per_coil Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","loc":"program/example_nurbs_curve.html"},{"title":"shape_hexahedron – ForCAD","text":"Uses forcad program~~shape_hexahedron~~UsesGraph program~shape_hexahedron shape_hexahedron module~forcad forcad program~shape_hexahedron->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8].\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file for visualization. Create the shape using the specified number of elements in each direction. Export the geometry to a VTK file for visualization. Finalize and clean up the shape object. Calls program~~shape_hexahedron~~CallsGraph program~shape_hexahedron shape_hexahedron proc~create~2 nurbs_volume%create program~shape_hexahedron->proc~create~2 proc~export_xc~2 nurbs_volume%export_Xc program~shape_hexahedron->proc~export_xc~2 proc~export_xg~2 nurbs_volume%export_Xg program~shape_hexahedron->proc~export_xg~2 proc~finalize~2 nurbs_volume%finalize program~shape_hexahedron->proc~finalize~2 proc~set_hexahedron nurbs_volume%set_hexahedron program~shape_hexahedron->proc~set_hexahedron interface~ndgrid ndgrid proc~create~2->interface~ndgrid proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline proc~kron kron proc~create~2->proc~kron proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 none~set~2 nurbs_volume%set proc~set_hexahedron->none~set~2 proc~hexahedron_xc hexahedron_Xc proc~set_hexahedron->proc~hexahedron_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_volume ) :: shape","tags":"","loc":"program/shape_hexahedron.html"},{"title":"example1_curve – ForCAD","text":"Uses forcad program~~example1_curve~~UsesGraph program~example1_curve example1_curve module~forcad forcad program~example1_curve->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. Define control points for the NURBS curve\nDefine weights for the control points (optional)\nDefine knot vector Set knot vector, control points, and weights for the NURBS curve object.\nWc is optional Export control points to a VTK file Generate the NURBS curve with a resolution of 20 Export the generated curve to a VTK file Print size of the knot vector Insert knots 0.25, twice and 0.75, once Print size of the updated knot vector Print the degree of the curve Elevate the degree of the curve (2 times) Print the updated degree of the curve Print size of the knot vector Remove knots 0.25, twice and 0.75, once Print size of the updated knot vector Generate the refined curve with a resolution of 20 Export updated control points to a VTK file Export the refined generated curve to a VTK file Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Finalize the NURBS curve object Calls program~~example1_curve~~CallsGraph program~example1_curve example1_curve none~get_knot~3 nurbs_curve%get_knot program~example1_curve->none~get_knot~3 none~set~3 nurbs_curve%set program~example1_curve->none~set~3 proc~create~3 nurbs_curve%create program~example1_curve->proc~create~3 proc~elevate_degree~3 nurbs_curve%elevate_degree program~example1_curve->proc~elevate_degree~3 proc~export_xc~3 nurbs_curve%export_Xc program~example1_curve->proc~export_xc~3 proc~export_xg~3 nurbs_curve%export_Xg program~example1_curve->proc~export_xg~3 proc~finalize~3 nurbs_curve%finalize program~example1_curve->proc~finalize~3 proc~get_degree nurbs_curve%get_degree program~example1_curve->proc~get_degree proc~insert_knots~3 nurbs_curve%insert_knots program~example1_curve->proc~insert_knots~3 proc~remove_knots~3 nurbs_curve%remove_knots program~example1_curve->proc~remove_knots~3 proc~rotate_xc~3 nurbs_curve%rotate_Xc program~example1_curve->proc~rotate_xc~3 proc~rotate_xg~3 nurbs_curve%rotate_Xg program~example1_curve->proc~rotate_xg~3 proc~translate_xc~3 nurbs_curve%translate_Xc program~example1_curve->proc~translate_xc~3 proc~translate_xg~3 nurbs_curve%translate_Xg program~example1_curve->proc~translate_xg~3 proc~get_knot_all~3 nurbs_curve%get_knot_all none~get_knot~3->proc~get_knot_all~3 proc~get_knoti~3 nurbs_curve%get_knoti none~get_knot~3->proc~get_knoti~3 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 proc~basis_bspline basis_bspline proc~create~3->proc~basis_bspline proc~is_rational~3 nurbs_curve%is_rational proc~create~3->proc~is_rational~3 proc~elevate_degree~3->none~set~3 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~3->proc~elevate_degree_a_5_9 proc~elevate_degree~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 proc~insert_knots~3->none~set~3 interface~compute_multiplicity compute_multiplicity proc~insert_knots~3->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~3->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~3->proc~insert_knot_a_5_1 proc~insert_knots~3->proc~is_rational~3 proc~remove_knots~3->none~set~3 proc~remove_knots~3->interface~compute_multiplicity proc~remove_knots~3->proc~findspan proc~remove_knots~3->proc~is_rational~3 proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~3->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~3->proc~rotation proc~rotate_xg~3->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_multiplicity~3->interface~compute_multiplicity cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~repelem repelem proc~compute_knot_vector->proc~repelem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot (6) Array for knot vector type( nurbs_curve ) :: nurbs Declare a NURBS curve object Source Code program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","loc":"program/example1_curve.html"},{"title":"shape_circle – ForCAD","text":"Uses forcad program~~shape_circle~~UsesGraph program~shape_circle shape_circle module~forcad forcad program~shape_circle->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] Export control points to a VTK file Generate the NURBS circle with a resolution of 100 Export the generated cirlce to a VTK file Finalize the NURBS curve object Calls program~~shape_circle~~CallsGraph program~shape_circle shape_circle proc~create~3 nurbs_curve%create program~shape_circle->proc~create~3 proc~export_xc~3 nurbs_curve%export_Xc program~shape_circle->proc~export_xc~3 proc~export_xg~3 nurbs_curve%export_Xg program~shape_circle->proc~export_xg~3 proc~finalize~3 nurbs_curve%finalize program~shape_circle->proc~finalize~3 proc~set_circle nurbs_curve%set_circle program~shape_circle->proc~set_circle proc~basis_bspline basis_bspline proc~create~3->proc~basis_bspline proc~is_rational~3 nurbs_curve%is_rational proc~create~3->proc~is_rational~3 proc~cmp_elem_xc_vis~3 nurbs_curve%cmp_elem_Xc_vis proc~export_xc~3->proc~cmp_elem_xc_vis~3 proc~cmp_elem_xg_vis~3 nurbs_curve%cmp_elem_Xg_vis proc~export_xg~3->proc~cmp_elem_xg_vis~3 none~set~3 nurbs_curve%set proc~set_circle->none~set~3 proc~set1~3 nurbs_curve%set1 none~set~3->proc~set1~3 proc~set2~3 nurbs_curve%set2 none~set~3->proc~set2~3 proc~set3~3 nurbs_curve%set3 none~set~3->proc~set3~3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~3->interface~elemconn_c0 proc~cmp_elem_xg_vis~3->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_degree nurbs_curve%get_degree proc~set1~3->proc~get_degree proc~compute_knot_vector compute_knot_vector proc~set2~3->proc~compute_knot_vector proc~set3~3->proc~get_degree proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~3 nurbs_curve%get_multiplicity proc~get_degree->proc~get_multiplicity~3 interface~compute_multiplicity compute_multiplicity proc~get_multiplicity~3->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( nurbs_curve ) :: shape","tags":"","loc":"program/shape_circle.html"},{"title":"example_nurbs_volume – ForCAD","text":"Uses forcad program~~example_nurbs_volume~~UsesGraph program~example_nurbs_volume example_nurbs_volume module~forcad forcad program~example_nurbs_volume->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume.\nIt sets up control points and weights, generates the volume, and exports the control points\nand the volume to VTK files at various stages. Define control points for the NURBS volume Define weights for the control points Set control points and weights for the NURBS volume object Export initial control points to a VTK file Generate the NURBS volume with a resolution of 15X15X15 Export the generated volume to a VTK file Finalize the NURBS volume object Calls program~~example_nurbs_volume~~CallsGraph program~example_nurbs_volume example_nurbs_volume none~set~2 nurbs_volume%set program~example_nurbs_volume->none~set~2 proc~create~2 nurbs_volume%create program~example_nurbs_volume->proc~create~2 proc~export_xc~2 nurbs_volume%export_Xc program~example_nurbs_volume->proc~export_xc~2 proc~export_xg~2 nurbs_volume%export_Xg program~example_nurbs_volume->proc~export_xg~2 proc~finalize~2 nurbs_volume%finalize program~example_nurbs_volume->proc~finalize~2 proc~generate_xc~3 generate_Xc program~example_nurbs_volume->proc~generate_xc~3 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 interface~ndgrid ndgrid proc~create~2->interface~ndgrid proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline proc~kron kron proc~create~2->proc~kron proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 none~get_degree~2 nurbs_volume%get_degree proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc~2->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 proc~get_multiplicity~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"program/example_nurbs_volume.html"},{"title":"example3_surface – ForCAD","text":"Uses forcad program~~example3_surface~~UsesGraph program~example3_surface example3_surface module~forcad forcad program~example3_surface->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. Define control points for the NURBS surface Define weights for the control points\nDefine knot vectors for both dimensions\nSet knot vectors, control points, and weights for the NURBS surface object Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Print size of the knot vectors\nInsert knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after inserting knots\nPrint the degrees Elevate degree by 2 in both directions\nPrint the degrees after elevating Print size of the knot vectors\nRemove knots 0.25, twice and 0.75, once in both directions\nPrint size of the knot vectors after removing knots\nGenerate the refined NURBS surface with resolutions of 30 in both dimensions Export updated control points to a VTK file Export the refined generated surface to a VTK file Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Finalize the NURBS surface object Calls program~~example3_surface~~CallsGraph program~example3_surface example3_surface none~get_degree nurbs_surface%get_degree program~example3_surface->none~get_degree none~get_knot nurbs_surface%get_knot program~example3_surface->none~get_knot none~set nurbs_surface%set program~example3_surface->none~set proc~create nurbs_surface%create program~example3_surface->proc~create proc~elevate_degree nurbs_surface%elevate_degree program~example3_surface->proc~elevate_degree proc~export_xc nurbs_surface%export_Xc program~example3_surface->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~example3_surface->proc~export_xg proc~finalize nurbs_surface%finalize program~example3_surface->proc~finalize proc~generate_xc~4 generate_Xc program~example3_surface->proc~generate_xc~4 proc~insert_knots nurbs_surface%insert_knots program~example3_surface->proc~insert_knots proc~remove_knots nurbs_surface%remove_knots program~example3_surface->proc~remove_knots proc~rotate_xc nurbs_surface%rotate_Xc program~example3_surface->proc~rotate_xc proc~rotate_xg nurbs_surface%rotate_Xg program~example3_surface->proc~rotate_xg proc~translate_xc nurbs_surface%translate_Xc program~example3_surface->proc~translate_xc proc~translate_xg nurbs_surface%translate_Xg program~example3_surface->proc~translate_xg proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~get_knot_all nurbs_surface%get_knot_all none~get_knot->proc~get_knot_all proc~get_knoti nurbs_surface%get_knoti none~get_knot->proc~get_knoti proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~ndgrid ndgrid proc~create->interface~ndgrid proc~basis_bspline basis_bspline proc~create->proc~basis_bspline proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~kron kron proc~create->proc~kron proc~elevate_degree->none~set proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree->proc~elevate_degree_a_5_9 proc~elevate_degree->proc~is_rational proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis proc~insert_knots->none~set interface~compute_multiplicity compute_multiplicity proc~insert_knots->interface~compute_multiplicity proc~findspan findspan proc~insert_knots->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots->proc~insert_knot_a_5_1 proc~insert_knots->proc~is_rational proc~remove_knots->none~set proc~remove_knots->interface~compute_multiplicity proc~remove_knots->proc~findspan proc~remove_knots->proc~is_rational proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc->proc~rotation proc~rotate_xg->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity->interface~compute_multiplicity proc~get_nc->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (6) Arrays for knot vectors in both dimensions real(kind=rk) :: knot2 (6) Arrays for knot vectors in both dimensions type( nurbs_surface ) :: nurbs Declare a NURBS surface object Functions function generate_Xc (num_rows, num_cols, peak_height) result(control_points) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_rows integer, intent(in) :: num_cols real(kind=rk), intent(in) :: peak_height Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","loc":"program/example3_surface.html"},{"title":"shape_tetragon – ForCAD","text":"Uses forcad program~~shape_tetragon~~UsesGraph program~shape_tetragon shape_tetragon module~forcad forcad program~shape_tetragon->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction\nThe weights of the control points (Wc) are optional. Export the control points to a VTK file Generate the NURBS surface with resolutions of 30 in both dimensions Export the generated surface to a VTK file Finalize the NURBS surface object Calls program~~shape_tetragon~~CallsGraph program~shape_tetragon shape_tetragon proc~create nurbs_surface%create program~shape_tetragon->proc~create proc~export_xc nurbs_surface%export_Xc program~shape_tetragon->proc~export_xc proc~export_xg nurbs_surface%export_Xg program~shape_tetragon->proc~export_xg proc~finalize nurbs_surface%finalize program~shape_tetragon->proc~finalize proc~set_tetragon nurbs_surface%set_tetragon program~shape_tetragon->proc~set_tetragon interface~ndgrid ndgrid proc~create->interface~ndgrid proc~basis_bspline basis_bspline proc~create->proc~basis_bspline proc~is_rational nurbs_surface%is_rational proc~create->proc~is_rational proc~kron kron proc~create->proc~kron proc~cmp_elem_xc_vis nurbs_surface%cmp_elem_Xc_vis proc~export_xc->proc~cmp_elem_xc_vis proc~cmp_elem_xg_vis nurbs_surface%cmp_elem_Xg_vis proc~export_xg->proc~cmp_elem_xg_vis none~set nurbs_surface%set proc~set_tetragon->none~set proc~tetragon_xc tetragon_Xc proc~set_tetragon->proc~tetragon_xc proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 proc~set1 nurbs_surface%set1 none~set->proc~set1 proc~set2 nurbs_surface%set2 none~set->proc~set2 proc~set3 nurbs_surface%set3 none~set->proc~set3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis->interface~elemconn_c0 proc~cmp_elem_xg_vis->interface~elemconn_c0 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v none~get_degree nurbs_surface%get_degree proc~set1->none~get_degree proc~get_nc nurbs_surface%get_nc proc~set1->proc~get_nc proc~compute_knot_vector compute_knot_vector proc~set2->proc~compute_knot_vector proc~set2->proc~get_nc proc~set3->none~get_degree proc~get_degree_all nurbs_surface%get_degree_all none~get_degree->proc~get_degree_all proc~get_degree_dir nurbs_surface%get_degree_dir none~get_degree->proc~get_degree_dir proc~repelem repelem proc~compute_knot_vector->proc~repelem interface~compute_multiplicity compute_multiplicity proc~get_nc->interface~compute_multiplicity proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~get_multiplicity nurbs_surface%get_multiplicity proc~get_degree_all->proc~get_multiplicity proc~get_degree_dir->proc~get_multiplicity proc~get_multiplicity->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk), allocatable :: knot1 (:) Arrays for knot vectors in both dimensions real(kind=rk), allocatable :: knot2 (:) Arrays for knot vectors in both dimensions type( nurbs_surface ) :: shape Declare a NURBS surface object","tags":"","loc":"program/shape_tetragon.html"},{"title":"example3_volume – ForCAD","text":"Uses forcad program~~example3_volume~~UsesGraph program~example3_volume example3_volume module~forcad forcad program~example3_volume->module~forcad module~forcad_nurbs_curve forcad_nurbs_curve module~forcad->module~forcad_nurbs_curve module~forcad_nurbs_surface forcad_nurbs_surface module~forcad->module~forcad_nurbs_surface module~forcad_nurbs_volume forcad_nurbs_volume module~forcad->module~forcad_nurbs_volume module~forcad_utils forcad_utils module~forcad->module~forcad_utils module~forcad_nurbs_curve->module~forcad_utils module~forcad_nurbs_surface->module~forcad_utils module~forcad_nurbs_volume->module~forcad_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume.\nIt sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. Define the control points for the NURBS volume Define weights for the control points (optional)\nDefine knot vectors for all three dimensions\nSet knot vectors, control points, and weights for the NURBS volume object\nWc is optional. Export the control points to a VTK file Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions Export the generated volume to a VTK file Print size of knot vectors\nInsert knots 0.25 and 0.75 in all three directions\nPrint size of knot vectors after inserting knots\nPrint degrees Elevate degree by 2 in all three directions\nPrint degrees after elevating Print size of knot vectors\nPrint size of knot vectors after removing knots\nGenerate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions Export updated control points to a VTK file Export the refined generated volume to a VTK file Rotate the control points Rotate the generated curve Translate the control points Translate the generated curve Export the transformed control points to a VTK file Export the transformed generated volume to a VTK file Finalize the NURBS volume object Calls program~~example3_volume~~CallsGraph program~example3_volume example3_volume none~get_degree~2 nurbs_volume%get_degree program~example3_volume->none~get_degree~2 none~get_knot~2 nurbs_volume%get_knot program~example3_volume->none~get_knot~2 none~set~2 nurbs_volume%set program~example3_volume->none~set~2 proc~create~2 nurbs_volume%create program~example3_volume->proc~create~2 proc~elevate_degree~2 nurbs_volume%elevate_degree program~example3_volume->proc~elevate_degree~2 proc~export_xc~2 nurbs_volume%export_Xc program~example3_volume->proc~export_xc~2 proc~export_xg~2 nurbs_volume%export_Xg program~example3_volume->proc~export_xg~2 proc~finalize~2 nurbs_volume%finalize program~example3_volume->proc~finalize~2 proc~generate_xc~5 generate_Xc program~example3_volume->proc~generate_xc~5 proc~insert_knots~2 nurbs_volume%insert_knots program~example3_volume->proc~insert_knots~2 proc~remove_knots~2 nurbs_volume%remove_knots program~example3_volume->proc~remove_knots~2 proc~rotate_xc~2 nurbs_volume%rotate_Xc program~example3_volume->proc~rotate_xc~2 proc~rotate_xg~2 nurbs_volume%rotate_Xg program~example3_volume->proc~rotate_xg~2 proc~translate_xc~2 nurbs_volume%translate_Xc program~example3_volume->proc~translate_xc~2 proc~translate_xg~2 nurbs_volume%translate_Xg program~example3_volume->proc~translate_xg~2 proc~get_degree_all~2 nurbs_volume%get_degree_all none~get_degree~2->proc~get_degree_all~2 proc~get_degree_dir~2 nurbs_volume%get_degree_dir none~get_degree~2->proc~get_degree_dir~2 proc~get_knot_all~2 nurbs_volume%get_knot_all none~get_knot~2->proc~get_knot_all~2 proc~get_knoti~2 nurbs_volume%get_knoti none~get_knot~2->proc~get_knoti~2 proc~set1~2 nurbs_volume%set1 none~set~2->proc~set1~2 proc~set2~2 nurbs_volume%set2 none~set~2->proc~set2~2 proc~set3~2 nurbs_volume%set3 none~set~2->proc~set3~2 interface~ndgrid ndgrid proc~create~2->interface~ndgrid proc~basis_bspline basis_bspline proc~create~2->proc~basis_bspline proc~kron kron proc~create~2->proc~kron proc~elevate_degree~2->none~set~2 proc~elevate_degree_a_5_9 elevate_degree_A_5_9 proc~elevate_degree~2->proc~elevate_degree_a_5_9 proc~cmp_elem_xc_vis~2 nurbs_volume%cmp_elem_Xc_vis proc~export_xc~2->proc~cmp_elem_xc_vis~2 proc~cmp_elem_xg_vis~2 nurbs_volume%cmp_elem_Xg_vis proc~export_xg~2->proc~cmp_elem_xg_vis~2 proc~insert_knots~2->none~set~2 interface~compute_multiplicity compute_multiplicity proc~insert_knots~2->interface~compute_multiplicity proc~findspan findspan proc~insert_knots~2->proc~findspan proc~insert_knot_a_5_1 insert_knot_A_5_1 proc~insert_knots~2->proc~insert_knot_a_5_1 proc~remove_knots~2->none~set~2 proc~remove_knots~2->interface~compute_multiplicity proc~remove_knots~2->proc~findspan proc~remove_knots_a_5_8 remove_knots_A_5_8 proc~remove_knots~2->proc~remove_knots_a_5_8 proc~rotation rotation proc~rotate_xc~2->proc~rotation proc~rotate_xg~2->proc~rotation proc~compute_multiplicity1 compute_multiplicity1 interface~compute_multiplicity->proc~compute_multiplicity1 proc~compute_multiplicity2 compute_multiplicity2 interface~compute_multiplicity->proc~compute_multiplicity2 proc~ndgrid2 ndgrid2 interface~ndgrid->proc~ndgrid2 proc~ndgrid3 ndgrid3 interface~ndgrid->proc~ndgrid3 interface~elemconn_c0 elemConn_C0 proc~cmp_elem_xc_vis~2->interface~elemconn_c0 proc~cmp_elem_xg_vis~2->interface~elemconn_c0 proc~elevate_degree_a_5_9->interface~compute_multiplicity proc~bincoeff bincoeff proc~elevate_degree_a_5_9->proc~bincoeff proc~get_multiplicity~2 nurbs_volume%get_multiplicity proc~get_degree_all~2->proc~get_multiplicity~2 proc~get_degree_dir~2->proc~get_multiplicity~2 cosd cosd proc~rotation->cosd sind sind proc~rotation->sind proc~set1~2->none~get_degree~2 proc~get_nc~2 nurbs_volume%get_nc proc~set1~2->proc~get_nc~2 proc~compute_knot_vector compute_knot_vector proc~set2~2->proc~compute_knot_vector proc~set2~2->proc~get_nc~2 proc~set3~2->none~get_degree~2 proc~cmp_elemconn_c0_l cmp_elemConn_C0_L interface~elemconn_c0->proc~cmp_elemconn_c0_l proc~cmp_elemconn_c0_s cmp_elemConn_C0_S interface~elemconn_c0->proc~cmp_elemconn_c0_s proc~cmp_elemconn_c0_v cmp_elemConn_C0_V interface~elemconn_c0->proc~cmp_elemconn_c0_v proc~factln factln proc~bincoeff->proc~factln proc~repelem repelem proc~compute_knot_vector->proc~repelem proc~get_multiplicity~2->interface~compute_multiplicity proc~get_nc~2->interface~compute_multiplicity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: Wc (:) Arrays for control points and weights real(kind=rk), allocatable :: Xc (:,:) Arrays for control points and weights real(kind=rk) :: knot1 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot2 (4) Arrays for knot vectors in all three dimensions real(kind=rk) :: knot3 (4) Arrays for knot vectors in all three dimensions type( nurbs_volume ) :: nurbs Declare a NURBS volume object Functions function generate_Xc (L) result(control_points) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: L Return Value real(kind=rk), allocatable, (:,:) Source Code program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","loc":"program/example3_volume.html"},{"title":"forcad_nurbs_surface.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_surface.f90~~EfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_surface.f90~~AfferentGraph sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_surface' type for representing a Non-Uniform Rational B-Spline (NURBS) surface. module forcad_nurbs_surface use forcad_utils , only : rk , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , tetragon_Xc , & elemConn_Cn , unique , rotation implicit none private public nurbs_surface !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_surface real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc(1)*nc(2)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) integer , private :: degree ( 2 ) !! Degree (order) of the surface integer , private :: nc ( 2 ) !! Number of control points in each direction integer , private :: ng ( 2 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vectors, control points and weights for the NURBS surface object procedure :: set2 !!> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier surface using control points and weights generic :: set => set1 , set2 , set3 !!> Set NURBS surface procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure , private :: get_degree_all !!> Get degree of the NURBS surface in both directions procedure , private :: get_degree_dir !!> Get degree of the NURBS surface in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS surface procedure :: finalize !!> Finalize the NURBS surface object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Get multiplicity of the knot vector procedure :: get_continuity !!> Get continuity of the surface procedure :: get_nc !!> Get number of required control points procedure :: derivative !!> Compute the derivative of the NURBS surface procedure :: basis !!> Compute the basis functions of the NURBS surface procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate degree procedure :: is_rational !!> Check if the NURBS surface is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points ! Shapes procedure :: set_tetragon !!> Set a tetragon end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vectors, control points and weights for the NURBS surface object. pure subroutine set1 ( this , knot1 , knot2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:) real ( rk ), intent ( in ), contiguous :: knot2 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = knot1 this % knot2 = knot2 this % degree = this % get_degree () this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS surface using nodes of parameter space, degree, continuity, control points and weights pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , degree , continuity1 , continuity2 , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % degree ( 1 ) = degree ( 1 ) this % degree ( 2 ) = degree ( 2 ) this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier surface using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc allocate ( this % knot1 ( 2 * this % nc ( 1 ))) this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk allocate ( this % knot2 ( 2 * this % nc ( 2 ))) this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk this % degree = this % get_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , Xt1 , Xt2 , Xt ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), contiguous , intent ( in ), optional :: Xt (:,:) integer :: i , j real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:), Tgc (:) real ( rk ), allocatable :: Xt_ (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if if ( present ( Xt )) then Xt_ = Xt else ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt_ ) end if if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( size ( Xt_ , 1 ), size ( this % Xc , 2 ))) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xt_ , 1 ) Tgc1 = basis_bspline ( Xt_ ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt_ ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else ! B-Spline do i = 1 , size ( Xt_ , 1 ) Tgc1 = basis_bspline ( Xt_ ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt_ ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc = kron ( Tgc2 , Tgc1 ) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( nurbs_surface ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS surface is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_surface ), intent ( in ) :: this integer :: ng ( 2 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer :: degree ( 2 ) integer , allocatable :: m1 (:), m2 (:) m1 = this % get_multiplicity ( 1 ) m2 = this % get_multiplicity ( 2 ) degree ( 1 ) = m1 ( 1 ) - 1 degree ( 2 ) = m2 ( 1 ) - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree integer , allocatable :: m1 (:), m2 (:) if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) degree = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) degree = m2 ( 1 ) - 1 else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_surface ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), p ( 1 ), p ( 2 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_surface ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 4 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 9 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , Xc = this % Xc , Wc = this % Wc ) else error stop 'The NURBS surface is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this , dir ) result ( nc ) class ( nurbs_surface ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative ( this , res1 , res2 , Xt1 , Xt2 , dTgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable :: dTgci (:) integer :: i real ( rk ), allocatable :: dTgc1 (:), dTgc2 (:) real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) allocate ( dTgc ( this % ng ( 1 ) * this % ng ( 2 ), this % nc ( 1 ) * this % nc ( 2 ))) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) dTgci = kron ( dTgc2 , dTgc1 ) dTgci = dTgci * ( this % Wc / ( dot_product ( dTgci , this % Wc ))) dTgc ( i ,:) = dTgci end do else ! B-Spline do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) dTgci = kron ( dTgc2 , dTgc1 ) dTgc ( i ,:) = dTgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis ( this , res1 , res2 , Xt1 , Xt2 , Tgc ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:) real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , Xt ) allocate ( Tgc ( this % ng ( 1 ) * this % ng ( 2 ), this % nc ( 1 ) * this % nc ( 2 ))) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgci = kron ( Tgc2 , Tgc1 ) Tgci = Tgci * ( this % Wc / ( dot_product ( Tgci , this % Wc ))) Tgc ( i ,:) = Tgci end do else ! B-Spline do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgci = kron ( Tgc2 , Tgc1 ) Tgc ( i ,:) = Tgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * ( n_new + 1 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * ( n_new + 1 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * ( n_new + 1 ))) do j = 1 , this % nc ( 2 ) * ( n_new + 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot1 , this % Wc ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc_new = reshape ( Xc_new ,[( this % nc ( 2 )) * ( n_new + 1 ), dim ]) deallocate ( this % Xc , this % knot1 ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , Xc = Xc_new ) end do end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc3 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( n_new + 1 ), dim + 1 ]) allocate ( Xc_new ( 1 :( n_new + 1 ) * this % nc ( 1 ), 1 : dim )) allocate ( Wc_new ( 1 :( n_new + 1 ) * this % nc ( 1 ))) do j = 1 , ( n_new + 1 ) * this % nc ( 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot2 , this % Wc ) call this % set ( knot2 = knot_new , knot1 = this % knot1 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc3 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), n_new + 1 , dim ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( n_new + 1 ), dim ]) deallocate ( this % Xc , this % knot2 ) call this % set ( knot2 = knot_new , knot1 = this % knot1 , Xc = Xc_new ) end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) integer :: dim , j , nc_new real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , nc_new , knot_new , Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * nc_new , dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * nc_new , 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * nc_new )) do j = 1 , this % nc ( 2 ) * nc_new Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot1 , this % Wc ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , nc_new , knot_new , Xc_new ) Xc_new = reshape ( Xc_new ,[ this % nc ( 2 ) * nc_new , dim ], order = [ 1 , 2 ]) deallocate ( this % Xc , this % knot1 ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , Xc = Xc_new ) deallocate ( Xc , Xc_new ) end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 )]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , nc_new , knot_new , Xcw_new ) Xc3 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * nc_new , dim + 1 ]) allocate ( Xc_new ( 1 : nc_new * this % nc ( 1 ), 1 : dim )) allocate ( Wc_new ( 1 : nc_new * this % nc ( 1 ))) do j = 1 , nc_new * this % nc ( 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot2 , this % Wc ) call this % set ( knot2 = knot_new , knot1 = this % knot1 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , nc_new , knot_new , Xc_new ) Xc3 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * nc_new , dim ]) deallocate ( this % Xc , this % knot2 ) call this % set ( knot2 = knot_new , knot1 = this % knot1 , Xc = Xc_new ) end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_surface ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_surface ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc3 (:,:,:) if ( dir == 1 ) then ! direction 1 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * ( dim + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[ this % nc ( 2 ) * ( nc_new ), dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : this % nc ( 2 ) * ( nc_new ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot1 , this % Wc ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * dim ], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc_new = reshape ( Xc_new ,[( this % nc ( 2 )) * ( nc_new ), dim ], order = [ 1 , 2 ]) deallocate ( this % Xc , this % knot1 ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc3 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ) * ( dim + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc3 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), dim + 1 ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim + 1 ], order = [ 2 , 1 , 3 ]) Xcw_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), dim + 1 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 1 ), 1 : dim )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 1 ))) do j = 1 , ( nc_new ) * this % nc ( 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot2 , this % Wc ) call this % set ( knot2 = knot_new , knot1 = this % knot1 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc3 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 2 , 1 , 3 ]) Xc = reshape ( Xc3 ,[ this % nc ( 2 ), this % nc ( 1 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xc_new , 1 ) Xc3 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), dim ]) Xc3 = reshape ( Xc3 , [ this % nc ( 1 ), nc_new , dim ], order = [ 2 , 1 , 3 ]) Xc_new = reshape ( Xc3 ,[( this % nc ( 1 )) * ( nc_new ), dim ]) deallocate ( this % Xc , this % knot2 ) call this % set ( knot2 = knot_new , knot1 = this % knot1 , Xc = Xc_new ) end if end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_tetragon ( this , L , nc , Wc ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: L ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) call this % set ( nc = nc , Xc = tetragon_Xc ( L , nc ), Wc = Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_surface ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ),& this % degree ( 1 ), this % degree ( 2 ),& unique ( this % knot1 ), unique ( this % knot2 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_surface ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== end module forcad_nurbs_surface","tags":"","loc":"sourcefile/forcad_nurbs_surface.f90.html"},{"title":"put_to_nurbs.f90 – ForCAD","text":"This file depends on sourcefile~~put_to_nurbs.f90~~EfferentGraph sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_morph use forcad use forcad_utils , only : hexahedron_Xc implicit none type ( nurbs_volume ) :: control_shape real ( rk ), allocatable :: X (:,:) integer , allocatable :: elem (:,:) integer :: i , nunit !> You can create your shape or use a predefined one !> Read coordinates from file allocate ( X ( 23200 , 3 )) open ( newunit = nunit , file = 'example/put_to_nurbs_X.txt' ) do i = 1 , 23200 read ( nunit , * ) X ( i , 1 ), X ( i , 2 ), X ( i , 3 ) end do close ( nunit ) !> Read element connectivities from file allocate ( elem ( 20577 , 8 )) open ( newunit = nunit , file = 'example/put_to_nurbs_elem.txt' ) do i = 1 , 20577 read ( nunit , * ) elem ( i , 1 ), elem ( i , 2 ), elem ( i , 4 ), elem ( i , 3 ), elem ( i , 5 ), elem ( i , 6 ), elem ( i , 8 ), elem ( i , 7 ) end do close ( nunit ) !> Set a control shape that will be used to put the shape into !> The contol shape is a hexahedron with 100x40x10 with 10x5x3 number of control points !> By modifying the control shape you can modify the shape call control_shape % set ( nc = [ 10 , 5 , 3 ], Xc = hexahedron_Xc ( L = [ 10 0.0_rk , 4 0.0_rk , 1 0.0_rk ], nc = [ 10 , 5 , 3 ])) !> Map the shape into the shape call control_shape % put_to_nurbs ( X , elem ) !> Export the shape and the control shape to vtk files call control_shape % export_Xc ( 'vtk/control_shape.vtk' ) call control_shape % export_Xg ( 'vtk/shape.vtk' ) end program","tags":"","loc":"sourcefile/put_to_nurbs.f90.html"},{"title":"demo_surface.f90 – ForCAD","text":"This file depends on sourcefile~~demo_surface.f90~~EfferentGraph sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS surface object to create, and finalize a NURBS surface. !> It sets up control points and weights, generates the surface, and exports the control points !> and the surface to VTK files at various stages. program example_nurbs_surface use forcad , only : rk , nurbs_surface implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 10 , 10 , 1.5_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS surface object call nurbs % set ([ 10 , 10 ], Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with a resolution of 30x30 call nurbs % create ( res1 = 30 , res2 = 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/demo_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_surface","tags":"","loc":"sourcefile/demo_surface.f90.html"},{"title":"demo_curve.f90 – ForCAD","text":"This file depends on sourcefile~~demo_curve.f90~~EfferentGraph sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS curve object to create, and finalize a NURBS curve. !> It sets up control points and weights, generates the curve, and exports the control points !> and the curve to VTK files at various stages. program example_nurbs_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve Xc = generate_Xc ( 5 , 1.0_rk , 2.0_rk , 20 ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS curve object call nurbs % set ( Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 500 call nurbs % create ( res = 500 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/demo_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_coils , radius , height , num_points_per_coil ) result ( control_points ) integer , intent ( in ) :: num_coils , num_points_per_coil real ( rk ), intent ( in ) :: radius , height real ( rk ), allocatable :: control_points (:,:) integer :: coil , i real ( rk ) :: theta , coil_height allocate ( control_points ( num_coils * num_points_per_coil , 3 )) do coil = 1 , num_coils coil_height = height * real ( coil - 1 , rk ) / real ( num_coils - 1 , rk ) theta = 0.0_rk do i = 1 , num_points_per_coil theta = theta + 2.0_rk * acos ( - 1.0_rk ) / real ( num_points_per_coil , rk ) control_points (( coil - 1 ) * num_points_per_coil + i , 1 ) = radius * cos ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 2 ) = radius * sin ( theta ) control_points (( coil - 1 ) * num_points_per_coil + i , 3 ) = coil_height end do end do end function !----------------------------------------------------------------------------- end program example_nurbs_curve","tags":"","loc":"sourcefile/demo_curve.f90.html"},{"title":"shape_hexahedron.f90 – ForCAD","text":"This file depends on sourcefile~~shape_hexahedron.f90~~EfferentGraph sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_hexahedron use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: shape !> Set up a hexahedron shape with dimensions L = [2.0, 4.0, 8.0] and a specified number of control points nc = [4, 6, 8]. !> The weights of the control points (Wc) are optional. call shape % set_hexahedron ( L = [ 2.0_rk , 4.0_rk , 8.0_rk ], nc = [ 4 , 6 , 8 ]) ! Additional modifications can be made to control points and weights, or the NURBS can be refined using knot insertion or degree elevation. ! call shape%insert_knots(...) ! call shape%elevate_degree(...) ! ... !> Export the control points to a VTK file for visualization. call shape % export_Xc ( 'vtk/shape_hexahedron_Xc.vtk' ) !> Create the shape using the specified number of elements in each direction. call shape % create ( 8 , 16 , 32 ) !> Export the geometry to a VTK file for visualization. call shape % export_Xg ( 'vtk/shape_hexahedron_Xg.vtk' ) !> Finalize and clean up the shape object. call shape % finalize () end program","tags":"","loc":"sourcefile/shape_hexahedron.f90.html"},{"title":"example_curve_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_curve_1.f90~~EfferentGraph sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) curve object to create  and finalize a NURBS curve. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the curve, and exports the control points and the curve to VTK files. program example1_curve use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: nurbs !! Declare a NURBS curve object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot ( 6 ) !! Array for knot vector !----------------------------------------------------------------------------- ! Setting up the NURBS curve !----------------------------------------------------------------------------- !> Define control points for the NURBS curve allocate ( Xc ( 3 , 3 )) Xc ( 1 ,:) = [ 0.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 0.0_rk , 5.0_rk , 0.0_rk ] Xc ( 3 ,:) = [ 5.0_rk , 5.0_rk , 0.0_rk ] !> Define weights for the control points (optional) allocate ( Wc ( 3 )) Wc = [ 1.0_rk , 2.0_rk , 0.3_rk ] !> Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vector, control points, and weights for the NURBS curve object. !> Wc is optional call nurbs % set ( knot , Xc , Wc ) !> Export control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS curve !----------------------------------------------------------------------------- !> Generate the NURBS curve with a resolution of 20 call nurbs % create ( res = 20 ) !> Export the generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Insert knots 0.25, twice and 0.75, once call nurbs % insert_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Print the degree of the curve print * , nurbs % get_degree () !> Elevate the degree of the curve (2 times) call nurbs % elevate_degree ( 2 ) !> Print the updated degree of the curve print * , nurbs % get_degree () !> Print size of the knot vector print * , size ( nurbs % get_knot ()) !> Remove knots 0.25, twice and 0.75, once call nurbs % remove_knots ([ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) !> Print size of the updated knot vector print * , size ( nurbs % get_knot ()) !> Generate the refined curve with a resolution of 20 call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc2.vtk' ) !> Export the refined generated curve to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_curve_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_curve_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call nurbs % finalize () end program example1_curve","tags":"","loc":"sourcefile/example_curve_1.f90.html"},{"title":"shape_circle.f90 – ForCAD","text":"This file depends on sourcefile~~shape_circle.f90~~EfferentGraph sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_circle use forcad , only : rk , nurbs_curve implicit none type ( nurbs_curve ) :: shape !----------------------------------------------------------------------------- ! Setting up NURBS circle !----------------------------------------------------------------------------- !> Set a circle with radius 2.0 and center at [0.0, 0.0, 0.0] call shape % set_circle ( center = [ 0.0_rk , 0.0_rk , 0.0_rk ], radius = 2.0_rk ) !> Export control points to a VTK file call shape % export_Xc ( 'vtk/shape_circle_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating circle !----------------------------------------------------------------------------- !> Generate the NURBS circle with a resolution of 100 call shape % create ( res = 100 ) !> Export the generated cirlce to a VTK file call shape % export_Xg ( 'vtk/shape_circle_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS curve object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_circle.f90.html"},{"title":"demo_volume.f90 – ForCAD","text":"This file depends on sourcefile~~demo_volume.f90~~EfferentGraph sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS volume object to create, and finalize a NURBS volume. !> It sets up control points and weights, generates the volume, and exports the control points !> and the volume to VTK files at various stages. program example_nurbs_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define control points for the NURBS volume Xc = generate_Xc ( 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) !> Set control points and weights for the NURBS volume object call nurbs % set ([ 2 , 2 , 2 ], Xc , Wc ) !> Export initial control points to a VTK file call nurbs % export_Xc ( 'vtk/demo_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with a resolution of 15X15X15 call nurbs % create ( 15 , 15 , 15 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/demo_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example_nurbs_volume","tags":"","loc":"sourcefile/demo_volume.f90.html"},{"title":"example_surface_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_surface_1.f90~~EfferentGraph sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) surface object to create  and finalize a NURBS surface. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the surface, and exports the control points and the surface to VTK files. program example3_surface use forcad implicit none type ( nurbs_surface ) :: nurbs !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 6 ), knot2 ( 6 ) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS surface !----------------------------------------------------------------------------- !> Define control points for the NURBS surface Xc = generate_Xc ( 3 , 3 , 1.0_rk ) !> Define weights for the control points allocate ( Wc ( size ( Xc , 1 ))) Wc = 1.0_rk Wc ( 2 ) = 2.0_rk !> Define knot vectors for both dimensions knot1 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS surface object call nurbs % set ( knot1 , knot2 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call nurbs % create ( 30 , 30 ) !> Export the generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Insert knots 0.25, twice and 0.75, once in both directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Print the degrees print * , nurbs % get_degree () !> Elevate degree by 2 in both directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 !> Print the degrees after elevating print * , nurbs % get_degree () !> Print size of the knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Remove knots 0.25, twice and 0.75, once in both directions call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 2 , 1 ]) ! direction 2 !> Print size of the knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) !> Generate the refined NURBS surface with resolutions of 30 in both dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc2.vtk' ) !> Export the refined generated surface to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha = 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta =- 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ - 1.0_rk , - 2.0_rk , 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_surface_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_surface_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( num_rows , num_cols , peak_height ) result ( control_points ) integer , intent ( in ) :: num_rows , num_cols real ( rk ), intent ( in ) :: peak_height real ( rk ), allocatable :: control_points (:,:) integer :: i , j real ( rk ) :: x_spacing , y_spacing , x_offset , y_offset x_spacing = 1.0_rk / real ( num_cols - 1 , rk ) y_spacing = 1.0_rk / real ( num_rows - 1 , rk ) x_offset = - 0.5_rk y_offset = - 0.5_rk allocate ( control_points ( num_rows * num_cols , 3 )) do i = 1 , num_rows do j = 1 , num_cols control_points (( i - 1 ) * num_cols + j , 1 ) = x_offset + real ( j - 1 , rk ) * x_spacing control_points (( i - 1 ) * num_cols + j , 2 ) = y_offset + real ( i - 1 , rk ) * y_spacing control_points (( i - 1 ) * num_cols + j , 3 ) = & peak_height * exp ( - (( control_points (( i - 1 ) * num_cols + j , 1 ) ** 2 ) & + ( control_points (( i - 1 ) * num_cols + j , 2 ) ** 2 ))) + 0.5_rk * peak_height * 0.2_rk end do end do end function !----------------------------------------------------------------------------- end program example3_surface","tags":"","loc":"sourcefile/example_surface_1.f90.html"},{"title":"shape_tetragon.f90 – ForCAD","text":"This file depends on sourcefile~~shape_tetragon.f90~~EfferentGraph sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program shape_tetragon use forcad implicit none type ( nurbs_surface ) :: shape !! Declare a NURBS surface object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ), allocatable :: knot1 (:), knot2 (:) !! Arrays for knot vectors in both dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS tetrangon !----------------------------------------------------------------------------- !> Set a tetragon with lengths of 2.0 and 3.0 and 3 and 4 control points in each direction !> The weights of the control points (Wc) are optional. call shape % set_tetragon ( L = [ 2.0_rk , 3.0_rk ], nc = [ 3 , 4 ]) !> Export the control points to a VTK file call shape % export_Xc ( 'vtk/shape_tetragon_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS surface !----------------------------------------------------------------------------- !> Generate the NURBS surface with resolutions of 30 in both dimensions call shape % create ( 30 , 30 ) !> Export the generated surface to a VTK file call shape % export_Xg ( 'vtk/shape_tetragon_Xg.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS surface object call shape % finalize () end program","tags":"","loc":"sourcefile/shape_tetragon.f90.html"},{"title":"forcad.f90 – ForCAD","text":"This file depends on sourcefile~~forcad.f90~~EfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad.f90~~AfferentGraph sourcefile~forcad.f90 forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forcad use forcad_utils use forcad_nurbs_curve use forcad_nurbs_surface use forcad_nurbs_volume private public rk , nurbs_curve , nurbs_surface , nurbs_volume end module forcad","tags":"","loc":"sourcefile/forcad.f90.html"},{"title":"forcad_nurbs_volume.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_volume.f90~~EfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_volume.f90~~AfferentGraph sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_volume' type for representing a Non-Uniform Rational B-Spline (NURBS) volume. module forcad_nurbs_volume use forcad_utils , only : rk , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation implicit none private public nurbs_volume !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_volume real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc(1)*nc(2)*nc(3), dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng(1)*ng(2)*ng(3), dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for the control points (1D array: [nc(1)*nc(2)*nc(3)]) real ( rk ), allocatable , private :: Xt1 (:) !! Evaluation parameter values in the first direction (1D array: [ng(1)]) real ( rk ), allocatable , private :: Xt2 (:) !! Evaluation parameter values in the second direction (1D array: [ng(2)]) real ( rk ), allocatable , private :: Xt3 (:) !! Evaluation parameter values in the third direction (1D array: [ng(3)]) real ( rk ), allocatable , private :: knot1 (:) !! Knot vector in the first direction (1D array) real ( rk ), allocatable , private :: knot2 (:) !! Knot vector in the second direction (1D array) real ( rk ), allocatable , private :: knot3 (:) !! Knot vector in the third direction (1D array) integer , private :: degree ( 3 ) !! Degree (order) of the volume integer , private :: nc ( 3 ) !! Number of control points in each direction integer , private :: ng ( 3 ) !! Number of geometry points in each direction integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vectors, control points and weights for the NURBS volume object procedure :: set2 !!> Set NURBS volume using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier volume using control points and weights generic :: set => set1 , set2 , set3 !!> Set NURBS volume procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure , private :: get_degree_all !!> Get degree of the NURBS volume in all directions procedure , private :: get_degree_dir !!> Get degree of the NURBS volume in a specific direction generic :: get_degree => get_degree_all , get_degree_dir !!> Get degree of the NURBS volume procedure :: finalize !!> Finalize the NURBS volume object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Get multiplicity of the knot vector procedure :: get_continuity !!> Get continuity of the volume procedure :: get_nc !!> Get number of required control points procedure :: derivative !!> Compute the derivative of the NURBS volume procedure :: basis !!> Compute the basis functions of the NURBS volume procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the NURBS volume procedure :: is_rational !!> Check if the NURBS volume is rational procedure :: put_to_nurbs !!> Put a shape to a NURBS volume procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points ! Shapes procedure :: set_hexahedron !!> Set a hexahedron end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set1 ( this , knot1 , knot2 , knot3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot1 (:), knot2 (:), knot3 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = knot1 this % knot2 = knot2 this % knot3 = knot3 this % degree = this % get_degree () this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % nc ( 3 ) = this % get_nc ( 3 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set control points and weights for the NURBS volume object. pure subroutine set2 ( this , Xth_dir1 , Xth_dir2 , Xth_dir3 , degree , continuity1 , continuity2 , continuity3 , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir1 (:), Xth_dir2 (:), Xth_dir3 (:) integer , intent ( in ), contiguous :: degree (:) integer , intent ( in ), contiguous :: continuity1 (:), continuity2 (:), continuity3 (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) this % knot1 = compute_knot_vector ( Xth_dir1 , degree ( 1 ), continuity1 ) this % knot2 = compute_knot_vector ( Xth_dir2 , degree ( 2 ), continuity2 ) this % knot3 = compute_knot_vector ( Xth_dir3 , degree ( 3 ), continuity3 ) this % degree ( 1 ) = degree ( 1 ) this % degree ( 2 ) = degree ( 2 ) this % degree ( 3 ) = degree ( 3 ) this % nc ( 1 ) = this % get_nc ( 1 ) this % nc ( 2 ) = this % get_nc ( 2 ) this % nc ( 3 ) = this % get_nc ( 3 ) this % Xc = Xc if ( present ( Wc )) this % Wc = Wc end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier volume using control points and weights. pure subroutine set3 ( this , nc , Xc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = nc allocate ( this % knot1 ( 2 * this % nc ( 1 ))) this % knot1 ( 1 : this % nc ( 1 )) = 0.0_rk this % knot1 ( this % nc ( 1 ) + 1 : 2 * this % nc ( 1 )) = 1.0_rk allocate ( this % knot2 ( 2 * this % nc ( 2 ))) this % knot2 ( 1 : this % nc ( 2 )) = 0.0_rk this % knot2 ( this % nc ( 2 ) + 1 : 2 * this % nc ( 2 )) = 1.0_rk allocate ( this % knot3 ( 2 * this % nc ( 3 ))) this % knot3 ( 1 : this % nc ( 3 )) = 0.0_rk this % knot3 ( this % nc ( 3 ) + 1 : 2 * this % nc ( 3 )) = 1.0_rk this % degree = this % get_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 )) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Xt ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), intent ( in ), contiguous , optional :: Xt (:,:) integer :: i , j real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:), Tgc3 (:), Tgc (:) real ( rk ), allocatable :: Xt_ (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if if ( present ( Xt )) then Xt_ = Xt else ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt_ ) end if if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( size ( Xt_ , 1 ), size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt_ , 1 ) Tgc1 = basis_bspline ( Xt_ ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt_ ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt_ ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else do i = 1 , size ( Xt_ , 1 ) Tgc1 = basis_bspline ( Xt_ ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt_ ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt_ ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( nurbs_volume ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS volume is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this , dir ) result ( Xt ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: Xt (:) if ( dir == 1 ) then if ( allocated ( this % Xt1 )) then Xt = this % Xt1 else error stop 'Parameter values are not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % Xt2 )) then Xt = this % Xt2 else error stop 'Parameter values are not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % Xt3 )) then Xt = this % Xt3 else error stop 'Parameter values are not set.' end if else error stop 'Invalid direction for parameter values.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_volume ), intent ( in ) :: this integer :: ng ( 3 ) ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_all ( this ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer :: degree ( 3 ) integer , allocatable :: m1 (:), m2 (:), m3 (:) m1 = this % get_multiplicity ( 1 ) m2 = this % get_multiplicity ( 2 ) m3 = this % get_multiplicity ( 3 ) degree ( 1 ) = m1 ( 1 ) - 1 degree ( 2 ) = m2 ( 1 ) - 1 degree ( 3 ) = m3 ( 1 ) - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree_dir ( this , dir ) result ( degree ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: degree integer , allocatable :: m1 (:), m2 (:), m3 (:) if ( dir == 1 ) then m1 = this % get_multiplicity ( 1 ) degree = m1 ( 1 ) - 1 else if ( dir == 2 ) then m2 = this % get_multiplicity ( 2 ) degree = m2 ( 1 ) - 1 else if ( dir == 3 ) then m3 = this % get_multiplicity ( 3 ) degree = m3 ( 1 ) - 1 else error stop 'Invalid direction for degree.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this , dir ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir real ( rk ), allocatable :: knot (:) if ( dir == 1 ) then if ( allocated ( this % knot1 )) then knot = this % knot1 else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then knot = this % knot2 else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then knot = this % knot3 else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , dir , i ) result ( knot ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: i real ( rk ) :: knot if ( dir == 1 ) then if ( allocated ( this % knot1 )) then if ( i < 1 . or . i > size ( this % knot1 )) then error stop 'Invalid index for knot vector.' else knot = this % knot1 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 2 ) then if ( allocated ( this % knot2 )) then if ( i < 1 . or . i > size ( this % knot2 )) then error stop 'Invalid index for knot vector.' else knot = this % knot2 ( i ) end if else error stop 'Knot vector is not set.' end if elseif ( dir == 3 ) then if ( allocated ( this % knot3 )) then if ( i < 1 . or . i > size ( this % knot3 )) then error stop 'Invalid index for knot vector.' else knot = this % knot3 ( i ) end if else error stop 'Knot vector is not set.' end if else error stop 'Invalid direction for knot vector.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_volume ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) if ( allocated ( this % knot1 )) deallocate ( this % knot1 ) if ( allocated ( this % knot2 )) deallocate ( this % knot2 ) if ( allocated ( this % knot3 )) deallocate ( this % knot3 ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), contiguous , optional :: p (:) if ( present ( p )) then elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), p ( 1 ), p ( 2 ), p ( 3 )) else elemConn = elemConn_C0 ( this % ng ( 1 ), this % ng ( 2 ), this % ng ( 3 ), 1 , 1 , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension for control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_volume ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension for geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 8 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , elemConn ( i , 4 ) - 1 , elemConn ( i , 3 ) - 1 ,& elemConn ( i , 5 ) - 1 , elemConn ( i , 6 ) - 1 , elemConn ( i , 8 ) - 1 , elemConn ( i , 7 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 12 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = this % knot3 , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = this % knot3 , Xc = this % Xc , Wc = this % Wc ) else error stop 'The NURBS surface is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this , dir ) result ( m ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: m (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this , dir ) result ( c ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer , allocatable :: c (:) if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else c = this % degree ( 1 ) - compute_multiplicity ( this % knot1 ) end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else c = this % degree ( 2 ) - compute_multiplicity ( this % knot2 ) end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else c = this % degree ( 3 ) - compute_multiplicity ( this % knot3 ) end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this , dir ) result ( nc ) class ( nurbs_volume ), intent ( in ) :: this integer , intent ( in ) :: dir integer :: nc if ( dir == 1 ) then ! check if (. not . allocated ( this % knot1 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot1 )) - this % degree ( 1 ) - 1 end if elseif ( dir == 2 ) then ! check if (. not . allocated ( this % knot2 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot2 )) - this % degree ( 2 ) - 1 end if elseif ( dir == 3 ) then ! check if (. not . allocated ( this % knot3 )) then error stop 'Knot vector is not set.' else nc = sum ( compute_multiplicity ( this % knot3 )) - this % degree ( 3 ) - 1 end if else error stop 'Invalid direction.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , dTgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable :: dTgci (:) integer :: i real ( rk ), allocatable :: dTgc1 (:), dTgc2 (:), dTgc3 (:) real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) allocate ( dTgc ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) dTgc3 = basis_bspline_der ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) dTgci = kron ( dTgc3 , kron ( dTgc2 , dTgc1 )) dTgci = dTgci * ( this % Wc / ( dot_product ( dTgci , this % Wc ))) dTgc ( i ,:) = dTgci end do else do i = 1 , size ( Xt , 1 ) dTgc1 = basis_bspline_der ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) dTgc2 = basis_bspline_der ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) dTgc3 = basis_bspline_der ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) dTgci = kron ( dTgc3 , kron ( dTgc2 , dTgc1 )) dTgc ( i ,:) = dTgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis ( this , res1 , res2 , res3 , Xt1 , Xt2 , Xt3 , Tgc ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), optional :: res1 , res2 , res3 real ( rk ), intent ( in ), contiguous , optional :: Xt1 (:), Xt2 (:), Xt3 (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:), Tgc3 (:) real ( rk ), allocatable :: Xt (:,:) ! Set parameter values if ( present ( Xt1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) this % Xt1 = Xt1 elseif ( present ( res1 )) then if ( allocated ( this % Xt1 )) deallocate ( this % Xt1 ) allocate ( this % Xt1 ( res1 )) this % Xt1 = [( real ( i - 1 , rk ) / real ( res1 - 1 , rk ), i = 1 , res1 )] ! else ! this%Xt1 = this%Xt1 end if ! Set parameter values if ( present ( Xt2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) this % Xt2 = Xt2 elseif ( present ( res2 )) then if ( allocated ( this % Xt2 )) deallocate ( this % Xt2 ) allocate ( this % Xt2 ( res2 )) this % Xt2 = [( real ( i - 1 , rk ) / real ( res2 - 1 , rk ), i = 1 , res2 )] ! else ! this%Xt2 = this%Xt2 end if ! Set parameter values if ( present ( Xt3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) this % Xt3 = Xt3 elseif ( present ( res3 )) then if ( allocated ( this % Xt3 )) deallocate ( this % Xt3 ) allocate ( this % Xt3 ( res3 )) this % Xt3 = [( real ( i - 1 , rk ) / real ( res3 - 1 , rk ), i = 1 , res3 )] ! else ! this%Xt3 = this%Xt3 end if ! Set number of geometry points this % ng ( 1 ) = size ( this % Xt1 , 1 ) this % ng ( 2 ) = size ( this % Xt2 , 1 ) this % ng ( 3 ) = size ( this % Xt3 , 1 ) call ndgrid ( this % Xt1 , this % Xt2 , this % Xt3 , Xt ) allocate ( Tgc ( this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ), this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgci = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgci = Tgci * ( this % Wc / ( dot_product ( Tgci , this % Wc ))) Tgc ( i ,:) = Tgci end do else do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgci = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc ( i ,:) = Tgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , dir , Xth , r ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , n_new real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xcw_new = reshape ( Xcw_new ,[( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 :( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 :( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , ( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot1 , this % Wc ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , knot3 = this % knot3 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc_new = reshape ( Xc_new ,[( n_new + 1 ) * this % nc ( 2 ) * this % nc ( 3 ), dim ]) deallocate ( this % Xc , this % knot1 ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , knot3 = this % knot3 , Xc = Xc_new ) end do end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc4 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot2 , this % Wc ) call this % set ( knot1 = this % knot1 , knot2 = knot_new , knot3 = this % knot3 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc4 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), n_new + 1 , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( n_new + 1 ) * this % nc ( 3 ), dim ]) deallocate ( this % Xc , this % knot2 ) call this % set ( knot1 = this % knot1 , knot2 = knot_new , knot3 = this % knot3 , Xc = Xc_new ) end do end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 )]) call insert_knot_A_5_1 (& this % degree ( 3 ),& this % knot3 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) Xc4 = reshape ( Xcw_new , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ))) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot3 , this % Wc ) call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) call insert_knot_A_5_1 (& this % degree ( 3 ),& this % knot3 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) Xc4 = reshape ( Xc_new , [ n_new + 1 , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), n_new + 1 , dim ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( n_new + 1 ), dim ]) deallocate ( this % Xc , this % knot3 ) call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = knot_new , Xc = Xc_new ) end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , dir , t ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir integer , intent ( in ) :: t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) integer :: nc_new , dim , j real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 )], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xcw , nc_new , knot_new , Xcw_new ) Xcw_new = reshape ( Xcw_new ,[ nc_new * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 : nc_new * this % nc ( 2 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : nc_new * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , nc_new * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot1 , this % Wc ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , knot3 = this % knot3 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ], order = [ 1 , 2 ]) call elevate_degree_A_5_9 ( t , this % knot1 , this % degree ( 1 ), Xc , nc_new , knot_new , Xc_new ) Xc_new = reshape ( Xc_new ,[ nc_new * this % nc ( 2 ) * this % nc ( 3 ), dim ], order = [ 1 , 2 ]) deallocate ( this % Xc , this % knot1 ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , knot3 = this % knot3 , Xc = Xc_new ) end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 )]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xcw , nc_new , knot_new , Xcw_new ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * nc_new * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * nc_new * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * nc_new * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * nc_new * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot2 , this % Wc ) call this % set ( knot1 = this % knot1 , knot2 = knot_new , knot3 = this % knot3 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot2 , this % degree ( 2 ), Xc , nc_new , knot_new , Xc_new ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * nc_new * this % nc ( 3 ), dim ]) deallocate ( this % Xc , this % knot2 ) call this % set ( knot1 = this % knot1 , knot2 = knot_new , knot3 = this % knot3 , Xc = Xc_new ) end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 )]) call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xcw , nc_new , knot_new , Xcw_new ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * nc_new , dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * nc_new , 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * nc_new )) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * nc_new Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot3 , this % Wc ) call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 ,[ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) call elevate_degree_A_5_9 ( t , this % knot3 , this % degree ( 3 ), Xc , nc_new , knot_new , Xc_new ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 ,[ this % nc ( 1 ) * this % nc ( 2 ) * nc_new , dim ]) deallocate ( this % Xc , this % knot3 ) call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = knot_new , Xc = Xc_new ) end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_volume ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_hexahedron ( this , L , nc , Wc ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: L (:) integer , intent ( in ), contiguous :: nc (:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( present ( Wc )) then call this % set ( nc , hexahedron_Xc ( L , nc ), Wc ) else call this % set ( nc , hexahedron_Xc ( L , nc )) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine put_to_nurbs ( this , X , elemConn ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: X (:,:) integer , intent ( in ), contiguous :: elemConn (:,:) integer :: i , j real ( rk ), allocatable :: Tgc1 (:), Tgc2 (:), Tgc3 (:), Tgc (:) real ( rk ), allocatable :: Xt (:,:) real ( rk ) :: min_X1 , max_X1 , min_X2 , max_X2 , min_X3 , max_X3 ! Assuming knot vectors are in the range [0,1] ! Normalize the X coordinates to the range [0,1] allocate ( Xt ( size ( X , 1 ), size ( X , 2 ))) min_X1 = minval ( X (:, 1 )) max_X1 = maxval ( X (:, 1 )) min_X2 = minval ( X (:, 2 )) max_X2 = maxval ( X (:, 2 )) min_X3 = minval ( X (:, 3 )) max_X3 = maxval ( X (:, 3 )) Xt (:, 1 ) = ( X (:, 1 ) - min_X1 ) / ( max_X1 - min_X1 ) Xt (:, 2 ) = ( X (:, 2 ) - min_X2 ) / ( max_X2 - min_X2 ) Xt (:, 3 ) = ( X (:, 3 ) - min_X3 ) / ( max_X3 - min_X3 ) allocate ( this % Xg ( size ( Xt , 1 ), size ( this % Xc , 2 ))) if ( allocated ( this % Wc )) then ! NURBS volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else ! B-Spline volume do i = 1 , size ( Xt , 1 ) Tgc1 = basis_bspline ( Xt ( i , 1 ), this % knot1 , this % nc ( 1 ), this % degree ( 1 )) Tgc2 = basis_bspline ( Xt ( i , 2 ), this % knot2 , this % nc ( 2 ), this % degree ( 2 )) Tgc3 = basis_bspline ( Xt ( i , 3 ), this % knot3 , this % nc ( 3 ), this % degree ( 3 )) Tgc = kron ( Tgc3 , kron ( Tgc2 , Tgc1 )) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if call this % set_elem_Xg_vis ( elemConn ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , dir , Xth , r ) class ( nurbs_volume ), intent ( inout ) :: this integer , intent ( in ) :: dir real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , nc_new , t real ( rk ), allocatable :: Xc (:,:), Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) real ( rk ), allocatable :: Xc4 (:,:,:,:) if ( dir == 1 ) then ! direction 1 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xcw = reshape ( Xcw ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * ( dim + 1 )], order = [ 1 , 2 ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xcw_new = reshape ( Xcw_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), dim + 1 ], order = [ 1 , 2 ]) allocate ( Xc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 :( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ))) do j = 1 , ( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot1 , this % Wc ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , knot3 = this % knot3 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 1 ) - 1 , this % degree ( 1 ), Xth ( i ), this % knot1 ) if ( this % knot1 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot1 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc = reshape ( this % Xc ,[ this % nc ( 1 ), this % nc ( 2 ) * this % nc ( 3 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 1 ),& this % knot1 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc_new = reshape ( Xc_new ,[( nc_new ) * this % nc ( 2 ) * this % nc ( 3 ), dim ]) deallocate ( this % Xc , this % knot1 ) call this % set ( knot1 = knot_new , knot2 = this % knot2 , knot3 = this % knot3 , Xc = Xc_new ) end if end do end if elseif ( dir == 2 ) then ! direction 2 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw = reshape ( Xc4 ,[ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * ( dim + 1 )]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim + 1 ], order = [ 2 , 1 , 3 , 4 ]) Xcw_new = reshape ( Xc4 ,[ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ))) do j = 1 , this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot2 , this % Wc ) call this % set ( knot1 = this % knot1 , knot2 = knot_new , knot3 = this % knot3 , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 2 ) - 1 , this % degree ( 2 ), Xth ( i ), this % knot2 ) if ( this % knot2 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot2 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ), this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 2 ), this % nc ( 1 ) * this % nc ( 3 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 2 ),& this % knot2 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 1 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), nc_new , this % nc ( 3 ), dim ], order = [ 2 , 1 , 3 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * ( nc_new ) * this % nc ( 3 ), dim ]) deallocate ( this % Xc , this % knot2 ) call this % set ( knot1 = this % knot1 , knot2 = knot_new , knot3 = this % knot3 , Xc = Xc_new ) end if end do end if elseif ( dir == 3 ) then ! direction 3 if ( allocated ( this % Wc )) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) Xc4 = reshape ( Xcw , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * ( dim + 1 )]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xcw_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim + 1 ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim + 1 ], order = [ 3 , 2 , 1 , 4 ]) Xcw_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), dim + 1 ]) allocate ( Xc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), 1 : dim )) allocate ( Wc_new ( 1 : this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ))) do j = 1 , this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ) Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot3 , this % Wc ) call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw_new , Xc_new , Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc ( 3 ) - 1 , this % degree ( 3 ), Xth ( i ), this % knot3 ) if ( this % knot3 ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot3 , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) Xc4 = reshape ( this % Xc , [ this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ), this % nc ( 1 ), dim ], order = [ 3 , 2 , 1 , 4 ]) Xc = reshape ( Xc4 , [ this % nc ( 3 ), this % nc ( 2 ) * this % nc ( 1 ) * dim ]) call remove_knots_A_5_8 (& this % degree ( 3 ),& this % knot3 ,& Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( allocated ( Xc )) deallocate ( Xc ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) Xc4 = reshape ( Xc_new , [ nc_new , this % nc ( 2 ), this % nc ( 1 ), dim ]) Xc4 = reshape ( Xc4 , [ this % nc ( 1 ), this % nc ( 2 ), nc_new , dim ], order = [ 3 , 2 , 1 , 4 ]) Xc_new = reshape ( Xc4 , [ this % nc ( 1 ) * this % nc ( 2 ) * ( nc_new ), dim ]) deallocate ( this % Xc , this % knot3 ) call this % set ( knot1 = this % knot1 , knot2 = this % knot2 , knot3 = knot_new , Xc = Xc_new ) end if end do end if else error stop 'Invalid direction.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_volume ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc ( 1 ), this % nc ( 2 ), this % nc ( 3 ),& this % degree ( 1 ), this % degree ( 2 ), this % degree ( 3 ),& unique ( this % knot1 ), unique ( this % knot2 ), unique ( this % knot3 ),& this % get_multiplicity ( 1 ), this % get_multiplicity ( 2 ), this % get_multiplicity ( 3 ),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc ( 1 ) * this % nc ( 2 ) * this % nc ( 3 ) this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_volume ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % ng ( 1 ) * this % ng ( 2 ) * this % ng ( 3 ) this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== end module forcad_nurbs_volume","tags":"","loc":"sourcefile/forcad_nurbs_volume.f90.html"},{"title":"forcad_utils.f90 – ForCAD","text":"Files dependent on this one sourcefile~~forcad_utils.f90~~AfferentGraph sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad_utils.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module contains parameters, functions and subroutines that are used in the library. module forcad_utils implicit none private public :: rk , basis_bernstein , basis_bspline , elemConn_C0 , kron , ndgrid , compute_multiplicity , compute_knot_vector , & basis_bspline_der , insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , hexahedron_Xc , tetragon_Xc , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation integer , parameter :: rk = kind ( 1.0d0 ) !=============================================================================== interface elemConn_C0 module procedure cmp_elemConn_C0_L module procedure cmp_elemConn_C0_S module procedure cmp_elemConn_C0_V end interface !=============================================================================== !=============================================================================== interface elemConn_Cn module procedure cmp_elemConn_Cn_L module procedure cmp_elemConn_Cn_S module procedure cmp_elemConn_Cn_V end interface !=============================================================================== !=============================================================================== interface ndgrid module procedure ndgrid2 module procedure ndgrid3 end interface !=============================================================================== !=============================================================================== interface compute_multiplicity module procedure compute_multiplicity1 module procedure compute_multiplicity2 end interface !=============================================================================== !=============================================================================== interface unique module procedure unique_integer module procedure unique_real end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bspline ( Xt , knot , nc , degree ) result ( B ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ) :: temp , Xth_i , Xth_i1 , Xth_ip , Xth_ip1 real ( rk ), allocatable :: Nt (:,:) integer :: i , p real ( rk ), allocatable :: B (:) temp = abs ( Xt - knot ( size ( knot ))) allocate ( Nt ( nc , 0 : degree ), source = 0.0_rk ) do p = 0 , degree do i = 1 , nc Xth_i = knot ( i ) Xth_i1 = knot ( i + 1 ) Xth_ip = knot ( i + p ) Xth_ip1 = knot ( i + p + 1 ) if ( temp /= tiny ( 0.0_rk ) . and . Xt >= Xth_i . and . Xt <= Xth_i1 ) Nt ( i , 0 ) = 1.0_rk if ( Xth_ip /= Xth_i ) Nt ( i , p ) = ( Xt - Xth_i ) / ( Xth_ip - Xth_i ) * Nt ( i , p - 1 ) if ( Xth_ip1 /= Xth_i1 ) Nt ( i , p ) = Nt ( i , p ) + ( Xth_ip1 - Xt ) / ( Xth_ip1 - Xth_i1 ) * Nt ( i + 1 , p - 1 ) end do end do B = Nt (:, degree ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bspline_der ( Xt , knot , nc , degree ) result ( dB ) integer , intent ( in ) :: degree real ( rk ), intent ( in ), contiguous :: knot (:) integer , intent ( in ) :: nc real ( rk ), intent ( in ) :: Xt real ( rk ), allocatable :: dB (:) real ( rk ), allocatable :: Nt (:,:), dNt_dXt (:,:) real ( rk ) :: R , L , Rp , Lp , knot_i , knot_ip , knot_jk , knot_jkm , knot_end , a , b , c , d integer :: i , k , n , m , jk k = degree + 1 n = nc - 1 allocate ( Nt ( nc + degree , degree + 1 )) Nt = 0.0_rk do i = 1 , n + k knot_i = knot ( i ) knot_ip = knot ( i + 1 ) knot_end = knot ( size ( knot )) if ( abs ( Xt - knot_end ) > tiny ( 0.0_rk ) ) then if ( Xt >= knot_i . and . Xt < knot_ip ) Nt ( i , 1 ) = 1.0_rk elseif ( abs ( Xt - knot_end ) < tiny ( 0.0_rk ) ) then if ( Xt >= knot_i . and . Xt <= knot_ip ) Nt ( i , 1 ) = 1.0_rk end if end do allocate ( dNt_dXt ( nc + degree , degree + 1 )) dNt_dXt = 0.0_rk m = 0 do jk = 2 , k m = m + 1 do i = 1 , n + k - m knot_i = knot ( i ) knot_ip = knot ( i + 1 ) knot_jk = knot ( i + jk ) knot_jkm = knot ( i + jk - 1 ) a = ( knot_jkm - knot_i ) b = ( knot_jk - Xt ) c = ( knot_jk - knot_ip ) d = ( Xt - knot_i ) R = d / a if ( isnan ( R ) . or . isinf ( R ) . or . abs ( R ) < tiny ( 0.0_rk ) ) R = 0.0_rk L = b / c if ( isnan ( L ) . or . isinf ( L ) . or . abs ( L ) < tiny ( 0.0_rk ) ) L = 0.0_rk Nt ( i , jk ) = R * Nt ( i , jk - 1 ) + L * Nt ( i + 1 , jk - 1 ) Rp = ( Nt ( i , jk - 1 ) + d * dNt_dXt ( i , jk - 1 )) / a if ( isnan ( Rp ) . or . isinf ( Rp ) . or . abs ( Rp ) < tiny ( 0.0_rk ) ) Rp = 0.0_rk Lp = ( b * dNt_dXt ( i + 1 , jk - 1 ) - Nt ( i + 1 , jk - 1 )) / c if ( isnan ( Lp ) . or . isinf ( Lp ) . or . abs ( Lp ) < tiny ( 0.0_rk ) ) Lp = 0.0_rk dNt_dXt ( i , jk ) = Rp + Lp end do end do dB = dNt_dXt ( 1 : nc , k ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function basis_bernstein ( Xt , nc ) result ( B ) real ( rk ), intent ( in ) :: Xt integer , intent ( in ) :: nc real ( rk ), allocatable :: B (:) integer :: p , degree degree = nc - 1 allocate ( B ( nc ), source = 0.0_rk ) do concurrent ( p = 0 : degree ) B ( p + 1 ) = gamma ( real ( nc , kind = rk )) / ( gamma ( real ( p + 1 , kind = rk )) * gamma ( real ( nc - p , kind = rk ))) if ( Xt == 0.0_rk . and . p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( 1.0_rk - Xt ) ** ( degree - p ) else if ( Xt == 0.0_rk . and . degree - p == 0 ) then B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) else B ( p + 1 ) = B ( p + 1 ) * ( Xt ** p ) * ( 1.0_rk - Xt ) ** ( degree - p ) end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function kron ( u , v ) result ( w ) real ( rk ), intent ( in ), contiguous :: u (:), v (:) real ( rk ) :: w ( size ( u ) * size ( v )) integer :: i , j , m , n m = size ( u ) n = size ( v ) do i = 1 , m do j = 1 , n w (( i - 1 ) * n + j ) = u ( i ) * v ( j ) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid2 ( X_dir1 , X_dir2 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , i , j , n s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) allocate ( Xt ( s1 * s2 , 2 )) n = 0 do j = 1 , s2 do i = 1 , s1 n = n + 1 Xt ( n , 1 ) = X_dir1 ( i ) Xt ( n , 2 ) = X_dir2 ( j ) end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine ndgrid3 ( X_dir1 , X_dir2 , X_dir3 , Xt ) real ( rk ), intent ( in ), contiguous :: X_dir1 (:), X_dir2 (:), X_dir3 (:) real ( rk ), allocatable , intent ( out ) :: Xt (:,:) integer :: s1 , s2 , s3 , i , j , k , n s1 = size ( X_dir1 ) s2 = size ( X_dir2 ) s3 = size ( X_dir3 ) allocate ( Xt ( s1 * s2 * s3 , 3 )) n = 0 do k = 1 , s3 do j = 1 , s2 do i = 1 , s1 n = n + 1 Xt ( n , 1 ) = X_dir1 ( i ) Xt ( n , 2 ) = X_dir2 ( j ) Xt ( n , 3 ) = X_dir3 ( k ) end do end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function repelem ( a , b ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:) integer , intent ( in ), contiguous :: b (:) real ( rk ) :: c ( sum ( b )) integer :: i , l , n l = 0 do i = 1 , size ( a ) n = b ( i ) c ( l + 1 : l + n ) = a ( i ) l = l + n end do end function repelem !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_L ( nnode , p ) result ( elemConn ) integer , intent ( in ) :: nnode integer , intent ( in ) :: p integer , allocatable :: elemConn (:,:) integer :: i , l integer , allocatable :: nodes (:) allocate ( elemConn ( (( nnode - p ) / p ) , 2 )) nodes = [( i , i = 1 , nnode )] l = 0 do i = 1 , nnode - p , p l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p ),[( p + 1 )]) end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_S ( nnode1 , nnode2 , p1 , p2 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 integer , intent ( in ) :: p1 , p2 integer , allocatable :: elemConn (:,:) integer :: i , j , l integer , allocatable :: nodes (:,:) allocate ( elemConn ( (( nnode1 - p1 ) / p1 ) * (( nnode2 - p2 ) / p2 ) , 4 )) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 )], [ nnode1 , nnode2 ]) l = 0 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 ),[( p1 + 1 ) * ( p2 + 1 )]) end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elemConn_C0_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ) result ( elemConn ) integer , intent ( in ) :: nnode1 , nnode2 , nnode3 integer , intent ( in ) :: p1 , p2 , p3 integer , allocatable :: elemConn (:,:) integer :: i , j , k , l integer , allocatable :: nodes (:,:,:) allocate ( elemConn ( (( nnode1 - p1 ) / p1 ) * (( nnode2 - p2 ) / p2 ) * (( nnode3 - p3 ) / p3 ) , 8 )) nodes = reshape ([( i , i = 1 , nnode1 * nnode2 * nnode3 )], [ nnode1 , nnode2 , nnode3 ]) l = 0 do k = 1 , nnode3 - p3 , p3 do j = 1 , nnode2 - p2 , p2 do i = 1 , nnode1 - p1 , p1 l = l + 1 elemConn ( l ,:) = reshape ( nodes ( i : i + p1 , j : j + p2 , k : k + p3 ),[( p1 + 1 ) * ( p2 + 1 ) * ( p3 + 1 )]) end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_L ( nnode , p , Xth , vecKnot_mul , elemConn ) integer , intent ( in ) :: p , nnode integer , intent ( in ), contiguous :: vecKnot_mul (:) real ( rk ), intent ( in ), contiguous :: Xth (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:) integer :: i , l , nnel , m , nelem nnel = p + 1 nodes = [( i , i = 1 , nnode )] nelem = size ( Xth ) - 1 allocate ( elemConn ( nelem , nnel )) l = 0 m = - p do i = 1 , nelem m = m + vecKnot_mul ( i ) l = l + 1 elemConn ( l ,:) = nodes ( m : m + p ) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_S ( nnode1 , nnode2 , p1 , p2 ,& Xth1 , Xth2 , vecKnot_mul1 , vecKnot_mul2 , elemConn ) integer , intent ( in ) :: p1 , p2 , nnode1 , nnode2 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:), nodes_vec (:) integer :: nnd_total , i , j , k , l , nnel1 , nnel2 , m , n , o , nelem1 , nelem2 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnd_total = nnode1 * nnode2 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem = nelem1 * nelem2 allocate ( elemConn ( nelem , nnel1 * nnel2 )) l = 0 n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 ), [ nnel1 * nnel2 ]) end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine cmp_elemConn_Cn_V ( nnode1 , nnode2 , nnode3 , p1 , p2 , p3 ,& Xth1 , Xth2 , Xth3 , vecKnot_mul1 , vecKnot_mul2 , vecKnot_mul3 , elemConn ) integer , intent ( in ) :: p1 , p2 , p3 , nnode1 , nnode2 , nnode3 integer , intent ( in ), contiguous :: vecKnot_mul1 (:), vecKnot_mul2 (:), vecKnot_mul3 (:) real ( rk ), intent ( in ), contiguous :: Xth1 (:), Xth2 (:), Xth3 (:) integer , allocatable , intent ( out ) :: elemConn (:,:) integer , allocatable :: nodes (:,:,:), nodes_vec (:) integer :: nnd_total , i , j , k , l , nnel1 , nnel2 , nnel3 , m , n , o , nelem1 , nelem2 , nelem3 , nelem nnel1 = p1 + 1 nnel2 = p2 + 1 nnel3 = p3 + 1 nnd_total = nnode1 * nnode2 * nnode3 allocate ( nodes_vec ( nnd_total )) Nodes_vec = [( i , i = 1 , nnd_total )] nodes = reshape ( nodes_vec ,[ nnode1 , nnode2 , nnode3 ]) nelem1 = size ( Xth1 ) - 1 nelem2 = size ( Xth2 ) - 1 nelem3 = size ( Xth3 ) - 1 nelem = nelem1 * nelem2 * nelem3 allocate ( elemConn ( nelem , nnel1 * nnel2 * nnel3 )) l = 0 o = - p3 do k = 1 , nelem3 o = o + vecKnot_mul3 ( k ) n = - p2 do j = 1 , nelem2 n = n + vecKnot_mul2 ( j ) m = - p1 do i = 1 , nelem1 m = m + vecKnot_mul1 ( i ) l = l + 1 elemConn ( l ,:) = reshape ( nodes ( m : m + p1 , n : n + p2 , o : o + p3 ), [ nnel1 * nnel2 * nnel3 ]) end do end do end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity1 ( knot ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) integer , allocatable :: multiplicity (:) integer :: i , count count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) count = count + 1 end do allocate ( multiplicity ( count )) multiplicity ( 1 ) = 1 count = 1 do i = 2 , size ( knot ) if ( knot ( i ) /= knot ( i - 1 )) then count = count + 1 multiplicity ( count ) = 1 else multiplicity ( count ) = multiplicity ( count ) + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_multiplicity2 ( knot , Xth ) result ( multiplicity ) real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ) :: Xth integer :: multiplicity integer :: i , count , size_knot size_knot = size ( knot ) multiplicity = 0 i = 1 do while ( i <= size_knot ) if ( knot ( i ) == Xth ) then count = 1 do while ( i + count <= size_knot . and . knot ( i + count ) == Xth ) count = count + 1 end do if ( count > multiplicity ) then multiplicity = count end if i = i + count else i = i + 1 end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function compute_knot_vector ( Xth_dir , degree , continuity ) result ( knot ) real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), allocatable :: knot (:) knot = repelem ( Xth_dir , ( degree - continuity )) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause elemental pure function isinf ( x ) result ( output ) real ( rk ), intent ( in ) :: x logical :: output output = . false . if ( x > huge ( x )) output = . true . if ( x < - huge ( x )) output = . true . end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause elemental pure function isnan ( x ) result ( output ) real ( rk ), intent ( in ) :: x logical :: output output = . false . if ( x /= x ) output = . true . end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knot_A_5_1 ( p , UP , Pw , u , k , s , r , nq , UQ , Qw ) integer , intent ( in ) :: p , k , s , r real ( rk ), intent ( in ), contiguous :: UP ( 0 :), Pw ( 0 :,:) real ( rk ), intent ( in ) :: u real ( rk ), allocatable , intent ( out ) :: UQ (:), Qw (:,:) integer , intent ( out ) :: nq integer :: i , j , L , mp , dim , np real ( rk ), allocatable :: Rw (:,:) real ( rk ) :: alpha dim = size ( Pw , 2 ) np = size ( Pw , 1 ) - 1 mp = np + p + 1 nq = np + r allocate ( UQ ( 0 : mp + r )) allocate ( Qw ( 0 : nq , 1 : dim )) allocate ( Rw ( 0 : p , 1 : dim )) UQ ( 0 : k ) = UP ( 0 : k ) UQ ( k + 1 : k + r ) = u UQ ( k + 1 + r : mp + r ) = UP ( k + 1 : mp ) Qw ( 0 : k - p ,:) = Pw ( 0 : k - p ,:) Qw ( k - s + r : np + r ,:) = Pw ( k - s : np ,:) Rw ( 0 : p - s ,:) = Pw ( k - p : k - s ,:) do j = 1 , r L = k - p + j do i = 0 , p - j - s alpha = ( u - UP ( L + i )) / ( UP ( i + k + 1 ) - UP ( L + i )) Rw ( i ,:) = alpha * Rw ( i + 1 ,:) + ( 1.0_rk - alpha ) * Rw ( i ,:) end do Qw ( L ,:) = Rw ( 0 ,:) Qw ( k + r - j - s ,:) = Rw ( p - j - s ,:) end do Qw ( L + 1 : k - s - 1 ,:) = Rw ( 1 : k - s - 1 - L ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function findspan ( n , degree , Xth , knot ) result ( s ) integer , intent ( in ) :: n , degree real ( rk ), intent ( in ) :: Xth real ( rk ), intent ( in ), contiguous :: knot (:) integer :: s integer :: low , high , mid if ( Xth == knot ( n + 2 )) then s = n return end if low = degree high = n + 1 mid = ( low + high ) / 2 do while ( Xth < knot ( mid + 1 ) . or . Xth >= knot ( mid + 2 )) if ( Xth < knot ( mid + 1 )) then high = mid else low = mid end if mid = ( low + high ) / 2 end do s = mid end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree_A_5_9 ( t , knot , degree , Xcw , nc_new , knot_new , Xcw_new ) integer , intent ( in ) :: t real ( rk ), intent ( in ), contiguous :: Xcw (:,:), knot (:) integer , intent ( in ) :: degree integer , intent ( out ) :: nc_new real ( rk ), allocatable , intent ( out ) :: Xcw_new (:,:), knot_new (:) real ( rk ), allocatable :: bezalfs (:,:), bpts (:,:), ebpts (:,:), Nextbpts (:,:), alfs (:) real ( rk ) :: inv , alpha1 , alpha2 , Xth1 , Xth2 , numer , den integer :: n , lbz , rbz , sv , tr , kj , first , knoti , last , alpha3 , dim , nc integer :: i , j , q , s , m , ph , ph2 , mpi , mh , r , a , b , Xcwi , oldr , mul integer , allocatable :: mlp (:) nc = size ( Xcw , 1 ) dim = size ( Xcw , 2 ) mlp = compute_multiplicity ( knot ) mlp = mlp + t nc_new = sum ( mlp ) - ( mlp ( 1 ) - 1 ) - 1 allocate ( Xcw_new ( nc_new , dim ), source = 0.0_rk ) allocate ( bezalfs ( degree + 1 , degree + t + 1 ), source = 0.0_rk ) allocate ( bpts ( degree + 1 , dim ), source = 0.0_rk ) allocate ( ebpts ( degree + t + 1 , dim ), source = 0.0_rk ) allocate ( Nextbpts ( degree + 1 , dim ), source = 0.0_rk ) allocate ( alfs ( degree ), source = 0.0_rk ) n = nc - 1 m = n + degree + 1 ph = degree + t ph2 = ph / 2 bezalfs ( 1 , 1 ) = 1.0_rk bezalfs ( degree + 1 , ph + 1 ) = 1.0_rk do i = 1 , ph2 inv = 1.0_rk / bincoeff ( ph , i ) mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = inv * bincoeff ( degree , j ) * bincoeff ( t , i - j ) end do end do do i = ph2 + 1 , ph - 1 mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi bezalfs ( j + 1 , i + 1 ) = bezalfs ( degree - j + 1 , ph - i + 1 ) end do end do mh = ph knoti = ph + 1 r = - 1 a = degree b = degree + 1 Xcwi = 1 Xth1 = knot ( 1 ) Xcw_new ( 1 ,:) = Xcw ( 1 ,:) allocate ( knot_new ( sum ( mlp )), source = 0.0_rk ) knot_new ( 1 : ph + 1 ) = Xth1 do i = 0 , degree bpts ( i + 1 ,:) = Xcw ( i + 1 ,:) end do do while ( b < m ) i = b do while ( b < m . and . knot ( b + 1 ) == knot ( b + 2 )) b = b + 1 if ( b + 2 > size ( knot )) then exit end if end do mul = b - i + 1 mh = mh + mul + t Xth2 = knot ( b + 1 ) oldr = r r = degree - mul if ( oldr > 0 ) then lbz = ( oldr + 2 ) / 2 else lbz = 1 end if if ( r > 0 ) then rbz = ph - ( r + 1 ) / 2 else rbz = ph end if if ( r > 0 ) then numer = Xth2 - Xth1 do q = degree , mul + 1 , - 1 alfs ( q - mul ) = numer / ( knot ( a + q + 1 ) - Xth1 ) end do do j = 1 , r sv = r - j s = mul + j do q = degree , s , - 1 bpts ( q + 1 ,:) = ( 1.0_rk - alfs ( q - s + 1 )) * bpts ( q ,:) + alfs ( q - s + 1 ) * bpts ( q + 1 ,:) end do Nextbpts ( sv + 1 ,:) = bpts ( degree + 1 ,:) end do end if do i = lbz , ph ebpts ( i + 1 ,:) = 0.0_rk mpi = min ( degree , i ) do j = max ( 0 , i - t ), mpi ebpts ( i + 1 ,:) = bezalfs ( j + 1 , i + 1 ) * bpts ( j + 1 ,:) + ebpts ( i + 1 ,:) end do end do if ( oldr > 1 ) then first = knoti - 2 last = knoti den = Xth2 - Xth1 alpha3 = floor (( Xth2 - knot ( knoti )) / den ) do tr = 1 , oldr - 1 i = first j = last kj = j - knoti + 1 do while ( j - i > tr ) if ( i < Xcwi ) then alpha1 = ( Xth2 - knot ( i + 1 )) / ( Xth1 - knot ( i + 1 )) Xcw_new ( i + 1 ,:) = ( 1 - alpha1 ) * Xcw_new ( i ,:) + alpha1 * Xcw_new ( i + 1 ,:) end if if ( j >= lbz ) then if ( j - tr <= knoti - ph + oldr ) then alpha2 = ( Xth2 - knot_new ( j - tr + 1 )) / den ebpts ( kj + 1 ,:) = alpha2 * ebpts ( kj + 1 ,:) + ( 1 - alpha2 ) * ebpts ( kj + 2 ,:) else ebpts ( kj + 1 ,:) = ( 1 - alpha3 ) * ebpts (:, kj + 2 ) + alpha3 * ebpts ( kj + 1 ,:) end if end if i = i + 1 j = j - 1 kj = kj - 1 end do first = first - 1 last = last + 1 end do end if if ( a /= degree ) then do i = 0 , ph - oldr - 1 knot_new ( knoti + 1 ) = Xth1 knoti = knoti + 1 end do end if do j = lbz , rbz Xcw_new ( Xcwi + 1 ,:) = ebpts ( j + 1 ,:) Xcwi = Xcwi + 1 end do if ( b < m ) then do j = 0 , r - 1 bpts ( j + 1 ,:) = Nextbpts ( j + 1 ,:) end do do j = r , degree bpts ( j + 1 ,:) = Xcw ( b - degree + j + 1 ,:) end do a = b b = b + 1 Xth1 = Xth2 else do i = 0 , ph knot_new ( knoti + i + 1 ) = Xth2 end do end if end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function bincoeff ( n , k ) result ( b ) integer , intent ( in ) :: n , k real ( rk ) :: b b = floor ( 0.5_rk + exp ( factln ( n ) - factln ( k ) - factln ( n - k ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function factln ( n ) result ( f ) integer , intent ( in ) :: n real ( rk ) :: f if ( n <= 1 ) then f = 0.0_rk return end if f = log ( gamma ( real ( n + 1 , rk ))) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function hexahedron_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 3 ) integer , intent ( in ) :: nc ( 3 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy , dz integer :: i , j , k , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) dz = L ( 3 ) / real ( nc ( 3 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ) * nc ( 3 ), 3 )) nci = 1 do k = 0 , nc ( 3 ) - 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = real ( k , rk ) * dz nci = nci + 1 end do end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function tetragon_Xc ( L , nc ) result ( Xc ) real ( rk ), intent ( in ) :: L ( 2 ) integer , intent ( in ) :: nc ( 2 ) real ( rk ), allocatable :: Xc (:,:) real ( rk ) :: dx , dy integer :: i , j , nci dx = L ( 1 ) / real ( nc ( 1 ) - 1 , rk ) dy = L ( 2 ) / real ( nc ( 2 ) - 1 , rk ) allocate ( Xc ( nc ( 1 ) * nc ( 2 ), 3 )) nci = 1 do j = 0 , nc ( 2 ) - 1 do i = 0 , nc ( 1 ) - 1 Xc ( nci , 1 ) = real ( i , rk ) * dx Xc ( nci , 2 ) = real ( j , rk ) * dy Xc ( nci , 3 ) = 0.0_rk nci = nci + 1 end do end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots_A_5_8 ( p , knot , Pw , u , r , s , num , t , knot_new , Pw_new ) real ( rk ), intent ( in ) :: u integer , intent ( in ) :: p , r , s , num real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Pw (:,:) real ( rk ), allocatable , intent ( out ) :: knot_new (:) real ( rk ), allocatable , intent ( out ) :: Pw_new (:,:) real ( rk ), allocatable :: Pw_copy (:,:), knot_copy (:) integer , intent ( out ) :: t real ( rk ) :: tol , alfi , alfj real ( rk ), allocatable :: temp (:,:) integer :: i , j , ii , jj , remflag , off , first , last , ord , fout , m , k , n , nc , dim , tt dim = size ( Pw , 2 ) nc = size ( Pw , 1 ) n = nc m = n + p + 1 ord = p + 1 fout = ( 2 * r - s - p ) / 2 last = r - s first = r - p Pw_copy = Pw knot_copy = knot ! TODO: tol = 1.0e-6_rk * minval ( Pw (:, dim )) / ( 1.0_rk + maxval ( sqrt ( sum ( Pw ** 2 , 2 )))) allocate ( temp ( 2 * p + 1 , dim ), source = 0.0_rk ) t = 0 do tt = 0 , num - 1 off = first - 1 temp ( 1 ,:) = Pw_copy ( off ,:) temp ( last + 1 - off + 1 ,:) = Pw_copy ( last + 1 ,:) i = first j = last ii = 1 jj = last - off remflag = 0 do while ( j - i > t ) alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) alfj = ( u - knot_copy ( j - t )) / ( knot_copy ( j + ord ) - knot_copy ( j - t )) temp ( ii + 1 ,:) = ( Pw_copy ( i ,:) - ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:)) / alfi temp ( jj + 1 ,:) = ( Pw_copy ( j ,:) - alfj * temp ( jj + 1 + 1 ,:)) / ( 1.0_rk - alfj ) i = i + 1 ii = ii + 1 j = j - 1 jj = jj - 1 end do if ( j - i <= t ) then if ( norm2 ( temp ( ii - 1 + 1 ,:) - temp ( jj + 1 + 1 ,:)) <= tol ) then remflag = 1 else alfi = ( u - knot_copy ( i )) / ( knot_copy ( i + ord + t ) - knot_copy ( i )) if ( norm2 ( Pw_copy ( i ,:) - ( alfi * temp ( ii + t + 1 + 1 ,:) + ( 1.0_rk - alfi ) * temp ( ii - 1 + 1 ,:))) <= tol ) then remflag = 1 end if end if end if if ( remflag == 0 ) then exit else i = first j = last do while ( j - i > t ) Pw_copy ( i ,:) = temp ( i - off + 1 ,:) Pw_copy ( j ,:) = temp ( j - off + 1 ,:) i = i + 1 j = j - 1 end do end if first = first - 1 last = last + 1 t = t + 1 end do if ( t == 0 ) then return end if do k = r + 1 , m knot_copy ( k - t ) = knot_copy ( k ) end do j = fout i = j do k = 1 , t - 1 if ( mod ( k , 2 ) == 1 ) then i = i + 1 else j = j - 1 end if end do do k = i + 1 , n Pw_copy ( j ,:) = Pw_copy ( k ,:) j = j + 1 end do knot_new = knot_copy ( 1 : size ( knot_copy ) - t ) Pw_new = Pw_copy ( 1 : size ( Pw_copy , 1 ) - t ,:) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_integer ( vec ) result ( unique ) integer , dimension (:), intent ( in ), contiguous :: vec integer , dimension (:), allocatable :: unique integer :: i , j , k allocate ( unique ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( unique ) if ( vec ( i ) == unique ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then unique = [ unique , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function unique_real ( vec ) result ( unique ) real ( rk ), dimension (:), intent ( in ), contiguous :: vec real ( rk ), dimension (:), allocatable :: unique integer :: i , j , k allocate ( unique ( 0 )) do i = 1 , size ( vec ) k = 0 do j = 1 , size ( unique ) if ( vec ( i ) == unique ( j )) then k = k + 1 exit end if end do if ( k == 0 ) then unique = [ unique , vec ( i )] end if end do end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function rotation ( alpha , beta , theta ) result ( R ) real ( rk ), intent ( in ) :: alpha , beta , theta real ( rk ), dimension ( 3 , 3 ) :: R R ( 1 , 1 ) = cosd ( beta ) * cosd ( theta ) R ( 2 , 1 ) = cosd ( beta ) * sind ( theta ) R ( 3 , 1 ) = - sind ( beta ) R ( 1 , 2 ) = sind ( alpha ) * sind ( beta ) * cosd ( theta ) - cosd ( alpha ) * sind ( theta ) R ( 2 , 2 ) = sind ( alpha ) * sind ( beta ) * sind ( theta ) + cosd ( alpha ) * cosd ( theta ) R ( 3 , 2 ) = sind ( alpha ) * cosd ( beta ) R ( 1 , 3 ) = cosd ( alpha ) * sind ( beta ) * cosd ( theta ) + sind ( alpha ) * sind ( theta ) R ( 2 , 3 ) = cosd ( alpha ) * sind ( beta ) * sind ( theta ) - sind ( alpha ) * cosd ( theta ) R ( 3 , 3 ) = cosd ( alpha ) * cosd ( beta ) end function !=============================================================================== end module forcad_utils","tags":"","loc":"sourcefile/forcad_utils.f90.html"},{"title":"forcad_nurbs_curve.f90 – ForCAD","text":"This file depends on sourcefile~~forcad_nurbs_curve.f90~~EfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forcad_nurbs_curve.f90~~AfferentGraph sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~demo_curve.f90 demo_curve.f90 sourcefile~demo_curve.f90->sourcefile~forcad.f90 sourcefile~demo_surface.f90 demo_surface.f90 sourcefile~demo_surface.f90->sourcefile~forcad.f90 sourcefile~demo_volume.f90 demo_volume.f90 sourcefile~demo_volume.f90->sourcefile~forcad.f90 sourcefile~example_curve_1.f90 example_curve_1.f90 sourcefile~example_curve_1.f90->sourcefile~forcad.f90 sourcefile~example_surface_1.f90 example_surface_1.f90 sourcefile~example_surface_1.f90->sourcefile~forcad.f90 sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~put_to_nurbs.f90 put_to_nurbs.f90 sourcefile~put_to_nurbs.f90->sourcefile~forcad.f90 sourcefile~shape_circle.f90 shape_circle.f90 sourcefile~shape_circle.f90->sourcefile~forcad.f90 sourcefile~shape_hexahedron.f90 shape_hexahedron.f90 sourcefile~shape_hexahedron.f90->sourcefile~forcad.f90 sourcefile~shape_tetragon.f90 shape_tetragon.f90 sourcefile~shape_tetragon.f90->sourcefile~forcad.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> This module defines the 'nurbs_curve' type for representing a Non-Uniform Rational B-Spline (NURBS) curve. module forcad_nurbs_curve use forcad_utils , only : rk , basis_bspline , elemConn_C0 , compute_multiplicity , compute_knot_vector , basis_bspline_der ,& insert_knot_A_5_1 , findspan , elevate_degree_A_5_9 , remove_knots_A_5_8 , & elemConn_Cn , unique , rotation implicit none private public nurbs_curve !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause type nurbs_curve real ( rk ), allocatable , private :: Xc (:,:) !! Control points (2D array: [nc, dim]) real ( rk ), allocatable , private :: Xg (:,:) !! Geometry points (2D array: [ng, dim]) real ( rk ), allocatable , private :: Wc (:) !! Weights for control points (1D array: [nc]) real ( rk ), allocatable , private :: Xt (:) !! Evaluation points (1D array: [ng]) real ( rk ), allocatable , private :: knot (:) !! Knot vector (1D array) integer , private :: degree !! Degree (order) of the curve integer , private :: nc !! Number of control points integer , private :: ng !! Number of geometry points integer , allocatable , private :: elemConn_Xc_vis (:,:) !! Connectivity for visualization of control points integer , allocatable , private :: elemConn_Xg_vis (:,:) !! Connectivity for visualization of geometry points integer , allocatable , private :: elemConn (:,:) !! IGA element connectivity contains procedure :: set1 !!> Set knot vector, control points and weights for the NURBS curve object procedure :: set2 !!> Set NURBS curve using nodes of parameter space, degree, continuity, control points and weights procedure :: set3 !!> Set Bezier or Rational Bezier curve using control points and weights generic :: set => set1 , set2 , set3 !!> Set NURBS curve procedure :: create !!> Generate geometry points procedure :: get_Xc !!> Get control points procedure :: get_Xg !!> Get geometry points procedure :: get_Wc !!> Get weights procedure :: get_Xt !!> Get parameter values procedure , private :: get_knot_all !!> Get all knot vectors procedure , private :: get_knoti !!> Get i-th knot value generic :: get_knot => get_knoti , get_knot_all !!> Get knot vector procedure :: get_ng !!> Get number of geometry points procedure :: get_degree !!> Get degree of the NURBS curve procedure :: finalize !!> Finalize the NURBS curve object procedure :: cmp_elem_Xc_vis !!> Generate connectivity for control points procedure :: cmp_elem_Xg_vis !!> Generate connectivity for geometry points procedure :: cmp_elem !!> Generate IGA element connectivity procedure :: get_elem_Xc_vis !!> Get connectivity for control points procedure :: get_elem_Xg_vis !!> Get connectivity for geometry points procedure :: get_elem !!> Get IGA element connectivity procedure :: set_elem_Xc_vis !!> Set connectivity for control points procedure :: set_elem_Xg_vis !!> Set connectivity for geometry points procedure :: set_elem !!> Set IGA element connectivity procedure :: export_Xc !!> Export control points to VTK file procedure :: export_Xg !!> Export geometry points to VTK file procedure :: modify_Xc !!> Modify control points procedure :: modify_Wc !!> Modify weights procedure :: get_multiplicity !!> Get multiplicity of the knot vector procedure :: get_continuity !!> Get continuity of the curve procedure :: get_nc !!> Get number of required control points procedure :: insert_knots !!> Insert knots into the knot vector procedure :: elevate_degree !!> Elevate the degree of the curve procedure :: derivative !!> Compute the derivative of the NURBS curve procedure :: basis !!> Compute the basis functions of the NURBS curve procedure :: is_rational !!> Check if the NURBS curve is rational procedure :: remove_knots !!> Remove knots from the knot vector procedure :: rotate_Xc !!> Rotate control points procedure :: rotate_Xg !!> Rotate geometry points procedure :: translate_Xc !!> Translate control points procedure :: translate_Xg !!> Translate geometry points ! Shapes procedure :: set_circle !!> Set a circle end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set knot vector, control points and weights for the NURBS curve object. pure subroutine set1 ( this , knot , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: knot (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot = knot this % degree = this % get_degree () this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set NURBS curve using nodes of parameter space (Xth), degree, continuity, control points and weights. pure subroutine set2 ( this , Xth_dir , degree , continuity , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth_dir (:) integer , intent ( in ) :: degree integer , intent ( in ), contiguous :: continuity (:) real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % knot = compute_knot_vector ( Xth_dir , degree , continuity ) this % degree = degree this % Xc = Xc this % nc = size ( this % Xc , 1 ) if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause !> Set Bezier or Rational Bezier curve using control points and weights. pure subroutine set3 ( this , Xc , Wc ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xc (:,:) real ( rk ), intent ( in ), contiguous , optional :: Wc (:) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % Xc )) deallocate ( this % Xc ) this % Xc = Xc this % nc = size ( this % Xc , 1 ) allocate ( this % knot ( 2 * this % nc )) this % knot ( 1 : this % nc ) = 0.0_rk this % knot ( this % nc + 1 : 2 * this % nc ) = 1.0_rk this % degree = this % get_degree () if ( present ( Wc )) then if ( size ( Wc ) /= this % nc ) then error stop 'Number of weights does not match the number of control points.' else if ( allocated ( this % Wc )) deallocate ( this % Wc ) this % Wc = Wc end if end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine create ( this , res , Xt ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable :: Tgc (:) integer :: i , j ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if ! Set number of geometry points this % ng = size ( this % Xt ) ! Allocate memory for geometry points if ( allocated ( this % Xg )) deallocate ( this % Xg ) allocate ( this % Xg ( this % ng , size ( this % Xc , 2 ))) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( this % Xt , 1 ) Tgc = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % degree ) Tgc = Tgc * ( this % Wc / ( dot_product ( Tgc , this % Wc ))) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do else ! B-Spline do i = 1 , size ( this % Xt , 1 ) Tgc = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % degree ) do j = 1 , size ( this % Xc , 2 ) this % Xg ( i , j ) = dot_product ( Tgc , this % Xc (:, j )) end do end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xc ( this ) result ( Xc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xc (:,:) if ( allocated ( this % Xc )) then Xc = this % Xc else error stop 'Control points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xg ( this ) result ( Xg ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xg (:,:) if ( allocated ( this % Xg )) then Xg = this % Xg else error stop 'Geometry points are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Wc ( this ) result ( Wc ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Wc (:) if ( allocated ( this % Wc )) then Wc = this % Wc else error stop 'The NURBS curve is not rational.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_Xt ( this ) result ( Xt ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: Xt (:) if ( allocated ( this % Xt )) then Xt = this % Xt else error stop 'Parameter values are not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_ng ( this ) result ( ng ) class ( nurbs_curve ), intent ( in ) :: this integer :: ng ng = this % ng end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_degree ( this ) result ( degree ) class ( nurbs_curve ), intent ( in ) :: this integer :: degree integer , allocatable :: m (:) m = this % get_multiplicity () degree = m ( 1 ) - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knot_all ( this ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this real ( rk ), allocatable :: knot (:) if ( allocated ( this % knot )) then knot = this % knot else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_knoti ( this , i ) result ( knot ) class ( nurbs_curve ), intent ( in ) :: this integer , intent ( in ) :: i real ( rk ) :: knot if ( allocated ( this % knot )) then if ( i < 1 . or . i > size ( this % knot )) then error stop 'Invalid index for knot vector.' else knot = this % knot ( i ) end if else error stop 'Knot vector is not set.' end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine finalize ( this ) class ( nurbs_curve ), intent ( inout ) :: this if ( allocated ( this % Xc )) deallocate ( this % Xc ) if ( allocated ( this % Xg )) deallocate ( this % Xg ) if ( allocated ( this % Wc )) deallocate ( this % Wc ) if ( allocated ( this % Xt )) deallocate ( this % Xt ) if ( allocated ( this % knot )) deallocate ( this % knot ) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xc_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % nc , p ) else elemConn = elemConn_C0 ( this % nc , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem_Xg_vis ( this , p ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) integer , intent ( in ), optional :: p if ( present ( p )) then elemConn = elemConn_C0 ( this % ng , p ) else elemConn = elemConn_C0 ( this % ng , 1 ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xc ( this , filename ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , nc , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xc )) then error stop 'Control points are not set.' end if if (. not . allocated ( this % elemConn_Xc_vis )) then elemConn = this % cmp_elem_Xc_vis () else elemConn = this % elemConn_Xc_vis end if nc = size ( this % Xc , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , nc , 'double' if ( size ( this % Xc , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), 0.0_rk , i = 1 , nc ) elseif ( size ( this % Xc , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xc ( i , 1 ), this % Xc ( i , 2 ), this % Xc ( i , 3 ) , i = 1 , nc ) else error stop 'Invalid dimension of the control points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine export_Xg ( this , filename ) class ( nurbs_curve ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer :: i , ng , nunit integer , allocatable :: elemConn (:,:) ! check if (. not . allocated ( this % Xg )) then error stop 'Geometry points are not set.' end if if (. not . allocated ( this % elemConn_Xg_vis )) then elemConn = this % cmp_elem_Xg_vis () else elemConn = this % elemConn_Xg_vis end if ng = size ( this % Xg , 1 ) open ( newunit = nunit , file = filename , action = 'write' ) write ( nunit , '(a)' ) '# vtk DataFile Version 2.0' write ( nunit , '(a)' ) 'Generated by ForCAD' write ( nunit , '(a)' ) 'ASCII' write ( nunit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( nunit , '(a,\" \",g0,\" \",a)' ) 'POINTS' , ng , 'double' if ( size ( this % Xg , 2 ) == 2 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), 0.0_rk , i = 1 , ng ) elseif ( size ( this % Xg , 2 ) == 3 ) then write ( nunit , '(g0,\" \",g0,\" \",g0)' ) ( this % Xg ( i , 1 ), this % Xg ( i , 2 ), this % Xg ( i , 3 ) , i = 1 , ng ) else error stop 'Invalid dimension of the geometry points.' end if write ( nunit , '(a,\" \",g0,\" \",g0)' ) 'CELLS' , size ( elemConn , 1 ), size ( elemConn , 1 ) * ( size ( elemConn , 2 ) + 1 ) write ( nunit , '(g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' )& ( 2 , elemConn ( i , 1 ) - 1 , elemConn ( i , 2 ) - 1 , i = 1 , size ( elemConn , 1 )) write ( nunit , '(a,\" \",g0)' ) 'CELL_TYPES' , size ( elemConn , 1 ) write ( nunit , '(g0)' ) ( 3 , i = 1 , size ( elemConn , 1 )) close ( nunit ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Xc ( this , X , num , dir ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: X integer , intent ( in ) :: num integer , intent ( in ) :: dir if ( allocated ( this % Xc )) then this % Xc ( num , dir ) = X call this % set ( knot = this % knot , Xc = this % Xc , Wc = this % Wc ) else error stop 'Control points are not set.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine modify_Wc ( this , W , num ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: W integer , intent ( in ) :: num if ( allocated ( this % Wc )) then this % Wc ( num ) = W call this % set ( knot = this % knot , Xc = this % Xc , Wc = this % Wc ) else error stop 'The NURBS curve is not rational.' end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_multiplicity ( this ) result ( m ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: m (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else m = compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_continuity ( this ) result ( c ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: c (:) ! check if (. not . allocated ( this % knot )) then error stop 'Knot vector is not set.' else c = this % degree - compute_multiplicity ( this % knot ) end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_nc ( this ) result ( nc ) class ( nurbs_curve ), intent ( in ) :: this integer :: nc nc = sum ( compute_multiplicity ( this % knot )) - this % degree - 1 end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine insert_knots ( this , Xth , r ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , n_new real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) call insert_knot_A_5_1 (& this % degree ,& this % knot ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xcw_new ) allocate ( Xc_new ( 1 : n_new + 1 , 1 : dim )) allocate ( Wc_new ( 1 : n_new + 1 )) do j = 1 , n_new + 1 Xc_new ( j , 1 : dim ) = Xcw_new ( j - 1 , 1 : dim ) / Xcw_new ( j - 1 , dim + 1 ) Wc_new ( j ) = Xcw_new ( j - 1 , dim + 1 ) end do call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if call insert_knot_A_5_1 (& this % degree ,& this % knot ,& this % Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& n_new ,& knot_new ,& Xc_new ) deallocate ( this % Xc , this % knot ) call this % set ( knot = knot_new , Xc = Xc_new ) end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine elevate_degree ( this , t ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ) :: t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), knot_new (:), Xc_new (:,:), Wc_new (:) integer :: dim , j , nc_new if ( this % is_rational ()) then ! NURBS dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) Xcw ( j , dim + 1 ) = this % Wc ( j ) end do call elevate_degree_A_5_9 ( t , this % knot , this % degree , Xcw , nc_new , knot_new , Xcw_new ) allocate ( Xc_new ( 1 : nc_new , 1 : dim )) allocate ( Wc_new ( 1 : nc_new )) do j = 1 , nc_new Xc_new ( j , 1 : dim ) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) deallocate ( Xcw , Xcw_new , Xc_new , Wc_new ) else ! B-Spline dim = size ( this % Xc , 2 ) call elevate_degree_A_5_9 ( t , this % knot , this % degree , this % Xc , nc_new , knot_new , Xc_new ) call this % set ( knot = knot_new , Xc = Xc_new ) deallocate ( Xc_new ) end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine derivative ( this , res , Xt , dTgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: dTgc (:,:) real ( rk ), allocatable :: dTgci (:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if allocate ( dTgc ( size ( this % Xt , 1 ), this % nc )) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( this % Xt , 1 ) dTgci = basis_bspline_der ( this % Xt ( i ), this % knot , this % nc , this % degree ) dTgci = dTgci * ( this % Wc / ( dot_product ( dTgci , this % Wc ))) dTgc ( i ,:) = dTgci end do else ! B-Spline do i = 1 , size ( this % Xt , 1 ) dTgci = basis_bspline_der ( this % Xt ( i ), this % knot , this % nc , this % degree ) dTgc ( i ,:) = dTgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine basis ( this , res , Xt , Tgc ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), optional :: res real ( rk ), intent ( in ), contiguous , optional :: Xt (:) real ( rk ), allocatable , intent ( out ) :: Tgc (:,:) real ( rk ), allocatable :: Tgci (:) integer :: i ! Set parameter values if ( present ( Xt )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) this % Xt = Xt elseif ( present ( res )) then if ( allocated ( this % Xt )) deallocate ( this % Xt ) allocate ( this % Xt ( res )) this % Xt = [( real ( i - 1 , rk ) / real ( res - 1 , rk ), i = 1 , res )] ! else ! this%Xt = this%Xt end if allocate ( Tgc ( size ( this % Xt , 1 ), this % nc )) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( this % Xt , 1 ) Tgci = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % degree ) Tgci = Tgci * ( this % Wc / ( dot_product ( Tgci , this % Wc ))) Tgc ( i ,:) = Tgci end do else ! B-Spline do i = 1 , size ( this % Xt , 1 ) Tgci = basis_bspline ( this % Xt ( i ), this % knot , this % nc , this % degree ) Tgc ( i ,:) = Tgci end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function is_rational ( this ) result ( r ) class ( nurbs_curve ), intent ( in ) :: this logical :: r r = . false . if ( allocated ( this % Wc )) then if ( any ( this % Wc /= this % Wc ( 1 ))) then r = . true . end if end if end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xc_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xc_vis )) deallocate ( this % elemConn_Xc_vis ) this % elemConn_Xc_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem_Xg_vis ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn_Xg_vis )) deallocate ( this % elemConn_Xg_vis ) this % elemConn_Xg_vis = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_elem ( this , elemConn ) class ( nurbs_curve ), intent ( inout ) :: this integer , intent ( in ), contiguous :: elemConn (:,:) if ( allocated ( this % elemConn )) deallocate ( this % elemConn ) this % elemConn = elemConn end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xc_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xc_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem_Xg_vis ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn_Xg_vis end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function get_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) elemConn = this % elemConn end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine remove_knots ( this , Xth , r ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: Xth (:) integer , intent ( in ), contiguous :: r (:) integer :: k , i , s , dim , j , nc_new , t real ( rk ), allocatable :: Xcw (:,:), Xcw_new (:,:), Xc_new (:,:), Wc_new (:), knot_new (:) if ( this % is_rational ()) then ! NURBS do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 dim = size ( this % Xc , 2 ) allocate ( Xcw ( size ( this % Xc , 1 ), dim + 1 )) do j = 1 , size ( this % Xc , 1 ) Xcw ( j , 1 : dim ) = this % Xc ( j , 1 : dim ) * this % Wc ( j ) end do Xcw (:, dim + 1 ) = this % Wc (:) call remove_knots_A_5_8 (& this % degree ,& this % knot ,& Xcw ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xcw_new ) if ( allocated ( Xcw )) deallocate ( Xcw ) if ( t == 0 ) then ! no change else nc_new = size ( Xcw_new , 1 ) allocate ( Xc_new ( nc_new , dim )) allocate ( Wc_new ( nc_new )) do j = 1 , nc_new Xc_new ( j ,:) = Xcw_new ( j , 1 : dim ) / Xcw_new ( j , dim + 1 ) end do Wc_new (:) = Xcw_new (:, dim + 1 ) deallocate ( this % Xc , this % knot , this % Wc ) call this % set ( knot = knot_new , Xc = Xc_new , Wc = Wc_new ) if ( allocated ( Xcw_new )) deallocate ( Xcw_new ) if ( allocated ( Xc_new )) deallocate ( Xc_new ) if ( allocated ( Wc_new )) deallocate ( Wc_new ) end if end do else ! B-Spline do i = 1 , size ( Xth ) k = findspan ( this % nc - 1 , this % degree , Xth ( i ), this % knot ) if ( this % knot ( k + 1 ) == Xth ( i )) then s = compute_multiplicity ( this % knot , Xth ( i )) else s = 0 end if k = k + 1 call remove_knots_A_5_8 (& this % degree ,& this % knot ,& this % Xc ,& Xth ( i ),& k ,& s ,& r ( i ),& t ,& knot_new ,& Xc_new ) if ( t == 0 ) then ! no change else deallocate ( this % Xc , this % knot ) call this % set ( knot = knot_new , Xc = Xc_new ) end if end do end if end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine set_circle ( this , center , radius ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ), contiguous :: center (:) real ( rk ), intent ( in ) :: radius real ( rk ), allocatable :: Xc (:,:), Wc (:), knot (:) integer :: i ! Define control points for circle allocate ( Xc ( 7 , 3 )) Xc ( 1 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] Xc ( 2 ,:) = [ 1.0_rk , sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 3 ,:) = [ - 0.5_rk , sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 4 ,:) = [ - 2.0_rk , 0.0_rk , 0.0_rk ] Xc ( 5 ,:) = [ - 0.5_rk , - sqrt ( 3.0_rk ) / 2.0_rk , 0.0_rk ] Xc ( 6 ,:) = [ 1.0_rk , - sqrt ( 3.0_rk ), 0.0_rk ] Xc ( 7 ,:) = [ 1.0_rk , 0.0_rk , 0.0_rk ] ! Scale and translate the control points do i = 1 , size ( Xc , 1 ) Xc ( i ,:) = center + Xc ( i ,:) * radius end do ! Define weights for the control points Wc = [ 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk , 0.5_rk , 1.0_rk ] ! Define knot vector knot = [ 0.0_rk , 0.0_rk , 0.0_rk , 1.0_rk / 3.0_rk , 1.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 2.0_rk / 3.0_rk , 1.0_rk , 1.0_rk , 1.0_rk ] ! Set knot vector, control points, and weights call this % set ( knot , Xc , Wc ) end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function cmp_elem ( this ) result ( elemConn ) class ( nurbs_curve ), intent ( in ) :: this integer , allocatable :: elemConn (:,:) call elemConn_Cn ( this % nc , this % degree , unique ( this % knot ), this % get_multiplicity (),& elemConn ) end function !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xc ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % nc this % Xc ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xc ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine rotate_Xg ( this , alpha , beta , theta ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: alpha , beta , theta integer :: i do i = 1 , this % ng this % Xg ( i , :) = matmul ( rotation ( alpha , beta , theta ), this % Xg ( i , :)) end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xc ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc this % Xc ( i , :) = this % Xc ( i , :) + vec end do end subroutine !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure subroutine translate_Xg ( this , vec ) class ( nurbs_curve ), intent ( inout ) :: this real ( rk ), intent ( in ) :: vec (:) integer :: i do i = 1 , this % nc this % Xg ( i , :) = this % Xg ( i , :) + vec end do end subroutine !=============================================================================== end module forcad_nurbs_curve","tags":"","loc":"sourcefile/forcad_nurbs_curve.f90.html"},{"title":"example_volume_1.f90 – ForCAD","text":"This file depends on sourcefile~~example_volume_1.f90~~EfferentGraph sourcefile~example_volume_1.f90 example_volume_1.f90 sourcefile~forcad.f90 forcad.f90 sourcefile~example_volume_1.f90->sourcefile~forcad.f90 sourcefile~forcad_nurbs_curve.f90 forcad_nurbs_curve.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_curve.f90 sourcefile~forcad_nurbs_surface.f90 forcad_nurbs_surface.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_surface.f90 sourcefile~forcad_nurbs_volume.f90 forcad_nurbs_volume.f90 sourcefile~forcad.f90->sourcefile~forcad_nurbs_volume.f90 sourcefile~forcad_utils.f90 forcad_utils.f90 sourcefile~forcad.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_curve.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_surface.f90->sourcefile~forcad_utils.f90 sourcefile~forcad_nurbs_volume.f90->sourcefile~forcad_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This program demonstrates the usage of a NURBS (Non-Uniform Rational B-Spline) volume object to create  and finalize a NURBS volume. !> It sets up control points, weights, and knot vectors for all three dimensions, generates the volume, and exports the control points and the volume to VTK files. program example3_volume use forcad , only : rk , nurbs_volume implicit none type ( nurbs_volume ) :: nurbs !! Declare a NURBS volume object real ( rk ), allocatable :: Xc (:,:), Wc (:) !! Arrays for control points and weights real ( rk ) :: knot1 ( 4 ), knot2 ( 4 ), knot3 ( 4 ) !! Arrays for knot vectors in all three dimensions !----------------------------------------------------------------------------- ! Setting up the NURBS volume !----------------------------------------------------------------------------- !> Define the control points for the NURBS volume Xc = generate_Xc ( 5.0_rk ) !> Define weights for the control points (optional) allocate ( Wc ( size ( Xc , 1 )), source = 1.0_rk ) Wc ( 2 ) = 5.0_rk !> Define knot vectors for all three dimensions knot1 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot2 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] knot3 = [ 0.0_rk , 0.0_rk , 1.0_rk , 1.0_rk ] !> Set knot vectors, control points, and weights for the NURBS volume object !> Wc is optional. call nurbs % set ( knot1 , knot2 , knot3 , Xc , Wc ) !> Export the control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc.vtk' ) !----------------------------------------------------------------------------- ! Creating the NURBS volume !----------------------------------------------------------------------------- !> Generate the NURBS volume with resolutions of 20, 20, and 20 in the three dimensions call nurbs % create ( 20 , 20 , 20 ) !> Export the generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg.vtk' ) !----------------------------------------------------------------------------- ! Refinements !----------------------------------------------------------------------------- !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Insert knots 0.25 and 0.75 in all three directions call nurbs % insert_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % insert_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % insert_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after inserting knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Print degrees print * , nurbs % get_degree () !> Elevate degree by 2 in all three directions call nurbs % elevate_degree ( 1 , 2 ) ! direction 1 call nurbs % elevate_degree ( 2 , 2 ) ! direction 2 call nurbs % elevate_degree ( 3 , 2 ) ! direction 3 !> Print degrees after elevating print * , nurbs % get_degree () !> Print size of knot vectors print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) call nurbs % remove_knots ( 1 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 1 call nurbs % remove_knots ( 2 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 2 call nurbs % remove_knots ( 3 , [ 0.25_rk , 0.75_rk ], [ 1 , 1 ]) ! direction 3 !> Print size of knot vectors after removing knots print * , size ( nurbs % get_knot ( 1 )) print * , size ( nurbs % get_knot ( 2 )) print * , size ( nurbs % get_knot ( 3 )) !> Generate the refined NURBS volume with resolutions of 40, 40, and 40 in the three dimensions call nurbs % create () !> Export updated control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc2.vtk' ) !> Export the refined generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg2.vtk' ) !----------------------------------------------------------------------------- ! Transformations !----------------------------------------------------------------------------- !> Rotate the control points call nurbs % rotate_Xc ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Rotate the generated curve call nurbs % rotate_Xg ( alpha =- 4 5.0_rk , beta = 0.0_rk , theta = 9 0.0_rk ) !> Translate the control points call nurbs % translate_Xc ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Translate the generated curve call nurbs % translate_Xg ([ 1.0_rk , 2.0_rk , - 3.0_rk ]) !> Export the transformed control points to a VTK file call nurbs % export_Xc ( 'vtk/nurbs_volume_Xc3.vtk' ) !> Export the transformed generated volume to a VTK file call nurbs % export_Xg ( 'vtk/nurbs_volume_Xg3.vtk' ) !----------------------------------------------------------------------------- ! Finalizing !----------------------------------------------------------------------------- !> Finalize the NURBS volume object call nurbs % finalize () contains !----------------------------------------------------------------------------- function generate_Xc ( L ) result ( control_points ) implicit none real ( rk ), intent ( in ) :: L real ( rk ), allocatable :: control_points (:,:) real ( rk ) :: L2 L2 = L / 2.0_rk allocate ( control_points ( 8 , 3 )) control_points ( 1 ,:) = [ L2 , - L2 , L2 ] control_points ( 2 ,:) = [ L2 , - L2 , - L2 ] control_points ( 3 ,:) = [ - L2 , - L2 , L2 ] control_points ( 4 ,:) = [ - L2 , - L2 , - L2 ] control_points ( 5 ,:) = [ L2 , L2 , L2 ] control_points ( 6 ,:) = [ L2 , L2 , - L2 ] control_points ( 7 ,:) = [ - L2 , L2 , L2 ] control_points ( 8 ,:) = [ - L2 , L2 , - L2 ] end function !----------------------------------------------------------------------------- end program example3_volume","tags":"","loc":"sourcefile/example_volume_1.f90.html"}]}